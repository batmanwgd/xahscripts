〈〈debug-on-entry〉〉:〈〈Request FUNCTION to invoke debugger each time it is called.

When called interactively, prompt for FUNCTION in the minibuffer.

This works by modifying the definition of FUNCTION.  If you tell the
debugger to continue, FUNCTION’s execution proceeds.  If FUNCTION is a
normal function or a macro written in Lisp, you can also step through
its execution.  FUNCTION can also be a primitive that is not a special
form, in which case stepping is not possible.  Break-on-entry for
primitive functions only works when that function is called from Lisp.

Use M-x cancel-debug-on-entry to cancel the effect of this command.
Redefining FUNCTION also cancels it.

(fn FUNCTION)〉〉enditem49840〈〈cancel-debug-on-entry〉〉:〈〈Undo effect of M-x debug-on-entry on FUNCTION.
If FUNCTION is nil, cancel debug-on-entry for all functions.
When called interactively, prompt for FUNCTION in the minibuffer.
To specify a nil argument interactively, exit with an empty minibuffer.

(fn &optional FUNCTION)〉〉enditem49840〈〈beginning-of-line〉〉:〈〈Move point to beginning of current line (in the logical order).
With argument N not nil or 1, move forward N - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.

This function constrains point to the current field unless this moves
point to a different line than the original, unconstrained result.
If N is nil or 1, and a front-sticky field starts at point, the point
does not move.  To ignore field boundaries bind
‘inhibit-field-text-motion’ to t, or use the ‘forward-line’ function
instead.  For instance, ‘(forward-line 0)’ does the same thing as
‘(beginning-of-line)’, except that it ignores field boundaries.

(fn &optional N)〉〉enditem49840〈〈end-of-line〉〉:〈〈Move point to end of current line (in the logical order).
With argument N not nil or 1, move forward N - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.

This function constrains point to the current field unless this moves
point to a different line than the original, unconstrained result.  If
N is nil or 1, and a rear-sticky field ends at point, the point does
not move.  To ignore field boundaries bind ‘inhibit-field-text-motion’
to t.

(fn &optional N)〉〉enditem49840〈〈forward-line〉〉:〈〈Move N lines forward (backward if N is negative).
Precisely, if point is on line I, move to the start of line I + N
("start of line" in the logical order).
If there isn’t room, go as far as possible (no error).

Returns the count of lines left to move.  If moving forward,
that is N minus number of lines moved; if backward, N plus number
moved.

Exception: With positive N, a non-empty line at the end of the
buffer, or of its accessible portion, counts as one line
successfully moved (for the return value).  This means that the
function will move point to the end of such a line and will count
it as a line moved across, even though there is no next line to
go to its beginning.

(fn &optional N)〉〉enditem49840〈〈count-words〉〉:〈〈Count words between START and END.
If called interactively, START and END are normally the start and
end of the buffer; but if the region is active, START and END are
the start and end of the region.  Print a message reporting the
number of lines, words, and chars.

If called from Lisp, return the number of words between START and
END, without printing any message.

(fn START END)〉〉enditem49840〈〈switch-to-buffer〉〉:〈〈Display buffer BUFFER-OR-NAME in the selected window.

WARNING: This is NOT the way to work on another buffer temporarily
within a Lisp program!  Use ‘set-buffer’ instead.  That avoids
messing with the window-buffer correspondences.

If the selected window cannot display the specified buffer
because it is a minibuffer window or strongly dedicated to
another buffer, call ‘pop-to-buffer’ to select the buffer in
another window.  In interactive use, if the selected window is
strongly dedicated to its buffer, the value of the option
‘switch-to-buffer-in-dedicated-window’ specifies how to proceed.

If called interactively, read the buffer name using ‘read-buffer’.
The variable ‘confirm-nonexistent-file-or-buffer’ determines
whether to request confirmation before creating a new buffer.
See ‘read-buffer’ for features related to input and completion
of buffer names.

BUFFER-OR-NAME may be a buffer, a string (a buffer name), or nil.
If BUFFER-OR-NAME is a string that does not identify an existing
buffer, create a buffer with that name.  If BUFFER-OR-NAME is
nil, switch to the buffer returned by ‘other-buffer’.

If optional argument NORECORD is non-nil, do not put the buffer
at the front of the buffer list, and do not make the window
displaying it the most recently selected one.

If optional argument FORCE-SAME-WINDOW is non-nil, the buffer
must be displayed in the selected window when called
non-interactively; if that is impossible, signal an error rather
than calling ‘pop-to-buffer’.

The option ‘switch-to-buffer-preserve-window-point’ can be used
to make the buffer appear at its last position in the selected
window.

Return the buffer switched to.

(fn BUFFER-OR-NAME &optional NORECORD FORCE-SAME-WINDOW)〉〉enditem49840〈〈switch-to-buffer-other-window〉〉:〈〈Select the buffer specified by BUFFER-OR-NAME in another window.
BUFFER-OR-NAME may be a buffer, a string (a buffer name), or
nil.  Return the buffer switched to.

If called interactively, read the buffer name using ‘read-buffer’.
The variable ‘confirm-nonexistent-file-or-buffer’ determines
whether to request confirmation before creating a new buffer.
See ‘read-buffer’ for features related to input and completion
of buffer names.

If BUFFER-OR-NAME is a string and does not identify an existing
buffer, create a new buffer with that name.  If BUFFER-OR-NAME is
nil, switch to the buffer returned by ‘other-buffer’.

Optional second argument NORECORD non-nil means do not put this
buffer at the front of the list of recently selected ones.

This uses the function ‘display-buffer’ as a subroutine; see its
documentation for additional customization information.

(fn BUFFER-OR-NAME &optional NORECORD)〉〉enditem49840〈〈switch-to-buffer-other-frame〉〉:〈〈Switch to buffer BUFFER-OR-NAME in another frame.
BUFFER-OR-NAME may be a buffer, a string (a buffer name), or
nil.  Return the buffer switched to.

If called interactively, read the buffer name using ‘read-buffer’.
The variable ‘confirm-nonexistent-file-or-buffer’ determines
whether to request confirmation before creating a new buffer.
See ‘read-buffer’ for features related to input and completion
of buffer names.

If BUFFER-OR-NAME is a string and does not identify an existing
buffer, create a new buffer with that name.  If BUFFER-OR-NAME is
nil, switch to the buffer returned by ‘other-buffer’.

Optional second arg NORECORD non-nil means do not put this
buffer at the front of the list of recently selected ones.

This uses the function ‘display-buffer’ as a subroutine; see its
documentation for additional customization information.

(fn BUFFER-OR-NAME &optional NORECORD)〉〉enditem49840〈〈pop-to-buffer〉〉:〈〈Display buffer specified by BUFFER-OR-NAME and select its window.
BUFFER-OR-NAME may be a buffer, a string (a buffer name), or nil.
If it is a string not naming an existent buffer, create a buffer
with that name.  If BUFFER-OR-NAME is nil, choose some other
buffer.  In either case, make that buffer current and return it.

This uses ‘display-buffer’ as a subroutine.  The optional ACTION
argument is passed to ‘display-buffer’ as its ACTION argument.
See ‘display-buffer’ for more information.  ACTION is t if called
interactively with a prefix argument, which means to pop to a
window other than the selected one even if the buffer is already
displayed in the selected window.

If a suitable window is found, select that window.  If it is not
on the selected frame, raise that window’s frame and give it
input focus.

Optional third arg NORECORD non-nil means do not put this buffer
at the front of the list of recently selected ones.

(fn BUFFER-OR-NAME &optional ACTION NORECORD)〉〉enditem49840〈〈indent-relative〉〉:〈〈Space out to under next indent point in previous nonblank line.
An indent point is a non-whitespace character following whitespace.
The following line shows the indentation points in this line.
    ^         ^    ^     ^   ^           ^      ^  ^    ^
If FIRST-ONLY is non-nil, then only the first indent point is
considered.

If the previous nonblank line has no indent points beyond the
column point starts at, then ‘tab-to-tab-stop’ is done, if both
FIRST-ONLY and UNINDENTED-OK are nil, otherwise nothing is done
in this case.

See also ‘indent-relative-first-indent-point’.

(fn &optional FIRST-ONLY UNINDENTED-OK)〉〉enditem49840〈〈indent-relative-maybe〉〉:〈〈Indent the current line like the previous nonblank line.
Indent to the first indentation position in the previous nonblank
line if that position is greater than the current column.

See also ‘indent-relative’.〉〉enditem49840〈〈run-at-time〉〉:〈〈Perform an action at time TIME.
Repeat the action every REPEAT seconds, if REPEAT is non-nil.
REPEAT may be an integer or floating point number.
TIME should be one of:
- a string giving today’s time like "11:23pm"
  (the acceptable formats are HHMM, H:MM, HH:MM, HHam, HHAM,
  HHpm, HHPM, HH:MMam, HH:MMAM, HH:MMpm, or HH:MMPM;
  a period ‘.’ can be used instead of a colon ‘:’ to separate
  the hour and minute parts);
- a string giving a relative time like "90" or "2 hours 35 minutes"
  (the acceptable forms are a number of seconds without units
  or some combination of values using units in ‘timer-duration-words’);
- nil, meaning now;
- a number of seconds from now;
- a value from ‘encode-time’;
- or t (with non-nil REPEAT) meaning the next integral
  multiple of REPEAT.

The action is to call FUNCTION with arguments ARGS.

This function returns a timer object which you can use in
‘cancel-timer’.

(fn TIME REPEAT FUNCTION &rest ARGS)〉〉enditem49840〈〈write-abbrev-file〉〉:〈〈Write all user-level abbrev definitions to a file of Lisp code.
This does not include system abbrevs; it includes only the abbrev tables
listed in listed in ‘abbrev-table-name-list’.
The file written can be loaded in another session to define the same abbrevs.
The argument FILE is the file name to write.  If omitted or nil, the file
specified in ‘abbrev-file-name’ is used.
If VERBOSE is non-nil, display a message indicating where abbrevs
have been saved.

(fn &optional FILE VERBOSE)〉〉enditem49840〈〈indent-for-tab-command〉〉:〈〈Indent the current line or region, or insert a tab, as appropriate.
This function either inserts a tab, or indents the current line,
or performs symbol completion, depending on ‘tab-always-indent’.
The function called to actually indent the line or insert a tab
is given by the variable ‘indent-line-function’.

If a prefix argument is given, after this function indents the
current line or inserts a tab, it also rigidly indents the entire
balanced expression which starts at the beginning of the current
line, to reflect the current line’s indentation.

In most major modes, if point was in the current line’s
indentation, it is moved to the first non-whitespace character
after indenting; otherwise it stays at the same position relative
to the text.

If ‘transient-mark-mode’ is turned on and the region is active,
this function instead calls ‘indent-region’.  In this case, any
prefix argument is ignored.

(fn &optional ARG)〉〉enditem49840〈〈indent-according-to-mode〉〉:〈〈Indent line in proper way for current major mode.
Normally, this is done by calling the function specified by the
variable ‘indent-line-function’.  However, if the value of that
variable is ‘indent-relative’ or ‘indent-relative-maybe’, handle
it specially (since those functions are used for tabbing); in
that case, indent by aligning to the previous non-blank line.〉〉enditem49840〈〈newline-and-indent〉〉:〈〈Insert a newline, then indent according to major mode.
Indentation is done using the value of ‘indent-line-function’.
In programming language modes, this is the same as TAB.
In some text modes, where TAB inserts a tab, this command indents to the
column specified by the function ‘current-left-margin’.〉〉enditem49840〈〈reindent-then-newline-and-indent〉〉:〈〈Reindent current line, insert newline, then indent the new line.
Indentation of both lines is done according to the current major mode,
which means calling the current value of ‘indent-line-function’.
In programming language modes, this is the same as TAB.
In some text modes, where TAB inserts a tab, this indents to the
column specified by the function ‘current-left-margin’.〉〉enditem49840〈〈minibuffer-complete-word〉〉:〈〈Complete the minibuffer contents at most a single word.
After one word is completed as much as possible, a space or hyphen
is added, provided that matches some possible completion.
Return nil if there is no valid completion, else t.〉〉enditem49840〈〈minibuffer-complete〉〉:〈〈Complete the minibuffer contents as far as possible.
Return nil if there is no valid completion, else t.
If no characters can be completed, display a list of possible completions.
If you repeat this command after it displayed such a list,
scroll the window of possible completions.〉〉enditem49840〈〈minibuffer-complete-and-exit〉〉:〈〈Exit if the minibuffer contains a valid completion.
Otherwise, try to complete the minibuffer contents.  If
completion leads to a valid completion, a repetition of this
command will exit.

If ‘minibuffer-completion-confirm’ is ‘confirm’, do not try to
 complete; instead, ask for confirmation and accept any input if
 confirmed.
If ‘minibuffer-completion-confirm’ is ‘confirm-after-completion’,
 do not try to complete; instead, ask for confirmation if the
 preceding minibuffer command was a member of
 ‘minibuffer-confirm-exit-commands’, and accept the input
 otherwise.〉〉enditem49840〈〈minibuffer-completion-help〉〉:〈〈Display a list of possible completions of the current minibuffer contents.

(fn &optional START END)〉〉enditem49840〈〈fill-paragraph〉〉:〈〈Fill paragraph at or after point.

If JUSTIFY is non-nil (interactively, with prefix argument), justify as well.
If ‘sentence-end-double-space’ is non-nil, then period followed by one
space does not end a sentence, so don’t break a line there.
The variable ‘fill-column’ controls the width for filling.

If ‘fill-paragraph-function’ is non-nil, we call it (passing our
argument to it), and if it returns non-nil, we simply return its value.

If ‘fill-paragraph-function’ is nil, return the ‘fill-prefix’ used for filling.

The REGION argument is non-nil if called interactively; in that
case, if Transient Mark mode is enabled and the mark is active,
call ‘fill-region’ to fill each of the paragraphs in the active
region, instead of just filling the current paragraph.〉〉enditem49840〈〈fill-region〉〉:〈〈Fill each of the paragraphs in the region.
A prefix arg means justify as well.
The ‘fill-column’ variable controls the width.

Noninteractively, the third argument JUSTIFY specifies which
kind of justification to do: ‘full’, ‘left’, ‘right’, ‘center’,
or ‘none’ (equivalent to nil).  A value of t means handle each
paragraph as specified by its text properties.

The fourth arg NOSQUEEZE non-nil means to leave whitespace other
than line breaks untouched, and fifth arg TO-EOP non-nil means
to keep filling to the end of the paragraph (or next hard newline,
if variable ‘use-hard-newlines’ is on).

Return the fill-prefix used for filling the last paragraph.

If ‘sentence-end-double-space’ is non-nil, then period followed by one
space does not end a sentence, so don’t break a line there.〉〉enditem49840〈〈fill-individual-paragraphs〉〉:〈〈Fill paragraphs of uniform indentation within the region.
This command divides the region into "paragraphs",
treating every change in indentation level or prefix as a paragraph boundary,
then fills each paragraph using its indentation level as the fill prefix.

There is one special case where a change in indentation does not start
a new paragraph.  This is for text of this form:

   foo>    This line with extra indentation starts
   foo> a paragraph that continues on more lines.

These lines are filled together.

When calling from a program, pass the range to fill
as the first two arguments.

Optional third and fourth arguments JUSTIFY and CITATION-REGEXP:
JUSTIFY to justify paragraphs (prefix arg).
When filling a mail message, pass a regexp for CITATION-REGEXP
which will match the prefix of a line which is a citation marker
plus whitespace, but no other kind of prefix.
Also, if CITATION-REGEXP is non-nil, don’t fill header lines.〉〉enditem49840〈〈fill-region-as-paragraph〉〉:〈〈Fill the region as one paragraph.
It removes any paragraph breaks in the region and extra newlines at the end,
indents and fills lines between the margins given by the
‘current-left-margin’ and ‘current-fill-column’ functions.
(In most cases, the variable ‘fill-column’ controls the width.)
It leaves point at the beginning of the line following the paragraph.

Normally performs justification according to the ‘current-justification’
function, but with a prefix arg, does full justification instead.

From a program, optional third arg JUSTIFY can specify any type of
justification.  Fourth arg NOSQUEEZE non-nil means not to make spaces
between words canonical before filling.  Fifth arg SQUEEZE-AFTER, if non-nil,
means don’t canonicalize spaces before that position.

Return the ‘fill-prefix’ used for filling.

If ‘sentence-end-double-space’ is non-nil, then period followed by one
space does not end a sentence, so don’t break a line there.〉〉enditem49840〈〈justify-current-line〉〉:〈〈Do some kind of justification on this line.
Normally does full justification: adds spaces to the line to make it end at
the column given by ‘current-fill-column’.
Optional first argument HOW specifies alternate type of justification:
it can be ‘left’, ‘right’, ‘full’, ‘center’, or ‘none’.
If HOW is t, will justify however the ‘current-justification’ function says to.
If HOW is nil or missing, full justification is done by default.
Second arg EOP non-nil means that this is the last line of the paragraph, so
it will not be stretched by full justification.
Third arg NOSQUEEZE non-nil means to leave interior whitespace unchanged,
otherwise it is made canonical.〉〉enditem49840〈〈push-button〉〉:〈〈Perform the action specified by a button at location POS.
POS may be either a buffer position or a mouse-event.  If
USE-MOUSE-ACTION is non-nil, invoke the button’s ‘mouse-action’
property instead of its ‘action’ property; if the button has no
‘mouse-action’, the value of ‘action’ is used instead.

The action in both cases may be either a function to call or a
marker to display and is invoked using ‘button-activate’ (which
see).

POS defaults to point, except when ‘push-button’ is invoked
interactively as the result of a mouse-event, in which case, the
mouse event is used.
If there’s no button at POS, do nothing and return nil, otherwise
return t.〉〉enditem49840〈〈forward-button〉〉:〈〈Move to the Nth next button, or Nth previous button if N is negative.
If N is 0, move to the start of any button at point.
If WRAP is non-nil, moving past either end of the buffer continues from the
other end.
If DISPLAY-MESSAGE is non-nil, the button’s help-echo string is displayed.
Any button with a non-nil ‘skip’ property is skipped over.
Returns the button found.〉〉enditem49840〈〈backward-button〉〉:〈〈Move to the Nth previous button, or Nth next button if N is negative.
If N is 0, move to the start of any button at point.
If WRAP is non-nil, moving past either end of the buffer continues from the
other end.
If DISPLAY-MESSAGE is non-nil, the button’s help-echo string is displayed.
Any button with a non-nil ‘skip’ property is skipped over.
Returns the button found.〉〉enditem49840〈〈append-to-file〉〉:〈〈Append the contents of the region to the end of file FILENAME.
When called from a function, expects three arguments,
START, END and FILENAME.  START and END are normally buffer positions
specifying the part of the buffer to write.
If START is nil, that means to use the entire buffer contents.
If START is a string, then output that string to the file
instead of any buffer contents; END is ignored.

This does character code conversion and applies annotations
like ‘write-region’ does.

(fn START END FILENAME)〉〉enditem49840〈〈write-region〉〉:〈〈Write current region into specified file.
When called from a program, requires three arguments:
START, END and FILENAME.  START and END are normally buffer positions
specifying the part of the buffer to write.
If START is nil, that means to use the entire buffer contents; END is
ignored.
If START is a string, then output that string to the file
instead of any buffer contents; END is ignored.

Optional fourth argument APPEND if non-nil means
  append to existing file contents (if any).  If it is a number,
  seek to that offset in the file before writing.
Optional fifth argument VISIT, if t or a string, means
  set the last-save-file-modtime of buffer to this file’s modtime
  and mark buffer not modified.
If VISIT is a string, it is a second file name;
  the output goes to FILENAME, but the buffer is marked as visiting VISIT.
  VISIT is also the file name to lock and unlock for clash detection.
If VISIT is neither t nor nil nor a string, or if Emacs is in batch mode,
  do not display the "Wrote file" message.
The optional sixth arg LOCKNAME, if non-nil, specifies the name to
  use for locking and unlocking, overriding FILENAME and VISIT.
The optional seventh arg MUSTBENEW, if non-nil, insists on a check
  for an existing file with the same name.  If MUSTBENEW is ‘excl’,
  that means to get an error if the file already exists; never overwrite.
  If MUSTBENEW is neither nil nor ‘excl’, that means ask for
  confirmation before overwriting, but do go ahead and overwrite the file
  if the user confirms.

This does code conversion according to the value of
‘coding-system-for-write’, ‘buffer-file-coding-system’, or
‘file-coding-system-alist’, and sets the variable
‘last-coding-system-used’ to the coding system actually used.

This calls ‘write-region-annotate-functions’ at the start, and
‘write-region-post-annotation-function’ at the end.

(fn START END FILENAME &optional APPEND VISIT LOCKNAME MUSTBENEW)〉〉enditem49840〈〈universal-argument〉〉:〈〈Begin a numeric argument for the following command.
Digits or minus sign following C-u make up the numeric argument.
C-u following the digits or minus sign ends the argument.
C-u without digits or minus sign provides 4 as argument.
Repeating C-u without digits or minus sign
 multiplies the argument by 4 each time.
For some commands, just C-u by itself serves as a flag
which is different in effect from any particular numeric argument.
These commands include y and M-x start-kbd-macro.〉〉enditem49840〈〈digit-argument〉〉:〈〈Part of the numeric argument for the next command.
C-u following digits or minus sign ends the argument.

(fn ARG)〉〉enditem49840〈〈negative-argument〉〉:〈〈Begin a negative numeric argument for the next command.
C-u following digits or minus sign ends the argument.

(fn ARG)〉〉enditem49840〈〈suspend-emacs〉〉:〈〈Stop Emacs and return to superior process.  You can resume later.
If ‘cannot-suspend’ is non-nil, or if the system doesn’t support job
control, run a subshell instead.

If optional arg STUFFSTRING is non-nil, its characters are stuffed
to be read as terminal input by Emacs’s parent, after suspension.

Before suspending, run the normal hook ‘suspend-hook’.
After resumption run the normal hook ‘suspend-resume-hook’.

Some operating systems cannot stop the Emacs process and resume it later.
On such systems, Emacs starts a subshell instead of suspending.

(fn &optional STUFFSTRING)〉〉enditem49840〈〈suspend-frame〉〉:〈〈Do whatever is right to suspend the current frame.
Calls ‘suspend-emacs’ if invoked from the controlling tty device,
‘suspend-tty’ from a secondary tty device, and
‘iconify-or-deiconify-frame’ from an X frame.〉〉enditem49840〈〈set-input-method〉〉:〈〈Select and activate input method INPUT-METHOD for the current buffer.
This also sets the default input method to the one you specify.
If INPUT-METHOD is nil, this function turns off the input method, and
also causes you to be prompted for a name of an input method the next
time you invoke DEL \.
When called interactively, the optional arg INTERACTIVE is non-nil,
which marks the variable ‘default-input-method’ as set for Custom buffers.

To deactivate the input method interactively, use DEL \.
To deactivate it programmatically, use ‘deactivate-input-method’.

(fn INPUT-METHOD &optional INTERACTIVE)〉〉enditem49840〈〈indent-to〉〉:〈〈Indent from point with tabs and spaces until COLUMN is reached.
Optional second argument MINIMUM says always do at least MINIMUM spaces
even if that goes past COLUMN; by default, MINIMUM is zero.

The return value is the column where the insertion ends.

(fn COLUMN &optional MINIMUM)〉〉enditem49840〈〈describe-current-display-table〉〉:〈〈Describe the display table in use in the selected window and buffer.〉〉enditem49840〈〈read-color〉〉:〈〈Read a color name or RGB triplet.
Completion is available for color names, but not for RGB triplets.

RGB triplets have the form "#RRGGBB".  Each of the R, G, and B
components can have one to four digits, but all three components
must have the same number of digits.  Each digit is a hex value
between 0 and F; either upper case or lower case for A through F
are acceptable.

In addition to standard color names and RGB hex values, the
following are available as color candidates.  In each case, the
corresponding color is used.

 * ‘foreground at point’   - foreground under the cursor
 * ‘background at point’   - background under the cursor

Optional arg PROMPT is the prompt; if nil, use a default prompt.

Interactively, or with optional arg CONVERT-TO-RGB-P non-nil,
convert an input color name to an RGB hex string.  Return the RGB
hex string.

If optional arg ALLOW-EMPTY-NAME is non-nil, the user is allowed
to enter an empty color name (the empty string).

Interactively, or with optional arg MSG non-nil, print the
resulting color name in the echo area.

(fn &optional PROMPT CONVERT-TO-RGB ALLOW-EMPTY-NAME MSG)〉〉enditem49840〈〈posix-search-forward〉〉:〈〈Search forward from point for regular expression REGEXP.
Find the longest match in accord with Posix regular expression rules.
Set point to the end of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not end after that position.  A value of nil
  means search to the end of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, move to limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  backward, instead of forward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth one (or first,
  if COUNT is 1 or nil) in the buffer located entirely after the
  origin of the search; correspondingly with COUNT negative.

Search case-sensitivity is determined by the value of the variable
‘case-fold-search’, which see.

See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,
and ‘replace-match’.

(fn REGEXP &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈posix-search-backward〉〉:〈〈Search backward from point for match for regular expression REGEXP.
Find the longest match in accord with Posix regular expression rules.
Set point to the beginning of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not begin before that position.  A value of nil
  means search to the beginning of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, position at limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  forward, instead of backward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth to last one (or
  last, if COUNT is 1 or nil) in the buffer located entirely before
  the origin of the search; correspondingly with COUNT negative.

Search case-sensitivity is determined by the value of the variable
‘case-fold-search’, which see.

See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,
and ‘replace-match’.

(fn REGEXP &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈save-buffer〉〉:〈〈Save current buffer in visited file if modified.
Variations are described below.

By default, makes the previous version into a backup file
 if previously requested or if this is the first save.
Prefixed with one C-u, marks this version
 to become a backup when the next save is done.
Prefixed with two C-u’s,
 makes the previous version into a backup file.
Prefixed with three C-u’s, marks this version
 to become a backup when the next save is done,
 and makes the previous version into a backup file.

With a numeric prefix argument of 0, never make the previous version
into a backup file.

Note that the various variables that control backups, such
as ‘version-control’, ‘backup-enable-predicate’, ‘vc-make-backup-files’,
and ‘backup-inhibited’, to name just the more popular ones, still
control whether a backup will actually be produced, even when you
invoke this command prefixed with two or three C-u’s.

If a file’s name is FOO, the names of its numbered backup versions are
 FOO.~i~ for various integers i.  A non-numbered backup file is called FOO~.
Numeric backups (rather than FOO~) will be made if value of
 ‘version-control’ is not the atom ‘never’ and either there are already
 numeric versions of the file being backed up, or ‘version-control’ is
 non-nil.
We don’t want excessive versions piling up, so there are variables
 ‘kept-old-versions’, which tells Emacs how many oldest versions to keep,
 and ‘kept-new-versions’, which tells how many newest versions to keep.
 Defaults are 2 old versions and 2 new.
‘dired-kept-versions’ controls dired’s clean-directory (.) command.
If ‘delete-old-versions’ is nil, system will query user
 before trimming versions.  Otherwise it does it silently.

If ‘vc-make-backup-files’ is nil, which is the default,
 no backup files are made for files managed by version control.
 (This is because the version control system itself records previous versions.)

See the subroutine ‘basic-save-buffer’ for more information.

(fn &optional ARG)〉〉enditem49840〈〈save-some-buffers〉〉:〈〈Save some modified file-visiting buffers.  Asks user about each one.
You can answer ‘y’ to save, ‘n’ not to save, ‘C-r’ to look at the
buffer in question with ‘view-buffer’ before deciding or ‘d’ to
view the differences using ‘diff-buffer-with-file’.

This command first saves any buffers where ‘buffer-save-without-query’ is
non-nil, without asking.

Optional argument ARG (interactively, prefix argument) non-nil means save
all with no questions.
Optional second argument PRED determines which buffers are considered:
If PRED is nil, all the file-visiting buffers are considered.
If PRED is t, then certain non-file buffers will also be considered.
If PRED is a zero-argument function, it indicates for each buffer whether
to consider it or not when called with that buffer current.
PRED defaults to the value of ‘save-some-buffers-default-predicate’.

See ‘save-some-buffers-action-alist’ if you want to
change the additional actions you can take on files.

(fn &optional ARG PRED)〉〉enditem49840〈〈write-file〉〉:〈〈Write current buffer into file FILENAME.
This makes the buffer visit that file, and marks it as not modified.

If you specify just a directory name as FILENAME, that means to use
the default file name but in that directory.  You can also yank
the default file name into the minibuffer to edit it, using M-n.

If the buffer is not already visiting a file, the default file name
for the output file is the buffer name.

If optional second arg CONFIRM is non-nil, this function
asks for confirmation before overwriting an existing file.
Interactively, confirmation is required unless you supply a prefix argument.

(fn FILENAME &optional CONFIRM)〉〉enditem49840〈〈signal-process〉〉:〈〈Send PROCESS the signal with code SIGCODE.
PROCESS may also be a number specifying the process id of the
process to signal; in this case, the process need not be a child of
this Emacs.
SIGCODE may be an integer, or a symbol whose name is a signal name.

(fn PROCESS SIGCODE)〉〉enditem49840〈〈exit-minibuffer〉〉:〈〈Terminate this minibuffer argument.〉〉enditem49840〈〈self-insert-and-exit〉〉:〈〈Terminate minibuffer input.〉〉enditem49840〈〈previous-history-element〉〉:〈〈Puts previous element of the minibuffer history in the minibuffer.
With argument N, it uses the Nth previous element.

(fn N)〉〉enditem49840〈〈next-history-element〉〉:〈〈Puts next element of the minibuffer history in the minibuffer.
With argument N, it uses the Nth following element.

(fn N)〉〉enditem49840〈〈previous-matching-history-element〉〉:〈〈Find the previous history element that matches REGEXP.
(Previous history elements refer to earlier actions.)
With prefix argument N, search for Nth previous match.
If N is negative, find the next or Nth next match.
Normally, history elements are matched case-insensitively if
‘case-fold-search’ is non-nil, but an uppercase letter in REGEXP
makes the search case-sensitive.
See also ‘minibuffer-history-case-insensitive-variables’.

(fn REGEXP N)〉〉enditem49840〈〈next-matching-history-element〉〉:〈〈Find the next history element that matches REGEXP.
(The next history element refers to a more recent action.)
With prefix argument N, search for Nth next match.
If N is negative, find the previous or Nth previous match.
Normally, history elements are matched case-insensitively if
‘case-fold-search’ is non-nil, but an uppercase letter in REGEXP
makes the search case-sensitive.

(fn REGEXP N)〉〉enditem49840〈〈previous-complete-history-element〉〉:〈〈Get previous history element which completes the minibuffer before the point.
The contents of the minibuffer after the point are deleted, and replaced
by the new completion.

(fn N)〉〉enditem49840〈〈next-complete-history-element〉〉:〈〈Get next history element which completes the minibuffer before the point.
The contents of the minibuffer after the point are deleted, and replaced
by the new completion.

(fn N)〉〉enditem49840〈〈load-file〉〉:〈〈Load the Lisp file named FILE.

(fn FILE)〉〉enditem49840〈〈load-library〉〉:〈〈Load the Emacs Lisp library named LIBRARY.
LIBRARY should be a string.
This is an interface to the function ‘load’.  LIBRARY is searched
for in ‘load-path’, both with and without ‘load-suffixes’ (as
well as ‘load-file-rep-suffixes’).

See Info node ‘(emacs)Lisp Libraries’ for more details.
See ‘load-file’ for a different interface to ‘load’.

(fn LIBRARY)〉〉enditem49840〈〈read-only-mode〉〉:〈〈Change whether the current buffer is read-only.
With prefix argument ARG, make the buffer read-only if ARG is
positive, otherwise make it writable.  If buffer is read-only
and ‘view-read-only’ is non-nil, enter view mode.

Do not call this from a Lisp program unless you really intend to
do the same thing as the DEL n p command, including
possibly enabling or disabling View mode.  Also, note that this
command works by setting the variable ‘buffer-read-only’, which
does not affect read-only regions caused by text properties.  To
ignore read-only status in a Lisp program (whether due to text
properties or buffer state), bind ‘inhibit-read-only’ temporarily
to a non-nil value.

(fn &optional ARG)〉〉enditem49840〈〈kill-emacs〉〉:〈〈Exit the Emacs job and kill it.
If ARG is an integer, return ARG as the exit program code.
If ARG is a string, stuff it as keyboard input.

This function is called upon receipt of the signals SIGTERM
or SIGHUP, and upon SIGINT in batch mode.

The value of ‘kill-emacs-hook’, if not void,
is a list of functions (of no args),
all of which are called before Emacs is actually killed.

(fn &optional ARG)〉〉enditem49840〈〈indent-region〉〉:〈〈Indent each nonblank line in the region.
A numeric prefix argument specifies a column: indent each line to that column.

With no prefix argument, the command chooses one of these methods and
indents all the lines with it:

  1) If ‘fill-prefix’ is non-nil, insert ‘fill-prefix’ at the
     beginning of each line in the region that does not already begin
     with it.
  2) If ‘indent-region-function’ is non-nil, call that function
     to indent the region.
  3) Indent each line via ‘indent-according-to-mode’.

Called from a program, START and END specify the region to indent.
If the third argument COLUMN is an integer, it specifies the
column to indent to; if it is nil, use one of the three methods above.

(fn START END &optional COLUMN)〉〉enditem49840〈〈indent-rigidly〉〉:〈〈Indent all lines starting in the region.
If called interactively with no prefix argument, activate a
transient mode in which the indentation can be adjusted interactively
by typing <left>, <right>, <S-left>, or <S-right>.
Typing any other key deactivates the transient mode.

If called from a program, or interactively with prefix ARG,
indent all lines starting in the region forward by ARG columns.
If called from a program, START and END specify the beginning and
end of the text to act on, in place of the region.

Negative values of ARG indent backward, so you can remove all
indentation by specifying a large negative ARG.

(fn START END ARG &optional INTERACTIVE)〉〉enditem49840〈〈indent-code-rigidly〉〉:〈〈Indent all lines of code, starting in the region, sideways by ARG columns.
Does not affect lines starting inside comments or strings, assuming that
the start of the region is not inside them.

Called from a program, takes args START, END, COLUMNS and NOCHANGE-REGEXP.
The last is a regexp which, if matched at the beginning of a line,
means don’t indent that line.

(fn START END ARG &optional NOCHANGE-REGEXP)〉〉enditem49840〈〈play-sound-file〉〉:〈〈Play sound stored in FILE.
VOLUME and DEVICE correspond to the keywords of the sound
specification for ‘play-sound’.

(fn FILE &optional VOLUME DEVICE)〉〉enditem49840〈〈forward-word〉〉:〈〈Move point forward ARG words (backward if ARG is negative).
If ARG is omitted or nil, move point forward one word.
Normally returns t.
If an edge of the buffer or a field boundary is reached, point is
left there and the function returns nil.  Field boundaries are not
noticed if ‘inhibit-field-text-motion’ is non-nil.

The word boundaries are normally determined by the buffer’s syntax
table and character script (according to ‘char-script-table’), but
‘find-word-boundary-function-table’, such as set up by ‘subword-mode’,
can change that.  If a Lisp program needs to move by words determined
strictly by the syntax table, it should use ‘forward-word-strictly’
instead.  See Info node ‘(elisp) Word Motion’ for details.

(fn &optional ARG)〉〉enditem49840〈〈backward-word〉〉:〈〈Move backward until encountering the beginning of a word.
With argument ARG, do this that many times.
If ARG is omitted or nil, move point backward one word.

The word boundaries are normally determined by the buffer’s
syntax table and character script (according to
‘char-script-table’), but ‘find-word-boundary-function-table’,
such as set up by ‘subword-mode’, can change that.  If a Lisp
program needs to move by words determined strictly by the syntax
table, it should use ‘backward-word-strictly’ instead.  See Info
node ‘(elisp) Word Motion’ for details.

(fn &optional ARG)〉〉enditem49840〈〈auto-save-mode〉〉:〈〈Toggle auto-saving in the current buffer (Auto Save mode).
With a prefix argument ARG, enable Auto Save mode if ARG is
positive, and disable it otherwise.

If called from Lisp, enable the mode if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈do-auto-save〉〉:〈〈Auto-save all buffers that need it.
This is all buffers that have auto-saving enabled
and are changed since last auto-saved.
Auto-saving writes the buffer into a file
so that your editing is not lost if the system crashes.
This file is not the file you visited; that changes only when you save.
Normally, run the normal hook ‘auto-save-hook’ before saving.

A non-nil NO-MESSAGE argument means do not print any message if successful.
A non-nil CURRENT-ONLY argument means save only current buffer.

(fn &optional NO-MESSAGE CURRENT-ONLY)〉〉enditem49840〈〈other-window〉〉:〈〈Select another window in cyclic ordering of windows.
COUNT specifies the number of windows to skip, starting with the
selected window, before making the selection.  If COUNT is
positive, skip COUNT windows forwards.  If COUNT is negative,
skip -COUNT windows backwards.  COUNT zero means do not skip any
window, so select the selected window.  In an interactive call,
COUNT is the numeric prefix argument.  Return nil.

If the ‘other-window’ parameter of the selected window is a
function and ‘ignore-window-parameters’ is nil, call that
function with the arguments COUNT and ALL-FRAMES.

This function does not select a window whose ‘no-other-window’
window parameter is non-nil.

This function uses ‘next-window’ for finding the window to
select.  The argument ALL-FRAMES has the same meaning as in
‘next-window’, but the MINIBUF argument of ‘next-window’ is
always effectively nil.

(fn COUNT &optional ALL-FRAMES)〉〉enditem49840〈〈normal-mode〉〉:〈〈Choose the major mode for this buffer automatically.
Also sets up any specified local variables of the file.
Uses the visited file name, the -*- line, and the local variables spec.

This function is called automatically from ‘find-file’.  In that case,
we may set up the file-specified mode and local variables,
depending on the value of ‘enable-local-variables’.
In addition, if ‘local-enable-local-variables’ is nil, we do
not set local variables (though we do notice a mode specified with -*-.)

‘enable-local-variables’ is ignored if you run ‘normal-mode’ interactively,
or from Lisp without specifying the optional argument FIND-FILE;
in that case, this function acts as if ‘enable-local-variables’ were t.

(fn &optional FIND-FILE)〉〉enditem49840〈〈fundamental-mode〉〉:〈〈Major mode not specialized for anything in particular.
Other major modes are defined by comparison with this one.〉〉enditem49840〈〈getenv〉〉:〈〈Get the value of environment variable VARIABLE.
VARIABLE should be a string.  Value is nil if VARIABLE is undefined in
the environment.  Otherwise, value is a string.

If optional parameter FRAME is non-nil, then it should be a
frame.  This function will look up VARIABLE in its ‘environment’
parameter.

Otherwise, this function searches ‘process-environment’ for
VARIABLE.  If it is not found there, then it continues the search
in the environment list of the selected frame.

(fn VARIABLE &optional FRAME)〉〉enditem49840〈〈setenv〉〉:〈〈Set the value of the environment variable named VARIABLE to VALUE.
VARIABLE should be a string.  VALUE is optional; if not provided or
nil, the environment variable VARIABLE will be removed.

Interactively, a prefix argument means to unset the variable, and
otherwise the current value (if any) of the variable appears at
the front of the history list when you type in the new value.
This function always replaces environment variables in the new
value when called interactively.

SUBSTITUTE-ENV-VARS, if non-nil, means to substitute environment
variables in VALUE with ‘substitute-env-vars’, which see.
This is normally used only for interactive calls.

The return value is the new value of VARIABLE, or nil if
it was removed from the environment.

This function works by modifying ‘process-environment’.

As a special case, setting variable ‘TZ’ calls ‘set-time-zone-rule’ as
a side-effect.

(fn VARIABLE &optional VALUE SUBSTITUTE-ENV-VARS)〉〉enditem49840〈〈search-forward〉〉:〈〈Search forward from point for STRING.
Set point to the end of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not end after that position.  A value of nil
  means search to the end of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, move to limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  backward, instead of forward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth one (or first,
  if COUNT is 1 or nil) in the buffer located entirely after the
  origin of the search; correspondingly with COUNT negative.

Search case-sensitivity is determined by the value of the variable
‘case-fold-search’, which see.

See also the functions ‘match-beginning’, ‘match-end’ and ‘replace-match’.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈search-backward〉〉:〈〈Search backward from point for STRING.
Set point to the beginning of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not begin before that position.  A value of nil
  means search to the beginning of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, position at limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  forward, instead of backward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth to last one (or
  last, if COUNT is 1 or nil) in the buffer located entirely before
  the origin of the search; correspondingly with COUNT negative.

Search case-sensitivity is determined by the value of the variable
‘case-fold-search’, which see.

See also the functions ‘match-beginning’, ‘match-end’ and ‘replace-match’.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈word-search-forward〉〉:〈〈Search forward from point for STRING, ignoring differences in punctuation.
Set point to the end of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not end after that position.  A value of nil
  means search to the end of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, move to limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  backward, instead of forward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth one (or first,
  if COUNT is 1 or nil) in the buffer located entirely after the
  origin of the search; correspondingly with COUNT negative.

Relies on the function ‘word-search-regexp’ to convert a sequence
of words in STRING to a regexp used to search words without regard
to punctuation.
This command does not support character folding, and lax space matching
has no effect on it.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈word-search-forward-lax〉〉:〈〈Search forward from point for STRING, ignoring differences in punctuation.
Set point to the end of the occurrence found, and return point.

Unlike ‘word-search-forward’, the end of STRING need not match a word
boundary, unless STRING ends in whitespace.

An optional second argument bounds the search; it is a buffer position.
  The match found must not end after that position.  A value of nil
  means search to the end of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, move to limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  backward, instead of forward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth one (or first,
  if COUNT is 1 or nil) in the buffer located entirely after the
  origin of the search; correspondingly with COUNT negative.

Relies on the function ‘word-search-regexp’ to convert a sequence
of words in STRING to a regexp used to search words without regard
to punctuation.
This command does not support character folding, and lax space matching
has no effect on it.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈word-search-backward〉〉:〈〈Search backward from point for STRING, ignoring differences in punctuation.
Set point to the beginning of the occurrence found, and return point.
An optional second argument bounds the search; it is a buffer position.
  The match found must not begin before that position.  A value of nil
  means search to the beginning of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, position at limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  forward, instead of backward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth to last one (or
  last, if COUNT is 1 or nil) in the buffer located entirely before
  the origin of the search; correspondingly with COUNT negative.

Relies on the function ‘word-search-regexp’ to convert a sequence
of words in STRING to a regexp used to search words without regard
to punctuation.
This command does not support character folding, and lax space matching
has no effect on it.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈word-search-backward-lax〉〉:〈〈Search backward from point for STRING, ignoring differences in punctuation.
Set point to the beginning of the occurrence found, and return point.

Unlike ‘word-search-backward’, the end of STRING need not match a word
boundary, unless STRING ends in whitespace.

An optional second argument bounds the search; it is a buffer position.
  The match found must not begin before that position.  A value of nil
  means search to the beginning of the accessible portion of the buffer.
Optional third argument, if t, means if fail just return nil (no error).
  If not nil and not t, position at limit of search and return nil.
Optional fourth argument COUNT, if a positive number, means to search
  for COUNT successive occurrences.  If COUNT is negative, search
  forward, instead of backward, for -COUNT occurrences.  A value of
  nil means the same as 1.
With COUNT positive, the match found is the COUNTth to last one (or
  last, if COUNT is 1 or nil) in the buffer located entirely before
  the origin of the search; correspondingly with COUNT negative.

Relies on the function ‘word-search-regexp’ to convert a sequence
of words in STRING to a regexp used to search words without regard
to punctuation.
This command does not support character folding, and lax space matching
has no effect on it.

(fn STRING &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈base64-encode-region〉〉:〈〈Base64-encode the region between BEG and END.
Return the length of the encoded text.
Optional third argument NO-LINE-BREAK means do not break long lines
into shorter lines.

(fn BEG END &optional NO-LINE-BREAK)〉〉enditem49840〈〈base64-decode-region〉〉:〈〈Base64-decode the region between BEG and END.
Return the length of the decoded text.
If the region can’t be decoded, signal an error and don’t modify the buffer.

(fn BEG END)〉〉enditem49840〈〈compile-defun〉〉:〈〈Compile and evaluate the current top-level form.
Print the result in the echo area.
With argument ARG, insert value in current buffer after the form.

(fn &optional ARG)〉〉enditem49840〈〈byte-compile-file〉〉:〈〈Compile a file of Lisp code named FILENAME into a file of byte code.
The output file’s name is generated by passing FILENAME to the
function ‘byte-compile-dest-file’ (which see).
With prefix arg (noninteractively: 2nd arg), LOAD the file after compiling.
The value is non-nil if there were no errors, nil if errors.

(fn FILENAME &optional LOAD)〉〉enditem49840〈〈byte-recompile-directory〉〉:〈〈Recompile every ‘.el’ file in DIRECTORY that needs recompilation.
This happens when a ‘.elc’ file exists but is older than the ‘.el’ file.
Files in subdirectories of DIRECTORY are processed also.

If the ‘.elc’ file does not exist, normally this function *does not*
compile the corresponding ‘.el’ file.  However, if the prefix argument
ARG is 0, that means do compile all those files.  A nonzero
ARG means ask the user, for each such ‘.el’ file, whether to
compile it.  A nonzero ARG also means ask about each subdirectory
before scanning it.

If the third argument FORCE is non-nil, recompile every ‘.el’ file
that already has a ‘.elc’ file.

(fn DIRECTORY &optional ARG FORCE)〉〉enditem49840〈〈execute-extended-command〉〉:〈〈Read a command name, then read the arguments and call the command.
To pass a prefix argument to the command you are
invoking, give a prefix argument to ‘execute-extended-command’.

(fn PREFIXARG &optional COMMAND-NAME TYPED)〉〉enditem49840〈〈backtrace〉〉:〈〈Print a trace of Lisp function calls currently active.
Output stream used is value of ‘standard-output’.〉〉enditem49840〈〈make-frame-on-display〉〉:〈〈Make a frame on display DISPLAY.
The optional argument PARAMETERS specifies additional frame parameters.

(fn DISPLAY &optional PARAMETERS)〉〉enditem49840〈〈find-file〉〉:〈〈Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists.
Interactively, the default if you just type RET is the current directory,
but the visited file name is available through the minibuffer history:
type M-x next-history-element to pull it into the minibuffer.

The first time M-x next-history-element is used after Emacs prompts for
the file name, the result is affected by ‘file-name-at-point-functions’,
which by default try to guess the file name by looking at point in the
current buffer.  Customize the value of ‘file-name-at-point-functions’
or set it to nil, if you want only the visited file name and the
current directory to be available on first M-x next-history-element
request.

You can visit files on remote machines by specifying something
like /ssh:SOME_REMOTE_MACHINE:FILE for the file name.  You can
also visit local files as a different user by specifying
/sudo::FILE for the file name.
See the Info node ‘(tramp)File name Syntax’ in the Tramp Info
manual, for more about this.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.  You can
suppress wildcard expansion by setting ‘find-file-wildcards’ to nil.

To visit a file without any kind of conversion and without
automatically choosing a major mode, use M-x find-file-literally.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-file-literally〉〉:〈〈Visit file FILENAME with no conversion of any kind.
Format conversion and character code conversion are both disabled,
and multibyte characters are disabled in the resulting buffer.
The major mode used is Fundamental mode regardless of the file name,
and local variable specifications in the file are ignored.
Automatic uncompression and adding a newline at the end of the
file due to ‘require-final-newline’ is also disabled.

If Emacs already has a buffer which is visiting the file,
this command asks you whether to visit it literally instead.

In non-interactive use, the value is the buffer where the file is
visited literally.  If the file was visited in a buffer before
this command was invoked, it will reuse the existing buffer,
regardless of whether it was created literally or not; however,
the contents of that buffer will be the literal text of the file
without any conversions.

In a Lisp program, if you want to be sure of accessing a file’s
contents literally, you should create a temporary buffer and then read
the file contents into it using ‘insert-file-contents-literally’.

(fn FILENAME)〉〉enditem49840〈〈find-file-other-window〉〉:〈〈Edit file FILENAME, in another window.

Like C-o (which see), but creates a new window or reuses
an existing one.  See the function ‘display-buffer’.

Interactively, the default if you just type RET is the current directory,
but the visited file name is available through the minibuffer history:
type M-x next-history-element to pull it into the minibuffer.

The first time M-x next-history-element is used after Emacs prompts for
the file name, the result is affected by ‘file-name-at-point-functions’,
which by default try to guess the file name by looking at point in the
current buffer.  Customize the value of ‘file-name-at-point-functions’
or set it to nil, if you want only the visited file name and the
current directory to be available on first M-x next-history-element
request.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-file-read-only〉〉:〈〈Edit file FILENAME but don’t allow changes.
Like C-o, but marks buffer as read-only.
Use DEL n p to permit editing.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈format-write-file〉〉:〈〈Write current buffer into FILENAME, using a format based on FORMAT.
Constructs the actual format starting from FORMAT, then appending
any elements from the value of ‘buffer-file-format’ with a non-nil
‘preserve’ flag (see the documentation of ‘format-alist’), if they
are not already present in FORMAT.  It then updates ‘buffer-file-format’
with this format, making it the default for future saves.

If the buffer is already visiting a file, you can specify a
directory name as FILENAME, to write a file of the same old name
in that directory.

If optional third arg CONFIRM is non-nil, asks for confirmation before
overwriting an existing file.  Interactively, requires confirmation
unless you supply a prefix argument.〉〉enditem49840〈〈format-find-file〉〉:〈〈Find the file FILENAME using data format FORMAT.
If FORMAT is nil then do not do any format conversion.〉〉enditem49840〈〈format-insert-file〉〉:〈〈Insert the contents of file FILENAME using data format FORMAT.
If FORMAT is nil then do not do any format conversion.
The optional third and fourth arguments BEG and END specify
the part (in bytes) of the file to read.

The return value is like the value of ‘insert-file-contents’:
a list (ABSOLUTE-FILE-NAME SIZE).〉〉enditem49840〈〈enable-command〉〉:〈〈Allow COMMAND to be executed without special confirmation from now on.
COMMAND must be a symbol.
This command alters the user’s .emacs file so that this will apply
to future sessions.

(fn COMMAND)〉〉enditem49840〈〈disable-command〉〉:〈〈Require special confirmation to execute COMMAND from now on.
COMMAND must be a symbol.
This command alters your init file so that this choice applies to
future sessions.

(fn COMMAND)〉〉enditem49840〈〈switch-to-prev-buffer〉〉:〈〈In WINDOW switch to previous buffer.
WINDOW must be a live window and defaults to the selected one.
Return the buffer switched to, nil if no suitable buffer could be
found.

Optional argument BURY-OR-KILL non-nil means the buffer currently
shown in WINDOW is about to be buried or killed and consequently
shall not be switched to in future invocations of this command.

As a special case, if BURY-OR-KILL equals ‘append’, this means to
move the buffer to the end of WINDOW’s previous buffers list so a
future invocation of ‘switch-to-prev-buffer’ less likely switches
to it.

(fn &optional WINDOW BURY-OR-KILL)〉〉enditem49840〈〈switch-to-next-buffer〉〉:〈〈In WINDOW switch to next buffer.
WINDOW must be a live window and defaults to the selected one.
Return the buffer switched to, nil if no suitable buffer could be
found.

(fn &optional WINDOW)〉〉enditem49840〈〈describe-buffer-case-table〉〉:〈〈Describe the case table of the current buffer.〉〉enditem49840〈〈recursive-edit〉〉:〈〈Invoke the editor command loop recursively.
To get out of the recursive edit, a command can throw to ‘exit’ -- for
instance (throw 'exit nil).
If you throw a value other than t, ‘recursive-edit’ returns normally
to the function that called it.  Throwing a t value causes
‘recursive-edit’ to quit, so that control returns to the command loop
one level up.

This function is called by the editor initialization to begin editing.

(fn)〉〉enditem49840〈〈exit-recursive-edit〉〉:〈〈Exit from the innermost recursive edit or minibuffer.

(fn)〉〉enditem49840〈〈abort-recursive-edit〉〉:〈〈Abort the command that requested this recursive edit or minibuffer input.

(fn)〉〉enditem49840〈〈top-level〉〉:〈〈Exit all recursive editing levels.
This also exits all active minibuffers.

(fn)〉〉enditem49840〈〈replace-buffer-in-windows〉〉:〈〈Replace BUFFER-OR-NAME with some other buffer in all windows showing it.
BUFFER-OR-NAME may be a buffer or the name of an existing buffer
and defaults to the current buffer.

When a window showing BUFFER-OR-NAME is dedicated, that window is
deleted.  If that window is the only window on its frame, the
frame is deleted too when there are other frames left.  If there
are no other frames left, some other buffer is displayed in that
window.

This function removes the buffer denoted by BUFFER-OR-NAME from
all window-local buffer lists.

(fn &optional BUFFER-OR-NAME)〉〉enditem49840〈〈goto-char〉〉:〈〈Set point to POSITION, a number or marker.
Beginning of buffer is position (point-min), end is (point-max).

The return value is POSITION.

(fn POSITION)〉〉enditem49840〈〈forward-char〉〉:〈〈Move point N characters forward (backward if N is negative).
On reaching end or beginning of buffer, stop and signal error.
Interactively, N is the numeric prefix argument.
If N is omitted or nil, move point 1 character forward.

Depending on the bidirectional context, the movement may be to the
right or to the left on the screen.  This is in contrast with
<right>, which see.

(fn &optional N)〉〉enditem49840〈〈backward-char〉〉:〈〈Move point N characters backward (forward if N is negative).
On attempt to pass beginning or end of buffer, stop and signal error.
Interactively, N is the numeric prefix argument.
If N is omitted or nil, move point 1 character backward.

Depending on the bidirectional context, the movement may be to the
right or to the left on the screen.  This is in contrast with
<left>, which see.

(fn &optional N)〉〉enditem49840〈〈set-face-foreground〉〉:〈〈Change the foreground color of face FACE to COLOR (a string).
FRAME nil or not specified means change face on all frames.
COLOR can be a system-defined color name (see ‘list-colors-display’)
or a hex spec of the form #RRGGBB.
When called interactively, prompts for the face and color.

(fn FACE COLOR &optional FRAME)〉〉enditem49840〈〈set-face-background〉〉:〈〈Change the background color of face FACE to COLOR (a string).
FRAME nil or not specified means change face on all frames.
COLOR can be a system-defined color name (see ‘list-colors-display’)
or a hex spec of the form #RRGGBB.
When called interactively, prompts for the face and color.

(fn FACE COLOR &optional FRAME)〉〉enditem49840〈〈set-face-stipple〉〉:〈〈Change the stipple pixmap of face FACE to STIPPLE.
FRAME nil or not specified means change face on all frames.
STIPPLE should be a string, the name of a file of pixmap data.
The directories listed in the ‘x-bitmap-file-path’ variable are searched.

Alternatively, STIPPLE may be a list of the form (WIDTH HEIGHT DATA)
where WIDTH and HEIGHT are the size in pixels,
and DATA is a string, containing the raw bits of the bitmap.

(fn FACE STIPPLE &optional FRAME)〉〉enditem49840〈〈set-face-font〉〉:〈〈Change font-related attributes of FACE to those of FONT (a string).
FRAME nil or not specified means change face on all frames.
This sets the attributes ‘:family’, ‘:foundry’, ‘:width’,
‘:height’, ‘:weight’, and ‘:slant’.  When called interactively,
prompt for the face and font.

(fn FACE FONT &optional FRAME)〉〉enditem49840〈〈invert-face〉〉:〈〈Swap the foreground and background colors of FACE.
If FRAME is omitted or nil, it means change face on all frames.
If FACE specifies neither foreground nor background color,
set its foreground and background to the background and foreground
of the default face.  Value is FACE.

(fn FACE &optional FRAME)〉〉enditem49840〈〈translate-region〉〉:〈〈From START to END, translate characters according to TABLE.
TABLE is a string or a char-table.
If TABLE is a string, the Nth character in it is the mapping
for the character with code N.
If TABLE is a char-table, the element for character N is the mapping
for the character with code N.
It returns the number of characters changed.〉〉enditem49840〈〈run-with-idle-timer〉〉:〈〈Perform an action the next time Emacs is idle for SECS seconds.
The action is to call FUNCTION with arguments ARGS.
SECS may be an integer, a floating point number, or the internal
time format returned by, e.g., ‘current-idle-time’.
If Emacs is currently idle, and has been idle for N seconds (N < SECS),
then it will call FUNCTION in SECS - N seconds from now.  Using
SECS <= N is not recommended if this function is invoked from an idle
timer, because FUNCTION will then be called immediately.

If REPEAT is non-nil, do the action each time Emacs has been idle for
exactly SECS seconds (that is, only once for each time Emacs becomes idle).

This function returns a timer object which you can use in ‘cancel-timer’.

(fn SECS REPEAT FUNCTION &rest ARGS)〉〉enditem49840〈〈delete-window〉〉:〈〈Delete WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil.

If the variable ‘ignore-window-parameters’ is non-nil or the
‘delete-window’ parameter of WINDOW equals t, do not process any
parameters of WINDOW.  Otherwise, if the ‘delete-window’
parameter of WINDOW specifies a function, call that function with
WINDOW as its sole argument and return the value returned by that
function.

Otherwise, if WINDOW is part of an atomic window, call
‘delete-window’ with the root of the atomic window as its
argument.  Signal an error if WINDOW is either the only window on
its frame, the last non-side window, or part of an atomic window
that is its frame’s root window.

(fn &optional WINDOW)〉〉enditem49840〈〈delete-other-windows〉〉:〈〈Make WINDOW fill its frame.
WINDOW must be a valid window and defaults to the selected one.
Return nil.

If the variable ‘ignore-window-parameters’ is non-nil or the
‘delete-other-windows’ parameter of WINDOW equals t, do not pay
attention to any other parameters of WINDOW.  Otherwise, if the
‘delete-other-windows’ parameter of WINDOW specifies a function,
call that function with WINDOW as its sole argument and return
the value returned by that function.

Else, if WINDOW is part of an atomic window, call this function
with the root of the atomic window as its argument.  Signal an
error if that root window is the root window of WINDOW’s frame.
Also signal an error if WINDOW is a side window.  Do not delete
any window whose ‘no-delete-other-windows’ parameter is non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈delete-windows-on〉〉:〈〈Delete all windows showing BUFFER-OR-NAME.
BUFFER-OR-NAME may be a buffer or the name of an existing buffer
and defaults to the current buffer.

The following non-nil values of the optional argument FRAME
have special meanings:

- t means consider all windows on the selected frame only.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Any other value of FRAME means consider all windows on all
frames.

When a window showing BUFFER-OR-NAME is dedicated and the only
window of its frame, that frame is deleted when there are other
frames left.

(fn &optional BUFFER-OR-NAME FRAME)〉〉enditem49840〈〈describe-mode〉〉:〈〈Display documentation of current major mode and minor modes.
A brief summary of the minor modes comes first, followed by the
major mode description.  This is followed by detailed
descriptions of the minor modes, each on a separate page.

For this to work correctly for a minor mode, the mode’s indicator
variable (listed in ‘minor-mode-alist’) must also be a function
whose documentation describes the minor mode.

If called from Lisp with a non-nil BUFFER argument, display
documentation for the major and minor modes of that buffer.〉〉enditem49840〈〈select-frame〉〉:〈〈Select FRAME.
Subsequent editing commands apply to its selected window.
Optional argument NORECORD means to neither change the order of
recently selected windows nor the buffer list.

The selection of FRAME lasts until the next time the user does
something to select a different frame, or until the next time
this function is called.  If you are using a window system, the
previously selected frame may be restored as the selected frame
when returning to the command loop, because it still may have
the window system’s input focus.  On a text terminal, the next
redisplay will display FRAME.

This function returns FRAME, or nil if FRAME has been deleted.

(fn FRAME &optional NORECORD)〉〉enditem49840〈〈handle-switch-frame〉〉:〈〈Handle a switch-frame event EVENT.
Switch-frame events are usually bound to this function.
A switch-frame event tells Emacs that the window manager has requested
that the user’s events be directed to the frame mentioned in the event.
This function selects the selected window of the frame of EVENT.

If EVENT is frame object, handle it as if it were a switch-frame event
to that frame.

(fn EVENT)〉〉enditem49840〈〈redraw-display〉〉:〈〈Clear and redisplay all visible frames.

(fn)〉〉enditem49840〈〈apropos〉〉:〈〈Show all meaningful Lisp symbols whose names match PATTERN.
Symbols are shown if they are defined as functions, variables, or
faces, or if they have nonempty property lists.

PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words.

With C-u prefix, or if ‘apropos-do-all’ is non-nil,
consider all symbols (if they match PATTERN).

Returns list of symbols and documentation found.

(fn PATTERN &optional DO-ALL)〉〉enditem49840〈〈describe-prefix-bindings〉〉:〈〈Describe the bindings of the prefix used to reach this command.
The prefix described consists of all but the last event
of the key sequence that ran this command.〉〉enditem49840〈〈Helper-describe-bindings〉〉:〈〈Describe local key bindings of current mode.

(fn)〉〉enditem49840〈〈Helper-help〉〉:〈〈Provide help for current mode.

(fn)〉〉enditem49840〈〈revert-buffer〉〉:〈〈Replace current buffer text with the text of the visited file on disk.
This undoes all changes since the file was visited or saved.
With a prefix argument, offer to revert from latest auto-save file, if
that is more recent than the visited file.

This command also implements an interface for special buffers
that contain text which doesn’t come from a file, but reflects
some other data instead (e.g. Dired buffers, ‘buffer-list’
buffers).  This is done via the variable ‘revert-buffer-function’.
In these cases, it should reconstruct the buffer contents from the
appropriate data.

When called from Lisp, the first argument is IGNORE-AUTO; only offer
to revert from the auto-save file when this is nil.  Note that the
sense of this argument is the reverse of the prefix argument, for the
sake of backward compatibility.  IGNORE-AUTO is optional, defaulting
to nil.

Optional second argument NOCONFIRM means don’t ask for confirmation
at all.  (The variable ‘revert-without-query’ offers another way to
revert buffers without querying for confirmation.)

Optional third argument PRESERVE-MODES non-nil means don’t alter
the files modes.  Normally we reinitialize them using ‘normal-mode’.

This function binds ‘revert-buffer-in-progress-p’ non-nil while it operates.

This function calls the function that ‘revert-buffer-function’ specifies
to do the work, with arguments IGNORE-AUTO and NOCONFIRM.
The default function runs the hooks ‘before-revert-hook’ and
‘after-revert-hook’.

(fn &optional IGNORE-AUTO NOCONFIRM PRESERVE-MODES)〉〉enditem49840〈〈narrow-to-region〉〉:〈〈Restrict editing in this buffer to the current region.
The rest of the text becomes temporarily invisible and untouchable
but is not deleted; if you save the buffer in a file, the invisible
text is included in the file.  DEL n h makes all visible again.
See also ‘save-restriction’.

When calling from a program, pass two arguments; positions (integers
or markers) bounding the text that should remain visible.

(fn START END)〉〉enditem49840〈〈narrow-to-page〉〉:〈〈Make text outside current page invisible.
A numeric arg specifies to move forward or backward by that many pages,
thus showing a page other than the one point was originally in.〉〉enditem49840〈〈widen〉〉:〈〈Remove restrictions (narrowing) from current buffer.
This allows the buffer’s full text to be seen and edited.

(fn)〉〉enditem49840〈〈disassemble〉〉:〈〈Print disassembled code for OBJECT in (optional) BUFFER.
OBJECT can be a symbol defined as a function, or a function itself
(a lambda expression or a compiled-function object).
If OBJECT is not already compiled, we compile it, but do not
redefine OBJECT if it is a symbol.

(fn OBJECT &optional BUFFER INDENT INTERACTIVE-P)〉〉enditem49840〈〈encode-coding-region〉〉:〈〈Encode the current region by specified coding system.
When called from a program, takes four arguments:
        START, END, CODING-SYSTEM and DESTINATION.
START and END are buffer positions.

Optional 4th argument DESTINATION specifies where the encoded text goes.
If nil, the region between START and END is replaced by the encoded text.
If buffer, the encoded text is inserted in that buffer after point (point
does not move).
In those cases, the length of the encoded text is returned.
If DESTINATION is t, the encoded text is returned.

This function sets ‘last-coding-system-used’ to the precise coding system
used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
not fully specified.)

(fn START END CODING-SYSTEM &optional DESTINATION)〉〉enditem49840〈〈decode-coding-region〉〉:〈〈Decode the current region from the specified coding system.
When called from a program, takes four arguments:
	START, END, CODING-SYSTEM, and DESTINATION.
START and END are buffer positions.

Optional 4th arguments DESTINATION specifies where the decoded text goes.
If nil, the region between START and END is replaced by the decoded text.
If buffer, the decoded text is inserted in that buffer after point (point
does not move).
In those cases, the length of the decoded text is returned.
If DESTINATION is t, the decoded text is returned.

This function sets ‘last-coding-system-used’ to the precise coding system
used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
not fully specified.)

(fn START END CODING-SYSTEM &optional DESTINATION)〉〉enditem49840〈〈imenu-add-to-menubar〉〉:〈〈Add an ‘imenu’ entry to the menu bar for the current buffer.
NAME is a string used to name the menu bar item.
See the command ‘imenu’ for more information.

(fn NAME)〉〉enditem49840〈〈set-keyboard-coding-system〉〉:〈〈Set coding system for keyboard input on TERMINAL to CODING-SYSTEM.

For a list of possible values of CODING-SYSTEM, use M-x list-coding-systems.
The default is determined by the selected language environment
or by the previous use of this command.

If CODING-SYSTEM is nil or the coding-type of CODING-SYSTEM is
‘raw-text’, the decoding of keyboard input is disabled.

TERMINAL may be a terminal object, a frame, or nil for the
selected frame’s terminal.  The setting has no effect on
graphical terminals.〉〉enditem49840〈〈set-terminal-coding-system〉〉:〈〈Set coding system of terminal output to CODING-SYSTEM.
All text output to TERMINAL will be encoded
with the specified coding system.

For a list of possible values of CODING-SYSTEM, use M-x list-coding-systems.
The default is determined by the selected language environment
or by the previous use of this command.

TERMINAL may be a terminal object, a frame, or nil for the
selected frame’s terminal.  The setting has no effect on
graphical terminals.〉〉enditem49840〈〈move-to-window-line〉〉:〈〈Position point relative to window.
ARG nil means position point at center of window.
Else, ARG specifies vertical position within the window;
zero means top of window, negative means relative to bottom
of window, -1 meaning the last fully visible display line
of the window.

Value is the screen line of the window point moved to, counting
from the top of the window.

(fn ARG)〉〉enditem49840〈〈display-buffer〉〉:〈〈Display BUFFER-OR-NAME in some window, without selecting it.
BUFFER-OR-NAME must be a buffer or the name of an existing
buffer.  Return the window chosen for displaying BUFFER-OR-NAME,
or nil if no such window is found.

Optional argument ACTION, if non-nil, should specify a display
action.  Its form is described below.

Optional argument FRAME, if non-nil, acts like an additional
ALIST entry (reusable-frames . FRAME) to the action list of ACTION,
specifying the frame(s) to search for a window that is already
displaying the buffer.  See ‘display-buffer-reuse-window’.

If ACTION is non-nil, it should have the form (FUNCTION . ALIST),
where FUNCTION is either a function or a list of functions, and
ALIST is an arbitrary association list (alist).

Each such FUNCTION should accept two arguments: the buffer to
display and an alist.  Based on those arguments, it should
display the buffer and return the window.  If the caller is
prepared to handle the case of not displaying the buffer
and returning nil from ‘display-buffer’ it should pass
(allow-no-window . t) as an element of the ALIST.

The ‘display-buffer’ function builds a function list and an alist
by combining the functions and alists specified in
‘display-buffer-overriding-action’, ‘display-buffer-alist’, the
ACTION argument, ‘display-buffer-base-action’, and
‘display-buffer-fallback-action’ (in order).  Then it calls each
function in the combined function list in turn, passing the
buffer as the first argument and the combined alist as the second
argument, until one of the functions returns non-nil.

If ACTION is nil, the function list and the alist are built using
only the other variables mentioned above.

Available action functions include:
 ‘display-buffer-same-window’
 ‘display-buffer-reuse-window’
 ‘display-buffer-pop-up-frame’
 ‘display-buffer-in-child-frame’
 ‘display-buffer-pop-up-window’
 ‘display-buffer-in-previous-window’
 ‘display-buffer-use-some-window’
 ‘display-buffer-use-some-frame’

Recognized alist entries include:

 ‘inhibit-same-window’ -- A non-nil value prevents the same
                          window from being used for display.

 ‘inhibit-switch-frame’ -- A non-nil value prevents any other
                           frame from being raised or selected,
                           even if the window is displayed there.

 ‘reusable-frames’ -- Value specifies frame(s) to search for a
                      window that already displays the buffer.
                      See ‘display-buffer-reuse-window’.

 ‘pop-up-frame-parameters’ -- Value specifies an alist of frame
                              parameters to give a new frame, if
                              one is created.

 ‘window-height’ -- Value specifies either an integer (the number
    of lines of a new window), a floating point number (the
    fraction of a new window with respect to the height of the
    frame’s root window) or a function to be called with one
    argument - a new window.  The function is supposed to adjust
    the height of the window; its return value is ignored.
    Suitable functions are ‘shrink-window-if-larger-than-buffer’
    and ‘fit-window-to-buffer’.

 ‘window-width’ -- Value specifies either an integer (the number
    of columns of a new window), a floating point number (the
    fraction of a new window with respect to the width of the
    frame’s root window) or a function to be called with one
    argument - a new window.  The function is supposed to adjust
    the width of the window; its return value is ignored.

 ‘allow-no-window’ -- A non-nil value indicates readiness for the case
    of not displaying the buffer and FUNCTION can safely return
    a non-window value to suppress displaying.

 ‘preserve-size’ -- Value should be either (t . nil) to
    preserve the width of the window, (nil . t) to preserve its
    height or (t . t) to preserve both.

 ‘window-parameters’ -- Value specifies an alist of window
                        parameters to give the chosen window.

The ACTION argument to ‘display-buffer’ can also have a non-nil
and non-list value.  This means to display the buffer in a window
other than the selected one, even if it is already displayed in
the selected window.  If called interactively with a prefix
argument, ACTION is t.

(fn BUFFER-OR-NAME &optional ACTION FRAME)〉〉enditem49840〈〈keyboard-quit〉〉:〈〈Signal a ‘quit’ condition.
During execution of Lisp code, this character causes a quit directly.
At top-level, as an editor command, this simply beeps.〉〉enditem49840〈〈open-dribble-file〉〉:〈〈Start writing all keyboard characters to a dribble file called FILE.
If FILE is nil, close any open dribble file.
The file will be closed when Emacs exits.

Be aware that this records ALL characters you type!
This may include sensitive information such as passwords.

(fn FILE)〉〉enditem49840〈〈make-local-variable〉〉:〈〈Make VARIABLE have a separate value in the current buffer.
Other buffers will continue to share a common default value.
(The buffer-local value of VARIABLE starts out as the same value
VARIABLE previously had.  If VARIABLE was void, it remains void.)
Return VARIABLE.

If the variable is already arranged to become local when set,
this function causes a local value to exist for this buffer,
just as setting the variable would do.

This function returns VARIABLE, and therefore
  (set (make-local-variable 'VARIABLE) VALUE-EXP)
works.

See also ‘make-variable-buffer-local’.

Do not use ‘make-local-variable’ to make a hook variable buffer-local.
Instead, use ‘add-hook’ and specify t for the LOCAL argument.

(fn VARIABLE)〉〉enditem49840〈〈make-variable-buffer-local〉〉:〈〈Make VARIABLE become buffer-local whenever it is set.
At any time, the value for the current buffer is in effect,
unless the variable has never been set in this buffer,
in which case the default value is in effect.
Note that binding the variable with ‘let’, or setting it while
a ‘let’-style binding made in this buffer is in effect,
does not make the variable buffer-local.  Return VARIABLE.

This globally affects all uses of this variable, so it belongs together with
the variable declaration, rather than with its uses (if you just want to make
a variable local to the current buffer for one particular use, use
‘make-local-variable’).  Buffer-local bindings are normally cleared
while setting up a new major mode, unless they have a ‘permanent-local’
property.

The function ‘default-value’ gets the default value and ‘set-default’ sets it.

(fn VARIABLE)〉〉enditem49840〈〈kill-local-variable〉〉:〈〈Make VARIABLE no longer have a separate value in the current buffer.
From now on the default value will apply in this buffer.  Return VARIABLE.

(fn VARIABLE)〉〉enditem49840〈〈rename-buffer〉〉:〈〈:around advice: ‘uniquify--rename-buffer-advice’

Change current buffer’s name to NEWNAME (a string).
If second arg UNIQUE is nil or omitted, it is an error if a
buffer named NEWNAME already exists.
If UNIQUE is non-nil, come up with a new name using
‘generate-new-buffer-name’.
Interactively, you can set UNIQUE with a prefix argument.
We return the name we actually gave the buffer.
This does not change the name of the visited file (if any).

(fn NEWNAME &optional UNIQUE)〉〉enditem49840〈〈describe-bindings〉〉:〈〈Display a buffer showing a list of all defined keys, and their definitions.
The keys are displayed in order of precedence.

The optional argument PREFIX, if non-nil, should be a key sequence;
then we display only bindings that start with that prefix.
The optional argument BUFFER specifies which buffer’s bindings
to display (default, the current buffer).  BUFFER can be a buffer
or a buffer name.〉〉enditem49840〈〈move-to-column〉〉:〈〈Move point to column COLUMN in the current line.
Interactively, COLUMN is the value of prefix numeric argument.
The column of a character is calculated by adding together the widths
as displayed of the previous characters in the line.
This function ignores line-continuation;
there is no upper limit on the column number a character can have
and horizontal scrolling has no effect.

If specified column is within a character, point goes after that character.
If it’s past end of line, point goes to end of line.

Optional second argument FORCE non-nil means if COLUMN is in the
middle of a tab character, change it to spaces.
In addition, if FORCE is t, and the line is too short to reach
COLUMN, add spaces/tabs to get there.

The return value is the current column.

(fn COLUMN &optional FORCE)〉〉enditem49840〈〈eval-region〉〉:〈〈Execute the region as Lisp code.
When called from programs, expects two arguments,
giving starting and ending indices in the current buffer
of the text to be executed.
Programs can pass third argument PRINTFLAG which controls output:
 a value of nil means discard it; anything else is stream for printing it.
 See Info node ‘(elisp)Output Streams’ for details on streams.
Also the fourth argument READ-FUNCTION, if non-nil, is used
instead of ‘read’ to read each expression.  It gets one argument
which is the input stream for reading characters.

This function does not move point.

(fn START END &optional PRINTFLAG READ-FUNCTION)〉〉enditem49840〈〈eval-buffer〉〉:〈〈Execute the accessible portion of current buffer as Lisp code.
You can use DEL n n to limit the part of buffer to be evaluated.
When called from a Lisp program (i.e., not interactively), this
function accepts up to five optional arguments:
BUFFER is the buffer to evaluate (nil means use current buffer),
 or a name of a buffer (a string).
PRINTFLAG controls printing of output by any output functions in the
 evaluated code, such as ‘print’, ‘princ’, and ‘prin1’:
  a value of nil means discard it; anything else is the stream to print to.
  See Info node ‘(elisp)Output Streams’ for details on streams.
FILENAME specifies the file name to use for ‘load-history’.
UNIBYTE, if non-nil, specifies ‘load-convert-to-unibyte’ for this
 invocation.
DO-ALLOW-PRINT, if non-nil, specifies that output functions in the
 evaluated code should work normally even if PRINTFLAG is nil, in
 which case the output is displayed in the echo area.

This function preserves the position of point.

(fn &optional BUFFER PRINTFLAG FILENAME UNIBYTE DO-ALLOW-PRINT)〉〉enditem49840〈〈package-initialize〉〉:〈〈Load Emacs Lisp packages, and activate them.
The variable ‘package-load-list’ controls which packages to load.
If optional arg NO-ACTIVATE is non-nil, don’t activate packages.
If ‘user-init-file’ does not mention ‘(package-initialize)’, add
it to the file.
If called as part of loading ‘user-init-file’, set
‘package-enable-at-startup’ to nil, to prevent accidentally
loading packages twice.
It is not necessary to adjust ‘load-path’ or ‘require’ the
individual packages after calling ‘package-initialize’ -- this is
taken care of by ‘package-initialize’.

(fn &optional NO-ACTIVATE)〉〉enditem49840〈〈insert-buffer〉〉:〈〈Insert after point the contents of BUFFER.
Puts mark after the inserted text.
BUFFER may be a buffer or a buffer name.

(fn BUFFER)〉〉enditem49840〈〈self-insert-command〉〉:〈〈Insert the character you type.
Whichever character you type to run this command is inserted.
The numeric prefix argument N says how many times to repeat the insertion.
Before insertion, ‘expand-abbrev’ is executed if the inserted character does
not have word syntax and the previous character in the buffer does.
After insertion, ‘internal-auto-fill’ is called if
‘auto-fill-function’ is non-nil and if the ‘auto-fill-chars’ table has
a non-nil value for the inserted character.  At the end, it runs
‘post-self-insert-hook’.

(fn N)〉〉enditem49840〈〈newline〉〉:〈〈Insert a newline, and move to left margin of the new line if it’s blank.
If option ‘use-hard-newlines’ is non-nil, the newline is marked with the
text-property ‘hard’.
With ARG, insert that many newlines.

If ‘electric-indent-mode’ is enabled, this indents the final new line
that it adds, and reindents the preceding line.  To just insert
a newline, use M-x electric-indent-just-newline.

Calls ‘auto-fill-function’ if the current column number is greater
than the value of ‘fill-column’ and ARG is nil.
A non-nil INTERACTIVE argument means to run the ‘post-self-insert-hook’.

(fn &optional ARG INTERACTIVE)〉〉enditem49840〈〈list-processes〉〉:〈〈Display a list of all processes that are Emacs sub-processes.
If optional argument QUERY-ONLY is non-nil, only processes with
the query-on-exit flag set are listed.
Any process listed as exited or signaled is actually eliminated
after the listing is made.
Optional argument BUFFER specifies a buffer to use, instead of
"*Process List*".
The return value is always nil.

This function lists only processes that were launched by Emacs.  To
see other processes running on the system, use ‘list-system-processes’.

(fn &optional QUERY-ONLY BUFFER)〉〉enditem49840〈〈quit-window〉〉:〈〈Quit WINDOW and bury its buffer.
WINDOW must be a live window and defaults to the selected one.
With prefix argument KILL non-nil, kill the buffer instead of
burying it.

According to information stored in WINDOW’s ‘quit-restore’ window
parameter either (1) delete WINDOW and its frame, (2) delete
WINDOW, (3) restore the buffer previously displayed in WINDOW,
or (4) make WINDOW display some other buffer than the present
one.  If non-nil, reset ‘quit-restore’ parameter to nil.

(fn &optional KILL WINDOW)〉〉enditem49840〈〈sort-regexp-fields〉〉:〈〈Sort the text in the region lexicographically.
If called interactively, prompt for two regular expressions,
RECORD-REGEXP and KEY-REGEXP.

RECORD-REGEXP specifies the textual units to be sorted.
  For example, to sort lines, RECORD-REGEXP would be "^.*$".

KEY-REGEXP specifies the part of each record (i.e. each match for
  RECORD-REGEXP) to be used for sorting.
  If it is "\\digit", use the digit’th "\\(...\\)"
  match field specified by RECORD-REGEXP.
  If it is "\\&", use the whole record.
  Otherwise, KEY-REGEXP should be a regular expression with which
  to search within the record.  If a match for KEY-REGEXP is not
  found within a record, that record is ignored.

With a negative prefix arg, sort in reverse order.

The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

For example: to sort lines in the region by the first word on each line
 starting with the letter "f",
 RECORD-REGEXP would be "^.*$" and KEY would be "\\<f\\w*\\>"

(fn REVERSE RECORD-REGEXP KEY-REGEXP BEG END)〉〉enditem49840〈〈sort-lines〉〉:〈〈Sort lines in region alphabetically; argument means descending order.
Called from a program, there are three arguments:
REVERSE (non-nil means reverse order), BEG and END (region to sort).
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

(fn REVERSE BEG END)〉〉enditem49840〈〈sort-paragraphs〉〉:〈〈Sort paragraphs in region alphabetically; argument means descending order.
Called from a program, there are three arguments:
REVERSE (non-nil means reverse order), BEG and END (region to sort).
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

(fn REVERSE BEG END)〉〉enditem49840〈〈sort-pages〉〉:〈〈Sort pages in region alphabetically; argument means descending order.
Called from a program, there are three arguments:
REVERSE (non-nil means reverse order), BEG and END (region to sort).
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

(fn REVERSE BEG END)〉〉enditem49840〈〈sort-fields〉〉:〈〈Sort lines in region lexicographically by the ARGth field of each line.
Fields are separated by whitespace and numbered from 1 up.
With a negative arg, sorts by the ARGth field counted from the right.
Called from a program, there are three arguments:
FIELD, BEG and END.  BEG and END specify region to sort.
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

(fn FIELD BEG END)〉〉enditem49840〈〈sort-numeric-fields〉〉:〈〈Sort lines in region numerically by the ARGth field of each line.
Fields are separated by whitespace and numbered from 1 up.
Specified field must contain a number in each line of the region,
which may begin with "0x" or "0" for hexadecimal and octal values.
Otherwise, the number is interpreted according to sort-numeric-base.
With a negative arg, sorts by the ARGth field counted from the right.
Called from a program, there are three arguments:
FIELD, BEG and END.  BEG and END specify region to sort.

(fn FIELD BEG END)〉〉enditem49840〈〈sort-columns〉〉:〈〈Sort lines in region alphabetically by a certain range of columns.
For the purpose of this command, the region BEG...END includes
the entire line that point is in and the entire line the mark is in.
The column positions of point and mark bound the range of columns to sort on.
A prefix argument means sort into REVERSE order.
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

Note that ‘sort-columns’ rejects text that contains tabs,
because tabs could be split across the specified columns
and it doesn’t know how to handle that.  Also, when possible,
it uses the ‘sort’ utility program, which doesn’t understand tabs.
Use M-x untabify to convert tabs to spaces before sorting.

(fn REVERSE &optional BEG END)〉〉enditem49840〈〈set-left-margin〉〉:〈〈Set the left margin of the region to WIDTH.
If ‘auto-fill-mode’ is active, re-fill the region to fit the new margin.

Interactively, WIDTH is the prefix argument, if specified.
Without prefix argument, the command prompts for WIDTH.

(fn FROM TO WIDTH)〉〉enditem49840〈〈set-right-margin〉〉:〈〈Set the right margin of the region to WIDTH.
If ‘auto-fill-mode’ is active, re-fill the region to fit the new margin.

Interactively, WIDTH is the prefix argument, if specified.
Without prefix argument, the command prompts for WIDTH.

(fn FROM TO WIDTH)〉〉enditem49840〈〈move-to-left-margin〉〉:〈〈Move to the left margin of the current line.
With optional argument, move forward N-1 lines first.
The column moved to is the one given by the ‘current-left-margin’ function.
If the line’s indentation appears to be wrong, and this command is called
interactively or with optional argument FORCE, it will be fixed.

(fn &optional N FORCE)〉〉enditem49840〈〈add-name-to-file〉〉:〈〈Give FILE additional name NEWNAME.  Both args must be strings.
If NEWNAME is a directory name, give FILE a like-named new name under
NEWNAME.

Signal a ‘file-already-exists’ error if a file NEWNAME already exists
unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
An integer third arg means request confirmation if NEWNAME already exists.
This is what happens in interactive use with M-x.

(fn FILE NEWNAME &optional OK-IF-ALREADY-EXISTS)〉〉enditem49840〈〈rename-file〉〉:〈〈Rename FILE as NEWNAME.  Both args must be strings.
If file has names other than FILE, it continues to have those names.
If NEWNAME is a directory name, rename FILE to a like-named file under
NEWNAME.  For NEWNAME to be recognized as a directory name, it should
end in a slash.

Signal a ‘file-already-exists’ error if a file NEWNAME already exists
unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
An integer third arg means request confirmation if NEWNAME already exists.
This is what happens in interactive use with M-x.

(fn FILE NEWNAME &optional OK-IF-ALREADY-EXISTS)〉〉enditem49840〈〈copy-file〉〉:〈〈Copy FILE to NEWNAME.  Both args must be strings.
If NEWNAME is a directory name, copy FILE to a like-named file under
NEWNAME.  For NEWNAME to be recognized as a directory name, it should
end in a slash.

This function always sets the file modes of the output file to match
the input file.

The optional third argument OK-IF-ALREADY-EXISTS specifies what to do
if file NEWNAME already exists.  If OK-IF-ALREADY-EXISTS is nil,
signal a ‘file-already-exists’ error without overwriting.  If
OK-IF-ALREADY-EXISTS is an integer, request confirmation from the user
about overwriting; this is what happens in interactive use with M-x.
Any other value for OK-IF-ALREADY-EXISTS means to overwrite the
existing file.

Fourth arg KEEP-TIME non-nil means give the output file the same
last-modified time as the old one.  (This works on only some systems.)

A prefix arg makes KEEP-TIME non-nil.

If PRESERVE-UID-GID is non-nil, try to transfer the uid and gid of
FILE to NEWNAME.

If PRESERVE-PERMISSIONS is non-nil, copy permissions of FILE to NEWNAME;
this includes the file modes, along with ACL entries and SELinux
context if present.  Otherwise, if NEWNAME is created its file
permission bits are those of FILE, masked by the default file
permissions.

(fn FILE NEWNAME &optional OK-IF-ALREADY-EXISTS KEEP-TIME PRESERVE-UID-GID PRESERVE-PERMISSIONS)〉〉enditem49840〈〈make-symbolic-link〉〉:〈〈Make a symbolic link to TARGET, named NEWNAME.
If NEWNAME is a directory name, make a like-named symbolic link under
NEWNAME.

Signal a ‘file-already-exists’ error if a file NEWNAME already exists
unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.
An integer third arg means request confirmation if NEWNAME already
exists, and expand leading "~" or strip leading "/:" in TARGET.
This happens for interactive use with M-x.

(fn TARGET LINKNAME &optional OK-IF-ALREADY-EXISTS)〉〉enditem49840〈〈delete-file〉〉:〈〈Delete file named FILENAME.  If it is a symlink, remove the symlink.
If file has multiple names, it continues to exist with the other names.
TRASH non-nil means to trash the file instead of deleting, provided
‘delete-by-moving-to-trash’ is non-nil.

When called interactively, TRASH is t if no prefix argument is given.
With a prefix argument, TRASH is nil.

(fn FILENAME &optional TRASH)〉〉enditem49840〈〈set-file-modes〉〉:〈〈Set mode bits of file named FILENAME to MODE (an integer).
Only the 12 low bits of MODE are used.

Interactively, mode bits are read by ‘read-file-modes’, which accepts
symbolic notation, like the ‘chmod’ command from GNU Coreutils.

(fn FILENAME MODE)〉〉enditem49840〈〈insert-char〉〉:〈〈Insert COUNT copies of CHARACTER.
Interactively, prompt for CHARACTER.  You can specify CHARACTER in one
of these ways:

 - As its Unicode character name, e.g. "LATIN SMALL LETTER A".
   Completion is available; if you type a substring of the name
   preceded by an asterisk ‘*’, Emacs shows all names which include
   that substring, not necessarily at the beginning of the name.

 - As a hexadecimal code point, e.g. 263A.  Note that code points in
   Emacs are equivalent to Unicode up to 10FFFF (which is the limit of
   the Unicode code space).

 - As a code point with a radix specified with #, e.g. #o21430
   (octal), #x2318 (hex), or #10r8984 (decimal).

If called interactively, COUNT is given by the prefix argument.  If
omitted or nil, it defaults to 1.

Inserting the character(s) relocates point and before-insertion
markers in the same ways as the function ‘insert’.

The optional third argument INHERIT, if non-nil, says to inherit text
properties from adjoining text, if those properties are sticky.  If
called interactively, INHERIT is t.

(fn CHARACTER &optional COUNT INHERIT)〉〉enditem49840〈〈emacs-version〉〉:〈〈Return string describing the version of Emacs that is running.
If optional argument HERE is non-nil, insert string at point.
Don’t use this function in programs to choose actions according
to the system configuration; look at ‘system-configuration’ instead.〉〉enditem49840〈〈iconify-frame〉〉:〈〈Make the frame FRAME into an icon.
If omitted, FRAME defaults to the currently selected frame.

If FRAME is a child frame, consult the variable ‘iconify-child-frame’
for how to proceed.

(fn &optional FRAME)〉〉enditem49840〈〈make-frame-visible〉〉:〈〈Make the frame FRAME visible (assuming it is an X window).
If omitted, FRAME defaults to the currently selected frame.

(fn &optional FRAME)〉〉enditem49840〈〈make-frame-invisible〉〉:〈〈Make the frame FRAME invisible.
If omitted, FRAME defaults to the currently selected frame.
On graphical displays, invisible frames are not updated and are
usually not displayed at all, even in a window system’s "taskbar".

Normally you may not make FRAME invisible if all other frames are invisible,
but if the second optional argument FORCE is non-nil, you may do so.

This function has no effect on text terminal frames.  Such frames are
always considered visible, whether or not they are currently being
displayed in the terminal.

(fn &optional FRAME FORCE)〉〉enditem49840〈〈minibuffer-inactive-mode〉〉:〈〈Major-mode.
Uses keymap ‘minibuffer-inactive-mode-map’ and syntax-table ‘minibuffer-inactive-mode-syntax-table’.

This mode runs the hook ‘minibuffer-inactive-mode-hook’, as the final or penultimate step
during initialization.

key             binding
---             -------

0 .. 9          digit-argument
e .. f          find-file-other-frame

-               negative-argument
b               switch-to-buffer-other-frame
i               info
m               mail
n               make-frame
<down-mouse-1>  ignore
<mouse-1>       view-echo-area-messages
<remap>         Prefix Command

〉〉enditem49840〈〈scroll-up〉〉:〈〈Scroll text of selected window upward ARG lines.
If ARG is omitted or nil, scroll upward by a near full screen.
A near full screen is ‘next-screen-context-lines’ less than a full screen.
Negative ARG means scroll downward.
If ARG is the atom ‘-’, scroll downward by nearly full screen.
When calling from a program, supply as argument a number, nil, or ‘-’.

(fn &optional ARG)〉〉enditem49840〈〈scroll-down〉〉:〈〈Scroll text of selected window down ARG lines.
If ARG is omitted or nil, scroll down by a near full screen.
A near full screen is ‘next-screen-context-lines’ less than a full screen.
Negative ARG means scroll upward.
If ARG is the atom ‘-’, scroll upward by nearly full screen.
When calling from a program, supply as argument a number, nil, or ‘-’.

(fn &optional ARG)〉〉enditem49840〈〈scroll-up-command〉〉:〈〈Scroll text of selected window upward ARG lines; or near full screen if no ARG.
If ‘scroll-error-top-bottom’ is non-nil and ‘scroll-up’ cannot
scroll window further, move cursor to the bottom line.
When point is already on that position, then signal an error.
A near full screen is ‘next-screen-context-lines’ less than a full screen.
Negative ARG means scroll downward.
If ARG is the atom ‘-’, scroll downward by nearly full screen.

(fn &optional ARG)〉〉enditem49840〈〈scroll-down-command〉〉:〈〈Scroll text of selected window down ARG lines; or near full screen if no ARG.
If ‘scroll-error-top-bottom’ is non-nil and ‘scroll-down’ cannot
scroll window further, move cursor to the top line.
When point is already on that position, then signal an error.
A near full screen is ‘next-screen-context-lines’ less than a full screen.
Negative ARG means scroll upward.
If ARG is the atom ‘-’, scroll upward by nearly full screen.

(fn &optional ARG)〉〉enditem49840〈〈scroll-other-window〉〉:〈〈Scroll next window upward ARG lines; or near full screen if no ARG.
A near full screen is ‘next-screen-context-lines’ less than a full screen.
The next window is the one below the current one; or the one at the top
if the current one is at the bottom.  Negative ARG means scroll downward.
If ARG is the atom ‘-’, scroll downward by nearly full screen.
When calling from a program, supply as argument a number, nil, or ‘-’.

If ‘other-window-scroll-buffer’ is non-nil, scroll the window
showing that buffer, popping the buffer up if necessary.
If in the minibuffer, ‘minibuffer-scroll-window’ if non-nil
specifies the window to scroll.  This takes precedence over
‘other-window-scroll-buffer’.

(fn &optional ARG)〉〉enditem49840〈〈recenter〉〉:〈〈Center point in selected window and maybe redisplay frame.
With a numeric prefix argument ARG, recenter putting point on screen line ARG
relative to the selected window.  If ARG is negative, it counts up from the
bottom of the window.  (ARG should be less than the height of the window.)

If ARG is omitted or nil, then recenter with point on the middle line of
the selected window; if the variable ‘recenter-redisplay’ is non-nil,
also erase the entire frame and redraw it (when ‘auto-resize-tool-bars’
is set to ‘grow-only’, this resets the tool-bar’s height to the minimum
height needed); if ‘recenter-redisplay’ has the special value ‘tty’,
then only tty frames are redrawn.

Just C-u as prefix means put point in the center of the window
and redisplay normally--don’t erase and redraw the frame.

(fn &optional ARG)〉〉enditem49840〈〈recenter-top-bottom〉〉:〈〈Move current buffer line to the specified window line.
With no prefix argument, successive calls place point according
to the cycling order defined by ‘recenter-positions’.

A prefix argument is handled like ‘recenter’:
 With numeric prefix ARG, move current line to window-line ARG.
 With plain ‘C-u’, move current line to window center.

(fn &optional ARG)〉〉enditem49840〈〈modify-syntax-entry〉〉:〈〈Set syntax for character CHAR according to string NEWENTRY.
The syntax is changed only for table SYNTAX-TABLE, which defaults to
 the current buffer’s syntax table.
CHAR may be a cons (MIN . MAX), in which case, syntaxes of all characters
in the range MIN to MAX are changed.
The first character of NEWENTRY should be one of the following:
  Space or -  whitespace syntax.    w   word constituent.
  _           symbol constituent.   .   punctuation.
  (           open-parenthesis.     )   close-parenthesis.
  "           string quote.         \   escape.
  $           paired delimiter.     '   expression quote or prefix operator.
  <           comment starter.      >   comment ender.
  /           character-quote.      @   inherit from parent table.
  |           generic string fence. !   generic comment fence.

Only single-character comment start and end sequences are represented thus.
Two-character sequences are represented as described below.
The second character of NEWENTRY is the matching parenthesis,
 used only if the first character is ‘(’ or ‘)’.
Any additional characters are flags.
Defined flags are the characters 1, 2, 3, 4, b, p, and n.
 1 means CHAR is the start of a two-char comment start sequence.
 2 means CHAR is the second character of such a sequence.
 3 means CHAR is the start of a two-char comment end sequence.
 4 means CHAR is the second character of such a sequence.

There can be several orthogonal comment sequences.  This is to support
language modes such as C++.  By default, all comment sequences are of style
a, but you can set the comment sequence style to b (on the second character
of a comment-start, and the first character of a comment-end sequence) and/or
c (on any of its chars) using this flag:
 b means CHAR is part of comment sequence b.
 c means CHAR is part of comment sequence c.
 n means CHAR is part of a nestable comment sequence.

 p means CHAR is a prefix character for ‘backward-prefix-chars’;
   such characters are treated as whitespace when they occur
   between expressions.

(fn CHAR NEWENTRY &optional SYNTAX-TABLE)〉〉enditem49840〈〈describe-syntax〉〉:〈〈Describe the syntax specifications in the syntax table of BUFFER.
The descriptions are inserted in a help buffer, which is then displayed.
BUFFER defaults to the current buffer.

(fn &optional BUFFER)〉〉enditem49840〈〈re-search-forward〉〉:〈〈Search forward from point for regular expression REGEXP.
Set point to the end of the occurrence found, and return point.
The optional second argument BOUND is a buffer position that bounds
  the search.  The match found must not end after that position.  A
  value of nil means search to the end of the accessible portion of
  the buffer.
The optional third argument NOERROR indicates how errors are handled
  when the search fails.  If it is nil or omitted, emit an error; if
  it is t, simply return nil and do nothing; if it is neither nil nor
  t, move to the limit of search and return nil.
The optional fourth argument COUNT is a number that indicates the
  search direction and the number of occurrences to search for.  If it
  is positive, search forward for COUNT successive occurrences; if it
  is negative, search backward, instead of forward, for -COUNT
  occurrences.  A value of nil means the same as 1.
With COUNT positive/negative, the match found is the COUNTth/-COUNTth
  one in the buffer located entirely after/before the origin of the
  search.

Search case-sensitivity is determined by the value of the variable
‘case-fold-search’, which see.

See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,
and ‘replace-match’.

(fn REGEXP &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈re-search-backward〉〉:〈〈Search backward from point for regular expression REGEXP.
This function is almost identical to ‘re-search-forward’, except that
by default it searches backward instead of forward, and the sign of
COUNT also indicates exactly the opposite searching direction.
See ‘re-search-forward’ for details.

Note that searching backwards may give a shorter match than expected,
because REGEXP is still matched in the forward direction.  See Info
anchor ‘(elisp) re-search-backward’ for details.

(fn REGEXP &optional BOUND NOERROR COUNT)〉〉enditem49840〈〈emacs-uptime〉〉:〈〈Return a string giving the uptime of this instance of Emacs.
FORMAT is a string to format the result, using ‘format-seconds’.
For example, the Unix uptime command format is "%D, %z%2h:%.2m".

(fn &optional FORMAT)〉〉enditem49840〈〈emacs-init-time〉〉:〈〈Return a string giving the duration of the Emacs initialization.

(fn)〉〉enditem49840〈〈delete-horizontal-space〉〉:〈〈Delete all spaces and tabs around point.
If BACKWARD-ONLY is non-nil, only delete them before point.

(fn &optional BACKWARD-ONLY)〉〉enditem49840〈〈delete-indentation〉〉:〈〈Join this line to previous and fix up whitespace at join.
If there is a fill prefix, delete it from the beginning of this line.
With argument, join this line to following line.

(fn &optional ARG)〉〉enditem49840〈〈fixup-whitespace〉〉:〈〈Fixup white space between objects around point.
Leave one space or none, according to the context.〉〉enditem49840〈〈just-one-space〉〉:〈〈Delete all spaces and tabs around point, leaving one space (or N spaces).
If N is negative, delete newlines as well, leaving -N spaces.
See also ‘cycle-spacing’.

(fn &optional N)〉〉enditem49840〈〈delete-blank-lines〉〉:〈〈On blank line, delete all surrounding blank lines, leaving just one.
On isolated blank line, delete that one.
On nonblank line, delete any immediately following blank lines.〉〉enditem49840〈〈delete-trailing-whitespace〉〉:〈〈Delete trailing whitespace between START and END.
If called interactively, START and END are the start/end of the
region if the mark is active, or of the buffer’s accessible
portion if the mark is inactive.

This command deletes whitespace characters after the last
non-whitespace character in each line between START and END.  It
does not consider formfeed characters to be whitespace.

If this command acts on the entire buffer (i.e. if called
interactively with the mark inactive, or called from Lisp with
END nil), it also deletes all trailing lines at the end of the
buffer if the variable ‘delete-trailing-lines’ is non-nil.

(fn &optional START END)〉〉enditem49840〈〈debug〉〉:〈〈Enter debugger.  
Uses keymap ‘debugger-mode-map’, which is not currently defined.
‘M-x debugger-continue’ returns from the debugger.
Arguments are mainly for use when this is called from the internals
of the evaluator.

You may call with no args, or you may pass nil as the first arg and
any other args you like.  In that case, the list of args after the
first will be printed into the backtrace buffer.

(fn &rest ARGS)〉〉enditem49840〈〈scroll-left〉〉:〈〈Scroll selected window display ARG columns left.
Default for ARG is window width minus 2.
Value is the total amount of leftward horizontal scrolling in
effect after the change.
If SET-MINIMUM is non-nil, the new scroll amount becomes the
lower bound for automatic scrolling, i.e. automatic scrolling
will not scroll a window to a column less than the value returned
by this function.  This happens in an interactive call.

(fn &optional ARG SET-MINIMUM)〉〉enditem49840〈〈scroll-right〉〉:〈〈Scroll selected window display ARG columns right.
Default for ARG is window width minus 2.
Value is the total amount of leftward horizontal scrolling in
effect after the change.
If SET-MINIMUM is non-nil, the new scroll amount becomes the
lower bound for automatic scrolling, i.e. automatic scrolling
will not scroll a window to a column less than the value returned
by this function.  This happens in an interactive call.

(fn &optional ARG SET-MINIMUM)〉〉enditem49840〈〈blink-matching-open〉〉:〈〈Momentarily highlight the beginning of the sexp before point.〉〉enditem49840〈〈global-set-key〉〉:〈〈Give KEY a global binding as COMMAND.
COMMAND is the command definition to use; usually it is
a symbol naming an interactively-callable function.
KEY is a key sequence; noninteractively, it is a string or vector
of characters or event types, and non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be included if you use a vector.

Note that if KEY has a local binding in the current buffer,
that local binding will continue to shadow any global binding
that you make with this function.

(fn KEY COMMAND)〉〉enditem49840〈〈global-unset-key〉〉:〈〈Remove global binding of KEY.
KEY is a string or vector representing a sequence of keystrokes.

(fn KEY)〉〉enditem49840〈〈local-set-key〉〉:〈〈Give KEY a local binding as COMMAND.
COMMAND is the command definition to use; usually it is
a symbol naming an interactively-callable function.
KEY is a key sequence; noninteractively, it is a string or vector
of characters or event types, and non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be included if you use a vector.

The binding goes in the current buffer’s local map, which in most
cases is shared with all other buffers in the same major mode.

(fn KEY COMMAND)〉〉enditem49840〈〈local-unset-key〉〉:〈〈Remove local binding of KEY.
KEY is a string or vector representing a sequence of keystrokes.

(fn KEY)〉〉enditem49840〈〈raise-frame〉〉:〈〈Bring FRAME to the front, so it occludes any frames it overlaps.
If FRAME is invisible or iconified, make it visible.
If you don’t specify a frame, the selected frame is used.
If Emacs is displaying on an ordinary terminal or some other device which
doesn’t support multiple overlapping frames, this function selects FRAME.

(fn &optional FRAME)〉〉enditem49840〈〈lower-frame〉〉:〈〈Send FRAME to the back, so it is occluded by any frames that overlap it.
If you don’t specify a frame, the selected frame is used.
If Emacs is displaying on an ordinary terminal or some other device which
doesn’t support multiple overlapping frames, this function does nothing.

(fn &optional FRAME)〉〉enditem49840〈〈delete-frame〉〉:〈〈Delete FRAME, permanently eliminating it from use.
FRAME must be a live frame and defaults to the selected one.

A frame may not be deleted if its minibuffer serves as surrogate
minibuffer for another frame.  Normally, you may not delete a frame if
all other frames are invisible, but if the second optional argument
FORCE is non-nil, you may do so.

This function runs ‘delete-frame-functions’ before actually
deleting the frame, unless the frame is a tooltip.
The functions are run with one argument, the frame to be deleted.

(fn &optional FRAME FORCE)〉〉enditem49840〈〈fit-window-to-buffer〉〉:〈〈Adjust size of WINDOW to display its buffer’s contents exactly.
WINDOW must be a live window and defaults to the selected one.

If WINDOW is part of a vertical combination, adjust WINDOW’s
height.  The new height is calculated from the actual height of
the accessible portion of its buffer.  The optional argument
MAX-HEIGHT specifies a maximum height and defaults to the height
of WINDOW’s frame.  The optional argument MIN-HEIGHT specifies a
minimum height and defaults to ‘window-min-height’.  Both
MAX-HEIGHT and MIN-HEIGHT are specified in lines and include mode
and header line and a bottom divider, if any.

If WINDOW is part of a horizontal combination and the value of
the option ‘fit-window-to-buffer-horizontally’ is non-nil, adjust
WINDOW’s width.  The new width of WINDOW is calculated from the
maximum length of its buffer’s lines that follow the current
start position of WINDOW.  The optional argument MAX-WIDTH
specifies a maximum width and defaults to the width of WINDOW’s
frame.  The optional argument MIN-WIDTH specifies a minimum width
and defaults to ‘window-min-width’.  Both MAX-WIDTH and MIN-WIDTH
are specified in columns and include fringes, margins, a
scrollbar and a vertical divider, if any.

If the optional argument ‘preserve-size’ is non-nil, preserve the
size of WINDOW (see ‘window-preserve-size’).

Fit pixelwise if the option ‘window-resize-pixelwise’ is non-nil.
If WINDOW is its frame’s root window and the option
‘fit-frame-to-buffer’ is non-nil, call ‘fit-frame-to-buffer’ to
adjust the frame’s size.

Note that even if this function makes WINDOW large enough to show
_all_ parts of its buffer you might not see the first part when
WINDOW was scrolled.  If WINDOW is resized horizontally, you will
not see the top of its buffer unless WINDOW starts at its minimum
accessible position.

(fn &optional WINDOW MAX-HEIGHT MIN-HEIGHT MAX-WIDTH MIN-WIDTH PRESERVE-SIZE)〉〉enditem49840〈〈fit-frame-to-buffer〉〉:〈〈Adjust size of FRAME to display the contents of its buffer exactly.
FRAME can be any live frame and defaults to the selected one.
Fit only if FRAME’s root window is live.  MAX-HEIGHT, MIN-HEIGHT,
MAX-WIDTH and MIN-WIDTH specify bounds on the new total size of
FRAME’s root window.  MIN-HEIGHT and MIN-WIDTH default to the values of
‘window-min-height’ and ‘window-min-width’ respectively.

If the optional argument ONLY is ‘vertically’, resize the frame
vertically only.  If ONLY is ‘horizontally’, resize the frame
horizontally only.

The new position and size of FRAME can be additionally determined
by customizing the options ‘fit-frame-to-buffer-sizes’ and
‘fit-frame-to-buffer-margins’ or setting the corresponding
parameters of FRAME.

(fn &optional FRAME MAX-HEIGHT MIN-HEIGHT MAX-WIDTH MIN-WIDTH ONLY)〉〉enditem49840〈〈shrink-window-if-larger-than-buffer〉〉:〈〈Shrink height of WINDOW if its buffer doesn’t need so many lines.
More precisely, shrink WINDOW vertically to be as small as
possible, while still showing the full contents of its buffer.
WINDOW must be a live window and defaults to the selected one.

Do not shrink WINDOW to less than ‘window-min-height’ lines.  Do
nothing if the buffer contains more lines than the present window
height, or if some of the window’s contents are scrolled out of
view, or if shrinking this window would also shrink another
window, or if the window is the only window of its frame.

Return non-nil if the window was shrunk, nil otherwise.

(fn &optional WINDOW)〉〉enditem49840〈〈balance-windows〉〉:〈〈Balance the sizes of windows of WINDOW-OR-FRAME.
WINDOW-OR-FRAME is optional and defaults to the selected frame.
If WINDOW-OR-FRAME denotes a frame, balance the sizes of all
windows of that frame.  If WINDOW-OR-FRAME denotes a window,
recursively balance the sizes of all child windows of that
window.

(fn &optional WINDOW-OR-FRAME)〉〉enditem49840〈〈balance-windows-area〉〉:〈〈Make all visible windows the same area (approximately).
See also ‘window-area-factor’ to change the relative size of
specific buffers.〉〉enditem49840〈〈maximize-window〉〉:〈〈Maximize WINDOW.
Make WINDOW as large as possible without deleting any windows.
WINDOW must be a valid window and defaults to the selected one.

If the option ‘window-resize-pixelwise’ is non-nil maximize
WINDOW pixelwise.

(fn &optional WINDOW)〉〉enditem49840〈〈minimize-window〉〉:〈〈Minimize WINDOW.
Make WINDOW as small as possible without deleting any windows.
WINDOW must be a valid window and defaults to the selected one.

If the option ‘window-resize-pixelwise’ is non-nil minimize
WINDOW pixelwise.

(fn &optional WINDOW)〉〉enditem49840〈〈delete-minibuffer-contents〉〉:〈〈Delete all user input in a minibuffer.
If the current buffer is not a minibuffer, erase its entire contents.〉〉enditem49840〈〈open-termscript〉〉:〈〈Start writing all terminal output to FILE as well as the terminal.
FILE = nil means just close any termscript file currently open.

(fn FILE)〉〉enditem49840〈〈erase-buffer〉〉:〈〈Delete the entire contents of the current buffer.
Any narrowing restriction in effect (see ‘narrow-to-region’) is removed,
so the buffer is truly empty after this.

(fn)〉〉enditem49840〈〈delete-region〉〉:〈〈Delete the text between START and END.
If called interactively, delete the region between point and mark.
This command deletes buffer text without modifying the kill ring.

(fn START END)〉〉enditem49840〈〈delete-char〉〉:〈〈Delete the following N characters (previous if N is negative).
Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).
Interactively, N is the prefix arg, and KILLFLAG is set if
N was explicitly specified.

The command ‘delete-forward-char’ is preferable for interactive use, e.g.
because it respects values of ‘delete-active-region’ and ‘overwrite-mode’.

(fn N &optional KILLFLAG)〉〉enditem49840〈〈delete-backward-char〉〉:〈〈Delete the previous N characters (following if N is negative).
If Transient Mark mode is enabled, the mark is active, and N is 1,
delete the text in the region and deactivate the mark instead.
To disable this, set option ‘delete-active-region’ to nil.

Optional second arg KILLFLAG, if non-nil, means to kill (save in
kill ring) instead of delete.  Interactively, N is the prefix
arg, and KILLFLAG is set if N is explicitly specified.

When killing, the killed text is filtered by
‘filter-buffer-substring’ before it is saved in the kill ring, so
the actual saved text might be different from what was killed.

In Overwrite mode, single character backward deletion may replace
tabs with spaces so as to back over columns, unless point is at
the end of the line.

(fn N &optional KILLFLAG)〉〉enditem49840〈〈backward-delete-char-untabify〉〉:〈〈Delete characters backward, changing tabs into spaces.
The exact behavior depends on ‘backward-delete-char-untabify-method’.
Delete ARG chars, and kill (save in kill ring) if KILLP is non-nil.
Interactively, ARG is the prefix arg (default 1)
and KILLP is t if a prefix arg was specified.

(fn ARG &optional KILLP)〉〉enditem49840〈〈capitalize-region〉〉:〈〈Convert the region to capitalized form.
This means that each word’s first character is converted to either
title case or upper case, and the rest to lower case.
In programs, give two arguments, the starting and ending
character positions to operate on.

(fn BEG END)〉〉enditem49840〈〈downcase-region〉〉:〈〈Convert the region to lower case.  In programs, wants two arguments.
These arguments specify the starting and ending character numbers of
the region to operate on.  When used as a command, the text between
point and the mark is operated on.

(fn BEG END &optional REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈upcase-region〉〉:〈〈Convert the region to upper case.  In programs, wants two arguments.
These arguments specify the starting and ending character numbers of
the region to operate on.  When used as a command, the text between
point and the mark is operated on.
See also ‘capitalize-region’.

(fn BEG END &optional REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈capitalize-word〉〉:〈〈Capitalize from point to the end of word, moving over.
With numerical argument ARG, capitalize the next ARG-1 words as well.
This gives the word(s) a first character in upper case
and the rest lower case.

If point is in the middle of a word, the part of that word before point
is ignored when moving forward.

With negative argument, capitalize previous words but do not move.

(fn ARG)〉〉enditem49840〈〈downcase-word〉〉:〈〈Convert to lower case from point to end of word, moving over.

If point is in the middle of a word, the part of that word before point
is ignored when moving forward.

With negative argument, convert previous words but do not move.

(fn ARG)〉〉enditem49840〈〈upcase-word〉〉:〈〈Convert to upper case from point to end of word, moving over.

If point is in the middle of a word, the part of that word before point
is ignored when moving forward.

With negative argument, convert previous words but do not move.
See also ‘capitalize-word’.

(fn ARG)〉〉enditem49840〈〈bury-buffer〉〉:〈〈Put BUFFER-OR-NAME at the end of the list of all buffers.
There it is the least likely candidate for ‘other-buffer’ to
return; thus, the least likely buffer for DEL u to
select by default.

You can specify a buffer name as BUFFER-OR-NAME, or an actual
buffer object.  If BUFFER-OR-NAME is nil or omitted, bury the
current buffer.  Also, if BUFFER-OR-NAME is nil or omitted,
remove the current buffer from the selected window if it is
displayed there.

(fn &optional BUFFER-OR-NAME)〉〉enditem49840〈〈unbury-buffer〉〉:〈〈Switch to the last buffer in the buffer list.〉〉enditem49840〈〈make-frame〉〉:〈〈Return a newly created frame displaying the current buffer.
Optional argument PARAMETERS is an alist of frame parameters for
the new frame.  Each element of PARAMETERS should have the
form (NAME . VALUE), for example:

 (name . STRING)	The frame should be named STRING.

 (width . NUMBER)	The frame should be NUMBER characters in width.
 (height . NUMBER)	The frame should be NUMBER text lines high.

 (minibuffer . t)	The frame should have a minibuffer.
 (minibuffer . nil)	The frame should have no minibuffer.
 (minibuffer . only)	The frame should contain only a minibuffer.
 (minibuffer . WINDOW)	The frame should use WINDOW as its minibuffer window.

 (window-system . nil)	The frame should be displayed on a terminal device.
 (window-system . x)	The frame should be displayed in an X window.

 (display . ":0")     The frame should appear on display :0.

 (terminal . TERMINAL)  The frame should use the terminal object TERMINAL.

In addition, any parameter specified in ‘default-frame-alist’,
but not present in PARAMETERS, is applied.

Before creating the frame (via ‘frame-creation-function’), this
function runs the hook ‘before-make-frame-hook’.  After creating
the frame, it runs the hook ‘after-make-frame-functions’ with one
argument, the newly created frame.

If a display parameter is supplied and a window-system is not,
guess the window-system from the display.

On graphical displays, this function does not itself make the new
frame the selected frame.  However, the window system may select
the new frame according to its own rules.

(fn &optional PARAMETERS)〉〉enditem49840〈〈view-register〉〉:〈〈Display what is contained in register named REGISTER.
The Lisp value REGISTER is a character.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER)〉〉enditem49840〈〈insert-register〉〉:〈〈Insert contents of register REGISTER.  (REGISTER is a character.)
Normally puts point before and mark after the inserted text.
If optional second arg is non-nil, puts mark before and point after.
Interactively, second arg is nil if prefix arg is supplied and t
otherwise.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER &optional ARG)〉〉enditem49840〈〈kill-region〉〉:〈〈Kill ("cut") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command C-v can retrieve it from there.
(If you want to save the region without killing it, use M-w.)

If you want to append the killed region to the last killed text,
use C-M-w before s-x.

Any command that calls this function is a "kill command".
If the previous command was also a kill command,
the text killed this time appends to the text killed last time
to make one entry in the kill ring.

The killed text is filtered by ‘filter-buffer-substring’ before it is
saved in the kill ring, so the actual saved text might be different
from what was killed.

If the buffer is read-only, Emacs will beep and refrain from deleting
the text, but put the text in the kill ring anyway.  This means that
you can use the killing commands to copy text from a read-only buffer.

Lisp programs should use this function for killing text.
 (To delete text, use ‘delete-region’.)
Supply two arguments, character positions BEG and END indicating the
 stretch of text to be killed.  If the optional argument REGION is
 non-nil, the function ignores BEG and END, and kills the current
 region instead.

(fn BEG END &optional REGION)〉〉enditem49840〈〈copy-region-as-kill〉〉:〈〈Save the region as if killed, but don’t kill it.
In Transient Mark mode, deactivate the mark.
If ‘interprogram-cut-function’ is non-nil, also save the text for a window
system cut and paste.

The copied text is filtered by ‘filter-buffer-substring’ before it is
saved in the kill ring, so the actual saved text might be different
from what was in the buffer.

When called from Lisp, save in the kill ring the stretch of text
between BEG and END, unless the optional argument REGION is
non-nil, in which case ignore BEG and END, and save the current
region instead.

This command’s old key binding has been given to ‘kill-ring-save’.

(fn BEG END &optional REGION)〉〉enditem49840〈〈expand-abbrev〉〉:〈〈Expand the abbrev before point, if there is an abbrev there.
Effective when explicitly called even when ‘abbrev-mode’ is nil.
Before doing anything else, runs ‘pre-abbrev-expand-hook’.
Calls the value of ‘abbrev-expand-function’ with no argument to do
the work, and returns whatever it does.  (That return value should
be the abbrev symbol if expansion occurred, else nil.)〉〉enditem49840〈〈abbrev-prefix-mark〉〉:〈〈Mark current point as the beginning of an abbrev.
Abbrev to be expanded starts here rather than at beginning of word.
This way, you can expand an abbrev with a prefix: insert the prefix,
use this command, then insert the abbrev.  This command inserts a
temporary hyphen after the prefix (until the intended abbrev
expansion occurs).
If the prefix is itself an abbrev, this command expands it, unless
ARG is non-nil.  Interactively, ARG is the prefix argument.

(fn &optional ARG)〉〉enditem49840〈〈set-frame-font〉〉:〈〈Set the default font to FONT.
When called interactively, prompt for the name of a font, and use
that font on the selected frame.  When called from Lisp, FONT
should be a font name (a string), a font object, font entity, or
font spec.

If KEEP-SIZE is nil, keep the number of frame lines and columns
fixed.  If KEEP-SIZE is non-nil (or with a prefix argument), try
to keep the current frame size fixed (in pixels) by adjusting the
number of lines and columns.

If FRAMES is nil, apply the font to the selected frame only.
If FRAMES is non-nil, it should be a list of frames to act upon,
or t meaning all existing graphical frames.
Also, if FRAMES is non-nil, alter the user’s Customization settings
as though the font-related attributes of the ‘default’ face had been
"set in this session", so that the font is applied to future frames.

(fn FONT &optional KEEP-SIZE FRAMES)〉〉enditem49840〈〈list-charset-chars〉〉:〈〈Display a list of characters in character set CHARSET.

(fn CHARSET)〉〉enditem49840〈〈make-indirect-buffer〉〉:〈〈Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.
BASE-BUFFER should be a live buffer, or the name of an existing buffer.
NAME should be a string which is not the name of an existing buffer.
Optional argument CLONE non-nil means preserve BASE-BUFFER’s state,
such as major and minor modes, in the indirect buffer.
CLONE nil means the indirect buffer’s state is reset to default values.

(fn BASE-BUFFER NAME &optional CLONE)〉〉enditem49840〈〈clone-indirect-buffer〉〉:〈〈Create an indirect buffer that is a twin copy of the current buffer.

Give the indirect buffer name NEWNAME.  Interactively, read NEWNAME
from the minibuffer when invoked with a prefix arg.  If NEWNAME is nil
or if not called with a prefix arg, NEWNAME defaults to the current
buffer’s name.  The name is modified by adding a ‘<N>’ suffix to it
or by incrementing the N in an existing suffix.  Trying to clone a
buffer whose major mode symbol has a non-nil ‘no-clone-indirect’
property results in an error.

DISPLAY-FLAG non-nil means show the new buffer with ‘pop-to-buffer’.
This is always done when called interactively.

Optional third arg NORECORD non-nil means do not put this buffer at the
front of the list of recently selected ones.

Returns the newly created indirect buffer.

(fn NEWNAME DISPLAY-FLAG &optional NORECORD)〉〉enditem49840〈〈make-directory〉〉:〈〈Create the directory DIR and optionally any nonexistent parent dirs.
If DIR already exists as a directory, signal an error, unless
PARENTS is non-nil.

Interactively, the default choice of directory to create is the
current buffer’s default directory.  That is useful when you have
visited a file in a nonexistent directory.

Noninteractively, the second (optional) argument PARENTS, if
non-nil, says whether to create parent directories that don’t
exist.  Interactively, this happens by default.

If creating the directory or directories fail, an error will be
raised.

(fn DIR &optional PARENTS)〉〉enditem49840〈〈copy-directory〉〉:〈〈Copy DIRECTORY to NEWNAME.  Both args must be strings.
This function always sets the file modes of the output files to match
the corresponding input file.

The third arg KEEP-TIME non-nil means give the output files the same
last-modified time as the old ones.  (This works on only some systems.)

A prefix arg makes KEEP-TIME non-nil.

Noninteractively, the last argument PARENTS says whether to
create parent directories if they don’t exist.  Interactively,
this happens by default.

If NEWNAME is a directory name, copy DIRECTORY as a subdirectory
there.  However, if called from Lisp with a non-nil optional
argument COPY-CONTENTS, copy the contents of DIRECTORY directly
into NEWNAME instead.

(fn DIRECTORY NEWNAME &optional KEEP-TIME PARENTS COPY-CONTENTS)〉〉enditem49840〈〈delete-directory〉〉:〈〈Delete the directory named DIRECTORY.  Does not follow symlinks.
If RECURSIVE is non-nil, delete files in DIRECTORY as well, with
no error if something else is simultaneously deleting them.
TRASH non-nil means to trash the directory instead, provided
‘delete-by-moving-to-trash’ is non-nil.

When called interactively, TRASH is nil if and only if a prefix
argument is given, and a further prompt asks the user for
RECURSIVE if DIRECTORY is nonempty.

(fn DIRECTORY &optional RECURSIVE TRASH)〉〉enditem49840〈〈locate-library〉〉:〈〈Show the precise file name of Emacs library LIBRARY.
LIBRARY should be a relative file name of the library, a string.
It can omit the suffix (a.k.a. file-name extension) if NOSUFFIX is
nil (which is the default, see below).
This command searches the directories in ‘load-path’ like ‘M-x load-library’
to find the file that ‘M-x load-library RET LIBRARY RET’ would load.
Optional second arg NOSUFFIX non-nil means don’t add suffixes ‘load-suffixes’
to the specified name LIBRARY.

If the optional third arg PATH is specified, that list of directories
is used instead of ‘load-path’.

When called from a program, the file name is normally returned as a
string.  When run interactively, the argument INTERACTIVE-CALL is t,
and the file name is displayed in the echo area.

(fn LIBRARY &optional NOSUFFIX PATH INTERACTIVE-CALL)〉〉enditem49840〈〈list-load-path-shadows〉〉:〈〈Display a list of Emacs Lisp files that shadow other files.

If STRINGP is non-nil, returns any shadows as a string.
Otherwise, if interactive shows any shadows in a ‘*Shadows*’ buffer;
else prints messages listing any shadows.

This function lists potential load path problems.  Directories in
the ‘load-path’ variable are searched, in order, for Emacs Lisp
files.  When a previously encountered file name is found again, a
message is displayed indicating that the later file is "hidden" by
the earlier.

For example, suppose ‘load-path’ is set to

("/usr/share/emacs/site-lisp" "/usr/share/emacs/24.3/lisp")

and that each of these directories contains a file called XXX.el.  Then
XXX.el in the site-lisp directory is referred to by all of:
(require 'XXX), (autoload .... "XXX"), (load-library "XXX") etc.

The first XXX.el file prevents Emacs from seeing the second (unless
the second is loaded explicitly via ‘load-file’).

When not intended, such shadowings can be the source of subtle
problems.  For example, the above situation may have arisen because the
XXX package was not distributed with versions of Emacs prior to
24.3.  A system administrator downloaded XXX from elsewhere and installed
it.  Later, XXX was updated and included in the Emacs distribution.
Unless the system administrator checks for this, the new version of XXX
will be hidden behind the old (which may no longer work with the new
Emacs version).

This function performs these checks and flags all possible
shadowings.  Because a .el file may exist without a corresponding .elc
(or vice-versa), these suffixes are essentially ignored.  A file
XXX.elc in an early directory (that does not contain XXX.el) is
considered to shadow a later file XXX.el, and vice-versa.

Shadowings are located by calling the (non-interactive) companion
function, ‘load-path-shadows-find’.

(fn &optional STRINGP)〉〉enditem49840〈〈tab-to-tab-stop〉〉:〈〈Insert spaces or tabs to next defined tab-stop column.
The variable ‘tab-stop-list’ is a list of columns at which there are tab stops.
Use M-x edit-tab-stops to edit them interactively.〉〉enditem49840〈〈kill-buffer〉〉:〈〈Kill the buffer specified by BUFFER-OR-NAME.
The argument may be a buffer or the name of an existing buffer.
Argument nil or omitted means kill the current buffer.  Return t if the
buffer is actually killed, nil otherwise.

The functions in ‘kill-buffer-query-functions’ are called with the
buffer to be killed as the current buffer.  If any of them returns nil,
the buffer is not killed.  The hook ‘kill-buffer-hook’ is run before the
buffer is actually killed.  The buffer being killed will be current
while the hook is running.  Functions called by any of these hooks are
supposed to not change the current buffer.

Any processes that have this buffer as the ‘process-buffer’ are killed
with SIGHUP.  This function calls ‘replace-buffer-in-windows’ for
cleaning up all windows currently displaying the buffer to be killed.

(fn &optional BUFFER-OR-NAME)〉〉enditem49840〈〈back-to-indentation〉〉:〈〈Move point to the first non-whitespace character on this line.〉〉enditem49840〈〈backward-to-indentation〉〉:〈〈Move backward ARG lines and position at first nonblank character.

(fn &optional ARG)〉〉enditem49840〈〈forward-to-indentation〉〉:〈〈Move forward ARG lines and position at first nonblank character.

(fn &optional ARG)〉〉enditem49840〈〈unload-feature〉〉:〈〈Unload the library that provided FEATURE.
If the feature is required by any other loaded code, and prefix arg FORCE
is nil, raise an error.

Standard unloading activities include restoring old autoloads for
functions defined by the library, undoing any additions that the
library has made to hook variables or to ‘auto-mode-alist’, undoing
ELP profiling of functions in that library, unproviding any features
provided by the library, and canceling timers held in variables
defined by the library.

If a function ‘FEATURE-unload-function’ is defined, this function
calls it with no arguments, before doing anything else.  That function
can do whatever is appropriate to undo the loading of the library.  If
‘FEATURE-unload-function’ returns non-nil, that suppresses the
standard unloading of the library.  Otherwise the standard unloading
proceeds.

‘FEATURE-unload-function’ has access to the package’s list of
definitions in the variable ‘unload-function-defs-list’ and could
remove symbols from it in the event that the package has done
something strange, such as redefining an Emacs function.

(fn FEATURE &optional FORCE)〉〉enditem49840〈〈read-kbd-macro〉〉:〈〈Read the region as a keyboard macro definition.
The region is interpreted as spelled-out keystrokes, e.g., "M-x abc RET".
See documentation for ‘edmacro-mode’ for details.
Leading/trailing "C-x (" and "C-x )" in the text are allowed and ignored.
The resulting macro is installed as the "current" keyboard macro.

In Lisp, may also be called with a single STRING argument in which case
the result is returned rather than being installed as the current macro.
The result will be a string if possible, otherwise an event vector.
Second argument NEED-VECTOR means to return an event vector always.〉〉enditem49840〈〈serial-term〉〉:〈〈Start a terminal-emulator for a serial port in a new buffer.
PORT is the path or name of the serial port.  For example, this
could be "/dev/ttyS0" on Unix.  On Windows, this could be
"COM1" or "\\.\COM10".
SPEED is the speed of the serial port in bits per second.  9600
is a common value.  SPEED can be nil, see
‘serial-process-configure’ for details.
The buffer is in Term mode; see ‘term-mode’ for the commands to
use in that buffer.
Type C-c b to switch to another buffer.〉〉enditem49840〈〈buffer-enable-undo〉〉:〈〈Start keeping undo information for buffer BUFFER.
No argument or nil as argument means do this for the current buffer.

(fn &optional BUFFER)〉〉enditem49840〈〈buffer-disable-undo〉〉:〈〈Make BUFFER stop keeping undo information.
No argument or nil as argument means do this for the current buffer.

(fn &optional BUFFER)〉〉enditem49840〈〈text-mode〉〉:〈〈Major mode for editing text written for humans to read.
In this mode, paragraphs are delimited only by blank or white lines.
You can thus get the full benefit of adaptive filling
 (see the variable ‘adaptive-fill-mode’).
key             binding
---             -------

ESC             Prefix Command

C-M-i           ispell-complete-word


Turning on Text mode runs the normal hook ‘text-mode-hook’.〉〉enditem49840〈〈prog-mode〉〉:〈〈Major mode for editing programming language source code.

This mode runs the hook ‘prog-mode-hook’, as the final or penultimate step
during initialization.

key             binding
---             -------

ESC             Prefix Command

C-M-q           prog-indent-sexp

〉〉enditem49840〈〈special-mode〉〉:〈〈Parent major mode from which special major modes should inherit.

This mode runs the hook ‘special-mode-hook’, as the final or penultimate step
during initialization.

key             binding
---             -------

SPC             scroll-up-command
-               negative-argument
0 .. 9          digit-argument
<               beginning-of-buffer
>               end-of-buffer
?               describe-mode
g               revert-buffer
h               describe-mode
q               quit-window
DEL             scroll-down-command
S-SPC           scroll-down-command
<remap>         Prefix Command

〉〉enditem49840〈〈beginning-of-buffer〉〉:〈〈Move point to the beginning of the buffer.
With numeric arg N, put point N/10 of the way from the beginning.
If the buffer is narrowed, this command uses the beginning of the
accessible part of the buffer.

Push mark at previous position, unless either a C-u prefix
is supplied, or Transient Mark mode is enabled and the mark is active.

(fn &optional ARG)〉〉enditem49840〈〈end-of-buffer〉〉:〈〈Move point to the end of the buffer.
With numeric arg N, put point N/10 of the way from the end.
If the buffer is narrowed, this command uses the end of the
accessible part of the buffer.

Push mark at previous position, unless either a C-u prefix
is supplied, or Transient Mark mode is enabled and the mark is active.

(fn &optional ARG)〉〉enditem49840〈〈forward-list〉〉:〈〈Move forward across one balanced group of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do it that many times.
Negative arg -N means move backward across N groups of parentheses.
This command assumes point is not in a string or comment.

(fn &optional ARG)〉〉enditem49840〈〈backward-list〉〉:〈〈Move backward across one balanced group of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do it that many times.
Negative arg -N means move forward across N groups of parentheses.
This command assumes point is not in a string or comment.

(fn &optional ARG)〉〉enditem49840〈〈up-list〉〉:〈〈Move forward out of one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.  With ARG, do this that
many times.  A negative argument means move backward but still to
a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is
interactively), move out of enclosing strings as well. If
NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to
break out of any enclosing string instead of moving to the start
of a list broken across multiple strings.  On error, location of
point is unspecified.

(fn &optional ARG ESCAPE-STRINGS NO-SYNTAX-CROSSING)〉〉enditem49840〈〈backward-up-list〉〉:〈〈Move backward out of one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.  With ARG, do this that
many times.  A negative argument means move forward but still to
a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is
interactively), move out of enclosing strings as well.  If
NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to
break out of any enclosing string instead of moving to the start
of a list broken across multiple strings.  On error, location of
point is unspecified.

(fn &optional ARG ESCAPE-STRINGS NO-SYNTAX-CROSSING)〉〉enditem49840〈〈down-list〉〉:〈〈Move forward down one level of parentheses.
This command will also work on other parentheses-like expressions
defined by the current language mode.
With ARG, do this that many times.
A negative argument means move backward but still go down a level.
This command assumes point is not in a string or comment.

(fn &optional ARG)〉〉enditem49840〈〈forward-sexp〉〉:〈〈Move forward across one balanced expression (sexp).
With ARG, do it that many times.  Negative arg -N means move
backward across N balanced expressions.  This command assumes
point is not in a string or comment.  Calls
‘forward-sexp-function’ to do the work, if that is non-nil.  If
unable to move over a sexp, signal ‘scan-error’ with three
arguments: a message, the start of the obstacle (usually a
parenthesis or list marker of some kind), and end of the
obstacle.

(fn &optional ARG)〉〉enditem49840〈〈backward-sexp〉〉:〈〈Move backward across one balanced expression (sexp).
With ARG, do it that many times.  Negative arg -N means
move forward across N balanced expressions.
This command assumes point is not in a string or comment.
Uses ‘forward-sexp’ to do the work.

(fn &optional ARG)〉〉enditem49840〈〈beginning-of-defun〉〉:〈〈Move backward to the beginning of a defun.
With ARG, do it that many times.  Negative ARG means move forward
to the ARGth following beginning of defun.

If search is successful, return t; point ends up at the beginning
of the line where the search succeeded.  Otherwise, return nil.

When ‘open-paren-in-column-0-is-defun-start’ is non-nil, a defun
is assumed to start where there is a char with open-parenthesis
syntax at the beginning of a line.  If ‘defun-prompt-regexp’ is
non-nil, then a string which matches that regexp may also precede
the open-parenthesis.  If ‘defun-prompt-regexp’ and
‘open-paren-in-column-0-is-defun-start’ are both nil, this
function instead finds an open-paren at the outermost level.

If the variable ‘beginning-of-defun-function’ is non-nil, its
value is called as a function, with argument ARG, to find the
defun’s beginning.

Regardless of the values of ‘defun-prompt-regexp’ and
‘beginning-of-defun-function’, point always moves to the
beginning of the line whenever the search is successful.

(fn &optional ARG)〉〉enditem49840〈〈end-of-defun〉〉:〈〈Move forward to next end of defun.
With argument, do it that many times.
Negative argument -N means move back to Nth preceding end of defun.

An end of a defun occurs right after the close-parenthesis that
matches the open-parenthesis that starts a defun; see function
‘beginning-of-defun’.

If variable ‘end-of-defun-function’ is non-nil, its value
is called as a function to find the defun’s end.

(fn &optional ARG)〉〉enditem49840〈〈gui-set-selection〉〉:〈〈Make an X selection of type TYPE and value DATA.
The argument TYPE (nil means ‘PRIMARY’) says which selection, and
DATA specifies the contents.  TYPE must be a symbol.  (It can also
be a string, which stands for the symbol with that name, but this
is considered obsolete.)  DATA may be a string, a symbol, an
integer (or a cons of two integers or list of two integers).

The selection may also be a cons of two markers pointing to the same buffer,
or an overlay.  In these cases, the selection is considered to be the text
between the markers *at whatever time the selection is examined*.
Thus, editing done in the buffer after you specify the selection
can alter the effective value of the selection.

The data may also be a vector of valid non-vector selection values.

The return value is DATA.

Interactively, this command sets the primary selection.  Without
prefix argument, it reads the selection in the minibuffer.  With
prefix argument, it uses the text of the region as the selection value.

Note that on MS-Windows, primary and secondary selections set by Emacs
are not available to other programs.

(fn TYPE DATA)〉〉enditem49840〈〈undefined〉〉:〈〈Beep to tell the user this binding is undefined.〉〉enditem49840〈〈garbage-collect〉〉:〈〈Reclaim storage for Lisp objects no longer needed.
Garbage collection happens automatically if you cons more than
‘gc-cons-threshold’ bytes of Lisp data since previous garbage collection.
‘garbage-collect’ normally returns a list with info on amount of space in use,
where each entry has the form (NAME SIZE USED FREE), where:
- NAME is a symbol describing the kind of objects this entry represents,
- SIZE is the number of bytes used by each one,
- USED is the number of those objects that were found live in the heap,
- FREE is the number of those objects that are not live but that Emacs
  keeps around for future allocations (maybe because it does not know how
  to return them to the OS).
However, if there was overflow in pure space, ‘garbage-collect’
returns nil, because real GC can’t be done.
See Info node ‘(elisp)Garbage Collection’.

(fn)〉〉enditem49840〈〈describe-categories〉〉:〈〈Describe the category specifications in the current category table.
The descriptions are inserted in a buffer, which is then displayed.
If BUFFER is non-nil, then describe BUFFER’s category table instead.
BUFFER should be a buffer or a buffer name.

(fn &optional BUFFER)〉〉enditem49840〈〈load-theme〉〉:〈〈Load Custom theme named THEME from its file.
The theme file is named THEME-theme.el, in one of the directories
specified by ‘custom-theme-load-path’.

If the theme is not considered safe by ‘custom-safe-themes’,
prompt the user for confirmation before loading it.  But if
optional arg NO-CONFIRM is non-nil, load the theme without
prompting.

Normally, this function also enables THEME.  If optional arg
NO-ENABLE is non-nil, load the theme but don’t enable it, unless
the theme was already enabled.

This function is normally called through Customize when setting
‘custom-enabled-themes’.  If used directly in your init file, it
should be called with a non-nil NO-CONFIRM argument, or after
‘custom-safe-themes’ has been loaded.

Return t if THEME was successfully loaded, nil otherwise.〉〉enditem49840〈〈enable-theme〉〉:〈〈Reenable all variable and face settings defined by THEME.
THEME should be either ‘user’, or a theme loaded via ‘load-theme’.
After this function completes, THEME will have the highest
precedence (after ‘user’).〉〉enditem49840〈〈disable-theme〉〉:〈〈Disable all variable and face settings defined by THEME.
See ‘custom-enabled-themes’ for a list of enabled themes.〉〉enditem49840〈〈not-modified〉〉:〈〈Mark current buffer as unmodified, not needing to be saved.
With prefix ARG, mark buffer as modified, so C-s will save.

It is not a good idea to use this function in Lisp programs, because it
prints a message in the minibuffer.  Instead, use ‘set-buffer-modified-p’.

(fn &optional ARG)〉〉enditem49840〈〈yank〉〉:〈〈Reinsert ("paste") the last stretch of killed text.
More precisely, reinsert the most recent kill, which is the
stretch of killed text most recently killed OR yanked.  Put point
at the end, and set mark at the beginning without activating it.
With just C-u as argument, put point at beginning, and mark at end.
With argument N, reinsert the Nth most recent kill.

This command honors the ‘yank-handled-properties’ and
‘yank-excluded-properties’ variables, and the ‘yank-handler’ text
property, as described below.

Properties listed in ‘yank-handled-properties’ are processed,
then those listed in ‘yank-excluded-properties’ are discarded.

If STRING has a non-nil ‘yank-handler’ property anywhere, the
normal insert behavior is altered, and instead, for each contiguous
segment of STRING that has a given value of the ‘yank-handler’
property, that value is used as follows:

The value of a ‘yank-handler’ property must be a list of one to four
elements, of the form (FUNCTION PARAM NOEXCLUDE UNDO).
FUNCTION, if non-nil, should be a function of one argument (the
 object to insert); FUNCTION is called instead of ‘insert’.
PARAM, if present and non-nil, is passed to FUNCTION (to be handled
 in whatever way is appropriate; e.g. if FUNCTION is ‘yank-rectangle’,
 PARAM may be a list of strings to insert as a rectangle).  If PARAM
 is nil, then the current segment of STRING is used.
If NOEXCLUDE is present and non-nil, the normal removal of
 ‘yank-excluded-properties’ is not performed; instead FUNCTION is
 responsible for the removal.  This may be necessary if FUNCTION
 adjusts point before or after inserting the object.
UNDO, if present and non-nil, should be a function to be called
 by ‘yank-pop’ to undo the insertion of the current PARAM.  It is
 given two arguments, the start and end of the region.  FUNCTION
 may set ‘yank-undo-function’ to override UNDO.

See also the command ‘yank-pop’ (M-y).

(fn &optional ARG)〉〉enditem49840〈〈yank-pop〉〉:〈〈Replace just-yanked stretch of killed text with a different stretch.
This command is allowed only immediately after a ‘yank’ or a ‘yank-pop’.
At such a time, the region contains a stretch of reinserted
previously-killed text.  ‘yank-pop’ deletes that text and inserts in its
place a different stretch of killed text.

With no argument, the previous kill is inserted.
With argument N, insert the Nth previous kill.
If N is negative, this is a more recent kill.

The sequence of kills wraps around, so that after the oldest one
comes the newest one.

This command honors the ‘yank-handled-properties’ and
‘yank-excluded-properties’ variables, and the ‘yank-handler’ text
property, in the way that ‘yank’ does.

(fn &optional ARG)〉〉enditem49840〈〈split-window-right〉〉:〈〈Split the selected window into two side-by-side windows.
The selected window is on the left.  The newly split-off window
is on the right and displays the same buffer.  Return the new
window.

If optional argument SIZE is omitted or nil, both windows get the
same width, or close to it.  If SIZE is positive, the left-hand
(selected) window gets SIZE columns.  If SIZE is negative, the
right-hand (new) window gets -SIZE columns.  Here, SIZE includes
the width of the window’s scroll bar; if there are no scroll
bars, it includes the width of the divider column to the window’s
right, if any.

(fn &optional SIZE)〉〉enditem49840〈〈split-window-below〉〉:〈〈Split the selected window into two windows, one above the other.
The selected window is above.  The newly split-off window is
below and displays the same buffer.  Return the new window.

If optional argument SIZE is omitted or nil, both windows get the
same height, or close to it.  If SIZE is positive, the upper
(selected) window gets SIZE lines.  If SIZE is negative, the
lower (new) window gets -SIZE lines.

If the variable ‘split-window-keep-point’ is non-nil, both
windows get the same value of point as the selected window.
Otherwise, the window starts are chosen so as to minimize the
amount of redisplay; this is convenient on slow terminals.

(fn &optional SIZE)〉〉enditem49840〈〈set-visited-file-name〉〉:〈〈Change name of file visited in current buffer to FILENAME.
This also renames the buffer to correspond to the new file.
The next time the buffer is saved it will go in the newly specified file.
FILENAME nil or an empty string means mark buffer as not visiting any file.
Remember to delete the initial contents of the minibuffer
if you wish to pass an empty string as the argument.

The optional second argument NO-QUERY, if non-nil, inhibits asking for
confirmation in the case where another buffer is already visiting FILENAME.

The optional third argument ALONG-WITH-FILE, if non-nil, means that
the old visited file has been renamed to the new name FILENAME.

(fn FILENAME &optional NO-QUERY ALONG-WITH-FILE)〉〉enditem49840〈〈mouse-on-link-p〉〉:〈〈Return non-nil if POS is on a link in the current buffer.
POS must specify a buffer position in the current buffer, as a list
of the form returned by the ‘event-start’ and ‘event-end’ functions,
or a mouse event location in the selected window (see ‘event-start’).
However, if ‘mouse-1-click-in-non-selected-windows’ is non-nil,
POS may be a mouse event location in any window.

A clickable link is identified by one of the following methods:

- If the character at POS has a non-nil ‘follow-link’ text or
overlay property, the value of that property determines what to do.

- If there is a local key-binding or a keybinding at position POS
for the ‘follow-link’ event, the binding of that event determines
what to do.

The resulting value determine whether POS is inside a link:

- If the value is ‘mouse-face’, POS is inside a link if there
is a non-nil ‘mouse-face’ property at POS.  Return t in this case.

- If the value is a function, FUNC, POS is inside a link if
the call (FUNC POS) returns non-nil.  Return the return value
from that call.  Arg is (posn-point POS) if POS is a mouse event.

- Otherwise, return the value itself.

The return value is interpreted as follows:

- If it is a string, the mouse-1 event is translated into the
first character of the string, i.e. the action of the mouse-1
click is the local or global binding of that character.

- If it is a vector, the mouse-1 event is translated into the
first element of that vector, i.e. the action of the mouse-1
click is the local or global binding of that event.

- Otherwise, the mouse-1 event is translated into a mouse-2 event
at the same position.

(fn POS)〉〉enditem49840〈〈macrop〉〉:〈〈Non-nil if and only if OBJECT is a macro.

(fn OBJECT)〉〉enditem49840〈〈run-hooks〉〉:〈〈Run each hook in HOOKS.
Each argument should be a symbol, a hook variable.
These symbols are processed in the order specified.
If a hook symbol has a non-nil value, that value may be a function
or a list of functions to be called to run the hook.
If the value is a function, it is called with no arguments.
If it is a list, the elements are called, in order, with no arguments.

Major modes should not use this function directly to run their mode
hook; they should use ‘run-mode-hooks’ instead.

Do not use ‘make-local-variable’ to make a hook variable buffer-local.
Instead, use ‘add-hook’ and specify t for the LOCAL argument.

(fn &rest HOOKS)〉〉enditem49840〈〈run-hook-with-args〉〉:〈〈Run HOOK with the specified arguments ARGS.
HOOK should be a symbol, a hook variable.  The value of HOOK
may be nil, a function, or a list of functions.  Call each
function in order with arguments ARGS.  The final return value
is unspecified.

Do not use ‘make-local-variable’ to make a hook variable buffer-local.
Instead, use ‘add-hook’ and specify t for the LOCAL argument.

(fn HOOK &rest ARGS)〉〉enditem49840〈〈run-hook-with-args-until-failure〉〉:〈〈Run HOOK with the specified arguments ARGS.
HOOK should be a symbol, a hook variable.  The value of HOOK
may be nil, a function, or a list of functions.  Call each
function in order with arguments ARGS, stopping at the first
one that returns nil, and return nil.  Otherwise (if all functions
return non-nil, or if there are no functions to call), return non-nil
(do not rely on the precise return value in this case).

Do not use ‘make-local-variable’ to make a hook variable buffer-local.
Instead, use ‘add-hook’ and specify t for the LOCAL argument.

(fn HOOK &rest ARGS)〉〉enditem49840〈〈run-hook-with-args-until-success〉〉:〈〈Run HOOK with the specified arguments ARGS.
HOOK should be a symbol, a hook variable.  The value of HOOK
may be nil, a function, or a list of functions.  Call each
function in order with arguments ARGS, stopping at the first
one that returns non-nil, and return that value.  Otherwise (if
all functions return nil, or if there are no functions to call),
return nil.

Do not use ‘make-local-variable’ to make a hook variable buffer-local.
Instead, use ‘add-hook’ and specify t for the LOCAL argument.

(fn HOOK &rest ARGS)〉〉enditem49840〈〈define-fringe-bitmap〉〉:〈〈Define fringe bitmap BITMAP from BITS of size HEIGHT x WIDTH.
BITMAP is a symbol identifying the new fringe bitmap.
BITS is either a string or a vector of integers.
HEIGHT is height of bitmap.  If HEIGHT is nil, use length of BITS.
WIDTH must be an integer between 1 and 16, or nil which defaults to 8.
Optional fifth arg ALIGN may be one of ‘top’, ‘center’, or ‘bottom’,
indicating the positioning of the bitmap relative to the rows where it
is used; the default is to center the bitmap.  Fifth arg may also be a
list (ALIGN PERIODIC) where PERIODIC non-nil specifies that the bitmap
should be repeated.
If BITMAP already exists, the existing definition is replaced.

(fn BITMAP BITS &optional HEIGHT WIDTH ALIGN)〉〉enditem49840〈〈destroy-fringe-bitmap〉〉:〈〈Destroy fringe bitmap BITMAP.
If BITMAP overrides a standard fringe bitmap, the original bitmap is restored.

(fn BITMAP)〉〉enditem49840〈〈set-fringe-bitmap-face〉〉:〈〈Set face for fringe bitmap BITMAP to FACE.
FACE is merged with the ‘fringe’ face, so normally FACE should specify
only the foreground color.
If FACE is nil, reset face to default fringe face.

(fn BITMAP &optional FACE)〉〉enditem49840〈〈file-name-directory〉〉:〈〈Return the directory component in file name FILENAME.
Return nil if FILENAME does not include a directory.
Otherwise return a directory name.
Given a Unix syntax file name, returns a string ending in slash.

(fn FILENAME)〉〉enditem49840〈〈file-name-nondirectory〉〉:〈〈Return file name FILENAME sans its directory.
For example, in a Unix-syntax file name,
this is everything after the last slash,
or the entire name if it contains no slash.

(fn FILENAME)〉〉enditem49840〈〈file-name-sans-versions〉〉:〈〈Return file NAME sans backup versions or strings.
This is a separate procedure so your site-init or startup file can
redefine it.
If the optional argument KEEP-BACKUP-VERSION is non-nil,
we do not remove backup version numbers, only true file version numbers.
See also ‘file-name-version-regexp’.

(fn NAME &optional KEEP-BACKUP-VERSION)〉〉enditem49840〈〈file-name-extension〉〉:〈〈Return FILENAME’s final "extension".
The extension, in a file name, is the part that begins with the last ‘.’,
excluding version numbers and backup suffixes, except that a leading ‘.’
of the file name, if there is one, doesn’t count.
Return nil for extensionless file names such as ‘foo’.
Return the empty string for file names such as ‘foo.’.

By default, the returned value excludes the period that starts the
extension, but if the optional argument PERIOD is non-nil, the period
is included in the value, and in that case, if FILENAME has no
extension, the value is "".

(fn FILENAME &optional PERIOD)〉〉enditem49840〈〈file-name-sans-extension〉〉:〈〈Return FILENAME sans final "extension".
The extension, in a file name, is the part that begins with the last ‘.’,
except that a leading ‘.’ of the file name, if there is one, doesn’t count.

(fn FILENAME)〉〉enditem49840〈〈file-name-base〉〉:〈〈Return the base name of the FILENAME: no directory, no extension.
FILENAME defaults to ‘buffer-file-name’.

(fn &optional FILENAME)〉〉enditem49840〈〈buffer-file-name〉〉:〈〈Return name of file BUFFER is visiting, or nil if none.
No argument or nil as argument means use the current buffer.

(fn &optional BUFFER)〉〉enditem49840〈〈get-file-buffer〉〉:〈〈Return the buffer visiting file FILENAME (a string).
The buffer’s ‘buffer-file-name’ must match exactly the expansion of FILENAME.
If there is no such live buffer, return nil.
See also ‘find-buffer-visiting’.

(fn FILENAME)〉〉enditem49840〈〈find-buffer-visiting〉〉:〈〈Return the buffer visiting file FILENAME (a string).
This is like ‘get-file-buffer’, except that it checks for any buffer
visiting the same file, possibly under a different name.
If PREDICATE is non-nil, only buffers satisfying it are eligible,
and others are ignored.
If there is no such live buffer, return nil.

(fn FILENAME &optional PREDICATE)〉〉enditem49840〈〈split-window〉〉:〈〈Make a new window adjacent to WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return the new window which is always a live window.

Optional argument SIZE a positive number means make WINDOW SIZE
lines or columns tall.  If SIZE is negative, make the new window
-SIZE lines or columns tall.  If and only if SIZE is non-nil, its
absolute value can be less than ‘window-min-height’ or
‘window-min-width’; so this command can make a new window as
small as one line or two columns.  SIZE defaults to half of
WINDOW’s size.

Optional third argument SIDE nil (or ‘below’) specifies that the
new window shall be located below WINDOW.  SIDE ‘above’ means the
new window shall be located above WINDOW.  In both cases SIZE
specifies the new number of lines for WINDOW (or the new window
if SIZE is negative) including space reserved for the mode and/or
header line.

SIDE t (or ‘right’) specifies that the new window shall be
located on the right side of WINDOW.  SIDE ‘left’ means the new
window shall be located on the left of WINDOW.  In both cases
SIZE specifies the new number of columns for WINDOW (or the new
window provided SIZE is negative) including space reserved for
fringes and the scrollbar or a divider column.  Any other non-nil
value for SIDE is currently handled like t (or ‘right’).

PIXELWISE, if non-nil, means to interpret SIZE pixelwise.

If the variable ‘ignore-window-parameters’ is non-nil or the
‘split-window’ parameter of WINDOW equals t, do not process any
parameters of WINDOW.  Otherwise, if the ‘split-window’ parameter
of WINDOW specifies a function, call that function with all three
arguments and return the value returned by that function.

Otherwise, if WINDOW is part of an atomic window, "split" the
root of that atomic window.  The new window does not become a
member of that atomic window.

If WINDOW is live, properties of the new window like margins and
scrollbars are inherited from WINDOW.  If WINDOW is an internal
window, these properties as well as the buffer displayed in the
new window are inherited from the window selected on WINDOW’s
frame.  The selected window is not changed by this function.

(fn &optional WINDOW SIZE SIDE PIXELWISE)〉〉enditem49840〈〈window-total-height〉〉:〈〈Return the height of window WINDOW in lines.
WINDOW must be a valid window and defaults to the selected one.

The return value includes the heights of WINDOW’s mode and header line
and its bottom divider, if any.  If WINDOW is an internal window, the
total height is the height of the screen areas spanned by its children.

If WINDOW’s pixel height is not an integral multiple of its frame’s
character height, the number of lines occupied by WINDOW is rounded
internally.  This is done in a way such that, if WINDOW is a parent
window, the sum of the total heights of all its children internally
equals the total height of WINDOW.

If the optional argument ROUND is ‘ceiling’, return the smallest integer
larger than WINDOW’s pixel height divided by the character height of
WINDOW’s frame.  ROUND ‘floor’ means to return the largest integer
smaller than WINDOW’s pixel height divided by the character height of
WINDOW’s frame.  Any other value of ROUND means to return the internal
total height of WINDOW.

(fn &optional WINDOW ROUND)〉〉enditem49840〈〈window-total-width〉〉:〈〈Return the total width of window WINDOW in columns.
WINDOW must be a valid window and defaults to the selected one.

The return value includes the widths of WINDOW’s fringes, margins,
scroll bars and its right divider, if any.  If WINDOW is an internal
window, the total width is the width of the screen areas spanned by its
children.

If WINDOW’s pixel width is not an integral multiple of its frame’s
character width, the number of lines occupied by WINDOW is rounded
internally.  This is done in a way such that, if WINDOW is a parent
window, the sum of the total widths of all its children internally
equals the total width of WINDOW.

If the optional argument ROUND is ‘ceiling’, return the smallest integer
larger than WINDOW’s pixel width divided by the character width of
WINDOW’s frame.  ROUND ‘floor’ means to return the largest integer
smaller than WINDOW’s pixel width divided by the character width of
WINDOW’s frame.  Any other value of ROUND means to return the internal
total width of WINDOW.

(fn &optional WINDOW ROUND)〉〉enditem49840〈〈window-total-size〉〉:〈〈Return the total height or width of WINDOW.
WINDOW must be a valid window and defaults to the selected one.

If HORIZONTAL is omitted or nil, return the total height of
WINDOW, in lines.  If WINDOW is live, its total height includes,
in addition to the height of WINDOW’s text, the heights of
WINDOW’s mode and header line and a bottom divider, if any.

If HORIZONTAL is non-nil, return the total width of WINDOW, in
columns.  If WINDOW is live, its total width includes, in
addition to the width of WINDOW’s text, the widths of WINDOW’s
fringes, margins, scroll bars and its right divider, if any.

If WINDOW is internal, return the respective size of the screen
areas spanned by its children.

Optional argument ROUND is handled as for ‘window-total-height’
and ‘window-total-width’.

(fn &optional WINDOW HORIZONTAL ROUND)〉〉enditem49840〈〈window-pixel-height〉〉:〈〈Return the height of window WINDOW in pixels.
WINDOW must be a valid window and defaults to the selected one.

The return value includes the mode line and header line and the bottom
divider, if any.  If WINDOW is an internal window, its pixel height is
the height of the screen areas spanned by its children.

(fn &optional WINDOW)〉〉enditem49840〈〈window-pixel-width〉〉:〈〈Return the width of window WINDOW in pixels.
WINDOW must be a valid window and defaults to the selected one.

The return value includes the fringes and margins of WINDOW as well as
any vertical dividers or scroll bars belonging to WINDOW.  If WINDOW is
an internal window, its pixel width is the width of the screen areas
spanned by its children.

(fn &optional WINDOW)〉〉enditem49840〈〈window-full-height-p〉〉:〈〈Return t if WINDOW is as high as its containing frame.
More precisely, return t if and only if the total height of
WINDOW equals the total height of the root window of WINDOW’s
frame.  WINDOW must be a valid window and defaults to the
selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-full-width-p〉〉:〈〈Return t if WINDOW is as wide as its containing frame.
More precisely, return t if and only if the total width of WINDOW
equals the total width of the root window of WINDOW’s frame.
WINDOW must be a valid window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-body-height〉〉:〈〈Return the height of WINDOW’s text area.
WINDOW must be a live window and defaults to the selected one.  Optional
argument PIXELWISE non-nil means return the height of WINDOW’s text area
in pixels.  The return value does not include the mode line or header
line or any horizontal divider.

If PIXELWISE is nil, return the largest integer smaller than WINDOW’s
pixel height divided by the character height of WINDOW’s frame.  This
means that if a line at the bottom of the text area is only partially
visible, that line is not counted.

(fn &optional WINDOW PIXELWISE)〉〉enditem49840〈〈window-body-width〉〉:〈〈Return the width of WINDOW’s text area.
WINDOW must be a live window and defaults to the selected one.  Optional
argument PIXELWISE non-nil means return the width in pixels.  The return
value does not include any vertical dividers, fringes or marginal areas,
or scroll bars.

If PIXELWISE is nil, return the largest integer smaller than WINDOW’s
pixel width divided by the character width of WINDOW’s frame.  This
means that if a column at the right of the text area is only partially
visible, that column is not counted.

Note that the returned value includes the column reserved for the
continuation glyph.

(fn &optional WINDOW PIXELWISE)〉〉enditem49840〈〈window-body-size〉〉:〈〈Return the height or width of WINDOW’s text area.
WINDOW must be a live window and defaults to the selected one.

If HORIZONTAL is omitted or nil, return the height of the text
area, like ‘window-body-height’.  Otherwise, return the width of
the text area, like ‘window-body-width’.  In either case, the
optional argument PIXELWISE is passed to the functions.

(fn &optional WINDOW HORIZONTAL PIXELWISE)〉〉enditem49840〈〈window-mode-line-height〉〉:〈〈Return the height in pixels of WINDOW’s mode-line.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-header-line-height〉〉:〈〈Return the height in pixels of WINDOW’s header-line.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-max-chars-per-line〉〉:〈〈Return the number of characters that can be displayed on one line in WINDOW.
WINDOW must be a live window and defaults to the selected one.

The character width of FACE is used for the calculation.  If FACE
is nil or omitted, the default face is used.  If FACE is
remapped (see ‘face-remapping-alist’), the function uses the
remapped face.

This function is different from ‘window-body-width’ in two
ways.  First, it accounts for the portions of the line reserved
for the continuation glyph.  Second, it accounts for the size of
the font.

(fn &optional WINDOW FACE)〉〉enditem49840〈〈window-min-size〉〉:〈〈Return the minimum size of WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Optional argument HORIZONTAL non-nil means return the minimum
number of columns of WINDOW; otherwise return the minimum number
of WINDOW’s lines.

The optional argument IGNORE has the same meaning as for
‘window-resizable’.  Optional argument PIXELWISE non-nil means
return the minimum pixel-size of WINDOW.

(fn &optional WINDOW HORIZONTAL IGNORE PIXELWISE)〉〉enditem49840〈〈window-edges〉〉:〈〈Return a list of the edge distances of WINDOW.
WINDOW must be a valid window and defaults to the selected one.
The list returned has the form (LEFT TOP RIGHT BOTTOM).

If the optional argument BODY is nil, this means to return the
edges corresponding to the total size of WINDOW.  BODY non-nil
means to return the edges of WINDOW’s body (aka text area).  If
BODY is non-nil, WINDOW must specify a live window.

Optional argument ABSOLUTE nil means to return edges relative to
the position of WINDOW’s native frame.  ABSOLUTE non-nil means to
return coordinates relative to the origin - the position (0, 0) -
of FRAME’s display.  On non-graphical systems this argument has
no effect.

Optional argument PIXELWISE nil means to return the coordinates
in terms of the canonical character width and height of WINDOW’s
frame, rounded if necessary.  PIXELWISE non-nil means to return
the coordinates in pixels where the values for RIGHT and BOTTOM
are one more than the actual value of these edges.  Note that if
ABSOLUTE is non-nil, PIXELWISE is implicitly non-nil too.

(fn &optional WINDOW BODY ABSOLUTE PIXELWISE)〉〉enditem49840〈〈window-body-edges〉〉:〈〈Return a list of the edge coordinates of WINDOW’s body.
The return value is that of ‘window-edges’ called with argument
BODY non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈window-at〉〉:〈〈Return window containing coordinates X and Y on FRAME.
FRAME must be a live frame and defaults to the selected one.
The top left corner of the frame is considered to be row 0,
column 0.

(fn X Y &optional FRAME)〉〉enditem49840〈〈coordinates-in-window-p〉〉:〈〈Return non-nil if COORDINATES are in WINDOW.
WINDOW must be a live window and defaults to the selected one.
COORDINATES is a cons of the form (X . Y), X and Y being distances
measured in characters from the upper-left corner of the frame.
(0 . 0) denotes the character in the upper left corner of the
frame.
If COORDINATES are in the text portion of WINDOW,
   the coordinates relative to the window are returned.
If they are in the bottom divider of WINDOW, ‘bottom-divider’ is returned.
If they are in the right divider of WINDOW, ‘right-divider’ is returned.
If they are in the mode line of WINDOW, ‘mode-line’ is returned.
If they are in the header line of WINDOW, ‘header-line’ is returned.
If they are in the left fringe of WINDOW, ‘left-fringe’ is returned.
If they are in the right fringe of WINDOW, ‘right-fringe’ is returned.
If they are on the border between WINDOW and its right sibling,
  ‘vertical-line’ is returned.
If they are in the windows’s left or right marginal areas, ‘left-margin’
  or ‘right-margin’ is returned.

(fn COORDINATES WINDOW)〉〉enditem49840〈〈window-pixel-edges〉〉:〈〈Return a list of the edge pixel coordinates of WINDOW.
The return value is that of ‘window-edges’ called with argument
PIXELWISE non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈window-body-pixel-edges〉〉:〈〈Return a list of the edge pixel coordinates of WINDOW’s body.
The return value is that of ‘window-edges’ called with arguments
BODY and PIXELWISE non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈window-absolute-pixel-edges〉〉:〈〈Return a list of the edge pixel coordinates of WINDOW.
The return value is that of ‘window-edges’ called with argument
ABSOLUTE non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈window-absolute-body-pixel-edges〉〉:〈〈Return a list of the edge pixel coordinates of WINDOW’s text area.
The return value is that of ‘window-edges’ called with arguments
BODY and ABSOLUTE non-nil.

(fn &optional WINDOW)〉〉enditem49840〈〈window-absolute-pixel-position〉〉:〈〈Return display coordinates of POSITION in WINDOW.
If the buffer position POSITION is visible in window WINDOW,
return the display coordinates of the upper/left corner of the
glyph at POSITION.  The return value is a cons of the X- and
Y-coordinates of that corner, relative to an origin at (0, 0) of
WINDOW’s display.  Return nil if POSITION is not visible in
WINDOW.

WINDOW must be a live window and defaults to the selected window.
POSITION defaults to the value of ‘window-point’ of WINDOW.

(fn &optional POSITION WINDOW)〉〉enditem49840〈〈buffer-modified-p〉〉:〈〈Return t if BUFFER was modified since its file was last read or saved.
No argument or nil as argument means use current buffer as BUFFER.

(fn &optional BUFFER)〉〉enditem49840〈〈set-buffer-modified-p〉〉:〈〈Mark current buffer as modified or unmodified according to FLAG.
A non-nil FLAG means mark the buffer modified.
In addition, this function unconditionally forces redisplay of the
mode lines of the windows that display the current buffer, and also
locks or unlocks the file visited by the buffer, depending on whether
the function’s argument is non-nil, but only if both ‘buffer-file-name’
and ‘buffer-file-truename’ are non-nil.

(fn FLAG)〉〉enditem49840〈〈restore-buffer-modified-p〉〉:〈〈Like ‘set-buffer-modified-p’, but doesn’t redisplay buffer’s mode line.
This function also locks and unlocks the file visited by the buffer,
if both ‘buffer-file-truename’ and ‘buffer-file-name’ are non-nil.

It is not ensured that mode lines will be updated to show the modified
state of the current buffer.  Use with care.

(fn FLAG)〉〉enditem49840〈〈buffer-modified-tick〉〉:〈〈Return BUFFER’s tick counter, incremented for each change in text.
Each buffer has a tick counter which is incremented each time the
text in that buffer is changed.  It wraps around occasionally.
No argument or nil as argument means use current buffer as BUFFER.

(fn &optional BUFFER)〉〉enditem49840〈〈buffer-chars-modified-tick〉〉:〈〈Return BUFFER’s character-change tick counter.
Each buffer has a character-change tick counter, which is set to the
value of the buffer’s tick counter (see ‘buffer-modified-tick’), each
time text in that buffer is inserted or deleted.  By comparing the
values returned by two individual calls of ‘buffer-chars-modified-tick’,
you can tell whether a character change occurred in that buffer in
between these calls.  No argument or nil as argument means use current
buffer as BUFFER.

(fn &optional BUFFER)〉〉enditem49840〈〈decode-time〉〉:〈〈Decode a time value as (SEC MINUTE HOUR DAY MONTH YEAR DOW DST UTCOFF).
The optional TIME should be a list of (HIGH LOW . IGNORED),
as from ‘current-time’ and ‘file-attributes’, or nil to use the
current time.  It can also be a single integer number of seconds since
the epoch.  The obsolete form (HIGH . LOW) is also still accepted.

The optional ZONE is omitted or nil for Emacs local time, t for
Universal Time, ‘wall’ for system wall clock time, or a string as in
the TZ environment variable.  It can also be a list (as from
‘current-time-zone’) or an integer (the UTC offset in seconds) applied
without consideration for daylight saving time.

The list has the following nine members: SEC is an integer between 0
and 60; SEC is 60 for a leap second, which only some operating systems
support.  MINUTE is an integer between 0 and 59.  HOUR is an integer
between 0 and 23.  DAY is an integer between 1 and 31.  MONTH is an
integer between 1 and 12.  YEAR is an integer indicating the
four-digit year.  DOW is the day of week, an integer between 0 and 6,
where 0 is Sunday.  DST is t if daylight saving time is in effect,
otherwise nil.  UTCOFF is an integer indicating the UTC offset in
seconds, i.e., the number of seconds east of Greenwich.  (Note that
Common Lisp has different meanings for DOW and UTCOFF.)

(fn &optional TIME ZONE)〉〉enditem49840〈〈encode-time〉〉:〈〈Convert SECOND, MINUTE, HOUR, DAY, MONTH, YEAR and ZONE to internal time.
This is the reverse operation of ‘decode-time’, which see.

The optional ZONE is omitted or nil for Emacs local time, t for
Universal Time, ‘wall’ for system wall clock time, or a string as in
the TZ environment variable.  It can also be a list (as from
‘current-time-zone’) or an integer (as from ‘decode-time’) applied
without consideration for daylight saving time.

You can pass more than 7 arguments; then the first six arguments
are used as SECOND through YEAR, and the *last* argument is used as ZONE.
The intervening arguments are ignored.
This feature lets (apply 'encode-time (decode-time ...)) work.

Out-of-range values for SECOND, MINUTE, HOUR, DAY, or MONTH are allowed;
for example, a DAY of 0 means the day preceding the given month.
Year numbers less than 100 are treated just like other year numbers.
If you want them to stand for years in this century, you must do that yourself.

Years before 1970 are not guaranteed to work.  On some systems,
year values as low as 1901 do work.

(fn SECOND MINUTE HOUR DAY MONTH YEAR &optional ZONE)〉〉enditem49840〈〈marker-position〉〉:〈〈Return the position of MARKER, or nil if it points nowhere.

(fn MARKER)〉〉enditem49840〈〈marker-buffer〉〉:〈〈Return the buffer that MARKER points into, or nil if none.
Returns nil if MARKER points into a dead buffer.

(fn MARKER)〉〉enditem49840〈〈create-fontset-from-fontset-spec〉〉:〈〈Create a fontset from fontset specification string FONTSET-SPEC.
FONTSET-SPEC is a string of the format:
	FONTSET-NAME[,SCRIPT-NAME0:FONT-NAME0,SCRIPT-NAME1:FONT-NAME1] ...
Any number of SPACE, TAB, and NEWLINE can be put before and after commas.

When a frame uses the fontset as the ‘font’ parameter, the frame’s
default font name is derived from FONTSET-NAME by substituting
"iso8859-1" for the tail part "fontset-XXX".  But, if SCRIPT-NAMEn
is "ascii", use the corresponding FONT-NAMEn as the default font
name.

Optional 2nd and 3rd arguments exist just for backward compatibility,
and are ignored.

It returns a name of the created fontset.

For backward compatibility, SCRIPT-NAME may be a charset name, in
which case, the corresponding script is decided by the variable
‘charset-script-alist’ (which see).〉〉enditem49840〈〈set-fontset-font〉〉:〈〈Modify fontset NAME to use FONT-SPEC for TARGET characters.

NAME is a fontset name string, nil for the fontset of FRAME, or t for
the default fontset.

TARGET may be a single character to use FONT-SPEC for.

Target may be a cons (FROM . TO), where FROM and TO are characters.
In that case, use FONT-SPEC for all characters in the range FROM
and TO (inclusive).

TARGET may be a script name symbol.  In that case, use FONT-SPEC for
all characters that belong to the script.

TARGET may be a charset.  In that case, use FONT-SPEC for all
characters in the charset.

TARGET may be nil.  In that case, use FONT-SPEC for any characters for
that no FONT-SPEC is specified.

FONT-SPEC may one of these:
 * A font-spec object made by the function ‘font-spec’ (which see).
 * A cons (FAMILY . REGISTRY), where FAMILY is a font family name and
   REGISTRY is a font registry name.  FAMILY may contain foundry
   name, and REGISTRY may contain encoding name.
 * A font name string.
 * nil, which explicitly specifies that there’s no font for TARGET.

Optional 4th argument FRAME is a frame or nil for the selected frame
that is concerned in the case that NAME is nil.

Optional 5th argument ADD, if non-nil, specifies how to add FONT-SPEC
to the font specifications for TARGET previously set.  If it is
‘prepend’, FONT-SPEC is prepended.  If it is ‘append’, FONT-SPEC is
appended.  By default, FONT-SPEC overrides the previous settings.

(fn NAME TARGET FONT-SPEC &optional FRAME ADD)〉〉enditem49840〈〈char-displayable-p〉〉:〈〈Return non-nil if we should be able to display CHAR.
On a multi-font display, the test is only whether there is an
appropriate font from the selected frame’s fontset to display
CHAR’s charset in general.  Since fonts may be specified on a
per-character basis, this may not be accurate.

(fn CHAR)〉〉enditem49840〈〈custom-add-frequent-value〉〉:〈〈To the variable SYMBOL add OPTION.

If SYMBOL’s custom type is a hook, OPTION should be a hook member.
If SYMBOL’s custom type is an alist, OPTION specifies a symbol
to offer to the user as a possible key in the alist.
For other custom types, this has no effect.〉〉enditem49840〈〈custom-reevaluate-setting〉〉:〈〈Reset the value of SYMBOL by re-evaluating its saved or standard value.
Use the :set function to do so.  This is useful for customizable options
that are defined before their standard value can really be computed.
E.g. dumped variables whose default depends on run-time information.〉〉enditem49840〈〈custom-variable-p〉〉:〈〈Return non-nil if VARIABLE is a customizable variable.
A customizable variable is either (i) a variable whose property
list contains a non-nil ‘standard-value’ or ‘custom-autoload’
property, or (ii) an alias for another customizable variable.〉〉enditem49840〈〈custom-theme-set-variables〉〉:〈〈Initialize variables for theme THEME according to settings in ARGS.
Each of the arguments in ARGS should be a list of this form:

  (SYMBOL EXP [NOW [REQUEST [COMMENT]]])

SYMBOL is the variable name, and EXP is an expression which
evaluates to the customized value.  EXP will also be stored,
without evaluating it, in SYMBOL’s ‘saved-value’ property, so
that it can be restored via the Customize interface.  It is also
added to the alist in SYMBOL’s ‘theme-value’ property (by
calling ‘custom-push-theme’).

NOW, if present and non-nil, means to install the variable’s
value directly now, even if its ‘defcustom’ declaration has not
been executed.  This is for internal use only.

REQUEST is a list of features to ‘require’ (which are loaded
prior to evaluating EXP).

COMMENT is a comment string about SYMBOL.〉〉enditem49840〈〈custom-theme-set-faces〉〉:〈〈Apply a list of face specs associated with theme THEME.
THEME should be a theme name (a symbol).  The special theme named
‘user’ refers to user settings applied via Customize.

The remaining ARGS should be a list where each entry is a list of
the form:

  (FACE SPEC [NOW [COMMENT]])

FACE should be a face name (a symbol).  If FACE is a face alias,
the setting refers to the parent face.

SPEC should be a face spec.  For details, see ‘defface’.

NOW, if present and non-nil, forces the face settings to take
immediate effect in the Emacs display; in particular, FACE is
initialized as a face if it is not yet one.  If NOW is omitted or
nil, the caller is responsible for making the settings take
effect later, by calling ‘custom-theme-recalc-face’ or
‘face-spec-recalc’.

COMMENT is a string comment about FACE.

This function works by calling ‘custom-push-theme’ to record each
SPEC in each FACE’s ‘theme-face’ property, and in THEME’s
‘theme-settings’ property.  If FACE has not already been
customized, it also stores SPEC in the ‘saved-face’ property.

If THEME has a non-nil ‘theme-immediate’ property, this is
equivalent to providing the NOW argument to all faces in the
argument list.〉〉enditem49840〈〈custom-theme-p〉〉:〈〈Non-nil when THEME has been defined.〉〉enditem49840〈〈add-to-list〉〉:〈〈Add ELEMENT to the value of LIST-VAR if it isn’t there yet.
The test for presence of ELEMENT is done with ‘equal’, or with
COMPARE-FN if that’s non-nil.
If ELEMENT is added, it is added at the beginning of the list,
unless the optional argument APPEND is non-nil, in which case
ELEMENT is added at the end.

The return value is the new value of LIST-VAR.

This is handy to add some elements to configuration variables,
but please do not abuse it in Elisp code, where you are usually
better off using ‘push’ or ‘cl-pushnew’.

If you want to use ‘add-to-list’ on a variable that is not
defined until a certain package is loaded, you should put the
call to ‘add-to-list’ into a hook function that will be run only
after loading the package.  ‘eval-after-load’ provides one way to
do this.  In some cases other hooks, such as major mode hooks,
can do the job.

(fn LIST-VAR ELEMENT &optional APPEND COMPARE-FN)〉〉enditem49840〈〈add-to-ordered-list〉〉:〈〈Add ELEMENT to the value of LIST-VAR if it isn’t there yet.
The test for presence of ELEMENT is done with ‘eq’.

The resulting list is reordered so that the elements are in the
order given by each element’s numeric list order.  Elements
without a numeric list order are placed at the end of the list.

If the third optional argument ORDER is a number (integer or
float), set the element’s list order to the given value.  If
ORDER is nil or omitted, do not change the numeric order of
ELEMENT.  If ORDER has any other value, remove the numeric order
of ELEMENT if it has one.

The list order for each element is stored in LIST-VAR’s
‘list-order’ property.

The return value is the new value of LIST-VAR.

(fn LIST-VAR ELEMENT &optional ORDER)〉〉enditem49840〈〈sin〉〉:〈〈Return the sine of ARG.

(fn ARG)〉〉enditem49840〈〈cos〉〉:〈〈Return the cosine of ARG.

(fn ARG)〉〉enditem49840〈〈tan〉〉:〈〈Return the tangent of ARG.

(fn ARG)〉〉enditem49840〈〈asin〉〉:〈〈Return the inverse sine of ARG.

(fn ARG)〉〉enditem49840〈〈acos〉〉:〈〈Return the inverse cosine of ARG.

(fn ARG)〉〉enditem49840〈〈atan〉〉:〈〈Return the inverse tangent of the arguments.
If only one argument Y is given, return the inverse tangent of Y.
If two arguments Y and X are given, return the inverse tangent of Y
divided by X, i.e. the angle in radians between the vector (X, Y)
and the x-axis.

(fn Y &optional X)〉〉enditem49840〈〈exp〉〉:〈〈Return the exponential base e of ARG.

(fn ARG)〉〉enditem49840〈〈log〉〉:〈〈Return the natural logarithm of ARG.
If the optional argument BASE is given, return log ARG using that base.

(fn ARG &optional BASE)〉〉enditem49840〈〈expt〉〉:〈〈Return the exponential ARG1 ** ARG2.

(fn ARG1 ARG2)〉〉enditem49840〈〈sqrt〉〉:〈〈Return the square root of ARG.

(fn ARG)〉〉enditem49840〈〈get-char-code-property〉〉:〈〈Return the value of CHAR’s PROPNAME property.

(fn CHAR PROPNAME)〉〉enditem49840〈〈char-code-property-description〉〉:〈〈Return a description string of character property PROP’s value VALUE.
If there’s no description string for VALUE, return nil.

(fn PROP VALUE)〉〉enditem49840〈〈put-char-code-property〉〉:〈〈Store CHAR’s PROPNAME property with VALUE.
It can be retrieved with ‘(get-char-code-property CHAR PROPNAME)’.

(fn CHAR PROPNAME VALUE)〉〉enditem49840〈〈prepare-change-group〉〉:〈〈Return a handle for the current buffer’s state, for a change group.
If you specify BUFFER, make a handle for BUFFER’s state instead.

Pass the handle to ‘activate-change-group’ afterward to initiate
the actual changes of the change group.

To finish the change group, call either ‘accept-change-group’ or
‘cancel-change-group’ passing the same handle as argument.  Call
‘accept-change-group’ to accept the changes in the group as final;
call ‘cancel-change-group’ to undo them all.  You should use
‘unwind-protect’ to make sure the group is always finished.  The call
to ‘activate-change-group’ should be inside the ‘unwind-protect’.
Once you finish the group, don’t use the handle again--don’t try to
finish the same group twice.  For a simple example of correct use, see
the source code of ‘atomic-change-group’.

The handle records only the specified buffer.  To make a multibuffer
change group, call this function once for each buffer you want to
cover, then use ‘nconc’ to combine the returned values, like this:

  (nconc (prepare-change-group buffer-1)
         (prepare-change-group buffer-2))

You can then activate that multibuffer change group with a single
call to ‘activate-change-group’ and finish it with a single call
to ‘accept-change-group’ or ‘cancel-change-group’.

(fn &optional BUFFER)〉〉enditem49840〈〈activate-change-group〉〉:〈〈Activate a change group made with ‘prepare-change-group’ (which see).

(fn HANDLE)〉〉enditem49840〈〈accept-change-group〉〉:〈〈Finish a change group made with ‘prepare-change-group’ (which see).
This finishes the change group by accepting its changes as final.

(fn HANDLE)〉〉enditem49840〈〈cancel-change-group〉〉:〈〈Finish a change group made with ‘prepare-change-group’ (which see).
This finishes the change group by reverting all of its changes.

(fn HANDLE)〉〉enditem49840〈〈active-minibuffer-window〉〉:〈〈Return the currently active minibuffer window, or nil if none.

(fn)〉〉enditem49840〈〈minibuffer-window〉〉:〈〈Return the minibuffer window for frame FRAME.
If FRAME is omitted or nil, it defaults to the selected frame.

(fn &optional FRAME)〉〉enditem49840〈〈set-minibuffer-window〉〉:〈〈Specify which minibuffer window to use for the minibuffer.
This affects where the minibuffer is displayed if you put text in it
without invoking the usual minibuffer commands.

(fn WINDOW)〉〉enditem49840〈〈window-minibuffer-p〉〉:〈〈Return non-nil if WINDOW is a minibuffer window.
WINDOW must be a valid window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈minibuffer-window-active-p〉〉:〈〈Return t if WINDOW is the currently active minibuffer window.

(fn WINDOW)〉〉enditem49840〈〈define-category〉〉:〈〈Define CATEGORY as a category which is described by DOCSTRING.
CATEGORY should be an ASCII printing character in the range ‘ ’ to ‘~’.
DOCSTRING is the documentation string of the category.  The first line
should be a terse text (preferably less than 16 characters),
and the rest lines should be the full description.
The category is defined only in category table TABLE, which defaults to
the current buffer’s category table.

(fn CATEGORY DOCSTRING &optional TABLE)〉〉enditem49840〈〈category-docstring〉〉:〈〈Return the documentation string of CATEGORY, as defined in TABLE.
TABLE should be a category table and defaults to the current buffer’s
category table.

(fn CATEGORY &optional TABLE)〉〉enditem49840〈〈get-unused-category〉〉:〈〈Return a category which is not yet defined in TABLE.
If no category remains available, return nil.
The optional argument TABLE specifies which category table to modify;
it defaults to the current buffer’s category table.

(fn &optional TABLE)〉〉enditem49840〈〈category-table〉〉:〈〈Return the current category table.
This is the one specified by the current buffer.

(fn)〉〉enditem49840〈〈category-table-p〉〉:〈〈Return t if ARG is a category table.

(fn ARG)〉〉enditem49840〈〈standard-category-table〉〉:〈〈Return the standard category table.
This is the one used for new buffers.

(fn)〉〉enditem49840〈〈copy-category-table〉〉:〈〈Construct a new category table and return it.
It is a copy of the TABLE, which defaults to the standard category table.

(fn &optional TABLE)〉〉enditem49840〈〈set-category-table〉〉:〈〈Specify TABLE as the category table for the current buffer.
Return TABLE.

(fn TABLE)〉〉enditem49840〈〈make-category-table〉〉:〈〈Construct a new and empty category table and return it.

(fn)〉〉enditem49840〈〈make-category-set〉〉:〈〈Return a newly created category-set which contains CATEGORIES.
CATEGORIES is a string of category mnemonics.
The value is a bool-vector which has t at the indices corresponding to
those categories.

(fn CATEGORIES)〉〉enditem49840〈〈char-category-set〉〉:〈〈Return the category set of CHAR.

(fn CHAR)〉〉enditem49840〈〈category-set-mnemonics〉〉:〈〈Return a string containing mnemonics of the categories in CATEGORY-SET.
CATEGORY-SET is a bool-vector, and the categories "in" it are those
that are indexes where t occurs in the bool-vector.
The return value is a string containing those same categories.

(fn CATEGORY-SET)〉〉enditem49840〈〈modify-category-entry〉〉:〈〈Modify the category set of CHARACTER by adding CATEGORY to it.
The category is changed only for table TABLE, which defaults to
the current buffer’s category table.
CHARACTER can be either a single character or a cons representing the
lower and upper ends of an inclusive character range to modify.
CATEGORY must be a category name (a character between ‘ ’ and ‘~’).
Use ‘describe-categories’ to see existing category names.
If optional fourth argument RESET is non-nil,
then delete CATEGORY from the category set instead of adding it.

(fn CHARACTER CATEGORY &optional TABLE RESET)〉〉enditem49840〈〈memory-limit〉〉:〈〈Return the address of the last byte Emacs has allocated, divided by 1024.
This may be helpful in debugging Emacs’s memory usage.
We divide the value by 1024 to make sure it fits in a Lisp integer.

(fn)〉〉enditem49840〈〈memory-use-counts〉〉:〈〈Return a list of counters that measure how much consing there has been.
Each of these counters increments for a certain kind of object.
The counters wrap around from the largest positive integer to zero.
Garbage collection does not decrease them.
The elements of the value are as follows:
  (CONSES FLOATS VECTOR-CELLS SYMBOLS STRING-CHARS MISCS INTERVALS STRINGS)
All are in units of 1 = one object consed
except for VECTOR-CELLS and STRING-CHARS, which count the total length of
objects consed.
MISCS include overlays, markers, and some internal types.
Frames, windows, buffers, and subprocesses count as vectors
  (but the contents of a buffer’s text do not count here).

(fn)〉〉enditem49840〈〈memory-info〉〉:〈〈Return a list of (TOTAL-RAM FREE-RAM TOTAL-SWAP FREE-SWAP).
All values are in Kbytes.  If there is no swap space,
last two values are zero.  If the system is not supported
or memory information can’t be obtained, return nil.

(fn)〉〉enditem49840〈〈lookup-key〉〉:〈〈In keymap KEYMAP, look up key sequence KEY.  Return the definition.
A value of nil means undefined.  See doc of ‘define-key’
for kinds of definitions.

A number as value means KEY is "too long";
that is, characters or symbols in it except for the last one
fail to be a valid sequence of prefix characters in KEYMAP.
The number is how many characters at the front of KEY
it takes to reach a non-prefix key.

Normally, ‘lookup-key’ ignores bindings for t, which act as default
bindings, used when nothing else in the keymap applies; this makes it
usable as a general function for probing keymaps.  However, if the
third optional argument ACCEPT-DEFAULT is non-nil, ‘lookup-key’ will
recognize the default bindings, just as ‘read-key-sequence’ does.

(fn KEYMAP KEY &optional ACCEPT-DEFAULT)〉〉enditem49840〈〈local-key-binding〉〉:〈〈Return the binding for command KEYS in current local keymap only.
KEYS is a string or vector, a sequence of keystrokes.
The binding is probably a symbol with a function definition.

If optional argument ACCEPT-DEFAULT is non-nil, recognize default
bindings; see the description of ‘lookup-key’ for more details about this.

(fn KEYS &optional ACCEPT-DEFAULT)〉〉enditem49840〈〈global-key-binding〉〉:〈〈Return the binding for command KEYS in current global keymap only.
KEYS is a string or vector, a sequence of keystrokes.
The binding is probably a symbol with a function definition.
This function’s return values are the same as those of ‘lookup-key’
(which see).

If optional argument ACCEPT-DEFAULT is non-nil, recognize default
bindings; see the description of ‘lookup-key’ for more details about this.

(fn KEYS &optional ACCEPT-DEFAULT)〉〉enditem49840〈〈minor-mode-key-binding〉〉:〈〈Find the visible minor mode bindings of KEY.
Return an alist of pairs (MODENAME . BINDING), where MODENAME is
the symbol which names the minor mode binding KEY, and BINDING is
KEY’s definition in that mode.  In particular, if KEY has no
minor-mode bindings, return nil.  If the first binding is a
non-prefix, all subsequent bindings will be omitted, since they would
be ignored.  Similarly, the list doesn’t include non-prefix bindings
that come after prefix bindings.

If optional argument ACCEPT-DEFAULT is non-nil, recognize default
bindings; see the description of ‘lookup-key’ for more details about this.

(fn KEY &optional ACCEPT-DEFAULT)〉〉enditem49840〈〈user-ptrp〉〉:〈〈Return t if OBJECT is a module user pointer.

(fn OBJECT)〉〉enditem49840〈〈gui-get-selection〉〉:〈〈Return the value of an X Windows selection.
The argument TYPE (default ‘PRIMARY’) says which selection,
and the argument DATA-TYPE (default ‘STRING’) says
how to convert the data.

TYPE may be any symbol (but nil stands for ‘PRIMARY’).  However,
only a few symbols are commonly used.  They conventionally have
all upper-case names.  The most often used ones, in addition to
‘PRIMARY’, are ‘SECONDARY’ and ‘CLIPBOARD’.

DATA-TYPE is usually ‘STRING’, but can also be one of the symbols
in ‘selection-converter-alist’, which see.  Window systems other
than X usually support only a small subset of these symbols, in
addition to ‘STRING’; MS-Windows supports ‘TARGETS’, which reports
the formats available in the clipboard if TYPE is ‘CLIPBOARD’.

(fn &optional TYPE DATA-TYPE)〉〉enditem49840〈〈point〉〉:〈〈Return value of point, as an integer.
Beginning of buffer is position (point-min).

(fn)〉〉enditem49840〈〈point-min〉〉:〈〈Return the minimum permissible value of point in the current buffer.
This is 1, unless narrowing (a buffer restriction) is in effect.

(fn)〉〉enditem49840〈〈point-max〉〉:〈〈Return the maximum permissible value of point in the current buffer.
This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
is in effect, in which case it is less.

(fn)〉〉enditem49840〈〈buffer-end〉〉:〈〈Return the "far end" position of the buffer, in direction ARG.
If ARG is positive, that’s the end of the buffer.
Otherwise, that’s the beginning of the buffer.

(fn ARG)〉〉enditem49840〈〈buffer-size〉〉:〈〈Return the number of characters in the current buffer.
If BUFFER is not nil, return the number of characters in that buffer
instead.

This does not take narrowing into account; to count the number of
characters in the accessible portion of the current buffer, use
‘(- (point-max) (point-min))’, and to count the number of characters
in some other BUFFER, use
‘(with-current-buffer BUFFER (- (point-max) (point-min)))’.

(fn &optional BUFFER)〉〉enditem49840〈〈add-to-history〉〉:〈〈Add NEWELT to the history list stored in the variable HISTORY-VAR.
Return the new history list.
If MAXELT is non-nil, it specifies the maximum length of the history.
Otherwise, the maximum history length is the value of the ‘history-length’
property on symbol HISTORY-VAR, if set, or the value of the ‘history-length’
variable.  The possible values of maximum length have the same meaning as
the values of ‘history-length’.
Remove duplicates of NEWELT if ‘history-delete-duplicates’ is non-nil.
If optional fourth arg KEEP-ALL is non-nil, add NEWELT to history even
if it is empty or a duplicate.

(fn HISTORY-VAR NEWELT &optional MAXELT KEEP-ALL)〉〉enditem49840〈〈car〉〉:〈〈Return the car of LIST.  If arg is nil, return nil.
Error if arg is not nil and not a cons cell.  See also ‘car-safe’.

See Info node ‘(elisp)Cons Cells’ for a discussion of related basic
Lisp concepts such as car, cdr, cons cell and list.

(fn LIST)〉〉enditem49840〈〈cdr〉〉:〈〈Return the cdr of LIST.  If arg is nil, return nil.
Error if arg is not nil and not a cons cell.  See also ‘cdr-safe’.

See Info node ‘(elisp)Cons Cells’ for a discussion of related basic
Lisp concepts such as cdr, car, cons cell and list.

(fn LIST)〉〉enditem49840〈〈car-safe〉〉:〈〈Return the car of OBJECT if it is a cons cell, or else nil.

(fn OBJECT)〉〉enditem49840〈〈cdr-safe〉〉:〈〈Return the cdr of OBJECT if it is a cons cell, or else nil.

(fn OBJECT)〉〉enditem49840〈〈nth〉〉:〈〈Return the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned.

(fn N LIST)〉〉enditem49840〈〈nthcdr〉〉:〈〈Take cdr N times on LIST, return the result.

(fn N LIST)〉〉enditem49840〈〈last〉〉:〈〈Return the last link of LIST.  Its car is the last element.
If LIST is nil, return nil.
If N is non-nil, return the Nth-to-last link of LIST.
If N is bigger than the length of LIST, return LIST.

(fn LIST &optional N)〉〉enditem49840〈〈safe-length〉〉:〈〈Return the length of a list, but avoid error or infinite loop.
This function never gets an error.  If LIST is not really a list,
it returns 0.  If LIST is circular, it returns a finite value
which is at least the number of distinct elements.

(fn LIST)〉〉enditem49840〈〈caar〉〉:〈〈Return the car of the car of X.

(fn X)〉〉enditem49840〈〈cadr〉〉:〈〈Return the car of the cdr of X.

(fn X)〉〉enditem49840〈〈cdar〉〉:〈〈Return the cdr of the car of X.

(fn X)〉〉enditem49840〈〈cddr〉〉:〈〈Return the cdr of the cdr of X.

(fn X)〉〉enditem49840〈〈butlast〉〉:〈〈Return a copy of LIST with the last N elements removed.
If N is omitted or nil, the last element is removed from the
copy.

(fn LIST &optional N)〉〉enditem49840〈〈nbutlast〉〉:〈〈Modifies LIST to remove the last N elements.
If N is omitted or nil, remove the last element.

(fn LIST &optional N)〉〉enditem49840〈〈macroexpand〉〉:〈〈Return result of expanding macros at top level of FORM.
If FORM is not a macro call, it is returned unchanged.
Otherwise, the macro is expanded and the expansion is considered
in place of FORM.  When a non-macro-call results, it is returned.

The second optional arg ENVIRONMENT specifies an environment of macro
definitions to shadow the loaded ones for use in file byte-compilation.

(fn FORM &optional ENVIRONMENT)〉〉enditem49840〈〈macroexpand-all〉〉:〈〈Return result of expanding macros at all levels in FORM.
If no macros are expanded, FORM is returned unchanged.
The second optional arg ENVIRONMENT specifies an environment of macro
definitions to shadow the loaded ones for use in file byte-compilation.

(fn FORM &optional ENVIRONMENT)〉〉enditem49840〈〈string-to-syntax〉〉:〈〈Convert a syntax descriptor STRING into a raw syntax descriptor.
STRING should be a string of the form allowed as argument of
‘modify-syntax-entry’.  The return value is a raw syntax descriptor: a
cons cell (CODE . MATCHING-CHAR) which can be used, for example, as
the value of a ‘syntax-table’ text property.

(fn STRING)〉〉enditem49840〈〈syntax-after〉〉:〈〈Return the raw syntax descriptor for the char after POS.
If POS is outside the buffer’s accessible portion, return nil.

(fn POS)〉〉enditem49840〈〈syntax-class〉〉:〈〈Return the code for the syntax class described by SYNTAX.

SYNTAX should be a raw syntax descriptor; the return value is a
integer which encodes the corresponding syntax class.  See Info
node ‘(elisp)Syntax Table Internals’ for a list of codes.

If SYNTAX is nil, return nil.

(fn SYNTAX)〉〉enditem49840〈〈make-finalizer〉〉:〈〈Make a finalizer that will run FUNCTION.
FUNCTION will be called after garbage collection when the returned
finalizer object becomes unreachable.  If the finalizer object is
reachable only through references from finalizer objects, it does not
count as reachable for the purpose of deciding whether to run
FUNCTION.  FUNCTION will be run once per finalizer object.

(fn FUNCTION)〉〉enditem49840〈〈unsafep〉〉:〈〈Return nil if evaluating FORM couldn’t possibly do any harm.
Otherwise result is a reason why FORM is unsafe.
UNSAFEP-VARS is a list of symbols with local bindings.

(fn FORM &optional UNSAFEP-VARS)〉〉enditem49840〈〈set-buffer-multibyte〉〉:〈〈Set the multibyte flag of the current buffer to FLAG.
If FLAG is t, this makes the buffer a multibyte buffer.
If FLAG is nil, this makes the buffer a single-byte buffer.
In these cases, the buffer contents remain unchanged as a sequence of
bytes but the contents viewed as characters do change.
If FLAG is ‘to’, this makes the buffer a multibyte buffer by changing
all eight-bit bytes to eight-bit characters.
If the multibyte flag was really changed, undo information of the
current buffer is cleared.

(fn FLAG)〉〉enditem49840〈〈string-as-unibyte〉〉:〈〈Return a unibyte string with the same individual bytes as STRING.
If STRING is unibyte, the result is STRING itself.
Otherwise it is a newly created string, with no text properties.
If STRING is multibyte and contains a character of charset
‘eight-bit’, it is converted to the corresponding single byte.

(fn STRING)〉〉enditem49840〈〈string-as-multibyte〉〉:〈〈Return a multibyte string with the same individual bytes as STRING.
If STRING is multibyte, the result is STRING itself.
Otherwise it is a newly created string, with no text properties.

If STRING is unibyte and contains an individual 8-bit byte (i.e. not
part of a correct utf-8 sequence), it is converted to the corresponding
multibyte character of charset ‘eight-bit’.
See also ‘string-to-multibyte’.

Beware, this often doesn’t really do what you think it does.
It is similar to (decode-coding-string STRING 'utf-8-emacs).
If you’re not sure, whether to use ‘string-as-multibyte’ or
‘string-to-multibyte’, use ‘string-to-multibyte’.

(fn STRING)〉〉enditem49840〈〈tabulated-list-init-header〉〉:〈〈Set up header line for the Tabulated List buffer.〉〉enditem49840〈〈tabulated-list-print〉〉:〈〈Populate the current Tabulated List mode buffer.
This sorts the ‘tabulated-list-entries’ list if sorting is
specified by ‘tabulated-list-sort-key’.  It then erases the
buffer and inserts the entries with ‘tabulated-list-printer’.

Optional argument REMEMBER-POS, if non-nil, means to move point
to the entry with the same ID element as the current line and
recenter window line accordingly.

Non-nil UPDATE argument means to use an alternative printing
method which is faster if most entries haven’t changed since the
last print.  The only difference in outcome is that tags will not
be removed from entries that haven’t changed (see
‘tabulated-list-put-tag’).  Don’t use this immediately after
changing ‘tabulated-list-sort-key’.

(fn &optional REMEMBER-POS UPDATE)〉〉enditem49840〈〈ffloor〉〉:〈〈Return the largest integer no greater than ARG, as a float.
(Round toward -inf.)

(fn ARG)〉〉enditem49840〈〈fceiling〉〉:〈〈Return the smallest integer no less than ARG, as a float.
(Round toward +inf.)

(fn ARG)〉〉enditem49840〈〈ftruncate〉〉:〈〈Truncate a floating point number to an integral float value.
(Round toward zero.)

(fn ARG)〉〉enditem49840〈〈fround〉〉:〈〈Return the nearest integer to ARG, as a float.

(fn ARG)〉〉enditem49840〈〈assoc〉〉:〈〈Return non-nil if KEY is equal to the car of an element of LIST.
The value is actually the first element of LIST whose car equals KEY.

Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.

(fn KEY LIST &optional TESTFN)〉〉enditem49840〈〈rassoc〉〉:〈〈Return non-nil if KEY is ‘equal’ to the cdr of an element of LIST.
The value is actually the first element of LIST whose cdr equals KEY.

(fn KEY LIST)〉〉enditem49840〈〈assq〉〉:〈〈Return non-nil if KEY is ‘eq’ to the car of an element of LIST.
The value is actually the first element of LIST whose car is KEY.
Elements of LIST that are not conses are ignored.

(fn KEY LIST)〉〉enditem49840〈〈alist-get〉〉:〈〈Return the value associated with KEY in ALIST.
If KEY is not found in ALIST, return DEFAULT.
Use TESTFN to lookup in the alist if non-nil.  Otherwise, use ‘assq’.

This is a generalized variable suitable for use with ‘setf’.
When using it to set a value, optional argument REMOVE non-nil
means to remove KEY from ALIST if the new value is ‘eql’ to DEFAULT.

(fn KEY ALIST &optional DEFAULT REMOVE TESTFN)〉〉enditem49840〈〈rassq〉〉:〈〈Return non-nil if KEY is ‘eq’ to the cdr of an element of LIST.
The value is actually the first element of LIST whose cdr is KEY.

(fn KEY LIST)〉〉enditem49840〈〈assoc-default〉〉:〈〈Find object KEY in a pseudo-alist ALIST.
ALIST is a list of conses or objects.  Each element
 (or the element’s car, if it is a cons) is compared with KEY by
 calling TEST, with two arguments: (i) the element or its car,
 and (ii) KEY.
If that is non-nil, the element matches; then ‘assoc-default’
 returns the element’s cdr, if it is a cons, or DEFAULT if the
 element is not a cons.

If no element matches, the value is nil.
If TEST is omitted or nil, ‘equal’ is used.

(fn KEY ALIST &optional TEST DEFAULT)〉〉enditem49840〈〈copy-alist〉〉:〈〈Return a copy of ALIST.
This is an alist which represents the same mapping from objects to objects,
but does not share the alist structure with ALIST.
The objects mapped (cars and cdrs of elements of the alist)
are shared, however.
Elements of ALIST that are not conses are also shared.

(fn ALIST)〉〉enditem49840〈〈assq-delete-all〉〉:〈〈Delete from ALIST all elements whose car is ‘eq’ to KEY.
Return the modified alist.
Elements of ALIST that are not conses are ignored.

(fn KEY ALIST)〉〉enditem49840〈〈rassq-delete-all〉〉:〈〈Delete from ALIST all elements whose cdr is ‘eq’ to VALUE.
Return the modified alist.
Elements of ALIST that are not conses are ignored.

(fn VALUE ALIST)〉〉enditem49840〈〈make-serial-process〉〉:〈〈Create and return a serial port process.

In Emacs, serial port connections are represented by process objects,
so input and output work as for subprocesses, and ‘delete-process’
closes a serial port connection.  However, a serial process has no
process id, it cannot be signaled, and the status codes are different
from normal processes.

‘make-serial-process’ creates a process and a buffer, on which you
probably want to use ‘process-send-string’.  Try M-x serial-term for
an interactive terminal.  See below for examples.

Arguments are specified as keyword/argument pairs.  The following
arguments are defined:

:port PORT -- (mandatory) PORT is the path or name of the serial port.
For example, this could be "/dev/ttyS0" on Unix.  On Windows, this
could be "COM1", or "\\.\COM10" for ports higher than COM9 (double
the backslashes in strings).

:speed SPEED -- (mandatory) is handled by ‘serial-process-configure’,
which this function calls.

:name NAME -- NAME is the name of the process.  If NAME is not given,
the value of PORT is used.

:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
with the process.  Process output goes at the end of that buffer,
unless you specify a filter function to handle the output.  If BUFFER
is not given, the value of NAME is used.

:coding CODING -- If CODING is a symbol, it specifies the coding
system used for both reading and writing for this process.  If CODING
is a cons (DECODING . ENCODING), DECODING is used for reading, and
ENCODING is used for writing.

:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
the process is running.  If BOOL is not given, query before exiting.

:stop BOOL -- Start process in the ‘stopped’ state if BOOL is non-nil.
In the stopped state, a serial process does not accept incoming data,
but you can send outgoing data.  The stopped state is cleared by
‘continue-process’ and set by ‘stop-process’.

:filter FILTER -- Install FILTER as the process filter.

:sentinel SENTINEL -- Install SENTINEL as the process sentinel.

:plist PLIST -- Install PLIST as the initial plist of the process.

:bytesize
:parity
:stopbits
:flowcontrol
-- This function calls ‘serial-process-configure’ to handle these
arguments.

The original argument list, possibly modified by later configuration,
is available via the function ‘process-contact’.

Examples:

(make-serial-process :port "/dev/ttyS0" :speed 9600)

(make-serial-process :port "COM1" :speed 115200 :stopbits 2)

(make-serial-process :port "\\.\COM13" :speed 1200 :bytesize 7 :parity 'odd)

(make-serial-process :port "/dev/tty.BlueConsole-SPP-1" :speed nil)

(fn &rest ARGS)〉〉enditem49840〈〈serial-process-configure〉〉:〈〈Configure speed, bytesize, etc. of a serial process.

Arguments are specified as keyword/argument pairs.  Attributes that
are not given are re-initialized from the process’s current
configuration (available via the function ‘process-contact’) or set to
reasonable default values.  The following arguments are defined:

:process PROCESS
:name NAME
:buffer BUFFER
:port PORT
-- Any of these arguments can be given to identify the process that is
to be configured.  If none of these arguments is given, the current
buffer’s process is used.

:speed SPEED -- SPEED is the speed of the serial port in bits per
second, also called baud rate.  Any value can be given for SPEED, but
most serial ports work only at a few defined values between 1200 and
115200, with 9600 being the most common value.  If SPEED is nil, the
serial port is not configured any further, i.e., all other arguments
are ignored.  This may be useful for special serial ports such as
Bluetooth-to-serial converters which can only be configured through AT
commands.  A value of nil for SPEED can be used only when passed
through ‘make-serial-process’ or ‘serial-term’.

:bytesize BYTESIZE -- BYTESIZE is the number of bits per byte, which
can be 7 or 8.  If BYTESIZE is not given or nil, a value of 8 is used.

:parity PARITY -- PARITY can be nil (don’t use parity), the symbol
‘odd’ (use odd parity), or the symbol ‘even’ (use even parity).  If
PARITY is not given, no parity is used.

:stopbits STOPBITS -- STOPBITS is the number of stopbits used to
terminate a byte transmission.  STOPBITS can be 1 or 2.  If STOPBITS
is not given or nil, 1 stopbit is used.

:flowcontrol FLOWCONTROL -- FLOWCONTROL determines the type of
flowcontrol to be used, which is either nil (don’t use flowcontrol),
the symbol ‘hw’ (use RTS/CTS hardware flowcontrol), or the symbol ‘sw’
(use XON/XOFF software flowcontrol).  If FLOWCONTROL is not given, no
flowcontrol is used.

‘serial-process-configure’ is called by ‘make-serial-process’ for the
initial configuration of the serial port.

Examples:

(serial-process-configure :process "/dev/ttyS0" :speed 1200)

(serial-process-configure
    :buffer "COM1" :stopbits 1 :parity 'odd :flowcontrol 'hw)

(serial-process-configure :port "\\.\COM13" :bytesize 7)

(fn &rest ARGS)〉〉enditem49840〈〈make-temp-file〉〉:〈〈Create a temporary file.
The returned file name (created by appending some random characters at the end
of PREFIX, and expanding against ‘temporary-file-directory’ if necessary),
is guaranteed to point to a newly created file.
You can then use ‘write-region’ to write new data into the file.

If DIR-FLAG is non-nil, create a new empty directory instead of a file.

If SUFFIX is non-nil, add that at the end of the file name.

If TEXT is a string, insert it into the new file; DIR-FLAG should be nil.
Otherwise the file will be empty.

(fn PREFIX &optional DIR-FLAG SUFFIX TEXT)〉〉enditem49840〈〈make-temp-name〉〉:〈〈Generate temporary file name (string) starting with PREFIX (a string).

This function tries to choose a name that has no existing file.
For this to work, PREFIX should be an absolute file name, and PREFIX
and the returned string should both be non-magic.

There is a race condition between calling ‘make-temp-name’ and
later creating the file, which opens all kinds of security holes.
For that reason, you should normally use ‘make-temp-file’ instead.

(fn PREFIX)〉〉enditem49840〈〈current-time-zone〉〉:〈〈Return the offset and name for the local time zone.
This returns a list of the form (OFFSET NAME).
OFFSET is an integer number of seconds ahead of UTC (east of Greenwich).
    A negative value means west of Greenwich.
NAME is a string giving the name of the time zone.
If SPECIFIED-TIME is given, the time zone offset is determined from it
instead of using the current time.  The argument should have the form
(HIGH LOW . IGNORED).  Thus, you can use times obtained from
‘current-time’ and from ‘file-attributes’.  SPECIFIED-TIME can also be
a single integer number of seconds since the epoch.  The obsolete form
(HIGH . LOW) is also still accepted.

The optional ZONE is omitted or nil for Emacs local time, t for
Universal Time, ‘wall’ for system wall clock time, or a string as in
the TZ environment variable.  It can also be a list (as from
‘current-time-zone’) or an integer (as from ‘decode-time’) applied
without consideration for daylight saving time.

Some operating systems cannot provide all this information to Emacs;
in this case, ‘current-time-zone’ returns a list containing nil for
the data it can’t find.

(fn &optional SPECIFIED-TIME ZONE)〉〉enditem49840〈〈key-description〉〉:〈〈Return a pretty description of key-sequence KEYS.
Optional arg PREFIX is the sequence of keys leading up to KEYS.
For example, [?C-x ?l] is converted into the string "C-x l".

For an approximate inverse of this, see ‘kbd’.

(fn KEYS &optional PREFIX)〉〉enditem49840〈〈single-key-description〉〉:〈〈Return a pretty description of command character KEY.
Control characters turn into C-whatever, etc.
Optional argument NO-ANGLES non-nil means don’t put angle brackets
around function keys and event symbols.

(fn KEY &optional NO-ANGLES)〉〉enditem49840〈〈text-char-description〉〉:〈〈Return a pretty description of file-character CHARACTER.
Control characters turn into "^char", etc.  This differs from
‘single-key-description’ which turns them into "C-char".
Also, this function recognizes the 2**7 bit as the Meta character,
whereas ‘single-key-description’ uses the 2**27 bit for Meta.
See Info node ‘(elisp)Describing Characters’ for examples.

(fn CHARACTER)〉〉enditem49840〈〈vectorp〉〉:〈〈Return t if OBJECT is a vector.

(fn OBJECT)〉〉enditem49840〈〈vector〉〉:〈〈Return a newly created vector with specified arguments as elements.
Any number of arguments, even zero arguments, are allowed.

(fn &rest OBJECTS)〉〉enditem49840〈〈make-vector〉〉:〈〈Return a newly created vector of length LENGTH, with each element being INIT.
See also the function ‘vector’.

(fn LENGTH INIT)〉〉enditem49840〈〈vconcat〉〉:〈〈Concatenate all the arguments and make the result a vector.
The result is a vector whose elements are the elements of all the arguments.
Each argument may be a list, vector or string.

(fn &rest SEQUENCES)〉〉enditem49840〈〈create-file-buffer〉〉:〈〈:around advice: ‘uniquify--create-file-buffer-advice’

Create a suitably named buffer for visiting FILENAME, and return it.
FILENAME (sans directory) is used unchanged if that name is free;
otherwise a string <2> or <3> or ... is appended to get an unused name.

Emacs treats buffers whose names begin with a space as internal buffers.
To avoid confusion when visiting a file whose name begins with a space,
this function prepends a "|" to the final result if necessary.

(fn FILENAME)〉〉enditem49840〈〈after-find-file〉〉:〈〈Called after finding a file and by the default revert function.
Sets buffer mode, parses local variables.
Optional args ERROR, WARN, and NOAUTO: ERROR non-nil means there was an
error in reading the file.  WARN non-nil means warn if there
exists an auto-save file more recent than the visited file.
NOAUTO means don’t mess with auto-save mode.
Fourth arg AFTER-FIND-FILE-FROM-REVERT-BUFFER is ignored
(see ‘revert-buffer-in-progress-p’ for similar functionality).
Fifth arg NOMODES non-nil means don’t alter the file’s modes.
Finishes by calling the functions in ‘find-file-hook’
unless NOMODES is non-nil.

(fn &optional ERROR WARN NOAUTO AFTER-FIND-FILE-FROM-REVERT-BUFFER NOMODES)〉〉enditem49840〈〈buffer-live-p〉〉:〈〈Return non-nil if OBJECT is a buffer which has not been killed.
Value is nil if OBJECT is not a buffer or if it has been killed.

(fn OBJECT)〉〉enditem49840〈〈transpose-regions〉〉:〈〈Transpose region STARTR1 to ENDR1 with STARTR2 to ENDR2.
The regions should not be overlapping, because the size of the buffer is
never changed in a transposition.

Optional fifth arg LEAVE-MARKERS, if non-nil, means don’t update
any markers that happen to be located in the regions.

Transposing beyond buffer boundaries is an error.

(fn STARTR1 ENDR1 STARTR2 ENDR2 &optional LEAVE-MARKERS)〉〉enditem49840〈〈number-to-string〉〉:〈〈Return the decimal representation of NUMBER as a string.
Uses a minus sign if negative.
NUMBER may be an integer or a floating point number.

(fn NUMBER)〉〉enditem49840〈〈string-to-number〉〉:〈〈Parse STRING as a decimal number and return the number.
Ignore leading spaces and tabs, and all trailing chars.  Return 0 if
STRING cannot be parsed as an integer or floating point number.

If BASE, interpret STRING as a number in that base.  If BASE isn’t
present, base 10 is used.  BASE must be between 2 and 16 (inclusive).
If the base used is not 10, STRING is always parsed as an integer.

(fn STRING &optional BASE)〉〉enditem49840〈〈char-to-string〉〉:〈〈Convert arg CHAR to a string containing that character.

(fn CHAR)〉〉enditem49840〈〈string-to-char〉〉:〈〈Return the first character in STRING.

(fn STRING)〉〉enditem49840〈〈makunbound〉〉:〈〈Make SYMBOL’s value be void.
Return SYMBOL.

(fn SYMBOL)〉〉enditem49840〈〈boundp〉〉:〈〈Return t if SYMBOL’s value is not void.
Note that if ‘lexical-binding’ is in effect, this refers to the
global value outside of any lexical scope.

(fn SYMBOL)〉〉enditem49840〈〈consp〉〉:〈〈Return t if OBJECT is a cons cell.

(fn OBJECT)〉〉enditem49840〈〈atom〉〉:〈〈Return t if OBJECT is not a cons cell.  This includes nil.

(fn OBJECT)〉〉enditem49840〈〈listp〉〉:〈〈Return t if OBJECT is a list, that is, a cons cell or nil.
Otherwise, return nil.

(fn OBJECT)〉〉enditem49840〈〈nlistp〉〉:〈〈Return t if OBJECT is not a list.  Lists include nil.

(fn OBJECT)〉〉enditem49840〈〈null〉〉:〈〈Return t if OBJECT is nil, and return nil otherwise.

(fn OBJECT)〉〉enditem49840〈〈buffer-base-buffer〉〉:〈〈Return the base buffer of indirect buffer BUFFER.
If BUFFER is not indirect, return nil.
BUFFER defaults to the current buffer.

(fn &optional BUFFER)〉〉enditem49840〈〈charsetp〉〉:〈〈Return non-nil if and only if OBJECT is a charset.

(fn OBJECT)〉〉enditem49840〈〈charset-priority-list〉〉:〈〈Return the list of charsets ordered by priority.
HIGHESTP non-nil means just return the highest priority one.

(fn &optional HIGHESTP)〉〉enditem49840〈〈set-charset-priority〉〉:〈〈Assign higher priority to the charsets given as arguments.

(fn &rest charsets)〉〉enditem49840〈〈char-charset〉〉:〈〈Return the charset of highest priority that contains CH.
ASCII characters are an exception: for them, this function always
returns ‘ascii’.
If optional 2nd arg RESTRICTION is non-nil, it is a list of charsets
from which to find the charset.  It may also be a coding system.  In
that case, find the charset from what supported by that coding system.

(fn CH &optional RESTRICTION)〉〉enditem49840〈〈charset-plist〉〉:〈〈Return the property list of CHARSET.

(fn CHARSET)〉〉enditem49840〈〈put-charset-property〉〉:〈〈Set CHARSETS’s PROPNAME property to value VALUE.
It can be retrieved with ‘(get-charset-property CHARSET PROPNAME)’.〉〉enditem49840〈〈get-charset-property〉〉:〈〈Return the value of CHARSET’s PROPNAME property.
This is the last value stored with
 (put-charset-property CHARSET PROPNAME VALUE).〉〉enditem49840〈〈decode-char〉〉:〈〈Decode the pair of CHARSET and CODE-POINT into a character.
Return nil if CODE-POINT is not valid in CHARSET.

CODE-POINT may be a cons (HIGHER-16-BIT-VALUE . LOWER-16-BIT-VALUE).

(fn CHARSET CODE-POINT)〉〉enditem49840〈〈encode-char〉〉:〈〈Encode the character CH into a code-point of CHARSET.
Return nil if CHARSET doesn’t include CH.

(fn CH CHARSET)〉〉enditem49840〈〈map-charset-chars〉〉:〈〈Call FUNCTION for all characters in CHARSET.
FUNCTION is called with an argument RANGE and the optional 3rd
argument ARG.

RANGE is a cons (FROM .  TO), where FROM and TO indicate a range of
characters contained in CHARSET.

The optional 4th and 5th arguments FROM-CODE and TO-CODE specify the
range of code points (in CHARSET) of target characters.

(fn FUNCTION CHARSET &optional ARG FROM-CODE TO-CODE)〉〉enditem49840〈〈x-list-fonts〉〉:〈〈Return a list of the names of available fonts matching PATTERN.
If optional arguments FACE and FRAME are specified, return only fonts
the same size as FACE on FRAME.

PATTERN should be a string containing a font name in the XLFD,
Fontconfig, or GTK format.  A font name given in the XLFD format may
contain wildcard characters:
  the * character matches any substring, and
  the ? character matches any single character.
  PATTERN is case-insensitive.

The return value is a list of strings, suitable as arguments to
‘set-face-font’.

Fonts Emacs can’t use may or may not be excluded
even if they match PATTERN and FACE.
The optional fourth argument MAXIMUM sets a limit on how many
fonts to match.  The first MAXIMUM fonts are reported.
The optional fifth argument WIDTH, if specified, is a number of columns
occupied by a character of a font.  In that case, return only fonts
the WIDTH times as wide as FACE on FRAME.

(fn PATTERN &optional FACE FRAME MAXIMUM WIDTH)〉〉enditem49840〈〈x-family-fonts〉〉:〈〈Return a list of available fonts of family FAMILY on FRAME.
If FAMILY is omitted or nil, list all families.
Otherwise, FAMILY must be a string, possibly containing wildcards
‘?’ and ‘*’.
If FRAME is omitted or nil, use the selected frame.
Each element of the result is a vector [FAMILY WIDTH POINT-SIZE WEIGHT
SLANT FIXED-P FULL REGISTRY-AND-ENCODING].
FAMILY is the font family name.  POINT-SIZE is the size of the
font in 1/10 pt.  WIDTH, WEIGHT, and SLANT are symbols describing the
width, weight and slant of the font.  These symbols are the same as for
face attributes.  FIXED-P is non-nil if the font is fixed-pitch.
FULL is the full name of the font, and REGISTRY-AND-ENCODING is a string
giving the registry and encoding of the font.
The result list is sorted according to the current setting of
the face font sort order.

(fn &optional FAMILY FRAME)〉〉enditem49840〈〈momentary-string-display〉〉:〈〈Momentarily display STRING in the buffer at POS.
Display remains until next event is input.
If POS is a marker, only its position is used; its buffer is ignored.
Optional third arg EXIT-CHAR can be a character, event or event
description list.  EXIT-CHAR defaults to SPC.  If the input is
EXIT-CHAR it is swallowed; otherwise it is then available as
input (as a command if nothing else).
Display MESSAGE (optional fourth arg) in the echo area.
If MESSAGE is nil, instructions to type EXIT-CHAR are displayed there.

(fn STRING POS &optional EXIT-CHAR MESSAGE)〉〉enditem49840〈〈frame-char-height〉〉:〈〈Height in pixels of a line in the font in frame FRAME.
If FRAME is omitted or nil, the selected frame is used.
For a terminal frame, the value is always 1.

(fn &optional FRAME)〉〉enditem49840〈〈frame-char-width〉〉:〈〈Width in pixels of characters in the font in frame FRAME.
If FRAME is omitted or nil, the selected frame is used.
On a graphical screen, the width is the standard width of the default font.
For a terminal screen, the value is always 1.

(fn &optional FRAME)〉〉enditem49840〈〈abbrev-symbol〉〉:〈〈Return the symbol representing abbrev named ABBREV.
This symbol’s name is ABBREV, but it is not the canonical symbol of that name;
it is interned in an abbrev-table rather than the normal obarray.
The value is nil if that abbrev is not defined.
Optional second arg TABLE is abbrev table to look it up in.
The default is to try buffer’s mode-specific abbrev table, then global table.

(fn ABBREV &optional TABLE)〉〉enditem49840〈〈abbrev-expansion〉〉:〈〈Return the string that ABBREV expands into in the current buffer.
Optionally specify an abbrev table as second arg;
then ABBREV is looked up in that table only.

(fn ABBREV &optional TABLE)〉〉enditem49840〈〈abbrev-insert〉〉:〈〈Insert abbrev ABBREV at point.
If non-nil, NAME is the name by which this abbrev was found.
If non-nil, WORDSTART is the place where to insert the abbrev.
If WORDEND is non-nil, the abbrev replaces the previous text between
WORDSTART and WORDEND.
Return ABBREV if the expansion should be considered as having taken place.
The return value can be influenced by a ‘no-self-insert’ property;
see ‘define-abbrev’ for details.

(fn ABBREV &optional NAME WORDSTART WORDEND)〉〉enditem49840〈〈setcdr〉〉:〈〈Set the cdr of CELL to be NEWCDR.  Returns NEWCDR.

(fn CELL NEWCDR)〉〉enditem49840〈〈fill-context-prefix〉〉:〈〈Compute a fill prefix from the text between FROM and TO.
This uses the variables ‘adaptive-fill-regexp’ and ‘adaptive-fill-function’
and ‘adaptive-fill-first-line-regexp’.  ‘paragraph-start’ also plays a role;
we reject a prefix based on a one-line paragraph if that prefix would
act as a paragraph-separator.〉〉enditem49840〈〈position-bytes〉〉:〈〈Return the byte position for character position POSITION.
If POSITION is out of range, the value is nil.

(fn POSITION)〉〉enditem49840〈〈byte-to-position〉〉:〈〈Return the character position for byte position BYTEPOS.
If BYTEPOS is out of range, the value is nil.

(fn BYTEPOS)〉〉enditem49840〈〈bufferpos-to-filepos〉〉:〈〈Try to return the file byte corresponding to a particular buffer POSITION.
Value is the file position given as a (0-based) byte count.
The function presumes the file is encoded with CODING-SYSTEM, which defaults
to ‘buffer-file-coding-system’.
QUALITY can be:
  ‘approximate’, in which case we may cut some corners to avoid
    excessive work.
  ‘exact’, in which case we may end up re-(en/de)coding a large
    part of the file/buffer, this can be expensive and slow.
  nil, in which case we may return nil rather than an approximation.

(fn POSITION &optional QUALITY CODING-SYSTEM)〉〉enditem49840〈〈filepos-to-bufferpos〉〉:〈〈Try to return the buffer position corresponding to a particular file position.
The file position is given as a (0-based) BYTE count.
The function presumes the file is encoded with CODING-SYSTEM, which defaults
to ‘buffer-file-coding-system’.
QUALITY can be:
  ‘approximate’, in which case we may cut some corners to avoid
    excessive work.
  ‘exact’, in which case we may end up re-(en/de)coding a large
    part of the file/buffer, this can be expensive and slow.
  nil, in which case we may return nil rather than an approximation.

(fn BYTE &optional QUALITY CODING-SYSTEM)〉〉enditem49840〈〈multibyte-string-p〉〉:〈〈Return t if OBJECT is a multibyte string.
Return nil if OBJECT is either a unibyte string, or not a string.

(fn OBJECT)〉〉enditem49840〈〈string-bytes〉〉:〈〈Return the number of bytes in STRING.
If STRING is multibyte, this may be greater than the length of STRING.

(fn STRING)〉〉enditem49840〈〈unibyte-string〉〉:〈〈Concatenate all the argument bytes and make the result a unibyte string.

(fn &rest BYTES)〉〉enditem49840〈〈split-window-sensibly〉〉:〈〈Split WINDOW in a way suitable for ‘display-buffer’.
WINDOW defaults to the currently selected window.
If ‘split-height-threshold’ specifies an integer, WINDOW is at
least ‘split-height-threshold’ lines tall and can be split
vertically, split WINDOW into two windows one above the other and
return the lower window.  Otherwise, if ‘split-width-threshold’
specifies an integer, WINDOW is at least ‘split-width-threshold’
columns wide and can be split horizontally, split WINDOW into two
windows side by side and return the window on the right.  If this
can’t be done either and WINDOW is the only window on its frame,
try to split WINDOW vertically disregarding any value specified
by ‘split-height-threshold’.  If that succeeds, return the lower
window.  Return nil otherwise.

By default ‘display-buffer’ routines call this function to split
the largest or least recently used window.  To change the default
customize the option ‘split-window-preferred-function’.

You can enforce this function to not split WINDOW horizontally,
by setting (or binding) the variable ‘split-width-threshold’ to
nil.  If, in addition, you set ‘split-height-threshold’ to zero,
chances increase that this function does split WINDOW vertically.

In order to not split WINDOW vertically, set (or bind) the
variable ‘split-height-threshold’ to nil.  Additionally, you can
set ‘split-width-threshold’ to zero to make a horizontal split
more likely to occur.

Have a look at the function ‘window-splittable-p’ if you want to
know how ‘split-window-sensibly’ determines whether WINDOW can be
split.

(fn &optional WINDOW)〉〉enditem49840〈〈same-window-p〉〉:〈〈Return non-nil if a buffer named BUFFER-NAME would be shown in the "same" window.
This function returns non-nil if ‘display-buffer’ or
‘pop-to-buffer’ would show a buffer named BUFFER-NAME in the
selected rather than (as usual) some other window.  See
‘same-window-buffer-names’ and ‘same-window-regexps’.

(fn BUFFER-NAME)〉〉enditem49840〈〈get-text-property〉〉:〈〈Return the value of POSITION’s property PROP, in OBJECT.
OBJECT should be a buffer or a string; if omitted or nil, it defaults
to the current buffer.
If POSITION is at the end of OBJECT, the value is nil.

(fn POSITION PROP &optional OBJECT)〉〉enditem49840〈〈get-char-property〉〉:〈〈Return the value of POSITION’s property PROP, in OBJECT.
Both overlay properties and text properties are checked.
OBJECT is optional and defaults to the current buffer.
If POSITION is at the end of OBJECT, the value is nil.
If OBJECT is a buffer, then overlay properties are considered as well as
text properties.
If OBJECT is a window, then that window’s buffer is used, but window-specific
overlays are considered only if they are associated with OBJECT.

(fn POSITION PROP &optional OBJECT)〉〉enditem49840〈〈get-pos-property〉〉:〈〈Return the value of POSITION’s property PROP, in OBJECT.
Almost identical to ‘get-char-property’ except for the following difference:
Whereas ‘get-char-property’ returns the property of the char at (i.e. right
after) POSITION, this pays attention to properties’s stickiness and overlays’s
advancement settings, in order to find the property of POSITION itself,
i.e. the property that a char would inherit if it were inserted
at POSITION.

(fn POSITION PROP &optional OBJECT)〉〉enditem49840〈〈get-char-property-and-overlay〉〉:〈〈Like ‘get-char-property’, but with extra overlay information.
The value is a cons cell.  Its car is the return value of ‘get-char-property’
with the same arguments--that is, the value of POSITION’s property
PROP in OBJECT.  Its cdr is the overlay in which the property was
found, or nil, if it was found as a text property or not found at all.

OBJECT is optional and defaults to the current buffer.  OBJECT may be
a string, a buffer or a window.  For strings, the cdr of the return
value is always nil, since strings do not have overlays.  If OBJECT is
a window, then that window’s buffer is used, but window-specific
overlays are considered only if they are associated with OBJECT.  If
POSITION is at the end of OBJECT, both car and cdr are nil.

(fn POSITION PROP &optional OBJECT)〉〉enditem49840〈〈text-properties-at〉〉:〈〈Return the list of properties of the character at POSITION in OBJECT.
If the optional second argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.
If POSITION is at the end of OBJECT, the value is nil.

(fn POSITION &optional OBJECT)〉〉enditem49840〈〈color-defined-p〉〉:〈〈Return non-nil if COLOR is supported on frame FRAME.
COLOR should be a string naming a color (e.g. "white"), or a
string specifying a color’s RGB components (e.g. "#ff12ec"), or
the symbol ‘unspecified’.

This function returns nil if COLOR is the symbol ‘unspecified’,
or one of the strings "unspecified-fg" or "unspecified-bg".

If FRAME is omitted or nil, use the selected frame.

(fn COLOR &optional FRAME)〉〉enditem49840〈〈defined-colors〉〉:〈〈Return a list of colors supported for a particular frame.
The argument FRAME specifies which frame to try.
The value may be different for frames on different display types.
If FRAME doesn’t support colors, the value is nil.
If FRAME is nil, that stands for the selected frame.

(fn &optional FRAME)〉〉enditem49840〈〈color-supported-p〉〉:〈〈Return non-nil if COLOR can be displayed on FRAME.
BACKGROUND-P non-nil means COLOR is used as a background.
Otherwise, this function tells whether it can be used as a foreground.
If FRAME is nil or omitted, use the selected frame.
COLOR must be a valid color name.

(fn COLOR &optional FRAME BACKGROUND-P)〉〉enditem49840〈〈color-gray-p〉〉:〈〈Return non-nil if COLOR is a shade of gray (or white or black).
FRAME specifies the frame and thus the display for interpreting COLOR.
If FRAME is nil or omitted, use the selected frame.

(fn COLOR &optional FRAME)〉〉enditem49840〈〈color-values〉〉:〈〈Return a description of the color named COLOR on frame FRAME.
COLOR should be a string naming a color (e.g. "white"), or a
string specifying a color’s RGB components (e.g. "#ff12ec").

Return a list of three integers, (RED GREEN BLUE), each between 0
and either 65280 or 65535 (the maximum depends on the system).
Use ‘color-name-to-rgb’ if you want RGB floating-point values
normalized to 1.0.

If FRAME is omitted or nil, use the selected frame.
If FRAME cannot display COLOR, the value is nil.

COLOR can also be the symbol ‘unspecified’ or one of the strings
"unspecified-fg" or "unspecified-bg", in which case the
return value is nil.

(fn COLOR &optional FRAME)〉〉enditem49840〈〈scroll-bar-event-ratio〉〉:〈〈Given a scroll bar event EVENT, return the scroll bar position as a ratio.
The value is a cons cell (PORTION . WHOLE) containing two integers
whose ratio gives the event’s vertical position in the scroll bar, with 0
referring to the top and 1 to the bottom.〉〉enditem49840〈〈scroll-bar-scale〉〉:〈〈Given a pair (NUM . DENOM) and WHOLE, return (/ (* NUM WHOLE) DENOM).
This is handy for scaling a position on a scroll bar into real units,
like buffer positions.  If SCROLL-BAR-POS is the (PORTION . WHOLE) pair
from a scroll bar event, then (scroll-bar-scale SCROLL-BAR-POS
(buffer-size)) is the position in the current buffer corresponding to
that scroll bar position.〉〉enditem49840〈〈get-register〉〉:〈〈Return contents of Emacs register named REGISTER, or nil if none.

(fn REGISTER)〉〉enditem49840〈〈set-register〉〉:〈〈Set contents of Emacs register named REGISTER to VALUE.  Returns VALUE.
See the documentation of the variable ‘register-alist’ for possible VALUEs.

(fn REGISTER VALUE)〉〉enditem49840〈〈register-read-with-preview〉〉:〈〈Read and return a register name, possibly showing existing registers.
Prompt with the string PROMPT.  If ‘register-alist’ and
‘register-preview-delay’ are both non-nil, display a window
listing existing registers after ‘register-preview-delay’ seconds.
If ‘help-char’ (or a member of ‘help-event-list’) is pressed,
display such a window regardless.

(fn PROMPT)〉〉enditem49840〈〈button-start〉〉:〈〈Return the position at which BUTTON starts.〉〉enditem49840〈〈button-end〉〉:〈〈Return the position at which BUTTON ends.〉〉enditem49840〈〈button-get〉〉:〈〈Get the property of button BUTTON named PROP.〉〉enditem49840〈〈button-put〉〉:〈〈Set BUTTON’s PROP property to VAL.〉〉enditem49840〈〈button-activate〉〉:〈〈Call BUTTON’s ‘action’ property.
If USE-MOUSE-ACTION is non-nil, invoke the button’s ‘mouse-action’
property instead of ‘action’; if the button has no ‘mouse-action’,
the value of ‘action’ is used instead.

The action can either be a marker or a function.  If it’s a
marker then goto it.  Otherwise if it is a function then it is
called with BUTTON as only argument.  BUTTON is either an
overlay, a buffer position, or (for buttons in the mode-line or
header-line) a string.〉〉enditem49840〈〈button-label〉〉:〈〈Return BUTTON’s text label.〉〉enditem49840〈〈button-type〉〉:〈〈Return BUTTON’s button-type.〉〉enditem49840〈〈button-has-type-p〉〉:〈〈Return t if BUTTON has button-type TYPE, or one of TYPE’s subtypes.〉〉enditem49840〈〈button-at〉〉:〈〈Return the button at position POS in the current buffer, or nil.
If the button at POS is a text property button, the return value
is a marker pointing to POS.〉〉enditem49840〈〈button-type-put〉〉:〈〈Set the button-type TYPE’s PROP property to VAL.〉〉enditem49840〈〈button-type-get〉〉:〈〈Get the property of button-type TYPE named PROP.〉〉enditem49840〈〈button-type-subtype-p〉〉:〈〈Return t if button-type TYPE is a subtype of SUPERTYPE.〉〉enditem49840〈〈buffer-list〉〉:〈〈Return a list of all live buffers.
If the optional arg FRAME is a frame, return the buffer list in the
proper order for that frame: the buffers shown in FRAME come first,
followed by the rest of the buffers.

(fn &optional FRAME)〉〉enditem49840〈〈other-buffer〉〉:〈〈Return most recently selected buffer other than BUFFER.
Buffers not visible in windows are preferred to visible buffers, unless
optional second argument VISIBLE-OK is non-nil.  Ignore the argument
BUFFER unless it denotes a live buffer.  If the optional third argument
FRAME specifies a live frame, then use that frame’s buffer list instead
of the selected frame’s buffer list.

The buffer is found by scanning the selected or specified frame’s buffer
list first, followed by the list of all buffers.  If no other buffer
exists, return the buffer ‘*scratch*’ (creating it if necessary).

(fn &optional BUFFER VISIBLE-OK FRAME)〉〉enditem49840〈〈last-buffer〉〉:〈〈Return the last buffer in FRAME’s buffer list.
If BUFFER is the last buffer, return the preceding buffer
instead.  Buffers not visible in windows are preferred to visible
buffers, unless optional argument VISIBLE-OK is non-nil.
Optional third argument FRAME nil or omitted means use the
selected frame’s buffer list.  If no such buffer exists, return
the buffer ‘*scratch*’, creating it if necessary.

(fn &optional BUFFER VISIBLE-OK FRAME)〉〉enditem49840〈〈current-frame-configuration〉〉:〈〈Return a list describing the positions and states of all frames.
Its car is ‘frame-configuration’.
Each element of the cdr is a list of the form (FRAME ALIST WINDOW-CONFIG),
where
  FRAME is a frame object,
  ALIST is an association list specifying some of FRAME’s parameters, and
  WINDOW-CONFIG is a window configuration object for FRAME.〉〉enditem49840〈〈set-frame-configuration〉〉:〈〈Restore the frames to the state described by CONFIGURATION.
Each frame listed in CONFIGURATION has its position, size, window
configuration, and other parameters set as specified in CONFIGURATION.
However, this function does not restore deleted frames.

Ordinarily, this function deletes all existing frames not
listed in CONFIGURATION.  But if optional second argument NODELETE
is given and non-nil, the unwanted frames are iconified instead.

(fn CONFIGURATION &optional NODELETE)〉〉enditem49840〈〈funcall〉〉:〈〈Call first argument as a function, passing remaining arguments to it.
Return the value that function returns.
Thus, (funcall 'cons 'x 'y) returns (x . y).

(fn FUNCTION &rest ARGUMENTS)〉〉enditem49840〈〈apply〉〉:〈〈Call FUNCTION with our remaining args, using our last arg as list of args.
Then return the value FUNCTION returns.
Thus, (apply '+ 1 2 '(3 4)) returns 10.

(fn FUNCTION &rest ARGUMENTS)〉〉enditem49840〈〈apply-partially〉〉:〈〈Return a function that is a partial application of FUN to ARGS.
ARGS is a list of the first N arguments to pass to FUN.
The result is a new function which does the same as FUN, except that
the first N arguments are fixed at the values with which this function
was called.

(fn FUN &rest ARGS)〉〉enditem49840〈〈identity〉〉:〈〈Return the argument unchanged.

(fn ARG)〉〉enditem49840〈〈ignore〉〉:〈〈Do nothing and return nil.
This function accepts any number of arguments, but ignores them.

(fn &rest IGNORE)〉〉enditem49840〈〈file-name-as-directory〉〉:〈〈Return a string representing the file name FILE interpreted as a directory.
This operation exists because a directory is also a file, but its name as
a directory is different from its name as a file.
The result can be used as the value of ‘default-directory’
or passed as second argument to ‘expand-file-name’.
For a Unix-syntax file name, just appends a slash unless a trailing slash
is already present.

(fn FILE)〉〉enditem49840〈〈directory-name-p〉〉:〈〈Return non-nil if NAME ends with a directory separator character.

(fn NAME)〉〉enditem49840〈〈directory-file-name〉〉:〈〈Returns the file name of the directory named DIRECTORY.
This is the name of the file that holds the data for the directory DIRECTORY.
This operation exists because a directory is also a file, but its name as
a directory is different from its name as a file.
In Unix-syntax, this function just removes the final slash.

(fn DIRECTORY)〉〉enditem49840〈〈abbreviate-file-name〉〉:〈〈Return a version of FILENAME shortened using ‘directory-abbrev-alist’.
This also substitutes "~" for the user’s home directory (unless the
home directory is a root directory) and removes automounter prefixes
(see the variable ‘automount-dir-prefix’).

When this function is first called, it caches the user’s home
directory as a regexp in ‘abbreviated-home-dir’, and reuses it
afterwards (so long as the home directory does not change;
if you want to permanently change your home directory after having
started Emacs, set ‘abbreviated-home-dir’ to nil so it will be recalculated).

(fn FILENAME)〉〉enditem49840〈〈delete-and-extract-region〉〉:〈〈Delete the text between START and END and return it.

(fn START END)〉〉enditem49840〈〈map-y-or-n-p〉〉:〈〈Ask a series of boolean questions.
Takes args PROMPTER ACTOR LIST, and optional args HELP and ACTION-ALIST.

LIST is a list of objects, or a function of no arguments to return the next
object or nil.

If PROMPTER is a string, the prompt is (format PROMPTER OBJECT).  If not
a string, PROMPTER is a function of one arg (an object from LIST), which
returns a string to be used as the prompt for that object.  If the return
value is not a string, it may be nil to ignore the object or non-nil to act
on the object without asking the user.

ACTOR is a function of one arg (an object from LIST),
which gets called with each object that the user answers ‘yes’ for.

If HELP is given, it is a list (OBJECT OBJECTS ACTION),
where OBJECT is a string giving the singular noun for an elt of LIST;
OBJECTS is the plural noun for elts of LIST, and ACTION is a transitive
verb describing ACTOR.  The default is ("object" "objects" "act on").

At the prompts, the user may enter y, Y, or SPC to act on that object;
n, N, or DEL to skip that object; ! to act on all following objects;
ESC or q to exit (skip all following objects); . (period) to act on the
current object and then exit; or C-h to get help.

If ACTION-ALIST is given, it is an alist (KEY FUNCTION HELP) of extra keys
that will be accepted.  KEY is a character; FUNCTION is a function of one
arg (an object from LIST); HELP is a string.  When the user hits KEY,
FUNCTION is called.  If it returns non-nil, the object is considered
"acted upon", and the next object from LIST is processed.  If it returns
nil, the prompt is repeated for the same object.

Final optional argument NO-CURSOR-IN-ECHO-AREA non-nil says not to set
‘cursor-in-echo-area’ while prompting.

This function uses ‘query-replace-map’ to define the standard responses,
but not all of the responses which ‘query-replace’ understands
are meaningful here.

Returns the number of actions taken.

(fn PROMPTER ACTOR LIST &optional HELP ACTION-ALIST NO-CURSOR-IN-ECHO-AREA)〉〉enditem49840〈〈message〉〉:〈〈Display a message at the bottom of the screen.
The message also goes into the ‘*Messages*’ buffer, if ‘message-log-max’
is non-nil.  (In keyboard macros, that’s all it does.)
Return the message.

In batch mode, the message is printed to the standard error stream,
followed by a newline.

The first argument is a format control string, and the rest are data
to be formatted under control of the string.  Percent sign (%), grave
accent (`) and apostrophe (') are special in the format; see
‘format-message’ for details.  To display STRING without special
treatment, use (message "%s" STRING).

If the first argument is nil or the empty string, the function clears
any existing message; this lets the minibuffer contents show.  See
also ‘current-message’.

(fn FORMAT-STRING &rest ARGS)〉〉enditem49840〈〈message-or-box〉〉:〈〈Display a message in a dialog box or in the echo area.
If this command was invoked with the mouse, use a dialog box if
‘use-dialog-box’ is non-nil.
Otherwise, use the echo area.
The first argument is a format control string, and the rest are data
to be formatted under control of the string.  See ‘format-message’ for
details.

If the first argument is nil or the empty string, clear any existing
message; let the minibuffer contents show.

(fn FORMAT-STRING &rest ARGS)〉〉enditem49840〈〈message-box〉〉:〈〈Display a message, in a dialog box if possible.
If a dialog box is not available, use the echo area.
The first argument is a format control string, and the rest are data
to be formatted under control of the string.  See ‘format-message’ for
details.

If the first argument is nil or the empty string, clear any existing
message; let the minibuffer contents show.

(fn FORMAT-STRING &rest ARGS)〉〉enditem49840〈〈display-message-or-buffer〉〉:〈〈Display MESSAGE in the echo area if possible, otherwise in a pop-up buffer.
MESSAGE may be either a string or a buffer.

A pop-up buffer is displayed using ‘display-buffer’ if MESSAGE is too long
for maximum height of the echo area, as defined by ‘max-mini-window-height’
if ‘resize-mini-windows’ is non-nil.

Returns either the string shown in the echo area, or when a pop-up
buffer is used, the window used to display it.

If MESSAGE is a string, then the optional argument BUFFER-NAME is the
name of the buffer used to display it in the case where a pop-up buffer
is used, defaulting to ‘*Message*’.  In the case where MESSAGE is a
string and it is displayed in the echo area, it is not specified whether
the contents are inserted into the buffer anyway.

Optional arguments ACTION and FRAME are as for ‘display-buffer’,
and are only used if a pop-up buffer is displayed.

(fn MESSAGE &optional BUFFER-NAME ACTION FRAME)〉〉enditem49840〈〈current-message〉〉:〈〈Return the string currently displayed in the echo area, or nil if none.

(fn)〉〉enditem49840〈〈ding〉〉:〈〈Beep, or flash the screen.
Also, unless an argument is given,
terminate any keyboard macro currently executing.

(fn &optional ARG)〉〉enditem49840〈〈beep〉〉:〈〈Beep, or flash the screen.
Also, unless an argument is given,
terminate any keyboard macro currently executing.

(fn &optional ARG)〉〉enditem49840〈〈x-popup-dialog〉〉:〈〈Pop up a dialog box and return user’s selection.
POSITION specifies which frame to use.
This is normally a mouse button event or a window or frame.
If POSITION is t, it means to use the frame the mouse is on.
The dialog box appears in the middle of the specified frame.

CONTENTS specifies the alternatives to display in the dialog box.
It is a list of the form (DIALOG ITEM1 ITEM2...).
Each ITEM is a cons cell (STRING . VALUE).
The return value is VALUE from the chosen item.

An ITEM may also be just a string--that makes a nonselectable item.
An ITEM may also be nil--that means to put all preceding items
on the left of the dialog box and all following items on the right.
(By default, approximately half appear on each side.)

If HEADER is non-nil, the frame title for the box is "Information",
otherwise it is "Question".

If the user gets rid of the dialog box without making a valid choice,
for instance using the window manager, then this produces a quit and
‘x-popup-dialog’ does not return.

(fn POSITION CONTENTS &optional HEADER)〉〉enditem49840〈〈network-interface-list〉〉:〈〈Return an alist of all network interfaces and their network address.
Each element is a cons, the car of which is a string containing the
interface name, and the cdr is the network address in internal
format; see the description of ADDRESS in ‘make-network-process’.

If the information is not available, return nil.

(fn)〉〉enditem49840〈〈network-interface-info〉〉:〈〈Return information about network interface named IFNAME.
The return value is a list (ADDR BCAST NETMASK HWADDR FLAGS),
where ADDR is the layer 3 address, BCAST is the layer 3 broadcast address,
NETMASK is the layer 3 network mask, HWADDR is the layer 2 address, and
FLAGS is the current flags of the interface.

Data that is unavailable is returned as nil.

(fn IFNAME)〉〉enditem49840〈〈format-network-address〉〉:〈〈Convert network ADDRESS from internal format to a string.
A 4 or 5 element vector represents an IPv4 address (with port number).
An 8 or 9 element vector represents an IPv6 address (with port number).
If optional second argument OMIT-PORT is non-nil, don’t include a port
number in the string, even when present in ADDRESS.
Return nil if format of ADDRESS is invalid.

(fn ADDRESS &optional OMIT-PORT)〉〉enditem49840〈〈floatp〉〉:〈〈Return t if OBJECT is a floating point number.

(fn OBJECT)〉〉enditem49840〈〈integerp〉〉:〈〈Return t if OBJECT is an integer.

(fn OBJECT)〉〉enditem49840〈〈numberp〉〉:〈〈Return t if OBJECT is a number (floating point or integer).

(fn OBJECT)〉〉enditem49840〈〈natnump〉〉:〈〈Return t if OBJECT is a nonnegative integer.

(fn OBJECT)〉〉enditem49840〈〈zerop〉〉:〈〈Return t if NUMBER is zero.

(fn NUMBER)〉〉enditem49840〈〈completion-table-dynamic〉〉:〈〈Use function FUN as a dynamic completion table.
FUN is called with one argument, the string for which completion is required,
and it should return an alist containing all the intended possible completions.
This alist may be a full list of possible completions so that FUN can ignore
the value of its argument.
If SWITCH-BUFFER is non-nil and completion is performed in the
minibuffer, FUN will be called in the buffer from which the minibuffer
was entered.

The result of the ‘completion-table-dynamic’ form is a function
that can be used as the COLLECTION argument to ‘try-completion’ and
‘all-completions’.  See Info node ‘(elisp)Programmed Completion’.

See also the related function ‘completion-table-with-cache’.

(fn FUN &optional SWITCH-BUFFER)〉〉enditem49840〈〈completion-table-with-cache〉〉:〈〈Create dynamic completion table from function FUN, with cache.
This is a wrapper for ‘completion-table-dynamic’ that saves the last
argument-result pair from FUN, so that several lookups with the
same argument (or with an argument that starts with the first one)
only need to call FUN once.  This can be useful when FUN performs a
relatively slow operation, such as calling an external process.

When IGNORE-CASE is non-nil, FUN is expected to be case-insensitive.

(fn FUN &optional IGNORE-CASE)〉〉enditem49840〈〈mouse-position〉〉:〈〈Return a list (FRAME X . Y) giving the current mouse frame and position.
The position is given in canonical character cells, where (0, 0) is the
upper-left corner of the frame, X is the horizontal offset, and Y is the
vertical offset, measured in units of the frame’s default character size.
If Emacs is running on a mouseless terminal or hasn’t been programmed
to read the mouse position, it returns the selected frame for FRAME
and nil for X and Y.
If ‘mouse-position-function’ is non-nil, ‘mouse-position’ calls it,
passing the normal return value to that function as an argument,
and returns whatever that function returns.

(fn)〉〉enditem49840〈〈set-mouse-position〉〉:〈〈Move the mouse pointer to the center of character cell (X,Y) in FRAME.
Coordinates are relative to the frame, not a window,
so the coordinates of the top left character in the frame
may be nonzero due to left-hand scroll bars or the menu bar.

The position is given in canonical character cells, where (0, 0) is
the upper-left corner of the frame, X is the horizontal offset, and
Y is the vertical offset, measured in units of the frame’s default
character size.

This function is a no-op for an X frame that is not visible.
If you have just created a frame, you must wait for it to become visible
before calling this function on it, like this.
  (while (not (frame-visible-p frame)) (sleep-for .5))

(fn FRAME X Y)〉〉enditem49840〈〈mouse-pixel-position〉〉:〈〈Return a list (FRAME X . Y) giving the current mouse frame and position.
The position is given in pixel units, where (0, 0) is the
upper-left corner of the frame, X is the horizontal offset, and Y is
the vertical offset.
If Emacs is running on a mouseless terminal or hasn’t been programmed
to read the mouse position, it returns the selected frame for FRAME
and nil for X and Y.

(fn)〉〉enditem49840〈〈set-mouse-pixel-position〉〉:〈〈Move the mouse pointer to pixel position (X,Y) in FRAME.
The position is given in pixels, where (0, 0) is the upper-left corner
of the frame, X is the horizontal offset, and Y is the vertical offset.

Note, this is a no-op for an X frame that is not visible.
If you have just created a frame, you must wait for it to become visible
before calling this function on it, like this.
  (while (not (frame-visible-p frame)) (sleep-for .5))

(fn FRAME X Y)〉〉enditem49840〈〈mouse-absolute-pixel-position〉〉:〈〈Return absolute position of mouse cursor in pixels.
The position is returned as a cons cell (X . Y) of the
coordinates of the mouse cursor position in pixels relative to a
position (0, 0) of the selected frame’s terminal.〉〉enditem49840〈〈set-mouse-absolute-pixel-position〉〉:〈〈Move mouse pointer to absolute pixel position (X, Y).
The coordinates X and Y are interpreted in pixels relative to a
position (0, 0) of the selected frame’s terminal.

(fn X Y)〉〉enditem49840〈〈frame-pointer-visible-p〉〉:〈〈Return t if the mouse pointer displayed on FRAME is visible.
Otherwise it returns nil.  FRAME omitted or nil means the
selected frame.  This is useful when ‘make-pointer-invisible’ is set.

(fn &optional FRAME)〉〉enditem49840〈〈tool-bar-add-item〉〉:〈〈Add an item to the tool bar.
ICON names the image, DEF is the key definition and KEY is a symbol
for the fake function key in the menu keymap.  Remaining arguments
PROPS are additional items to add to the menu item specification.  See
Info node ‘(elisp)Tool Bar’.  Items are added from left to right.

ICON is the base name of a file containing the image to use.  The
function will first try to use low-color/ICON.xpm if ‘display-color-cells’
is less or equal to 256, then ICON.xpm, then ICON.pbm, and finally
ICON.xbm, using ‘find-image’.

Use this function only to make bindings in the global value of ‘tool-bar-map’.
To define items in any other map, use ‘tool-bar-local-item’.〉〉enditem49840〈〈tool-bar-add-item-from-menu〉〉:〈〈Define tool bar binding for COMMAND in keymap MAP using the given ICON.
This makes a binding for COMMAND in ‘tool-bar-map’, copying its
binding from the menu bar in MAP (which defaults to ‘global-map’), but
modifies the binding by adding an image specification for ICON.  It
finds ICON just like ‘tool-bar-add-item’.  PROPS are additional
properties to add to the binding.

MAP must contain appropriate binding for ‘[menu-bar]’ which holds a keymap.

Use this function only to make bindings in the global value of ‘tool-bar-map’.
To define items in any other map, use ‘tool-bar-local-item-from-menu’.〉〉enditem49840〈〈tool-bar-local-item-from-menu〉〉:〈〈Define local tool bar binding for COMMAND using the given ICON.
This makes a binding for COMMAND in IN-MAP, copying its binding from
the menu bar in FROM-MAP (which defaults to ‘global-map’), but
modifies the binding by adding an image specification for ICON.  It
finds ICON just like ‘tool-bar-add-item’.  PROPS are additional
properties to add to the binding.

FROM-MAP must contain appropriate binding for ‘[menu-bar]’ which
holds a keymap.〉〉enditem49840〈〈send-string-to-terminal〉〉:〈〈Send STRING to the terminal without alteration.
Control characters in STRING will have terminal-dependent effects.

Optional parameter TERMINAL specifies the tty terminal device to use.
It may be a terminal object, a frame, or nil for the terminal used by
the currently selected frame.  In batch mode, STRING is sent to stdout
when TERMINAL is nil.

(fn STRING &optional TERMINAL)〉〉enditem49840〈〈insert-and-inherit〉〉:〈〈Insert the arguments at point, inheriting properties from adjoining text.
Point and after-insertion markers move forward to end up
 after the inserted text.
Any other markers at the point of insertion remain before the text.

If the current buffer is multibyte, unibyte strings are converted
to multibyte for insertion (see ‘unibyte-char-to-multibyte’).
If the current buffer is unibyte, multibyte strings are converted
to unibyte for insertion.

(fn &rest ARGS)〉〉enditem49840〈〈insert-before-markers-and-inherit〉〉:〈〈Insert text at point, relocating markers and inheriting properties.
Point and markers move forward to end up after the inserted text.

If the current buffer is multibyte, unibyte strings are converted
to multibyte for insertion (see ‘unibyte-char-to-multibyte’).
If the current buffer is unibyte, multibyte strings are converted
to unibyte for insertion.

(fn &rest ARGS)〉〉enditem49840〈〈completing-read〉〉:〈〈Read a string in the minibuffer, with completion.
PROMPT is a string to prompt with; normally it ends in a colon and a space.
COLLECTION can be a list of strings, an alist, an obarray or a hash table.
COLLECTION can also be a function to do the completion itself.
PREDICATE limits completion to a subset of COLLECTION.
See ‘try-completion’, ‘all-completions’, ‘test-completion’,
and ‘completion-boundaries’, for more details on completion,
COLLECTION, and PREDICATE.  See also Info node ‘(elisp)Basic Completion’
for the details about completion, and Info node ‘(elisp)Programmed
Completion’ for expectations from COLLECTION when it’s a function.

REQUIRE-MATCH can take the following values:
- t means that the user is not allowed to exit unless the input is (or
  completes to) an element of COLLECTION or is null.
- nil means that the user can exit with any input.
- ‘confirm’ means that the user can exit with any input, but she needs
  to confirm her choice if the input is not an element of COLLECTION.
- ‘confirm-after-completion’ means that the user can exit with any
  input, but she needs to confirm her choice if she called
  ‘minibuffer-complete’ right before ‘minibuffer-complete-and-exit’
  and the input is not an element of COLLECTION.
- anything else behaves like t except that typing RET does not exit if it
  does non-null completion.

If the input is null, ‘completing-read’ returns DEF, or the first
element of the list of default values, or an empty string if DEF is
nil, regardless of the value of REQUIRE-MATCH.

If INITIAL-INPUT is non-nil, insert it in the minibuffer initially,
  with point positioned at the end.  If it is (STRING . POSITION), the
  initial input is STRING, but point is placed at _zero-indexed_
  position POSITION in STRING.  (*Note* that this is different from
  ‘read-from-minibuffer’ and related functions, which use one-indexing
  for POSITION.)  This feature is deprecated--it is best to pass nil
  for INITIAL-INPUT and supply the default value DEF instead.  The
  user can yank the default value into the minibuffer easily using
  M-n.

HIST, if non-nil, specifies a history list and optionally the initial
  position in the list.  It can be a symbol, which is the history list
  variable to use, or it can be a cons cell (HISTVAR . HISTPOS).  In
  that case, HISTVAR is the history list variable to use, and HISTPOS
  is the initial position (the position in the list used by the
  minibuffer history commands).  For consistency, you should also
  specify that element of the history as the value of INITIAL-INPUT.
  (This is the only case in which you should use INITIAL-INPUT instead
  of DEF.)  Positions are counted starting from 1 at the beginning of
  the list.  The variable ‘history-length’ controls the maximum length
  of a history list.

DEF, if non-nil, is the default value or the list of default values.

If INHERIT-INPUT-METHOD is non-nil, the minibuffer inherits the
  current input method and the setting of ‘enable-multibyte-characters’.

Completion ignores case if the ambient value of
  ‘completion-ignore-case’ is non-nil.

See also ‘completing-read-function’.

(fn PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)〉〉enditem49840〈〈minibuffer-prompt〉〉:〈〈Return the prompt string of the currently-active minibuffer.
If no minibuffer is active, return nil.

(fn)〉〉enditem49840〈〈minibuffer-prompt-end〉〉:〈〈Return the buffer position of the end of the minibuffer prompt.
Return (point-min) if current buffer is not a minibuffer.

(fn)〉〉enditem49840〈〈minibuffer-prompt-width〉〉:〈〈Return the display width of the minibuffer prompt.
Return 0 if current buffer is not a minibuffer.〉〉enditem49840〈〈minibuffer-contents〉〉:〈〈Return the user input in a minibuffer as a string.
If the current buffer is not a minibuffer, return its entire contents.

(fn)〉〉enditem49840〈〈minibuffer-contents-no-properties〉〉:〈〈Return the user input in a minibuffer as a string, without text-properties.
If the current buffer is not a minibuffer, return its entire contents.

(fn)〉〉enditem49840〈〈windowp〉〉:〈〈Return t if OBJECT is a window and nil otherwise.

(fn OBJECT)〉〉enditem49840〈〈window-live-p〉〉:〈〈Return t if OBJECT is a live window and nil otherwise.
A live window is a window that displays a buffer.
Internal windows and deleted windows are not live.

(fn OBJECT)〉〉enditem49840〈〈window-valid-p〉〉:〈〈Return t if OBJECT is a valid window and nil otherwise.
A valid window is either a window that displays a buffer or an internal
window.  Windows that have been deleted are not valid.

(fn OBJECT)〉〉enditem49840〈〈selected-window〉〉:〈〈Return the selected window.
The selected window is the window in which the standard cursor for
selected windows appears and to which many commands apply.

(fn)〉〉enditem49840〈〈selected-window-group〉〉:〈〈Return the list of windows in the group containing the selected window.
When a grouping mode (such as Follow Mode) is not active, the
result is a list containing only the selected window.〉〉enditem49840〈〈window-resizable〉〉:〈〈Return DELTA if WINDOW can be resized vertically by DELTA lines.
WINDOW must be a valid window and defaults to the selected one.
Optional argument HORIZONTAL non-nil means return DELTA if WINDOW
can be resized horizontally by DELTA columns.  A return value of
zero means that WINDOW is not resizable.

DELTA positive means WINDOW shall be enlarged by DELTA lines or
columns.  If WINDOW cannot be enlarged by DELTA lines or columns
return the maximum value in the range 0..DELTA by which WINDOW
can be enlarged.

DELTA negative means WINDOW shall be shrunk by -DELTA lines or
columns.  If WINDOW cannot be shrunk by -DELTA lines or columns,
return the minimum value in the range DELTA..0 that can be used
for shrinking WINDOW.

Optional argument IGNORE, if non-nil, means to ignore restraints
induced by fixed size windows or the values of the variables
‘window-min-height’ and ‘window-min-width’.  The following values
have special meanings: ‘safe’ means that in addition live windows
are allowed to get as small as ‘window-safe-min-height’ lines and
‘window-safe-min-width’ columns.  ‘preserved’ means to ignore
only restrictions induced by ‘window-preserve-size’.  If IGNORE
is a window, then ignore restrictions for that window only.

Optional argument PIXELWISE non-nil means interpret DELTA as
pixels.

(fn WINDOW DELTA &optional HORIZONTAL IGNORE PIXELWISE)〉〉enditem49840〈〈window-resize〉〉:〈〈Resize WINDOW vertically by DELTA lines.
WINDOW can be an arbitrary window and defaults to the selected
one.  An attempt to resize the root window of a frame will raise
an error though.

DELTA a positive number means WINDOW shall be enlarged by DELTA
lines.  DELTA negative means WINDOW shall be shrunk by -DELTA
lines.

Optional argument HORIZONTAL non-nil means resize WINDOW
horizontally by DELTA columns.  In this case a positive DELTA
means enlarge WINDOW by DELTA columns.  DELTA negative means
WINDOW shall be shrunk by -DELTA columns.

Optional argument IGNORE, if non-nil, means to ignore restraints
induced by fixed size windows or the values of the variables
‘window-min-height’ and ‘window-min-width’.  The following values
have special meanings: ‘safe’ means that in addition live windows
are allowed to get as small as ‘window-safe-min-height’ lines and
‘window-safe-min-width’ columns.  ‘preserved’ means to ignore
only restrictions induced by ‘window-preserve-size’.  If IGNORE
is a window, then ignore restrictions for that window only.

Optional argument PIXELWISE non-nil means resize WINDOW by DELTA
pixels.

This function resizes other windows proportionally and never
deletes any windows.  If you want to move only the low (right)
edge of WINDOW consider using ‘adjust-window-trailing-edge’
instead.

(fn WINDOW DELTA &optional HORIZONTAL IGNORE PIXELWISE)〉〉enditem49840〈〈adjust-window-trailing-edge〉〉:〈〈Move WINDOW’s bottom edge by DELTA lines.
Optional argument HORIZONTAL non-nil means move WINDOW’s right
edge by DELTA columns.  WINDOW must be a valid window and
defaults to the selected one.

Optional argument PIXELWISE non-nil means interpret DELTA as
number of pixels.

If DELTA is greater than zero, move the edge downwards or to the
right.  If DELTA is less than zero, move the edge upwards or to
the left.  If the edge can’t be moved by DELTA lines or columns,
move it as far as possible in the desired direction.

(fn WINDOW DELTA &optional HORIZONTAL PIXELWISE)〉〉enditem49840〈〈frame-live-p〉〉:〈〈Return non-nil if OBJECT is a frame which has not been deleted.
Value is nil if OBJECT is not a live frame.  If object is a live
frame, the return value indicates what sort of terminal device it is
displayed on.  See the documentation of ‘framep’ for possible
return values.

(fn OBJECT)〉〉enditem49840〈〈window-frame〉〉:〈〈Return the frame that window WINDOW is on.
WINDOW must be a valid window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-list〉〉:〈〈Return a list of windows on FRAME, starting with WINDOW.
FRAME nil or omitted means use the selected frame.
WINDOW nil or omitted means use the window selected within FRAME.
MINIBUF t means include the minibuffer window, even if it isn’t active.
MINIBUF nil or omitted means include the minibuffer window only
if it’s active.
MINIBUF neither nil nor t means never include the minibuffer window.

(fn &optional FRAME MINIBUF WINDOW)〉〉enditem49840〈〈frame-root-window〉〉:〈〈Return the root window of FRAME-OR-WINDOW.
If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
With a frame argument, return that frame’s root window.
With a window argument, return the root window of that window’s frame.

(fn &optional FRAME-OR-WINDOW)〉〉enditem49840〈〈window-parent〉〉:〈〈Return the parent window of window WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil for a window with no parent (e.g. a root window).

(fn &optional WINDOW)〉〉enditem49840〈〈window-top-child〉〉:〈〈Return the topmost child window of window WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil if WINDOW is a live window (live windows have no children).
Return nil if WINDOW is an internal window whose children form a
horizontal combination.

(fn &optional WINDOW)〉〉enditem49840〈〈window-left-child〉〉:〈〈Return the leftmost child window of window WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil if WINDOW is a live window (live windows have no children).
Return nil if WINDOW is an internal window whose children form a
vertical combination.

(fn &optional WINDOW)〉〉enditem49840〈〈window-child〉〉:〈〈Return WINDOW’s first child window.
WINDOW can be any window.

(fn WINDOW)〉〉enditem49840〈〈window-combined-p〉〉:〈〈Return non-nil if WINDOW has siblings in a given direction.
WINDOW must be a valid window and defaults to the selected one.

HORIZONTAL determines a direction for the window combination.  If
HORIZONTAL is omitted or nil, return non-nil if WINDOW is part of
a vertical window combination.  If HORIZONTAL is non-nil, return
non-nil if WINDOW is part of a horizontal window combination.

(fn &optional WINDOW HORIZONTAL)〉〉enditem49840〈〈window-next-sibling〉〉:〈〈Return the next sibling window of window WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil if WINDOW has no next sibling.

(fn &optional WINDOW)〉〉enditem49840〈〈window-prev-sibling〉〉:〈〈Return the previous sibling window of window WINDOW.
WINDOW must be a valid window and defaults to the selected one.
Return nil if WINDOW has no previous sibling.

(fn &optional WINDOW)〉〉enditem49840〈〈frame-first-window〉〉:〈〈Return the topmost, leftmost live window on FRAME-OR-WINDOW.
If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
Else if FRAME-OR-WINDOW denotes a valid window, return the first window
of that window’s frame.  If FRAME-OR-WINDOW denotes a live frame, return
the first window of that frame.

(fn &optional FRAME-OR-WINDOW)〉〉enditem49840〈〈window-in-direction〉〉:〈〈Return window in DIRECTION as seen from WINDOW.
More precisely, return the nearest window in direction DIRECTION
as seen from the position of ‘window-point’ in window WINDOW.
DIRECTION must be one of ‘above’, ‘below’, ‘left’ or ‘right’.
WINDOW must be a live window and defaults to the selected one.

Do not return a window whose ‘no-other-window’ parameter is
non-nil.  If the nearest window’s ‘no-other-window’ parameter is
non-nil, try to find another window in the indicated direction.
If, however, the optional argument IGNORE is non-nil, return that
window even if its ‘no-other-window’ parameter is non-nil.

Optional argument SIGN a negative number means to use the right
or bottom edge of WINDOW as reference position instead of
‘window-point’.  SIGN a positive number means to use the left or
top edge of WINDOW as reference position.

Optional argument WRAP non-nil means to wrap DIRECTION around
frame borders.  This means to return for WINDOW at the top of the
frame and DIRECTION ‘above’ the minibuffer window if the frame
has one, and a window at the bottom of the frame otherwise.

Optional argument MINI nil means to return the minibuffer window
if and only if it is currently active.  MINI non-nil means to
return the minibuffer window even when it’s not active.  However,
if WRAP is non-nil, always act as if MINI were nil.

Return nil if no suitable window can be found.

(fn DIRECTION &optional WINDOW IGNORE SIGN WRAP MINI)〉〉enditem49840〈〈window-tree〉〉:〈〈Return the window tree of frame FRAME.
FRAME must be a live frame and defaults to the selected frame.
The return value is a list of the form (ROOT MINI), where ROOT
represents the window tree of the frame’s root window, and MINI
is the frame’s minibuffer window.

If the root window is not split, ROOT is the root window itself.
Otherwise, ROOT is a list (DIR EDGES W1 W2 ...) where DIR is nil
for a horizontal split, and t for a vertical split.  EDGES gives
the combined size and position of the child windows in the split,
and the rest of the elements are the child windows in the split.
Each of the child windows may again be a window or a list
representing a window split, and so on.  EDGES is a list (LEFT
TOP RIGHT BOTTOM) as returned by ‘window-edges’.

(fn &optional FRAME)〉〉enditem49840〈〈tty-top-frame〉〉:〈〈Return the topmost terminal frame on TERMINAL.
TERMINAL can be a terminal object, a frame or nil (meaning the
selected frame’s terminal).  This function returns nil if TERMINAL
does not refer to a text terminal.  Otherwise, it returns the
top-most frame on the text terminal.

(fn &optional TERMINAL)〉〉enditem49840〈〈font-family-list〉〉:〈〈List available font families on the current frame.
If FRAME is omitted or nil, the selected frame is used.

(fn &optional FRAME)〉〉enditem49840〈〈bitmap-spec-p〉〉:〈〈Value is non-nil if OBJECT is a valid bitmap specification.
A bitmap specification is either a string, a file name, or a list
(WIDTH HEIGHT DATA) where WIDTH is the pixel width of the bitmap,
HEIGHT is its height, and DATA is a string containing the bits of
the pixmap.  Bits are stored row by row, each row occupies
(WIDTH + 7)/8 bytes.

(fn OBJECT)〉〉enditem49840〈〈region-beginning〉〉:〈〈Return the integer value of point or mark, whichever is smaller.

(fn)〉〉enditem49840〈〈region-end〉〉:〈〈Return the integer value of point or mark, whichever is larger.

(fn)〉〉enditem49840〈〈use-region-p〉〉:〈〈Return t if the region is active and it is appropriate to act on it.
This is used by commands that act specially on the region under
Transient Mark mode.

The return value is t if Transient Mark mode is enabled and the
mark is active; furthermore, if ‘use-empty-active-region’ is nil,
the region must not be empty.  Otherwise, the return value is nil.

For some commands, it may be appropriate to ignore the value of
‘use-empty-active-region’; in that case, use ‘region-active-p’.〉〉enditem49840〈〈default-value〉〉:〈〈Return SYMBOL’s default value.
This is the value that is seen in buffers that do not have their own values
for this variable.  The default value is meaningful for variables with
local bindings in certain buffers.

(fn SYMBOL)〉〉enditem49840〈〈default-boundp〉〉:〈〈Return t if SYMBOL has a non-void default value.
This is the value that is seen in buffers that do not have their own values
for this variable.

(fn SYMBOL)〉〉enditem49840〈〈set-default〉〉:〈〈Set SYMBOL’s default value to VALUE.  SYMBOL and VALUE are evaluated.
The default value is seen in buffers that do not have their own values
for this variable.

(fn SYMBOL VALUE)〉〉enditem49840〈〈put-text-property〉〉:〈〈Set one property of the text from START to END.
The third and fourth arguments PROPERTY and VALUE
specify the property to add.
If the optional fifth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.

(fn START END PROPERTY VALUE &optional OBJECT)〉〉enditem49840〈〈add-text-properties〉〉:〈〈Add properties to the text from START to END.
The third argument PROPERTIES is a property list
specifying the property values to add.  If the optional fourth argument
OBJECT is a buffer (or nil, which means the current buffer),
START and END are buffer positions (integers or markers).
If OBJECT is a string, START and END are 0-based indices into it.
Return t if any property value actually changed, nil otherwise.

(fn START END PROPERTIES &optional OBJECT)〉〉enditem49840〈〈remove-text-properties〉〉:〈〈Remove some properties from text from START to END.
The third argument PROPERTIES is a property list
whose property names specify the properties to remove.
(The values stored in PROPERTIES are ignored.)
If the optional fourth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.
Return t if any property was actually removed, nil otherwise.

Use ‘set-text-properties’ if you want to remove all text properties.

(fn START END PROPERTIES &optional OBJECT)〉〉enditem49840〈〈remove-list-of-text-properties〉〉:〈〈Remove some properties from text from START to END.
The third argument LIST-OF-PROPERTIES is a list of property names to remove.
If the optional fourth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.
Return t if any property was actually removed, nil otherwise.

(fn START END LIST-OF-PROPERTIES &optional OBJECT)〉〉enditem49840〈〈set-text-properties〉〉:〈〈Completely replace properties of text from START to END.
The third argument PROPERTIES is the new property list.
If the optional fourth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.
If PROPERTIES is nil, the effect is to remove all properties from
the designated part of OBJECT.

(fn START END PROPERTIES &optional OBJECT)〉〉enditem49840〈〈add-face-text-property〉〉:〈〈Add the face property to the text from START to END.
FACE specifies the face to add.  It should be a valid value of the
‘face’ property (typically a face name or a plist of face attributes
and values).

If any text in the region already has a non-nil ‘face’ property, those
face(s) are retained.  This is done by setting the ‘face’ property to
a list of faces, with FACE as the first element (by default) and the
pre-existing faces as the remaining elements.

If optional fourth argument APPEND is non-nil, append FACE to the end
of the face list instead.

If optional fifth argument OBJECT is a buffer (or nil, which means the
current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices
into it.

(fn START END FACE &optional APPEND OBJECT)〉〉enditem49840〈〈propertize〉〉:〈〈Return a copy of STRING with text properties added.
First argument is the string to copy.
Remaining arguments form a sequence of PROPERTY VALUE pairs for text
properties to add to the result.

(fn STRING &rest PROPERTIES)〉〉enditem49840〈〈not〉〉:〈〈Return t if OBJECT is nil, and return nil otherwise.

(fn OBJECT)〉〉enditem49840〈〈error〉〉:〈〈Signal an error, making a message by passing args to ‘format-message’.
In Emacs, the convention is that error messages start with a capital
letter but *do not* end with a period.  Please follow this convention
for the sake of consistency.

Note: (error "%s" VALUE) makes the message VALUE without
interpreting format characters like ‘%’, ‘`’, and ‘'’.

(fn &rest ARGS)〉〉enditem49840〈〈signal〉〉:〈〈Signal an error.  Args are ERROR-SYMBOL and associated DATA.
This function does not return.

An error symbol is a symbol with an ‘error-conditions’ property
that is a list of condition names.
A handler for any of those names will get to handle this signal.
The symbol ‘error’ should normally be one of them.

DATA should be a list.  Its elements are printed as part of the error message.
See Info anchor ‘(elisp)Definition of signal’ for some details on how this
error message is constructed.
If the signal is handled, DATA is made available to the handler.
See also the function ‘condition-case’.

(fn ERROR-SYMBOL DATA)〉〉enditem49840〈〈user-error〉〉:〈〈Signal a pilot error, making a message by passing args to ‘format-message’.
In Emacs, the convention is that error messages start with a capital
letter but *do not* end with a period.  Please follow this convention
for the sake of consistency.
This is just like ‘error’ except that ‘user-error’s are expected to be the
result of an incorrect manipulation on the part of the user, rather than the
result of an actual problem.

Note: (user-error "%s" VALUE) makes the message VALUE without
interpreting format characters like ‘%’, ‘`’, and ‘'’.

(fn FORMAT &rest ARGS)〉〉enditem49840〈〈set-marker〉〉:〈〈Position MARKER before character number POSITION in BUFFER.
If BUFFER is omitted or nil, it defaults to the current buffer.  If
POSITION is nil, makes marker point nowhere so it no longer slows down
editing in any buffer.  Returns MARKER.

(fn MARKER POSITION &optional BUFFER)〉〉enditem49840〈〈move-marker〉〉:〈〈Position MARKER before character number POSITION in BUFFER.
If BUFFER is omitted or nil, it defaults to the current buffer.  If
POSITION is nil, makes marker point nowhere so it no longer slows down
editing in any buffer.  Returns MARKER.

(fn MARKER POSITION &optional BUFFER)〉〉enditem49840〈〈frame-current-scroll-bars〉〉:〈〈Return the current scroll-bar types for frame FRAME.
Value is a cons (VERTICAL . HORIZ0NTAL) where VERTICAL specifies
the current location of the vertical scroll-bars (‘left’, ‘right’
or nil), and HORIZONTAL specifies the current location of the
horizontal scroll bars (‘bottom’ or nil).  FRAME must specify a
live frame and defaults to the selected one.

(fn &optional FRAME)〉〉enditem49840〈〈frame-scroll-bar-width〉〉:〈〈Return scroll bar width of FRAME in pixels.

(fn &optional FRAME)〉〉enditem49840〈〈frame-scroll-bar-height〉〉:〈〈Return scroll bar height of FRAME in pixels.

(fn &optional FRAME)〉〉enditem49840〈〈set-window-scroll-bars〉〉:〈〈Set width and type of scroll bars of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Second parameter WIDTH specifies the pixel width for the vertical scroll
bar.  If WIDTH is nil, use the scroll bar width of WINDOW’s frame.
Third parameter VERTICAL-TYPE specifies the type of the vertical scroll
bar: left, right, nil or t where nil means to not display a vertical
scroll bar on WINDOW and t means to use WINDOW frame’s vertical scroll
bar type.

Fourth parameter HEIGHT specifies the pixel height for the horizontal
scroll bar.  If HEIGHT is nil, use the scroll bar height of WINDOW’s
frame.  Fifth parameter HORIZONTAL-TYPE specifies the type of the
horizontal scroll bar: bottom, nil, or t where nil means to not display
a horizontal scroll bar on WINDOW and t means to use WINDOW frame’s
horizontal scroll bar type.

Return t if scroll bars were actually changed and nil otherwise.

(fn WINDOW &optional WIDTH VERTICAL-TYPE HEIGHT HORIZONTAL-TYPE)〉〉enditem49840〈〈window-scroll-bars〉〉:〈〈Get width and type of scroll bars of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Value is a list of the form (WIDTH COLUMNS VERTICAL-TYPE HEIGHT LINES
HORIZONTAL-TYPE).  If WIDTH or HEIGHT is nil or VERTICAL-TYPE or
HORIZONTAL-TYPE is t, the window is using the frame’s corresponding
value.

(fn &optional WINDOW)〉〉enditem49840〈〈window-current-scroll-bars〉〉:〈〈Return the current scroll bar types for WINDOW.
WINDOW must be a live window and defaults to the selected one.

The return value is a cons cell (VERTICAL . HORIZONTAL) where
VERTICAL specifies the current location of the vertical scroll
bar (‘left’, ‘right’ or nil), and HORIZONTAL specifies the
current location of the horizontal scroll bar (‘bottom’ or nil).

Unlike ‘window-scroll-bars’, this function reports the scroll bar
type actually used, once frame defaults and ‘scroll-bar-mode’ are
taken into account.

(fn &optional WINDOW)〉〉enditem49840〈〈window-scroll-bar-width〉〉:〈〈Return the width in pixels of WINDOW’s vertical scrollbar.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-scroll-bar-height〉〉:〈〈Return the height in pixels of WINDOW’s horizontal scrollbar.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-hscroll〉〉:〈〈Return the number of columns by which WINDOW is scrolled from left margin.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-hscroll〉〉:〈〈Set number of columns WINDOW is scrolled from left margin to NCOL.
WINDOW must be a live window and defaults to the selected one.
Clip the number to a reasonable value if out of range.
Return the new number.  NCOL should be zero or positive.

Note that if ‘automatic-hscrolling’ is non-nil, you cannot scroll the
window so that the location of point moves off-window.

(fn WINDOW NCOL)〉〉enditem49840〈〈create-image〉〉:〈〈Create an image.
FILE-OR-DATA is an image file name or image data.
Optional TYPE is a symbol describing the image type.  If TYPE is omitted
or nil, try to determine the image type from its first few bytes
of image data.  If that doesn’t work, and FILE-OR-DATA is a file name,
use its file extension as image type.
Optional DATA-P non-nil means FILE-OR-DATA is a string containing image data.
Optional PROPS are additional image attributes to assign to the image,
like, e.g. ‘:mask MASK’.
Value is the image created, or nil if images of type TYPE are not supported.

Images should not be larger than specified by ‘max-image-size’.

Image file names that are not absolute are searched for in the
"images" sub-directory of ‘data-directory’ and
‘x-bitmap-file-path’ (in that order).

(fn FILE-OR-DATA &optional TYPE DATA-P &rest PROPS)〉〉enditem49840〈〈find-image〉〉:〈〈Find an image, choosing one of a list of image specifications.

SPECS is a list of image specifications.

Each image specification in SPECS is a property list.  The contents of
a specification are image type dependent.  All specifications must at
least contain the properties ‘:type TYPE’ and either ‘:file FILE’ or
‘:data DATA’, where TYPE is a symbol specifying the image type,
e.g. ‘xbm’, FILE is the file to load the image from, and DATA is a
string containing the actual image data.  The specification whose TYPE
is supported, and FILE exists, is used to construct the image
specification to be returned.  Return nil if no specification is
satisfied.

The image is looked for in ‘image-load-path’.

Image files should not be larger than specified by ‘max-image-size’.

(fn SPECS)〉〉enditem49840〈〈image-load-path-for-library〉〉:〈〈Return a suitable search path for images used by LIBRARY.

It searches for IMAGE in ‘image-load-path’ (excluding
"‘data-directory’/images") and ‘load-path’, followed by a path
suitable for LIBRARY, which includes "../../etc/images" and
"../etc/images" relative to the library file itself, and then
in "‘data-directory’/images".

Then this function returns a list of directories which contains
first the directory in which IMAGE was found, followed by the
value of ‘load-path’.  If PATH is given, it is used instead of
‘load-path’.

If NO-ERROR is non-nil and a suitable path can’t be found, don’t
signal an error.  Instead, return a list of directories as before,
except that nil appears in place of the image directory.

Here is an example that uses a common idiom to provide
compatibility with versions of Emacs that lack the variable
‘image-load-path’:

    ;; Shush compiler.
    (defvar image-load-path)

    (let* ((load-path (image-load-path-for-library "mh-e" "mh-logo.xpm"))
           (image-load-path (cons (car load-path)
                                  (when (boundp 'image-load-path)
                                    image-load-path))))
      (mh-tool-bar-folder-buttons-init))

(fn LIBRARY IMAGE &optional PATH NO-ERROR)〉〉enditem49840〈〈make-byte-code〉〉:〈〈Create a byte-code object with specified arguments as elements.
The arguments should be the ARGLIST, bytecode-string BYTE-CODE, constant
vector CONSTANTS, maximum stack size DEPTH, (optional) DOCSTRING,
and (optional) INTERACTIVE-SPEC.
The first four arguments are required; at most six have any
significance.
The ARGLIST can be either like the one of ‘lambda’, in which case the arguments
will be dynamically bound before executing the byte code, or it can be an
integer of the form NNNNNNNRMMMMMMM where the 7bit MMMMMMM specifies the
minimum number of arguments, the 7-bit NNNNNNN specifies the maximum number
of arguments (ignoring &rest) and the R bit specifies whether there is a &rest
argument to catch the left-over arguments.  If such an integer is used, the
arguments will not be dynamically bound but will be instead pushed on the
stack before executing the byte-code.

(fn ARGLIST BYTE-CODE CONSTANTS DEPTH &optional DOCSTRING INTERACTIVE-SPEC &rest ELEMENTS)〉〉enditem49840〈〈field-beginning〉〉:〈〈Return the beginning of the field surrounding POS.
A field is a region of text with the same ‘field’ property.
If POS is nil, the value of point is used for POS.
If ESCAPE-FROM-EDGE is non-nil and POS is at the beginning of its
field, then the beginning of the *previous* field is returned.
If LIMIT is non-nil, it is a buffer position; if the beginning of the field
is before LIMIT, then LIMIT will be returned instead.

(fn &optional POS ESCAPE-FROM-EDGE LIMIT)〉〉enditem49840〈〈field-end〉〉:〈〈Return the end of the field surrounding POS.
A field is a region of text with the same ‘field’ property.
If POS is nil, the value of point is used for POS.
If ESCAPE-FROM-EDGE is non-nil and POS is at the end of its field,
then the end of the *following* field is returned.
If LIMIT is non-nil, it is a buffer position; if the end of the field
is after LIMIT, then LIMIT will be returned instead.

(fn &optional POS ESCAPE-FROM-EDGE LIMIT)〉〉enditem49840〈〈field-string〉〉:〈〈Return the contents of the field surrounding POS as a string.
A field is a region of text with the same ‘field’ property.
If POS is nil, the value of point is used for POS.

(fn &optional POS)〉〉enditem49840〈〈field-string-no-properties〉〉:〈〈Return the contents of the field around POS, without text properties.
A field is a region of text with the same ‘field’ property.
If POS is nil, the value of point is used for POS.

(fn &optional POS)〉〉enditem49840〈〈delete-field〉〉:〈〈Delete the field surrounding POS.
A field is a region of text with the same ‘field’ property.
If POS is nil, the value of point is used for POS.

(fn &optional POS)〉〉enditem49840〈〈constrain-to-field〉〉:〈〈Return the position closest to NEW-POS that is in the same field as OLD-POS.
A field is a region of text with the same ‘field’ property.

If NEW-POS is nil, then use the current point instead, and move point
to the resulting constrained position, in addition to returning that
position.

If OLD-POS is at the boundary of two fields, then the allowable
positions for NEW-POS depends on the value of the optional argument
ESCAPE-FROM-EDGE: If ESCAPE-FROM-EDGE is nil, then NEW-POS is
constrained to the field that has the same ‘field’ char-property
as any new characters inserted at OLD-POS, whereas if ESCAPE-FROM-EDGE
is non-nil, NEW-POS is constrained to the union of the two adjacent
fields.  Additionally, if two fields are separated by another field with
the special value ‘boundary’, then any point within this special field is
also considered to be ‘on the boundary’.

If the optional argument ONLY-IN-LINE is non-nil and constraining
NEW-POS would move it to a different line, NEW-POS is returned
unconstrained.  This is useful for commands that move by line, like
t or M-x beginning-of-line, which should generally respect field boundaries
only in the case where they can still move to the right line.

If the optional argument INHIBIT-CAPTURE-PROPERTY is non-nil, and OLD-POS has
a non-nil property of that name, then any field boundaries are ignored.

Field boundaries are not noticed if ‘inhibit-field-text-motion’ is non-nil.

(fn NEW-POS OLD-POS &optional ESCAPE-FROM-EDGE ONLY-IN-LINE INHIBIT-CAPTURE-PROPERTY)〉〉enditem49840〈〈insert-for-yank〉〉:〈〈Insert STRING at point for the ‘yank’ command.

This function is like ‘insert’, except it honors the variables
‘yank-handled-properties’ and ‘yank-excluded-properties’, and the
‘yank-handler’ text property, in the way that ‘yank’ does.

(fn STRING)〉〉enditem49840〈〈insert-buffer-substring-as-yank〉〉:〈〈Insert before point a part of BUFFER, stripping some text properties.
BUFFER may be a buffer or a buffer name.
Arguments START and END are character positions specifying the substring.
They default to the values of (point-min) and (point-max) in BUFFER.
Before insertion, process text properties according to
‘yank-handled-properties’ and ‘yank-excluded-properties’.

(fn BUFFER &optional START END)〉〉enditem49840〈〈get-internal-run-time〉〉:〈〈Return the current run time used by Emacs.
The time is returned as a list (HIGH LOW USEC PSEC), using the same
style as (current-time).

On systems that can’t determine the run time, ‘get-internal-run-time’
does the same thing as ‘current-time’.

(fn)〉〉enditem49840〈〈eq〉〉:〈〈Return t if the two args are the same Lisp object.

(fn OBJ1 OBJ2)〉〉enditem49840〈〈equal〉〉:〈〈Return t if two Lisp objects have similar structure and contents.
They must have the same data type.
Conses are compared by comparing the cars and the cdrs.
Vectors and strings are compared element by element.
Numbers are compared by value, but integers cannot equal floats.
 (Use ‘=’ if you want integers and floats to be able to be equal.)
Symbols must match exactly.

(fn O1 O2)〉〉enditem49840〈〈equal-including-properties〉〉:〈〈Return t if two Lisp objects have similar structure and contents.
This is like ‘equal’ except that it compares the text properties
of strings.  (‘equal’ ignores text properties.)

(fn O1 O2)〉〉enditem49840〈〈define-package〉〉:〈〈Define a new package.
NAME-STRING is the name of the package, as a string.
VERSION-STRING is the version of the package, as a string.
DOCSTRING is a short description of the package, a string.
REQUIREMENTS is a list of dependencies on other packages.
 Each requirement is of the form (OTHER-PACKAGE OTHER-VERSION),
 where OTHER-VERSION is a string.

EXTRA-PROPERTIES is currently unused.

(fn NAME-STRING VERSION-STRING &optional DOCSTRING REQUIREMENTS &rest EXTRA-PROPERTIES)〉〉enditem49840〈〈print〉〉:〈〈Output the printed representation of OBJECT, with newlines around it.
Quoting characters are printed when needed to make output that ‘read’
can handle, whenever this is possible.  For complex objects, the behavior
is controlled by ‘print-level’ and ‘print-length’, which see.

OBJECT is any of the Lisp data types: a number, a string, a symbol,
a list, a buffer, a window, a frame, etc.

A printed representation of an object is text which describes that object.

Optional argument PRINTCHARFUN is the output stream, which can be one
of these:

   - a buffer, in which case output is inserted into that buffer at point;
   - a marker, in which case output is inserted at marker’s position;
   - a function, in which case that function is called once for each
     character of OBJECT’s printed representation;
   - a symbol, in which case that symbol’s function definition is called; or
   - t, in which case the output is displayed in the echo area.

If PRINTCHARFUN is omitted, the value of ‘standard-output’ (which see)
is used instead.

(fn OBJECT &optional PRINTCHARFUN)〉〉enditem49840〈〈princ〉〉:〈〈Output the printed representation of OBJECT, any Lisp object.
No quoting characters are used; no delimiters are printed around
the contents of strings.

OBJECT is any of the Lisp data types: a number, a string, a symbol,
a list, a buffer, a window, a frame, etc.

A printed representation of an object is text which describes that object.

Optional argument PRINTCHARFUN is the output stream, which can be one
of these:

   - a buffer, in which case output is inserted into that buffer at point;
   - a marker, in which case output is inserted at marker’s position;
   - a function, in which case that function is called once for each
     character of OBJECT’s printed representation;
   - a symbol, in which case that symbol’s function definition is called; or
   - t, in which case the output is displayed in the echo area.

If PRINTCHARFUN is omitted, the value of ‘standard-output’ (which see)
is used instead.

(fn OBJECT &optional PRINTCHARFUN)〉〉enditem49840〈〈terpri〉〉:〈〈Output a newline to stream PRINTCHARFUN.
If ENSURE is non-nil only output a newline if not already at the
beginning of a line.  Value is non-nil if a newline is printed.
If PRINTCHARFUN is omitted or nil, the value of ‘standard-output’ is used.

(fn &optional PRINTCHARFUN ENSURE)〉〉enditem49840〈〈write-char〉〉:〈〈Output character CHARACTER to stream PRINTCHARFUN.
PRINTCHARFUN defaults to the value of ‘standard-output’ (which see).

(fn CHARACTER &optional PRINTCHARFUN)〉〉enditem49840〈〈pp〉〉:〈〈Output the pretty-printed representation of OBJECT, any Lisp object.
Quoting characters are printed as needed to make output that ‘read’
can handle, whenever this is possible.
Output stream is STREAM, or value of ‘standard-output’ (which see).

(fn OBJECT &optional STREAM)〉〉enditem49840〈〈set-process-sentinel〉〉:〈〈Give PROCESS the sentinel SENTINEL; nil for default.
The sentinel is called as a function when the process changes state.
It gets two arguments: the process, and a string describing the change.

(fn PROCESS SENTINEL)〉〉enditem49840〈〈process-sentinel〉〉:〈〈Return the sentinel of PROCESS.
See ‘set-process-sentinel’ for more info on sentinels.

(fn PROCESS)〉〉enditem49840〈〈waiting-for-user-input-p〉〉:〈〈Return non-nil if Emacs is waiting for input from the user.
This is intended for use by asynchronous process output filters and sentinels.

(fn)〉〉enditem49840〈〈make-char-table〉〉:〈〈Return a newly created char-table, with purpose PURPOSE.
Each element is initialized to INIT, which defaults to nil.

PURPOSE should be a symbol.  If it has a ‘char-table-extra-slots’
property, the property’s value should be an integer between 0 and 10
that specifies how many extra slots the char-table has.  Otherwise,
the char-table has no extra slot.

(fn PURPOSE &optional INIT)〉〉enditem49840〈〈char-table-p〉〉:〈〈Return t if OBJECT is a char-table.

(fn OBJECT)〉〉enditem49840〈〈char-table-subtype〉〉:〈〈Return the subtype of char-table CHAR-TABLE.  The value is a symbol.

(fn CHAR-TABLE)〉〉enditem49840〈〈char-table-parent〉〉:〈〈Return the parent char-table of CHAR-TABLE.
The value is either nil or another char-table.
If CHAR-TABLE holds nil for a given character,
then the actual applicable value is inherited from the parent char-table
(or from its parents, if necessary).

(fn CHAR-TABLE)〉〉enditem49840〈〈set-char-table-parent〉〉:〈〈Set the parent char-table of CHAR-TABLE to PARENT.
Return PARENT.  PARENT must be either nil or another char-table.

(fn CHAR-TABLE PARENT)〉〉enditem49840〈〈char-table-extra-slot〉〉:〈〈Return the value of CHAR-TABLE’s extra-slot number N.

(fn CHAR-TABLE N)〉〉enditem49840〈〈set-char-table-extra-slot〉〉:〈〈Set CHAR-TABLE’s extra-slot number N to VALUE.

(fn CHAR-TABLE N VALUE)〉〉enditem49840〈〈char-table-range〉〉:〈〈Return the value in CHAR-TABLE for a range of characters RANGE.
RANGE should be nil (for the default value),
a cons of character codes (for characters in the range), or a character code.

(fn CHAR-TABLE RANGE)〉〉enditem49840〈〈set-char-table-range〉〉:〈〈Set the value in CHAR-TABLE for a range of characters RANGE to VALUE.
RANGE should be t (for all characters), nil (for the default value),
a cons of character codes (for characters in the range),
or a character code.  Return VALUE.

(fn CHAR-TABLE RANGE VALUE)〉〉enditem49840〈〈map-char-table〉〉:〈〈Call FUNCTION for each character in CHAR-TABLE that has non-nil value.
FUNCTION is called with two arguments, KEY and VALUE.
KEY is a character code or a cons of character codes specifying a
range of characters that have the same value.
VALUE is what (char-table-range CHAR-TABLE KEY) returns.

(fn FUNCTION CHAR-TABLE)〉〉enditem49840〈〈string-match〉〉:〈〈Return index of start of first match for REGEXP in STRING, or nil.
Matching ignores case if ‘case-fold-search’ is non-nil.
If third arg START is non-nil, start search at that index in STRING.
For index of first char beyond the match, do (match-end 0).
‘match-end’ and ‘match-beginning’ also give indices of substrings
matched by parenthesis constructs in the pattern.

You can use the function ‘match-string’ to extract the substrings
matched by the parenthesis constructions in REGEXP.

(fn REGEXP STRING &optional START)〉〉enditem49840〈〈string-match-p〉〉:〈〈Same as ‘string-match’ except this function does not change the match data.

(fn REGEXP STRING &optional START)〉〉enditem49840〈〈looking-at〉〉:〈〈Return t if text after point matches regular expression REGEXP.
This function modifies the match data that ‘match-beginning’,
‘match-end’ and ‘match-data’ access; save and restore the match
data if you want to preserve them.

(fn REGEXP)〉〉enditem49840〈〈looking-back〉〉:〈〈Return non-nil if text before point matches regular expression REGEXP.
Like ‘looking-at’ except matches before point, and is slower.
LIMIT if non-nil speeds up the search by specifying a minimum
starting position, to avoid checking matches that would start
before LIMIT.

If GREEDY is non-nil, extend the match backwards as far as
possible, stopping when a single additional previous character
cannot be part of a match for REGEXP.  When the match is
extended, its starting position is allowed to occur before
LIMIT.

As a general recommendation, try to avoid using ‘looking-back’
wherever possible, since it is slow.

(fn REGEXP &optional LIMIT GREEDY)〉〉enditem49840〈〈looking-at-p〉〉:〈〈Same as ‘looking-at’ except this function does not change the match data.

(fn REGEXP)〉〉enditem49840〈〈make-syntax-table〉〉:〈〈Return a new syntax table.
Create a syntax table which inherits from OLDTABLE (if non-nil) or
from ‘standard-syntax-table’ otherwise.

(fn &optional OLDTABLE)〉〉enditem49840〈〈copy-syntax-table〉〉:〈〈Construct a new syntax table and return it.
It is a copy of the TABLE, which defaults to the standard syntax table.

(fn &optional TABLE)〉〉enditem49840〈〈char-syntax〉〉:〈〈Return the syntax code of CHARACTER, described by a character.
For example, if CHARACTER is a word constituent, the
character ‘w’ (119) is returned.
The characters that correspond to various syntax codes
are listed in the documentation of ‘modify-syntax-entry’.

If you’re trying to determine the syntax of characters in the buffer,
this is probably the wrong function to use, because it can’t take
‘syntax-table’ text properties into account.  Consider using
‘syntax-after’ instead.

(fn CHARACTER)〉〉enditem49840〈〈set-syntax-table〉〉:〈〈Select a new syntax table for the current buffer.
One argument, a syntax table.

(fn TABLE)〉〉enditem49840〈〈syntax-table〉〉:〈〈Return the current syntax table.
This is the one specified by the current buffer.

(fn)〉〉enditem49840〈〈face-remap-add-relative〉〉:〈〈Add a face remapping entry of FACE to SPECS in the current buffer.
Return a cookie which can be used to delete this remapping with
‘face-remap-remove-relative’.

The remaining arguments, SPECS, should form a list of faces.
Each list element should be either a face name or a property list
of face attribute/value pairs.  If more than one face is listed,
that specifies an aggregate face, in the same way as in a ‘face’
text property, except for possible priority changes noted below.

The face remapping specified by SPECS takes effect alongside the
remappings from other calls to ‘face-remap-add-relative’ for the
same FACE, as well as the normal definition of FACE (at lowest
priority).  This function tries to sort multiple remappings for
the same face, so that remappings specifying relative face
attributes are applied after remappings specifying absolute face
attributes.

The base (lowest priority) remapping may be set to something
other than the normal definition of FACE via ‘face-remap-set-base’.

(fn FACE &rest SPECS)〉〉enditem49840〈〈face-remap-set-base〉〉:〈〈Set the base remapping of FACE in the current buffer to SPECS.
This causes the remappings specified by ‘face-remap-add-relative’
to apply on top of the face specification given by SPECS.

The remaining arguments, SPECS, should form a list of faces.
Each list element should be either a face name or a property list
of face attribute/value pairs, like in a ‘face’ text property.

If SPECS is empty, call ‘face-remap-reset-base’ to use the normal
definition of FACE as the base remapping; note that this is
different from SPECS containing a single value nil, which means
not to inherit from the global definition of FACE at all.

(fn FACE &rest SPECS)〉〉enditem49840〈〈face-remap-reset-base〉〉:〈〈Set the base remapping of FACE to the normal definition of FACE.
This causes the remappings specified by ‘face-remap-add-relative’
to apply on top of the normal definition of FACE.

(fn FACE)〉〉enditem49840〈〈keymap-parent〉〉:〈〈Return the parent keymap of KEYMAP.
If KEYMAP has no parent, return nil.

(fn KEYMAP)〉〉enditem49840〈〈set-keymap-parent〉〉:〈〈Modify KEYMAP to set its parent map to PARENT.
Return PARENT.  PARENT should be nil or another keymap.

(fn KEYMAP PARENT)〉〉enditem49840〈〈make-composed-keymap〉〉:〈〈Construct a new keymap composed of MAPS and inheriting from PARENT.
When looking up a key in the returned map, the key is looked in each
keymap of MAPS in turn until a binding is found.
If no binding is found in MAPS, the lookup continues in PARENT, if non-nil.
As always with keymap inheritance, a nil binding in MAPS overrides
any corresponding binding in PARENT, but it does not override corresponding
bindings in other keymaps of MAPS.
MAPS can be a list of keymaps or a single keymap.
PARENT if non-nil should be a keymap.

(fn MAPS &optional PARENT)〉〉enditem49840〈〈define-key〉〉:〈〈In KEYMAP, define key sequence KEY as DEF.
KEYMAP is a keymap.

KEY is a string or a vector of symbols and characters, representing a
sequence of keystrokes and events.  Non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be represented by vectors.
Two types of vector have special meanings:
 [remap COMMAND] remaps any key binding for COMMAND.
 [t] creates a default definition, which applies to any event with no
    other definition in KEYMAP.

DEF is anything that can be a key’s definition:
 nil (means key is undefined in this keymap),
 a command (a Lisp function suitable for interactive calling),
 a string (treated as a keyboard macro),
 a keymap (to define a prefix key),
 a symbol (when the key is looked up, the symbol will stand for its
    function definition, which should at that time be one of the above,
    or another symbol whose function definition is used, etc.),
 a cons (STRING . DEFN), meaning that DEFN is the definition
    (DEFN should be a valid definition in its own right),
 or a cons (MAP . CHAR), meaning use definition of CHAR in keymap MAP,
 or an extended menu item definition.
 (See info node ‘(elisp)Extended Menu Items’.)

If KEYMAP is a sparse keymap with a binding for KEY, the existing
binding is altered.  If there is no binding for KEY, the new pair
binding KEY to DEF is added at the front of KEYMAP.

(fn KEYMAP KEY DEF)〉〉enditem49840〈〈substitute-key-definition〉〉:〈〈Replace OLDDEF with NEWDEF for any keys in KEYMAP now defined as OLDDEF.
In other words, OLDDEF is replaced with NEWDEF wherever it appears.
Alternatively, if optional fourth argument OLDMAP is specified, we redefine
in KEYMAP as NEWDEF those keys which are defined as OLDDEF in OLDMAP.

If you don’t specify OLDMAP, you can usually get the same results
in a cleaner way with command remapping, like this:
  (define-key KEYMAP [remap OLDDEF] NEWDEF)

(fn OLDDEF NEWDEF KEYMAP &optional OLDMAP)〉〉enditem49840〈〈suppress-keymap〉〉:〈〈Make MAP override all normally self-inserting keys to be undefined.
Normally, as an exception, digits and minus-sign are set to make prefix args,
but optional second arg NODIGITS non-nil treats them like other chars.

(fn MAP &optional NODIGITS)〉〉enditem49840〈〈plist-get〉〉:〈〈Extract a value from a property list.
PLIST is a property list, which is a list of the form
(PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value
corresponding to the given PROP, or nil if PROP is not one of the
properties on the list.  This function never signals an error.

(fn PLIST PROP)〉〉enditem49840〈〈plist-put〉〉:〈〈Change value in PLIST of PROP to VAL.
PLIST is a property list, which is a list of the form
(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol and VAL is any object.
If PROP is already a property on the list, its value is set to VAL,
otherwise the new PROP VAL pair is added.  The new plist is returned;
use ‘(setq x (plist-put x prop val))’ to be sure to use the new value.
The PLIST is modified by side effects.

(fn PLIST PROP VAL)〉〉enditem49840〈〈lax-plist-get〉〉:〈〈Extract a value from a property list, comparing with ‘equal’.
PLIST is a property list, which is a list of the form
(PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value
corresponding to the given PROP, or nil if PROP is not
one of the properties on the list.

(fn PLIST PROP)〉〉enditem49840〈〈lax-plist-put〉〉:〈〈Change value in PLIST of PROP to VAL, comparing with ‘equal’.
PLIST is a property list, which is a list of the form
(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP and VAL are any objects.
If PROP is already a property on the list, its value is set to VAL,
otherwise the new PROP VAL pair is added.  The new plist is returned;
use ‘(setq x (lax-plist-put x prop val))’ to be sure to use the new value.
The PLIST is modified by side effects.

(fn PLIST PROP VAL)〉〉enditem49840〈〈plist-member〉〉:〈〈Return non-nil if PLIST has the property PROP.
PLIST is a property list, which is a list of the form
(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol.
Unlike ‘plist-get’, this allows you to distinguish between a missing
property and a property with the value nil.
The value is actually the tail of PLIST whose car is PROP.

(fn PLIST PROP)〉〉enditem49840〈〈libxml-parse-html-region〉〉:〈〈Parse the region as an HTML document and return the parse tree.
If BASE-URL is non-nil, it is used to expand relative URLs.
If DISCARD-COMMENTS is non-nil, all HTML comments are discarded.

(fn START END &optional BASE-URL DISCARD-COMMENTS)〉〉enditem49840〈〈shr-insert-document〉〉:〈〈Render the parsed document DOM into the current buffer.
DOM should be a parse tree as generated by
‘libxml-parse-html-region’ or similar.

(fn DOM)〉〉enditem49840〈〈libxml-parse-xml-region〉〉:〈〈Parse the region as an XML document and return the parse tree.
If BASE-URL is non-nil, it is used to expand relative URLs.
If DISCARD-COMMENTS is non-nil, all HTML comments are discarded.

(fn START END &optional BASE-URL DISCARD-COMMENTS)〉〉enditem49840〈〈recenter-window-group〉〉:〈〈Center point in the group of windows containing the selected window
and maybe redisplay frame.  When a grouping mode (such as Follow Mode)
is not active, this function is identical to ‘recenter’.

With a numeric prefix argument ARG, recenter putting point on screen line ARG
relative to the first window in the selected window group.  If ARG is
negative, it counts up from the bottom of the last window in the
group.  (ARG should be less than the total height of the window group.)

If ARG is omitted or nil, then recenter with point on the middle line of
the selected window group; if the variable ‘recenter-redisplay’ is
non-nil, also erase the entire frame and redraw it (when
‘auto-resize-tool-bars’ is set to ‘grow-only’, this resets the
tool-bar’s height to the minimum height needed); if
‘recenter-redisplay’ has the special value ‘tty’, then only tty frames
are redrawn.

Just C-u as prefix means put point in the center of the window
and redisplay normally--don’t erase and redraw the frame.

(fn &optional ARG)〉〉enditem49840〈〈called-interactively-p〉〉:〈〈Return t if the containing function was called by ‘call-interactively’.
If KIND is ‘interactive’, then only return t if the call was made
interactively by the user, i.e. not in ‘noninteractive’ mode nor
when ‘executing-kbd-macro’.
If KIND is ‘any’, on the other hand, it will return t for any kind of
interactive call, including being called as the binding of a key or
from a keyboard macro, even in ‘noninteractive’ mode.

This function is very brittle, it may fail to return the intended result when
the code is debugged, advised, or instrumented in some form.  Some macros and
special forms (such as ‘condition-case’) may also sometimes wrap their bodies
in a ‘lambda’, so any call to ‘called-interactively-p’ from those bodies will
indicate whether that lambda (rather than the surrounding function) was called
interactively.

Instead of using this function, it is cleaner and more reliable to give your
function an extra optional argument whose ‘interactive’ spec specifies
non-nil unconditionally ("p" is a good way to do this), or via
(not (or executing-kbd-macro noninteractive)).

The only known proper use of ‘interactive’ for KIND is in deciding
whether to display a helpful message, or how to display it.  If you’re
thinking of using it for any other purpose, it is quite likely that
you’re making a mistake.  Think: what do you want to do when the
command is called from a keyboard macro?

(fn &optional KIND)〉〉enditem49840〈〈keywordp〉〉:〈〈Return t if OBJECT is a keyword.
This means that it is a symbol with a print name beginning with ‘:’
interned in the initial obarray.

(fn OBJECT)〉〉enditem49840〈〈compare-buffer-substrings〉〉:〈〈Compare two substrings of two buffers; return result as number.
Return -N if first string is less after N-1 chars, +N if first string is
greater after N-1 chars, or 0 if strings match.
The first substring is in BUFFER1 from START1 to END1 and the second
is in BUFFER2 from START2 to END2.
All arguments may be nil.  If BUFFER1 or BUFFER2 is nil, the current
buffer is used.  If START1 or START2 is nil, the value of ‘point-min’
in the respective buffers is used.  If END1 or END2 is nil, the value
of ‘point-max’ in the respective buffers is used.
The value of ‘case-fold-search’ in the current buffer
determines whether case is significant or ignored.

(fn BUFFER1 START1 END1 BUFFER2 START2 END2)〉〉enditem49840〈〈sequencep〉〉:〈〈Return t if OBJECT is a sequence (list or array).

(fn OBJECT)〉〉enditem49840〈〈length〉〉:〈〈Return the length of vector, list or string SEQUENCE.
A byte-code function object is also allowed.
If the string contains multibyte characters, this is not necessarily
the number of bytes in the string; it is the number of characters.
To get the number of bytes, use ‘string-bytes’.

(fn SEQUENCE)〉〉enditem49840〈〈elt〉〉:〈〈Return element of SEQUENCE at index N.

(fn SEQUENCE N)〉〉enditem49840〈〈copy-sequence〉〉:〈〈Return a copy of a list, vector, string, char-table or record.
The elements of a list, vector or record are not copied; they are
shared with the original.
If the original sequence is empty, this function may return
the same empty object instead of its copy.

(fn ARG)〉〉enditem49840〈〈reverse〉〉:〈〈Return the reversed copy of list, vector, or string SEQ.
See also the function ‘nreverse’, which is used more often.

(fn SEQ)〉〉enditem49840〈〈nreverse〉〉:〈〈Reverse order of items in a list, vector or string SEQ.
If SEQ is a list, it should be nil-terminated.
This function may destructively modify SEQ to produce the value.

(fn SEQ)〉〉enditem49840〈〈sort〉〉:〈〈Sort SEQ, stably, comparing elements using PREDICATE.
Returns the sorted sequence.  SEQ should be a list or vector.  SEQ is
modified by side effects.  PREDICATE is called with two elements of
SEQ, and should return non-nil if the first element should sort before
the second.

(fn SEQ PREDICATE)〉〉enditem49840〈〈seq-elt〉〉:〈〈Return Nth element of SEQUENCE.

(fn SEQUENCE N)〉〉enditem49840〈〈seq-length〉〉:〈〈Return the number of elements of SEQUENCE.

(fn SEQUENCE)〉〉enditem49840〈〈seqp〉〉:〈〈Return non-nil if SEQUENCE is a sequence, nil otherwise.

(fn SEQUENCE)〉〉enditem49840〈〈seq-drop〉〉:〈〈Remove the first N elements of SEQUENCE and return the result.
The result is a sequence of the same type as SEQUENCE.

If N is a negative integer or zero, SEQUENCE is returned.

(fn SEQUENCE N)〉〉enditem49840〈〈seq-take〉〉:〈〈Take the first N elements of SEQUENCE and return the result.
The result is a sequence of the same type as SEQUENCE.

If N is a negative integer or zero, an empty sequence is
returned.

(fn SEQUENCE N)〉〉enditem49840〈〈seq-take-while〉〉:〈〈Take the successive elements of SEQUENCE for which PRED returns non-nil.
PRED is a function of one argument.  The result is a sequence of
the same type as SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-drop-while〉〉:〈〈Remove the successive elements of SEQUENCE for which PRED returns non-nil.
PRED is a function of one argument.  The result is a sequence of
the same type as SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-do〉〉:〈〈Apply FUNCTION to each element of SEQUENCE, presumably for side effects.
Return SEQUENCE.

(fn FUNCTION SEQUENCE)〉〉enditem49840〈〈seq-map〉〉:〈〈Return the result of applying FUNCTION to each element of SEQUENCE.

(fn FUNCTION SEQUENCE)〉〉enditem49840〈〈seq-mapn〉〉:〈〈Like ‘seq-map’ but FUNCTION is mapped over all SEQUENCES.
The arity of FUNCTION must match the number of SEQUENCES, and the
mapping stops on the shortest sequence.
Return a list of the results.

(fn FUNCTION SEQUENCES...)〉〉enditem49840〈〈seq-filter〉〉:〈〈Return a list of all the elements for which (PRED element) is non-nil in SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-remove〉〉:〈〈Return a list of all the elements for which (PRED element) is nil in SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-reduce〉〉:〈〈Reduce the function FUNCTION across SEQUENCE, starting with INITIAL-VALUE.

Return the result of calling FUNCTION with INITIAL-VALUE and the
first element of SEQUENCE, then calling FUNCTION with that result and
the second element of SEQUENCE, then with that result and the third
element of SEQUENCE, etc.

If SEQUENCE is empty, return INITIAL-VALUE and FUNCTION is not called.

(fn FUNCTION SEQUENCE INITIAL-VALUE)〉〉enditem49840〈〈seq-some〉〉:〈〈Return non-nil if PRED is satisfied for at least one element of SEQUENCE.
If so, return the first non-nil value returned by PRED.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-find〉〉:〈〈Return the first element for which (PRED element) is non-nil in SEQUENCE.
If no element is found, return DEFAULT.

Note that ‘seq-find’ has an ambiguity if the found element is
identical to DEFAULT, as it cannot be known if an element was
found or not.

(fn PRED SEQUENCE &optional DEFAULT)〉〉enditem49840〈〈seq-every-p〉〉:〈〈Return non-nil if (PRED element) is non-nil for all elements of SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-empty-p〉〉:〈〈Return non-nil if the SEQUENCE is empty, nil otherwise.

(fn SEQUENCE)〉〉enditem49840〈〈seq-count〉〉:〈〈Return the number of elements for which (PRED element) is non-nil in SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-sort〉〉:〈〈Sort SEQUENCE using PRED as comparison function.
The result is a sequence of the same type as SEQUENCE.

(fn PRED SEQUENCE)〉〉enditem49840〈〈seq-contains〉〉:〈〈Return the first element in SEQUENCE that is equal to ELT.
Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.

(fn SEQUENCE ELT &optional TESTFN)〉〉enditem49840〈〈seq-position〉〉:〈〈Return the index of the first element in SEQUENCE that is equal to ELT.
Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.

(fn SEQUENCE ELT &optional TESTFN)〉〉enditem49840〈〈seq-uniq〉〉:〈〈Return a list of the elements of SEQUENCE with duplicates removed.
TESTFN is used to compare elements, or ‘equal’ if TESTFN is nil.

(fn SEQUENCE &optional TESTFN)〉〉enditem49840〈〈seq-subseq〉〉:〈〈Return the sequence of elements of SEQUENCE from START to END.
END is exclusive.

If END is omitted, it defaults to the length of the sequence.  If
START or END is negative, it counts from the end.  Signal an
error if START or END are outside of the sequence (i.e too large
if positive or too small if negative).

(fn SEQUENCE START &optional END)〉〉enditem49840〈〈seq-concatenate〉〉:〈〈Concatenate SEQUENCES into a single sequence of type TYPE.
TYPE must be one of following symbols: vector, string or list.


(fn TYPE SEQUENCE...)〉〉enditem49840〈〈seq-mapcat〉〉:〈〈Concatenate the result of applying FUNCTION to each element of SEQUENCE.
The result is a sequence of type TYPE, or a list if TYPE is nil.

(fn FUNCTION SEQUENCE &optional TYPE)〉〉enditem49840〈〈seq-partition〉〉:〈〈Return a list of the elements of SEQUENCE grouped into sub-sequences of length N.
The last sequence may contain less than N elements.  If N is a
negative integer or 0, nil is returned.

(fn SEQUENCE N)〉〉enditem49840〈〈seq-intersection〉〉:〈〈Return a list of the elements that appear in both SEQUENCE1 and SEQUENCE2.
Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.

(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)〉〉enditem49840〈〈seq-difference〉〉:〈〈Return a list of the elements that appear in SEQUENCE1 but not in SEQUENCE2.
Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.

(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)〉〉enditem49840〈〈seq-group-by〉〉:〈〈Apply FUNCTION to each element of SEQUENCE.
Separate the elements of SEQUENCE into an alist using the results as
keys.  Keys are compared using ‘equal’.

(fn FUNCTION SEQUENCE)〉〉enditem49840〈〈seq-into〉〉:〈〈Concatenate the elements of SEQUENCE into a sequence of type TYPE.
TYPE can be one of the following symbols: vector, string or
list.

(fn SEQUENCE TYPE)〉〉enditem49840〈〈seq-min〉〉:〈〈Return the smallest element of SEQUENCE.
SEQUENCE must be a sequence of numbers or markers.

(fn SEQUENCE)〉〉enditem49840〈〈seq-max〉〉:〈〈Return the largest element of SEQUENCE.
SEQUENCE must be a sequence of numbers or markers.

(fn SEQUENCE)〉〉enditem49840〈〈stringp〉〉:〈〈Return t if OBJECT is a string.

(fn OBJECT)〉〉enditem49840〈〈string-or-null-p〉〉:〈〈Return t if OBJECT is a string or nil.
Otherwise, return nil.

(fn OBJECT)〉〉enditem49840〈〈char-or-string-p〉〉:〈〈Return t if OBJECT is a character or a string.

(fn OBJECT)〉〉enditem49840〈〈ewoc-create〉〉:〈〈Create an empty ewoc.

The ewoc will be inserted in the current buffer at the current position.

PRETTY-PRINTER should be a function that takes one argument, an
element, and inserts a string representing it in the buffer (at
point).  The string PRETTY-PRINTER inserts may be empty or span
several lines.  The PRETTY-PRINTER should use ‘insert’, and not
‘insert-before-markers’.

Optional second and third arguments HEADER and FOOTER are strings,
possibly empty, that will always be present at the top and bottom,
respectively, of the ewoc.

Normally, a newline is automatically inserted after the header,
the footer and every node’s printed representation.  Optional
fourth arg NOSEP non-nil inhibits this.

(fn PRETTY-PRINTER &optional HEADER FOOTER NOSEP)〉〉enditem49840〈〈indirect-function〉〉:〈〈Return the function at the end of OBJECT’s function chain.
If OBJECT is not a symbol, just return it.  Otherwise, follow all
function indirections to find the final function binding and return it.
Signal a cyclic-function-indirection error if there is a loop in the
function chain of symbols.

(fn OBJECT &optional NOERROR)〉〉enditem49840〈〈set-network-process-option〉〉:〈〈For network process PROCESS set option OPTION to value VALUE.
See ‘make-network-process’ for a list of options and values.
If optional fourth arg NO-ERROR is non-nil, don’t signal an error if
OPTION is not a supported option, return nil instead; otherwise return t.

If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS OPTION VALUE &optional NO-ERROR)〉〉enditem49840〈〈face-spec-set〉〉:〈〈Set the FACE’s spec SPEC, define FACE, and recalculate its attributes.
See ‘defface’ for the format of SPEC.

The appearance of each face is controlled by its specs (set via
this function), and by the internal frame-specific face
attributes (set via ‘set-face-attribute’).

This function also defines FACE as a valid face name if it is not
already one, and (re)calculates its attributes on existing
frames.

The optional argument SPEC-TYPE determines which spec to set:
  nil, omitted or ‘face-override-spec’ means the override spec,
    which overrides all the other types of spec mentioned below
    (this is usually what you want if calling this function
    outside of Custom code);
  ‘customized-face’ or ‘saved-face’ means the customized spec or
    the saved custom spec;
  ‘face-defface-spec’ means the default spec
    (usually set only via ‘defface’);
  ‘reset’ means to ignore SPEC, but clear the ‘customized-face’
    and ‘face-override-spec’ specs;
Any other value means not to set any spec, but to run the
function for defining FACE and recalculating its attributes.

(fn FACE SPEC &optional SPEC-TYPE)〉〉enditem49840〈〈substitute-command-keys〉〉:〈〈Substitute key descriptions for command names in STRING.
Each substring of the form \[COMMAND] is replaced by either a
keystroke sequence that invokes COMMAND, or "M-x COMMAND" if COMMAND
is not on any keys.

Each substring of the form \{MAPVAR} is replaced by a summary of
the value of MAPVAR as a keymap.  This summary is similar to the one
produced by ‘describe-bindings’.  The summary ends in two newlines
(used by the helper function ‘help-make-xrefs’ to find the end of the
summary).

Each substring of the form \<MAPVAR> specifies the use of MAPVAR
as the keymap for future \[COMMAND] substrings.

Each grave accent ` is replaced by left quote, and each apostrophe '
is replaced by right quote.  Left and right quote characters are
specified by ‘text-quoting-style’.

\= quotes the following character and is discarded; thus, \=\= puts \=
into the output, \=\[ puts \[ into the output, and \=` puts ` into the
output.

Return the original STRING if no substitutions are made.
Otherwise, return a new string.

(fn STRING)〉〉enditem49840〈〈make-progress-reporter〉〉:〈〈Return progress reporter object for use with ‘progress-reporter-update’.

MESSAGE is shown in the echo area, with a status indicator
appended to the end.  When you call ‘progress-reporter-done’, the
word "done" is printed after the MESSAGE.  You can change the
MESSAGE of an existing progress reporter by calling
‘progress-reporter-force-update’.

MIN-VALUE and MAX-VALUE, if non-nil, are starting (0% complete)
and final (100% complete) states of operation; the latter should
be larger.  In this case, the status message shows the percentage
progress.

If MIN-VALUE and/or MAX-VALUE is omitted or nil, the status
message shows a "spinning", non-numeric indicator.

Optional CURRENT-VALUE is the initial progress; the default is
MIN-VALUE.
Optional MIN-CHANGE is the minimal change in percents to report;
the default is 1%.
CURRENT-VALUE and MIN-CHANGE do not have any effect if MIN-VALUE
and/or MAX-VALUE are nil.

Optional MIN-TIME specifies the minimum interval time between
echo area updates (default is 0.2 seconds.)  If the OS is not
capable of measuring fractions of seconds, this parameter is
effectively rounded up.

(fn MESSAGE &optional MIN-VALUE MAX-VALUE CURRENT-VALUE MIN-CHANGE MIN-TIME)〉〉enditem49840〈〈progress-reporter-update〉〉:〈〈Report progress of an operation in the echo area.
REPORTER should be the result of a call to ‘make-progress-reporter’.

If REPORTER is a numerical progress reporter---i.e. if it was
 made using non-nil MIN-VALUE and MAX-VALUE arguments to
 ‘make-progress-reporter’---then VALUE should be a number between
 MIN-VALUE and MAX-VALUE.

If REPORTER is a non-numerical reporter, VALUE should be nil.

This function is relatively inexpensive.  If the change since
last update is too small or insufficient time has passed, it does
nothing.

(fn REPORTER &optional VALUE)〉〉enditem49840〈〈progress-reporter-force-update〉〉:〈〈Report progress of an operation in the echo area unconditionally.

The first two arguments are the same as in ‘progress-reporter-update’.
NEW-MESSAGE, if non-nil, sets a new message for the reporter.

(fn REPORTER &optional VALUE NEW-MESSAGE)〉〉enditem49840〈〈progress-reporter-done〉〉:〈〈Print reporter’s message followed by word "done" in echo area.

(fn REPORTER)〉〉enditem49840〈〈current-buffer〉〉:〈〈Return the current buffer as a Lisp object.

(fn)〉〉enditem49840〈〈set-buffer〉〉:〈〈Make buffer BUFFER-OR-NAME current for editing operations.
BUFFER-OR-NAME may be a buffer or the name of an existing buffer.
See also ‘with-current-buffer’ when you want to make a buffer current
temporarily.  This function does not display the buffer, so its effect
ends when the current command terminates.  Use ‘switch-to-buffer’ or
‘pop-to-buffer’ to switch buffers permanently.
The return value is the buffer made current.

(fn BUFFER-OR-NAME)〉〉enditem49840〈〈minibufferp〉〉:〈〈Return t if BUFFER is a minibuffer.
No argument or nil as argument means use current buffer as BUFFER.
BUFFER can be a buffer or a buffer name.

(fn &optional BUFFER)〉〉enditem49840〈〈minibuffer-selected-window〉〉:〈〈Return window selected just before minibuffer window was selected.
Return nil if the selected window is not a minibuffer window.

(fn)〉〉enditem49840〈〈minibuffer-message〉〉:〈〈Temporarily display MESSAGE at the end of the minibuffer.
The text is displayed for ‘minibuffer-message-timeout’ seconds,
or until the next input event arrives, whichever comes first.
Enclose MESSAGE in [...] if this is not yet the case.
If ARGS are provided, then pass MESSAGE through ‘format-message’.

(fn MESSAGE &rest ARGS)〉〉enditem49840〈〈this-command-keys〉〉:〈〈Return the key sequence that invoked this command.
However, if the command has called ‘read-key-sequence’, it returns
the last key sequence that has been read.
The value is a string or a vector.

See also ‘this-command-keys-vector’.

(fn)〉〉enditem49840〈〈this-command-keys-vector〉〉:〈〈Return the key sequence that invoked this command, as a vector.
However, if the command has called ‘read-key-sequence’, it returns
the last key sequence that has been read.

See also ‘this-command-keys’.

(fn)〉〉enditem49840〈〈clear-this-command-keys〉〉:〈〈Clear out the vector that ‘this-command-keys’ returns.
Also clear the record of the last 100 events, unless optional arg
KEEP-RECORD is non-nil.

(fn &optional KEEP-RECORD)〉〉enditem49840〈〈markerp〉〉:〈〈Return t if OBJECT is a marker (editor pointer).

(fn OBJECT)〉〉enditem49840〈〈integer-or-marker-p〉〉:〈〈Return t if OBJECT is an integer or a marker (editor pointer).

(fn OBJECT)〉〉enditem49840〈〈number-or-marker-p〉〉:〈〈Return t if OBJECT is a number or a marker.

(fn OBJECT)〉〉enditem49840〈〈make-translation-table〉〉:〈〈Make a translation table from arguments.
A translation table is a char table intended for character
translation in CCL programs.

Each argument is a list of elements of the form (FROM . TO), where FROM
is a character to be translated to TO.

The arguments and forms in each argument are processed in the given
order, and if a previous form already translates TO to some other
character, say TO-ALT, FROM is also translated to TO-ALT.〉〉enditem49840〈〈make-translation-table-from-vector〉〉:〈〈Make translation table from decoding vector VEC.
VEC is an array of 256 elements to map unibyte codes to multibyte
characters.  Elements may be nil for undefined code points.〉〉enditem49840〈〈make-translation-table-from-alist〉〉:〈〈Make translation table from N<->M mapping in ALIST.
ALIST is an alist, each element has the form (FROM . TO).
FROM and TO are a character or a vector of characters.
If FROM is a character, that character is translated to TO.
If FROM is a vector of characters, that sequence is translated to TO.
The first extra-slot of the value is a translation table for reverse mapping.

FROM and TO may be nil.  If TO is nil, the translation from FROM
to nothing is defined in the translation table and that element
is ignored in the reverse map.  If FROM is nil, the translation
from TO to nothing is defined in the reverse map only.  A vector
of length zero has the same meaning as specifying nil.〉〉enditem49840〈〈sit-for〉〉:〈〈Redisplay, then wait for SECONDS seconds.  Stop when input is available.
SECONDS may be a floating-point value.
(On operating systems that do not support waiting for fractions of a
second, floating-point values are rounded down to the nearest integer.)

If optional arg NODISP is t, don’t redisplay, just wait for input.
Redisplay does not happen if input is available before it starts.

Value is t if waited the full time with no input arriving, and nil otherwise.

An obsolete, but still supported form is
(sit-for SECONDS &optional MILLISECONDS NODISP)
where the optional arg MILLISECONDS specifies an additional wait period,
in milliseconds; this was useful when Emacs was built without
floating point support.

(fn SECONDS &optional NODISP OBSOLETE)〉〉enditem49840〈〈sleep-for〉〉:〈〈Pause, without updating display, for SECONDS seconds.
SECONDS may be a floating-point value, meaning that you can wait for a
fraction of a second.  Optional second arg MILLISECONDS specifies an
additional wait period, in milliseconds; this is for backwards compatibility.
(Not all operating systems support waiting for a fraction of a second.)

(fn SECONDS &optional MILLISECONDS)〉〉enditem49840〈〈read-from-minibuffer〉〉:〈〈Read a string from the minibuffer, prompting with string PROMPT.
The optional second arg INITIAL-CONTENTS is an obsolete alternative to
  DEFAULT-VALUE.  It normally should be nil in new code, except when
  HIST is a cons.  It is discussed in more detail below.

Third arg KEYMAP is a keymap to use whilst reading;
  if omitted or nil, the default is ‘minibuffer-local-map’.

If fourth arg READ is non-nil, interpret the result as a Lisp object
  and return that object:
  in other words, do ‘(car (read-from-string INPUT-STRING))’

Fifth arg HIST, if non-nil, specifies a history list and optionally
  the initial position in the list.  It can be a symbol, which is the
  history list variable to use, or a cons cell (HISTVAR . HISTPOS).
  In that case, HISTVAR is the history list variable to use, and
  HISTPOS is the initial position for use by the minibuffer history
  commands.  For consistency, you should also specify that element of
  the history as the value of INITIAL-CONTENTS.  Positions are counted
  starting from 1 at the beginning of the list.

Sixth arg DEFAULT-VALUE, if non-nil, should be a string, which is used
  as the default to ‘read’ if READ is non-nil and the user enters
  empty input.  But if READ is nil, this function does _not_ return
  DEFAULT-VALUE for empty input!  Instead, it returns the empty string.

  Whatever the value of READ, DEFAULT-VALUE is made available via the
  minibuffer history commands.  DEFAULT-VALUE can also be a list of
  strings, in which case all the strings are available in the history,
  and the first string is the default to ‘read’ if READ is non-nil.

Seventh arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
 the current input method and the setting of ‘enable-multibyte-characters’.

If the variable ‘minibuffer-allow-text-properties’ is non-nil,
 then the string which is returned includes whatever text properties
 were present in the minibuffer.  Otherwise the value has no text properties.

The remainder of this documentation string describes the
INITIAL-CONTENTS argument in more detail.  It is only relevant when
studying existing code, or when HIST is a cons.  If non-nil,
INITIAL-CONTENTS is a string to be inserted into the minibuffer before
reading input.  Normally, point is put at the end of that string.
However, if INITIAL-CONTENTS is (STRING . POSITION), the initial
input is STRING, but point is placed at _one-indexed_ position
POSITION in the minibuffer.  Any integer value less than or equal to
one puts point at the beginning of the string.  *Note* that this
behavior differs from the way such arguments are used in ‘completing-read’
and some related functions, which use zero-indexing for POSITION.

(fn PROMPT &optional INITIAL-CONTENTS KEYMAP READ HIST DEFAULT-VALUE INHERIT-INPUT-METHOD)〉〉enditem49840〈〈read-string〉〉:〈〈Read a string from the minibuffer, prompting with string PROMPT.
If non-nil, second arg INITIAL-INPUT is a string to insert before reading.
  This argument has been superseded by DEFAULT-VALUE and should normally be nil
  in new code.  It behaves as INITIAL-CONTENTS in ‘read-from-minibuffer’ (which
  see).
The third arg HISTORY, if non-nil, specifies a history list
  and optionally the initial position in the list.
See ‘read-from-minibuffer’ for details of HISTORY argument.
Fourth arg DEFAULT-VALUE is the default value or the list of default values.
 If non-nil, it is used for history commands, and as the value (or the first
 element of the list of default values) to return if the user enters the
 empty string.
Fifth arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
 the current input method and the setting of ‘enable-multibyte-characters’.

(fn PROMPT &optional INITIAL-INPUT HISTORY DEFAULT-VALUE INHERIT-INPUT-METHOD)〉〉enditem49840〈〈read-regexp〉〉:〈〈Read and return a regular expression as a string.
Prompt with the string PROMPT.  If PROMPT ends in ":" (followed by
optional whitespace), use it as-is.  Otherwise, add ": " to the end,
possibly preceded by the default result (see below).

The optional argument DEFAULTS can be either: nil, a string, a list
of strings, or a symbol.  We use DEFAULTS to construct the default
return value in case of empty input.

If DEFAULTS is a string, we use it as-is.

If DEFAULTS is a list of strings, the first element is the
default return value, but all the elements are accessible
using the history command M-n.

If DEFAULTS is a non-nil symbol, then if ‘read-regexp-defaults-function’
is non-nil, we use that in place of DEFAULTS in the following:
  If DEFAULTS is the symbol ‘regexp-history-last’, we use the first
  element of HISTORY (if specified) or ‘regexp-history’.
  If DEFAULTS is a function, we call it with no arguments and use
  what it returns, which should be either nil, a string, or a list of strings.

We append the standard values from ‘read-regexp-suggestions’ to DEFAULTS
before using it.

If the first element of DEFAULTS is non-nil (and if PROMPT does not end
in ":", followed by optional whitespace), we add it to the prompt.

The optional argument HISTORY is a symbol to use for the history list.
If nil, uses ‘regexp-history’.

(fn PROMPT &optional DEFAULTS HISTORY)〉〉enditem49840〈〈read-no-blanks-input〉〉:〈〈Read a string from the terminal, not allowing blanks.
Prompt with PROMPT.  Whitespace terminates the input.  If INITIAL is
non-nil, it should be a string, which is used as initial input, with
point positioned at the end, so that SPACE will accept the input.
(Actually, INITIAL can also be a cons of a string and an integer.
Such values are treated as in ‘read-from-minibuffer’, but are normally
not useful in this function.)
Third arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits
the current input method and the setting of‘enable-multibyte-characters’.

(fn PROMPT &optional INITIAL INHERIT-INPUT-METHOD)〉〉enditem49840〈〈frame-visible-p〉〉:〈〈Return t if FRAME is "visible" (actually in use for display).
Return the symbol ‘icon’ if FRAME is iconified or "minimized".
Return nil if FRAME was made invisible, via ‘make-frame-invisible’.
On graphical displays, invisible frames are not updated and are
usually not displayed at all, even in a window system’s "taskbar".

If FRAME is a text terminal frame, this always returns t.
Such frames are always considered visible, whether or not they are
currently being displayed on the terminal.

(fn FRAME)〉〉enditem49840〈〈make-process〉〉:〈〈Start a program in a subprocess.  Return the process object for it.

This is similar to ‘start-process’, but arguments are specified as
keyword/argument pairs.  The following arguments are defined:

:name NAME -- NAME is name for process.  It is modified if necessary
to make it unique.

:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
with the process.  Process output goes at end of that buffer, unless
you specify a filter function to handle the output.  BUFFER may be
also nil, meaning that this process is not associated with any buffer.

:command COMMAND -- COMMAND is a list starting with the program file
name, followed by strings to give to the program as arguments.

:coding CODING -- If CODING is a symbol, it specifies the coding
system used for both reading and writing for this process.  If CODING
is a cons (DECODING . ENCODING), DECODING is used for reading, and
ENCODING is used for writing.

:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
the process is running.  If BOOL is not given, query before exiting.

:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.
In the stopped state, a process does not accept incoming data, but you
can send outgoing data.  The stopped state is cleared by
‘continue-process’ and set by ‘stop-process’.

:connection-type TYPE -- TYPE is control type of device used to
communicate with subprocesses.  Values are ‘pipe’ to use a pipe, ‘pty’
to use a pty, or nil to use the default specified through
‘process-connection-type’.

:filter FILTER -- Install FILTER as the process filter.

:sentinel SENTINEL -- Install SENTINEL as the process sentinel.

:stderr STDERR -- STDERR is either a buffer or a pipe process attached
to the standard error of subprocess.  Specifying this implies
‘:connection-type’ is set to ‘pipe’.

(fn &rest ARGS)〉〉enditem49840〈〈make-pipe-process〉〉:〈〈Create and return a bidirectional pipe process.

In Emacs, pipes are represented by process objects, so input and
output work as for subprocesses, and ‘delete-process’ closes a pipe.
However, a pipe process has no process id, it cannot be signaled,
and the status codes are different from normal processes.

Arguments are specified as keyword/argument pairs.  The following
arguments are defined:

:name NAME -- NAME is the name of the process.  It is modified if necessary to make it unique.

:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
with the process.  Process output goes at the end of that buffer,
unless you specify a filter function to handle the output.  If BUFFER
is not given, the value of NAME is used.

:coding CODING -- If CODING is a symbol, it specifies the coding
system used for both reading and writing for this process.  If CODING
is a cons (DECODING . ENCODING), DECODING is used for reading, and
ENCODING is used for writing.

:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and
the process is running.  If BOOL is not given, query before exiting.

:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.
In the stopped state, a pipe process does not accept incoming data,
but you can send outgoing data.  The stopped state is cleared by
‘continue-process’ and set by ‘stop-process’.

:filter FILTER -- Install FILTER as the process filter.

:sentinel SENTINEL -- Install SENTINEL as the process sentinel.

(fn &rest ARGS)〉〉enditem49840〈〈start-process〉〉:〈〈Start a program in a subprocess.  Return the process object for it.
NAME is name for process.  It is modified if necessary to make it unique.
BUFFER is the buffer (or buffer name) to associate with the process.

Process output (both standard output and standard error streams)
goes at end of BUFFER, unless you specify a filter function to
handle the output.  BUFFER may also be nil, meaning that this
process is not associated with any buffer.

PROGRAM is the program file name.  It is searched for in ‘exec-path’
(which see).  If nil, just associate a pty with the buffer.  Remaining
arguments PROGRAM-ARGS are strings to give program as arguments.

If you want to separate standard output from standard error, use
‘make-process’ or invoke the command through a shell and redirect
one of them using the shell syntax.

The process runs in ‘default-directory’ if that is local (as
determined by ‘unhandled-file-name-directory’), or "~"
otherwise.  If you want to run a process in a remote directory
use ‘start-file-process’.

(fn NAME BUFFER PROGRAM &rest PROGRAM-ARGS)〉〉enditem49840〈〈start-file-process〉〉:〈〈Start a program in a subprocess.  Return the process object for it.

Similar to ‘start-process’, but may invoke a file handler based on
‘default-directory’.  See Info node ‘(elisp)Magic File Names’.

This handler ought to run PROGRAM, perhaps on the local host,
perhaps on a remote host that corresponds to ‘default-directory’.
In the latter case, the local part of ‘default-directory’ becomes
the working directory of the process.

PROGRAM and PROGRAM-ARGS might be file names.  They are not
objects of file handler invocation.  File handlers might not
support pty association, if PROGRAM is nil.

(fn NAME BUFFER PROGRAM &rest PROGRAM-ARGS)〉〉enditem49840〈〈start-process-shell-command〉〉:〈〈Start a program in a subprocess.  Return the process object for it.
NAME is name for process.  It is modified if necessary to make it unique.
BUFFER is the buffer (or buffer name) to associate with the process.
 Process output goes at end of that buffer, unless you specify
 an output stream or filter function to handle the output.
 BUFFER may be also nil, meaning that this process is not associated
 with any buffer
COMMAND is the shell command to run.

An old calling convention accepted any number of arguments after COMMAND,
which were just concatenated to COMMAND.  This is still supported but strongly
discouraged.

(fn NAME BUFFER &rest ARGS)〉〉enditem49840〈〈start-file-process-shell-command〉〉:〈〈Start a program in a subprocess.  Return the process object for it.
Similar to ‘start-process-shell-command’, but calls ‘start-file-process’.

(fn NAME BUFFER &rest ARGS)〉〉enditem49840〈〈find-file-name-handler〉〉:〈〈Return FILENAME’s handler function for OPERATION, if it has one.
Otherwise, return nil.
A file name is handled if one of the regular expressions in
‘file-name-handler-alist’ matches it.

If OPERATION equals ‘inhibit-file-name-operation’, then ignore
any handlers that are members of ‘inhibit-file-name-handlers’,
but still do run any other handlers.  This lets handlers
use the standard functions without calling themselves recursively.

(fn FILENAME OPERATION)〉〉enditem49840〈〈file-local-copy〉〉:〈〈Copy the file FILE into a temporary file on this machine.
Returns the name of the local copy, or nil, if FILE is directly
accessible.

(fn FILE)〉〉enditem49840〈〈file-remote-p〉〉:〈〈Test whether FILE specifies a location on a remote system.
A file is considered remote if accessing it is likely to
be slower or less reliable than accessing local files.

‘file-remote-p’ never opens a new remote connection.  It can
only reuse a connection that is already open.

Return nil or a string identifying the remote connection
(ideally a prefix of FILE).  Return nil if FILE is a relative
file name.

When IDENTIFICATION is nil, the returned string is a complete
remote identifier: with components method, user, and host.  The
components are those present in FILE, with defaults filled in for
any that are missing.

IDENTIFICATION can specify which part of the identification to
return.  IDENTIFICATION can be the symbol ‘method’, ‘user’,
‘host’, or ‘localname’.  Any other value is handled like nil and
means to return the complete identification.  The string returned
for IDENTIFICATION ‘localname’ can differ depending on whether
there is an existing connection.

If CONNECTED is non-nil, return an identification only if FILE is
located on a remote system and a connection is established to
that remote system.

Tip: You can use this expansion of remote identifier components
     to derive a new remote file name from an existing one.  For
     example, if FILE is "/sudo::/path/to/file" then

       (concat (file-remote-p FILE) "/bin/sh")

     returns a remote file name for file "/bin/sh" that has the
     same remote identifier as FILE but expanded; a name such as
     "/sudo:root@myhost:/bin/sh".

(fn FILE &optional IDENTIFICATION CONNECTED)〉〉enditem49840〈〈unhandled-file-name-directory〉〉:〈〈Return a directly usable directory name somehow associated with FILENAME.
A ‘directly usable’ directory name is one that may be used without the
intervention of any file handler.
If FILENAME is a directly usable file itself, return
(file-name-as-directory FILENAME).
If FILENAME refers to a file which is not accessible from a local process,
then this should return nil.
The ‘call-process’ and ‘start-process’ functions use this function to
get a current directory to run processes in.

(fn FILENAME)〉〉enditem49840〈〈match-data〉〉:〈〈Return a list describing what the last search matched.
Element 2N is ‘(match-beginning N)’; element 2N + 1 is ‘(match-end N)’.
All the elements are markers or nil (nil if the Nth pair didn’t match)
if the last match was on a buffer; integers or nil if a string was matched.
Use ‘set-match-data’ to reinstate the data in this list.

If INTEGERS (the optional first argument) is non-nil, always use
integers (rather than markers) to represent buffer positions.  In
this case, and if the last match was in a buffer, the buffer will get
stored as one additional element at the end of the list.

If REUSE is a list, reuse it as part of the value.  If REUSE is long
enough to hold all the values, and if INTEGERS is non-nil, no consing
is done.

If optional third arg RESEAT is non-nil, any previous markers on the
REUSE list will be modified to point to nowhere.

Return value is undefined if the last search failed.

(fn &optional INTEGERS REUSE RESEAT)〉〉enditem49840〈〈set-match-data〉〉:〈〈Set internal data on last search match from elements of LIST.
LIST should have been created by calling ‘match-data’ previously.

If optional arg RESEAT is non-nil, make markers on LIST point nowhere.

(fn LIST &optional RESEAT)〉〉enditem49840〈〈overlay-get〉〉:〈〈Get the property of overlay OVERLAY with property name PROP.

(fn OVERLAY PROP)〉〉enditem49840〈〈overlay-put〉〉:〈〈Set one property of overlay OVERLAY: give property PROP value VALUE.
VALUE will be returned.

(fn OVERLAY PROP VALUE)〉〉enditem49840〈〈overlay-properties〉〉:〈〈Return a list of the properties on OVERLAY.
This is a copy of OVERLAY’s plist; modifying its conses has no effect on
OVERLAY.

(fn OVERLAY)〉〉enditem49840〈〈file-name-absolute-p〉〉:〈〈Return t if FILENAME is an absolute file name or starts with ‘~’.
On Unix, absolute file names start with ‘/’.

(fn FILENAME)〉〉enditem49840〈〈file-relative-name〉〉:〈〈Convert FILENAME to be relative to DIRECTORY (default: ‘default-directory’).
This function returns a relative file name which is equivalent to FILENAME
when used with that default directory as the default.
If FILENAME is a relative file name, it will be interpreted as existing in
‘default-directory’.
If FILENAME and DIRECTORY lie on different machines or on different drives
on a DOS/Windows machine, it returns FILENAME in expanded form.

(fn FILENAME &optional DIRECTORY)〉〉enditem49840〈〈hack-dir-local-variables〉〉:〈〈Read per-directory local variables for the current buffer.
Store the directory-local variables in ‘dir-local-variables-alist’
and ‘file-local-variables-alist’, without applying them.

This does nothing if either ‘enable-local-variables’ or
‘enable-dir-local-variables’ are nil.〉〉enditem49840〈〈hack-dir-local-variables-non-file-buffer〉〉:〈〈Apply directory-local variables to a non-file buffer.
For non-file buffers, such as Dired buffers, directory-local
variables are looked for in ‘default-directory’ and its parent
directories.〉〉enditem49840〈〈dir-locals-set-class-variables〉〉:〈〈Map the type CLASS to a list of variable settings.
CLASS is the project class, a symbol.  VARIABLES is a list
that declares directory-local variables for the class.
An element in VARIABLES is either of the form:
    (MAJOR-MODE . ALIST)
or
    (DIRECTORY . LIST)

In the first form, MAJOR-MODE is a symbol, and ALIST is an alist
whose elements are of the form (VARIABLE . VALUE).

In the second form, DIRECTORY is a directory name (a string), and
LIST is a list of the form accepted by the function.

When a file is visited, the file’s class is found.  A directory
may be assigned a class using ‘dir-locals-set-directory-class’.
Then variables are set in the file’s buffer according to the
VARIABLES list of the class.  The list is processed in order.

* If the element is of the form (MAJOR-MODE . ALIST), and the
  buffer’s major mode is derived from MAJOR-MODE (as determined
  by ‘derived-mode-p’), then all the variables in ALIST are
  applied.  A MAJOR-MODE of nil may be used to match any buffer.
  ‘make-local-variable’ is called for each variable before it is
  set.

* If the element is of the form (DIRECTORY . LIST), and DIRECTORY
  is an initial substring of the file’s directory, then LIST is
  applied by recursively following these rules.

(fn CLASS VARIABLES)〉〉enditem49840〈〈dir-locals-set-directory-class〉〉:〈〈Declare that the DIRECTORY root is an instance of CLASS.
DIRECTORY is the name of a directory, a string.
CLASS is the name of a project class, a symbol.
MTIME is either the modification time of the directory-local
variables file that defined this class, or nil.

When a file beneath DIRECTORY is visited, the mode-specific
variables from CLASS are applied to the buffer.  The variables
for a class are defined using ‘dir-locals-set-class-variables’.

(fn DIRECTORY CLASS &optional MTIME)〉〉enditem49840〈〈make-button〉〉:〈〈Make a button from BEG to END in the current buffer.
The remaining arguments form a sequence of PROPERTY VALUE pairs,
specifying properties to add to the button.
In addition, the keyword argument :type may be used to specify a
button-type from which to inherit other properties; see
‘define-button-type’.

Also see ‘make-text-button’, ‘insert-button’.〉〉enditem49840〈〈insert-button〉〉:〈〈Insert a button with the label LABEL.
The remaining arguments form a sequence of PROPERTY VALUE pairs,
specifying properties to add to the button.
In addition, the keyword argument :type may be used to specify a
button-type from which to inherit other properties; see
‘define-button-type’.

Also see ‘insert-text-button’, ‘make-button’.〉〉enditem49840〈〈make-text-button〉〉:〈〈Make a button from BEG to END in the current buffer.
The remaining arguments form a sequence of PROPERTY VALUE pairs,
specifying properties to add to the button.
In addition, the keyword argument :type may be used to specify a
button-type from which to inherit other properties; see
‘define-button-type’.

This function is like ‘make-button’, except that the button is actually
part of the text instead of being a property of the buffer.  That is,
this function uses text properties, the other uses overlays.
Creating large numbers of buttons can also be somewhat faster
using ‘make-text-button’.  Note, however, that if there is an existing
face property at the site of the button, the button face may not be visible.
You may want to use ‘make-button’ in that case.

BEG can also be a string, in which case it is made into a button.

Also see ‘insert-text-button’.〉〉enditem49840〈〈insert-text-button〉〉:〈〈Insert a button with the label LABEL.
The remaining arguments form a sequence of PROPERTY VALUE pairs,
specifying properties to add to the button.
In addition, the keyword argument :type may be used to specify a
button-type from which to inherit other properties; see
‘define-button-type’.

This function is like ‘insert-button’, except that the button is
actually part of the text instead of being a property of the buffer.
Creating large numbers of buttons can also be somewhat faster using
‘insert-text-button’.

Also see ‘make-text-button’.〉〉enditem49840〈〈insert-image〉〉:〈〈Insert IMAGE into current buffer at point.
IMAGE is displayed by inserting STRING into the current buffer
with a ‘display’ property whose value is the image.  STRING
defaults to a single space if you omit it.
AREA is where to display the image.  AREA nil or omitted means
display it in the text area, a value of ‘left-margin’ means
display it in the left marginal area, a value of ‘right-margin’
means display it in the right marginal area.
SLICE specifies slice of IMAGE to insert.  SLICE nil or omitted
means insert whole image.  SLICE is a list (X Y WIDTH HEIGHT)
specifying the X and Y positions and WIDTH and HEIGHT of image area
to insert.  A float value 0.0 - 1.0 means relative to the width or
height of the image; integer values are taken as pixel values.

(fn IMAGE &optional STRING AREA SLICE)〉〉enditem49840〈〈insert-sliced-image〉〉:〈〈Insert IMAGE into current buffer at point.
IMAGE is displayed by inserting STRING into the current buffer
with a ‘display’ property whose value is the image.  The default
STRING is a single space.
AREA is where to display the image.  AREA nil or omitted means
display it in the text area, a value of ‘left-margin’ means
display it in the left marginal area, a value of ‘right-margin’
means display it in the right marginal area.
The image is automatically split into ROWS x COLS slices.

(fn IMAGE &optional STRING AREA ROWS COLS)〉〉enditem49840〈〈put-image〉〉:〈〈Put image IMAGE in front of POS in the current buffer.
IMAGE must be an image created with ‘create-image’ or ‘defimage’.
IMAGE is displayed by putting an overlay into the current buffer with a
‘before-string’ STRING that has a ‘display’ property whose value is the
image.  STRING is defaulted if you omit it.
The overlay created will have the ‘put-image’ property set to t.
POS may be an integer or marker.
AREA is where to display the image.  AREA nil or omitted means
display it in the text area, a value of ‘left-margin’ means
display it in the left marginal area, a value of ‘right-margin’
means display it in the right marginal area.

(fn IMAGE POS &optional STRING AREA)〉〉enditem49840〈〈remove-images〉〉:〈〈Remove images between START and END in BUFFER.
Remove only images that were put in BUFFER with calls to ‘put-image’.
BUFFER nil or omitted means use the current buffer.

(fn START END &optional BUFFER)〉〉enditem49840〈〈image-size〉〉:〈〈Return the size of image SPEC as pair (WIDTH . HEIGHT).
PIXELS non-nil means return the size in pixels, otherwise return the
size in canonical character units.
FRAME is the frame on which the image will be displayed.  FRAME nil
or omitted means use the selected frame.

(fn SPEC &optional PIXELS FRAME)〉〉enditem49840〈〈insert-file-contents〉〉:〈〈Insert contents of file FILENAME after point.
Returns list of absolute file name and number of characters inserted.
If second argument VISIT is non-nil, the buffer’s visited filename and
last save file modtime are set, and it is marked unmodified.  If
visiting and the file does not exist, visiting is completed before the
error is signaled.

The optional third and fourth arguments BEG and END specify what portion
of the file to insert.  These arguments count bytes in the file, not
characters in the buffer.  If VISIT is non-nil, BEG and END must be nil.

If optional fifth argument REPLACE is non-nil, replace the current
buffer contents (in the accessible portion) with the file contents.
This is better than simply deleting and inserting the whole thing
because (1) it preserves some marker positions and (2) it puts less data
in the undo list.  When REPLACE is non-nil, the second return value is
the number of characters that replace previous buffer contents.

This function does code conversion according to the value of
‘coding-system-for-read’ or ‘file-coding-system-alist’, and sets the
variable ‘last-coding-system-used’ to the coding system actually used.

In addition, this function decodes the inserted text from known formats
by calling ‘format-decode’, which see.

(fn FILENAME &optional VISIT BEG END REPLACE)〉〉enditem49840〈〈insert-file-contents-literally〉〉:〈〈Like ‘insert-file-contents’, but only reads in the file literally.
See ‘insert-file-contents’ for an explanation of the parameters.
A buffer may be modified in several ways after reading into the buffer,
due to Emacs features such as format decoding, character code
conversion, ‘find-file-hook’, automatic uncompression, etc.

This function ensures that none of these modifications will take place.

(fn FILENAME &optional VISIT BEG END REPLACE)〉〉enditem49840〈〈format〉〉:〈〈Format a string out of a format-string and arguments.
The first argument is a format control string.
The other arguments are substituted into it to make the result, a string.

The format control string may contain %-sequences meaning to substitute
the next available argument, or the argument explicitly specified:

%s means print a string argument.  Actually, prints any object, with ‘princ’.
%d means print as signed number in decimal.
%o means print as unsigned number in octal, %x as unsigned number in hex.
%X is like %x, but uses upper case.
%e means print a number in exponential notation.
%f means print a number in decimal-point notation.
%g means print a number in exponential notation if the exponent would be
   less than -4 or greater than or equal to the precision (default: 6);
   otherwise it prints in decimal-point notation.
%c means print a number as a single character.
%S means print any object as an s-expression (using ‘prin1’).

The argument used for %d, %o, %x, %e, %f, %g or %c must be a number.
Use %% to put a single % into the output.

A %-sequence other than %% may contain optional field number, flag,
width, and precision specifiers, as follows:

  %<field><flags><width><precision>character

where field is [0-9]+ followed by a literal dollar "$", flags is
[+ #-0]+, width is [0-9]+, and precision is a literal period "."
followed by [0-9]+.

If a %-sequence is numbered with a field with positive value N, the
Nth argument is substituted instead of the next one.  A format can
contain either numbered or unnumbered %-sequences but not both, except
that %% can be mixed with numbered %-sequences.

The + flag character inserts a + before any positive number, while a
space inserts a space before any positive number; these flags only
affect %d, %e, %f, and %g sequences, and the + flag takes precedence.
The - and 0 flags affect the width specifier, as described below.

The # flag means to use an alternate display form for %o, %x, %X, %e,
%f, and %g sequences: for %o, it ensures that the result begins with
"0"; for %x and %X, it prefixes the result with "0x" or "0X";
for %e and %f, it causes a decimal point to be included even if the
precision is zero; for %g, it causes a decimal point to be
included even if the precision is zero, and also forces trailing
zeros after the decimal point to be left in place.

The width specifier supplies a lower limit for the length of the
printed representation.  The padding, if any, normally goes on the
left, but it goes on the right if the - flag is present.  The padding
character is normally a space, but it is 0 if the 0 flag is present.
The 0 flag is ignored if the - flag is present, or the format sequence
is something other than %d, %e, %f, and %g.

For %e and %f sequences, the number after the "." in the precision
specifier says how many decimal places to show; if zero, the decimal
point itself is omitted.  For %g, the precision specifies how many
significant digits to print; zero or omitted are treated as 1.
For %s and %S, the precision specifier truncates the string to the
given width.

Text properties, if any, are copied from the format-string to the
produced text.

(fn STRING &rest OBJECTS)〉〉enditem49840〈〈format-message〉〉:〈〈Format a string out of a format-string and arguments.
The first argument is a format control string.
The other arguments are substituted into it to make the result, a string.

This acts like ‘format’, except it also replaces each grave accent (`)
by a left quote, and each apostrophe (') by a right quote.  The left
and right quote replacement characters are specified by
‘text-quoting-style’.

(fn STRING &rest OBJECTS)〉〉enditem49840〈〈run-mode-hooks〉〉:〈〈Run mode hooks ‘delayed-mode-hooks’ and HOOKS, or delay HOOKS.
Call ‘hack-local-variables’ to set up file local and directory local
variables.

If the variable ‘delay-mode-hooks’ is non-nil, does not do anything,
just adds the HOOKS to the list ‘delayed-mode-hooks’.
Otherwise, runs hooks in the sequence: ‘change-major-mode-after-body-hook’,
‘delayed-mode-hooks’ (in reverse order), HOOKS, then runs
‘hack-local-variables’, runs the hook ‘after-change-major-mode-hook’, and
finally evaluates the functions in ‘delayed-after-hook-functions’ (see
‘define-derived-mode’).

Major mode functions should use this instead of ‘run-hooks’ when
running their FOO-mode-hook.

(fn &rest HOOKS)〉〉enditem49840〈〈cl-call-next-method〉〉:〈〈Function to call the next applicable method.
Can only be used from within the lexical body of a primary or around method.

(fn &rest ARGS)〉〉enditem49840〈〈cl-next-method-p〉〉:〈〈Return non-nil if there is a next method.
Can only be used from within the lexical body of a primary or around method.〉〉enditem49840〈〈char-equal〉〉:〈〈Return t if two characters match, optionally ignoring case.
Both arguments must be characters (i.e. integers).
Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.

(fn C1 C2)〉〉enditem49840〈〈string-equal〉〉:〈〈Return t if two strings have identical contents.
Case is significant, but text properties are ignored.
Symbols are also allowed; their print names are used instead.

(fn S1 S2)〉〉enditem49840〈〈string-collate-equalp〉〉:〈〈Return t if two strings have identical contents.
Symbols are also allowed; their print names are used instead.

This function obeys the conventions for collation order in your locale
settings.  For example, characters with different coding points but
the same meaning might be considered as equal, like different grave
accent Unicode characters:

(string-collate-equalp (string ?\uFF40) (string ?\u1FEF))
  => t

The optional argument LOCALE, a string, overrides the setting of your
current locale identifier for collation.  The value is system
dependent; a LOCALE "en_US.UTF-8" is applicable on POSIX systems,
while it would be "enu_USA.1252" on MS Windows systems.

If IGNORE-CASE is non-nil, characters are converted to lower-case
before comparing them.

To emulate Unicode-compliant collation on MS-Windows systems,
bind ‘w32-collate-ignore-punctuation’ to a non-nil value, since
the codeset part of the locale cannot be "UTF-8" on MS-Windows.

If your system does not support a locale environment, this function
behaves like ‘string-equal’.

Do NOT use this function to compare file names for equality.

(fn S1 S2 &optional LOCALE IGNORE-CASE)〉〉enditem49840〈〈string-prefix-p〉〉:〈〈Return non-nil if PREFIX is a prefix of STRING.
If IGNORE-CASE is non-nil, the comparison is done without paying attention
to case differences.

(fn PREFIX STRING &optional IGNORE-CASE)〉〉enditem49840〈〈string-suffix-p〉〉:〈〈Return non-nil if SUFFIX is a suffix of STRING.
If IGNORE-CASE is non-nil, the comparison is done without paying
attention to case differences.

(fn SUFFIX STRING &optional IGNORE-CASE)〉〉enditem49840〈〈string-lessp〉〉:〈〈Return non-nil if STRING1 is less than STRING2 in lexicographic order.
Case is significant.
Symbols are also allowed; their print names are used instead.

(fn STRING1 STRING2)〉〉enditem49840〈〈string-greaterp〉〉:〈〈Return non-nil if STRING1 is greater than STRING2 in lexicographic order.
Case is significant.
Symbols are also allowed; their print names are used instead.

(fn STRING1 STRING2)〉〉enditem49840〈〈string-collate-lessp〉〉:〈〈Return t if first arg string is less than second in collation order.
Symbols are also allowed; their print names are used instead.

This function obeys the conventions for collation order in your
locale settings.  For example, punctuation and whitespace characters
might be considered less significant for sorting:

(sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp)
  => ("11" "1 1" "1.1" "12" "1 2" "1.2")

The optional argument LOCALE, a string, overrides the setting of your
current locale identifier for collation.  The value is system
dependent; a LOCALE "en_US.UTF-8" is applicable on POSIX systems,
while it would be, e.g., "enu_USA.1252" on MS-Windows systems.

If IGNORE-CASE is non-nil, characters are converted to lower-case
before comparing them.

To emulate Unicode-compliant collation on MS-Windows systems,
bind ‘w32-collate-ignore-punctuation’ to a non-nil value, since
the codeset part of the locale cannot be "UTF-8" on MS-Windows.

If your system does not support a locale environment, this function
behaves like ‘string-lessp’.

(fn S1 S2 &optional LOCALE IGNORE-CASE)〉〉enditem49840〈〈compare-strings〉〉:〈〈Compare the contents of two strings, converting to multibyte if needed.
The arguments START1, END1, START2, and END2, if non-nil, are
positions specifying which parts of STR1 or STR2 to compare.  In
string STR1, compare the part between START1 (inclusive) and END1
(exclusive).  If START1 is nil, it defaults to 0, the beginning of
the string; if END1 is nil, it defaults to the length of the string.
Likewise, in string STR2, compare the part between START2 and END2.
Like in ‘substring’, negative values are counted from the end.

The strings are compared by the numeric values of their characters.
For instance, STR1 is "less than" STR2 if its first differing
character has a smaller numeric value.  If IGNORE-CASE is non-nil,
characters are converted to upper-case before comparing them.  Unibyte
strings are converted to multibyte for comparison.

The value is t if the strings (or specified portions) match.
If string STR1 is less, the value is a negative number N;
  - 1 - N is the number of characters that match at the beginning.
If string STR1 is greater, the value is a positive number N;
  N - 1 is the number of characters that match at the beginning.

(fn STR1 START1 END1 STR2 START2 END2 &optional IGNORE-CASE)〉〉enditem49840〈〈assoc-string〉〉:〈〈Like ‘assoc’ but specifically for strings (and symbols).

This returns the first element of LIST whose car matches the string or
symbol KEY, or nil if no match exists.  When performing the
comparison, symbols are first converted to strings, and unibyte
strings to multibyte.  If the optional arg CASE-FOLD is non-nil, both
KEY and the elements of LIST are upcased for comparison.

Unlike ‘assoc’, KEY can also match an entry in LIST consisting of a
single string, rather than a cons cell whose car is a string.

(fn KEY LIST &optional CASE-FOLD)〉〉enditem49840〈〈display-popup-menus-p〉〉:〈〈Return non-nil if popup menus are supported on DISPLAY.
DISPLAY can be a display name, a frame, or nil (meaning the selected
frame’s display).
Support for popup menus requires that the mouse be available.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-graphic-p〉〉:〈〈Return non-nil if DISPLAY is a graphic display.
Graphical displays are those which are capable of displaying several
frames and several different fonts at once.  This is true for displays
that use a window system such as X, and false for text-only terminals.
DISPLAY can be a display name, a frame, or nil (meaning the selected
frame’s display).

(fn &optional DISPLAY)〉〉enditem49840〈〈display-mouse-p〉〉:〈〈Return non-nil if DISPLAY has a mouse available.
DISPLAY can be a display name, a frame, or nil (meaning the selected
frame’s display).

(fn &optional DISPLAY)〉〉enditem49840〈〈display-color-p〉〉:〈〈Return t if DISPLAY supports color.
The optional argument DISPLAY specifies which display to ask about.
DISPLAY should be either a frame or a display name (a string).
If omitted or nil, that stands for the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-grayscale-p〉〉:〈〈Return non-nil if frames on DISPLAY can display shades of gray.
DISPLAY should be either a frame or a display name (a string).
If omitted or nil, that stands for the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-supports-face-attributes-p〉〉:〈〈Return non-nil if all the face attributes in ATTRIBUTES are supported.
The optional argument DISPLAY can be a display name, a frame, or
nil (meaning the selected frame’s display).

The definition of ‘supported’ is somewhat heuristic, but basically means
that a face containing all the attributes in ATTRIBUTES, when merged
with the default face for display, can be represented in a way that’s

 (1) different in appearance than the default face, and
 (2) ‘close in spirit’ to what the attributes specify, if not exact.

Point (2) implies that a ‘:weight black’ attribute will be satisfied by
any display that can display bold, and a ‘:foreground "yellow"’ as long
as it can display a yellowish color, but ‘:slant italic’ will _not_ be
satisfied by the tty display code’s automatic substitution of a ‘dim’
face for italic.

(fn ATTRIBUTES &optional DISPLAY)〉〉enditem49840〈〈display-selections-p〉〉:〈〈Return non-nil if DISPLAY supports selections.
A selection is a way to transfer text or other data between programs
via special system buffers called ‘selection’ or ‘clipboard’.
DISPLAY can be a display name, a frame, or nil (meaning the selected
frame’s display).

(fn &optional DISPLAY)〉〉enditem49840〈〈display-images-p〉〉:〈〈Return non-nil if DISPLAY can display images.

DISPLAY can be a display name, a frame, or nil (meaning the selected
frame’s display).

(fn &optional DISPLAY)〉〉enditem49840〈〈display-screens〉〉:〈〈Return the number of screens associated with DISPLAY.
DISPLAY should be either a frame or a display name (a string).
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-pixel-height〉〉:〈〈Return the height of DISPLAY’s screen in pixels.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

For character terminals, each character counts as a single pixel.

For graphical terminals, note that on "multi-monitor" setups this
refers to the pixel height for all physical monitors associated
with DISPLAY.  To get information for each physical monitor, use
‘display-monitor-attributes-list’.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-pixel-width〉〉:〈〈Return the width of DISPLAY’s screen in pixels.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

For character terminals, each character counts as a single pixel.

For graphical terminals, note that on "multi-monitor" setups this
refers to the pixel width for all physical monitors associated
with DISPLAY.  To get information for each physical monitor, use
‘display-monitor-attributes-list’.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-mm-height〉〉:〈〈Return the height of DISPLAY’s screen in millimeters.
If the information is unavailable, this function returns nil.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

You can override what the system thinks the result should be by
adding an entry to ‘display-mm-dimensions-alist’.

For graphical terminals, note that on "multi-monitor" setups this
refers to the height in millimeters for all physical monitors
associated with DISPLAY.  To get information for each physical
monitor, use ‘display-monitor-attributes-list’.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-mm-width〉〉:〈〈Return the width of DISPLAY’s screen in millimeters.
If the information is unavailable, this function returns nil.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

You can override what the system thinks the result should be by
adding an entry to ‘display-mm-dimensions-alist’.

For graphical terminals, note that on "multi-monitor" setups this
refers to the width in millimeters for all physical monitors
associated with DISPLAY.  To get information for each physical
monitor, use ‘display-monitor-attributes-list’.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-backing-store〉〉:〈〈Return the backing store capability of DISPLAY’s screen.
The value may be ‘always’, ‘when-mapped’, ‘not-useful’, or nil if
the question is inapplicable to a certain kind of display.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-save-under〉〉:〈〈Return non-nil if DISPLAY’s screen supports the SaveUnder feature.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-planes〉〉:〈〈Return the number of planes supported by DISPLAY.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-visual-class〉〉:〈〈Return the visual class of DISPLAY.
The value is one of the symbols ‘static-gray’, ‘gray-scale’,
‘static-color’, ‘pseudo-color’, ‘true-color’, or ‘direct-color’.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈display-color-cells〉〉:〈〈Return the number of color cells supported by DISPLAY.
DISPLAY can be a display name or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.

(fn &optional DISPLAY)〉〉enditem49840〈〈x-server-version〉〉:〈〈Return the version numbers of the GUI software on TERMINAL.
The value is a list of three integers specifying the version of the GUI
software in use.

For GNU and Unix system, the first 2 numbers are the version of the X
Protocol used on TERMINAL and the 3rd number is the distributor-specific
release number.  For MS-Windows, the 3 numbers report the version and
the build number of the OS.

See also the function ‘x-server-vendor’.

The optional argument TERMINAL specifies which display to ask about.
TERMINAL should be a terminal object, a frame or a display name (a string).
If omitted or nil, that stands for the selected frame’s display.

(fn &optional FRAME)〉〉enditem49840〈〈x-server-vendor〉〉:〈〈Return the "vendor ID" string of the GUI software on TERMINAL.

(Labeling every distributor as a "vendor" embodies the false assumption
that operating systems cannot be developed and distributed noncommercially.)

For GNU and Unix systems, this queries the X server software; for
MS-Windows, this queries the OS.

The optional argument TERMINAL specifies which display to ask about.
TERMINAL should be a terminal object, a frame or a display name (a string).
If omitted or nil, that stands for the selected frame’s display.

(fn &optional FRAME)〉〉enditem49840〈〈define-prefix-command〉〉:〈〈Define COMMAND as a prefix command.  COMMAND should be a symbol.
A new sparse keymap is stored as COMMAND’s function definition and its
value.
This prepares COMMAND for use as a prefix key’s binding.
If a second optional argument MAPVAR is given, it should be a symbol.
The map is then stored as MAPVAR’s value instead of as COMMAND’s
value; but COMMAND is still defined as a function.
The third optional argument NAME, if given, supplies a menu name
string for the map.  This is required to use the keymap as a menu.
This function returns COMMAND.

(fn COMMAND &optional MAPVAR NAME)〉〉enditem49840〈〈insert〉〉:〈〈Insert the arguments, either strings or characters, at point.
Point and after-insertion markers move forward to end up
 after the inserted text.
Any other markers at the point of insertion remain before the text.

If the current buffer is multibyte, unibyte strings are converted
to multibyte for insertion (see ‘string-make-multibyte’).
If the current buffer is unibyte, multibyte strings are converted
to unibyte for insertion (see ‘string-make-unibyte’).

When operating on binary data, it may be necessary to preserve the
original bytes of a unibyte string when inserting it into a multibyte
buffer; to accomplish this, apply ‘string-as-multibyte’ to the string
and insert the result.

(fn &rest ARGS)〉〉enditem49840〈〈insert-before-markers〉〉:〈〈Insert strings or characters at point, relocating markers after the text.
Point and markers move forward to end up after the inserted text.

If the current buffer is multibyte, unibyte strings are converted
to multibyte for insertion (see ‘unibyte-char-to-multibyte’).
If the current buffer is unibyte, multibyte strings are converted
to unibyte for insertion.

If an overlay begins at the insertion point, the inserted text falls
outside the overlay; if a nonempty overlay ends at the insertion
point, the inserted text falls inside that overlay.

(fn &rest ARGS)〉〉enditem49840〈〈insert-buffer-substring〉〉:〈〈Insert before point a substring of the contents of BUFFER.
BUFFER may be a buffer or a buffer name.
Arguments START and END are character positions specifying the substring.
They default to the values of (point-min) and (point-max) in BUFFER.

Point and before-insertion markers move forward to end up after the
inserted text.
Any other markers at the point of insertion remain before the text.

If the current buffer is multibyte and BUFFER is unibyte, or vice
versa, strings are converted from unibyte to multibyte or vice versa
using ‘string-make-multibyte’ or ‘string-make-unibyte’, which see.

(fn BUFFER &optional START END)〉〉enditem49840〈〈insert-buffer-substring-no-properties〉〉:〈〈Insert before point a substring of BUFFER, without text properties.
BUFFER may be a buffer or a buffer name.
Arguments START and END are character positions specifying the substring.
They default to the values of (point-min) and (point-max) in BUFFER.

(fn BUFFER &optional START END)〉〉enditem49840〈〈replace-match〉〉:〈〈Replace text matched by last search with NEWTEXT.
Leave point at the end of the replacement text.

If optional second arg FIXEDCASE is non-nil, do not alter the case of
the replacement text.  Otherwise, maybe capitalize the whole text, or
maybe just word initials, based on the replaced text.  If the replaced
text has only capital letters and has at least one multiletter word,
convert NEWTEXT to all caps.  Otherwise if all words are capitalized
in the replaced text, capitalize each word in NEWTEXT.

If optional third arg LITERAL is non-nil, insert NEWTEXT literally.
Otherwise treat ‘\’ as special:
  ‘\&’ in NEWTEXT means substitute original matched text.
  ‘\N’ means substitute what matched the Nth ‘\(...\)’.
       If Nth parens didn’t match, substitute nothing.
  ‘\\’ means insert one ‘\’.
  ‘\?’ is treated literally
       (for compatibility with ‘query-replace-regexp’).
  Any other character following ‘\’ signals an error.
Case conversion does not apply to these substitutions.

If optional fourth argument STRING is non-nil, it should be a string
to act on; this should be the string on which the previous match was
done via ‘string-match’.  In this case, ‘replace-match’ creates and
returns a new string, made by copying STRING and replacing the part of
STRING that was matched (the original STRING itself is not altered).

The optional fifth argument SUBEXP specifies a subexpression;
it says to replace just that subexpression with NEWTEXT,
rather than replacing the entire matched text.
This is, in a vague sense, the inverse of using ‘\N’ in NEWTEXT;
‘\N’ copies subexp N into NEWTEXT, but using N as SUBEXP puts
NEWTEXT in place of subexp N.
This is useful only after a regular expression search or match,
since only regular expressions have distinguished subexpressions.

(fn NEWTEXT &optional FIXEDCASE LITERAL STRING SUBEXP)〉〉enditem49840〈〈match-substitute-replacement〉〉:〈〈Return REPLACEMENT as it will be inserted by ‘replace-match’.
In other words, all back-references in the form ‘\&’ and ‘\N’
are substituted with actual strings matched by the last search.
Optional FIXEDCASE, LITERAL, STRING and SUBEXP have the same
meaning as for ‘replace-match’.

(fn REPLACEMENT &optional FIXEDCASE LITERAL STRING SUBEXP)〉〉enditem49840〈〈set-input-mode〉〉:〈〈Set mode of reading keyboard input.
First arg INTERRUPT non-nil means use input interrupts;
 nil means use CBREAK mode.
Second arg FLOW non-nil means use ^S/^Q flow control for output to terminal
 (no effect except in CBREAK mode).
Third arg META t means accept 8-bit input (for a Meta key).
 META nil means ignore the top bit, on the assumption it is parity.
 Otherwise, accept 8-bit input and don’t use the top bit for Meta.
Optional fourth arg QUIT if non-nil specifies character to use for quitting.
See also ‘current-input-mode’.

(fn INTERRUPT FLOW META &optional QUIT)〉〉enditem49840〈〈current-input-mode〉〉:〈〈Return information about the way Emacs currently reads keyboard input.
The value is a list of the form (INTERRUPT FLOW META QUIT), where
  INTERRUPT is non-nil if Emacs is using interrupt-driven input; if
    nil, Emacs is using CBREAK mode.
  FLOW is non-nil if Emacs uses ^S/^Q flow control for output to the
    terminal; this does not apply if Emacs uses interrupt-driven input.
  META is t if accepting 8-bit input with 8th bit as Meta flag.
    META nil means ignoring the top bit, on the assumption it is parity.
    META is neither t nor nil if accepting 8-bit input and using
    all 8 bits as the character code.
  QUIT is the character Emacs currently uses to quit.
The elements of this list correspond to the arguments of
‘set-input-mode’.

(fn)〉〉enditem49840〈〈tty-color-define〉〉:〈〈Specify a tty color by its NAME, terminal INDEX and RGB values.
NAME is a string, INDEX is typically a small integer used to send to
the terminal driver a command to switch this color on, and RGB is a
list of 3 numbers that specify the intensity of red, green, and blue
components of the color.
If specified, each one of the RGB components must be a number between
0 and 65535.  If RGB is omitted, the specified color will never be used
by ‘tty-color-translate’ as an approximation to another color.
FRAME is the frame where the defined color should be used.
If FRAME is not specified or is nil, it defaults to the selected frame.〉〉enditem49840〈〈tty-color-clear〉〉:〈〈Clear the list of supported tty colors for frame FRAME.
If FRAME is unspecified or nil, it defaults to the selected frame.〉〉enditem49840〈〈tty-color-alist〉〉:〈〈Return an alist of colors supported by FRAME’s terminal.
FRAME defaults to the selected frame.
Each element of the returned alist is of the form:
 (NAME INDEX R G B)
where NAME is the name of the color, a string;
INDEX is the index of this color to be sent to the terminal driver
when the color should be displayed; it is typically a small integer;
R, G, and B are the intensities of, accordingly, red, green, and blue
components of the color, represented as numbers between 0 and 65535.
The file ‘etc/rgb.txt’ in the Emacs distribution lists the standard
RGB values of the X colors.  If RGB is nil, this color will not be
considered by ‘tty-color-translate’ as an approximation to another
color.〉〉enditem49840〈〈tty-color-approximate〉〉:〈〈Find the color in ‘tty-color-alist’ that best approximates RGB.
Value is a list of the form (NAME INDEX R G B).
The argument RGB should be an rgb value, that is, a list of three
integers in the 0..65535 range.
FRAME defaults to the selected frame.〉〉enditem49840〈〈tty-color-translate〉〉:〈〈Given a color COLOR, return the index of the corresponding TTY color.

COLOR must be a string that is either the color’s name, or its X-style
specification like "#RRGGBB" or "RGB:rr/gg/bb", where each primary.
color can be given with 1 to 4 hex digits.

If COLOR is a color name that is found among supported colors in
‘tty-color-alist’, the associated index is returned.  Otherwise, the
RGB values of the color, either as given by the argument or from
looking up the name in ‘color-name-rgb-alist’, are used to find the
supported color that is the best approximation for COLOR in the RGB
space.
If COLOR is neither a valid X RGB specification of the color, nor a
name of a color in ‘color-name-rgb-alist’, the returned value is nil.

If FRAME is unspecified or nil, it defaults to the selected frame.〉〉enditem49840〈〈call-process〉〉:〈〈Call PROGRAM synchronously in separate process.
The remaining arguments are optional.
The program’s input comes from file INFILE (nil means ‘/dev/null’).
Insert output in DESTINATION before point; t means current buffer; nil for DESTINATION
 means discard it; 0 means discard and don’t wait; and ‘(:file FILE)’, where
 FILE is a file name string, means that it should be written to that file
 (if the file already exists it is overwritten).
DESTINATION can also have the form (REAL-BUFFER STDERR-FILE); in that case,
REAL-BUFFER says what to do with standard output, as above,
while STDERR-FILE says what to do with standard error in the child.
STDERR-FILE may be nil (discard standard error output),
t (mix it with ordinary output), or a file name string.

Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.
Remaining arguments are strings passed as command arguments to PROGRAM.

If executable PROGRAM can’t be found as an executable, ‘call-process’
signals a Lisp error.  ‘call-process’ reports errors in execution of
the program only through its return and output.

If DESTINATION is 0, ‘call-process’ returns immediately with value nil.
Otherwise it waits for PROGRAM to terminate
and returns a numeric exit status or a signal description string.
If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.

The process runs in ‘default-directory’ if that is local (as
determined by ‘unhandled-file-name-directory’), or "~" otherwise.  If
you want to run a process in a remote directory use ‘process-file’.

(fn PROGRAM &optional INFILE DESTINATION DISPLAY &rest ARGS)〉〉enditem49840〈〈process-file〉〉:〈〈Process files synchronously in a separate process.
Similar to ‘call-process’, but may invoke a file handler based on
‘default-directory’.  The current working directory of the
subprocess is ‘default-directory’.

File names in INFILE and BUFFER are handled normally, but file
names in ARGS should be relative to ‘default-directory’, as they
are passed to the process verbatim.  (This is a difference to
‘call-process’ which does not support file handlers for INFILE
and BUFFER.)

Some file handlers might not support all variants, for example
they might behave as if DISPLAY was nil, regardless of the actual
value passed.

(fn PROGRAM &optional INFILE BUFFER DISPLAY &rest ARGS)〉〉enditem49840〈〈call-process-region〉〉:〈〈Send text from START to END to a synchronous process running PROGRAM.

START and END are normally buffer positions specifying the part of the
buffer to send to the process.
If START is nil, that means to use the entire buffer contents; END is
ignored.
If START is a string, then send that string to the process
instead of any buffer contents; END is ignored.
The remaining arguments are optional.
Delete the text if fourth arg DELETE is non-nil.

Insert output in BUFFER before point; t means current buffer; nil for
 BUFFER means discard it; 0 means discard and don’t wait; and ‘(:file
 FILE)’, where FILE is a file name string, means that it should be
 written to that file (if the file already exists it is overwritten).
BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
REAL-BUFFER says what to do with standard output, as above,
while STDERR-FILE says what to do with standard error in the child.
STDERR-FILE may be nil (discard standard error output),
t (mix it with ordinary output), or a file name string.

Sixth arg DISPLAY non-nil means redisplay buffer as output is inserted.
Remaining args are passed to PROGRAM at startup as command args.

If BUFFER is 0, ‘call-process-region’ returns immediately with value nil.
Otherwise it waits for PROGRAM to terminate
and returns a numeric exit status or a signal description string.
If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.

(fn START END PROGRAM &optional DELETE BUFFER DISPLAY &rest ARGS)〉〉enditem49840〈〈call-process-shell-command〉〉:〈〈Execute the shell command COMMAND synchronously in separate process.
The remaining arguments are optional.
The program’s input comes from file INFILE (nil means ‘/dev/null’).
Insert output in BUFFER before point; t means current buffer;
 nil for BUFFER means discard it; 0 means discard and don’t wait.
BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,
REAL-BUFFER says what to do with standard output, as above,
while STDERR-FILE says what to do with standard error in the child.
STDERR-FILE may be nil (discard standard error output),
t (mix it with ordinary output), or a file name string.

Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.
Wildcards and redirection are handled as usual in the shell.

If BUFFER is 0, ‘call-process-shell-command’ returns immediately with value nil.
Otherwise it waits for COMMAND to terminate and returns a numeric exit
status or a signal description string.
If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.

An old calling convention accepted any number of arguments after DISPLAY,
which were just concatenated to COMMAND.  This is still supported but strongly
discouraged.

(fn COMMAND &optional INFILE BUFFER DISPLAY &rest ARGS)〉〉enditem49840〈〈process-file-shell-command〉〉:〈〈Process files synchronously in a separate process.
Similar to ‘call-process-shell-command’, but calls ‘process-file’.

(fn COMMAND &optional INFILE BUFFER DISPLAY &rest ARGS)〉〉enditem49840〈〈shell-command-to-string〉〉:〈〈Execute shell command COMMAND and return its output as a string.

(fn COMMAND)〉〉enditem49840〈〈process-lines〉〉:〈〈Execute PROGRAM with ARGS, returning its output as a list of lines.
Signal an error if the program returns with a non-zero exit status.

(fn PROGRAM &rest ARGS)〉〉enditem49840〈〈current-kill〉〉:〈〈Rotate the yanking point by N places, and then return that kill.
If N is zero and ‘interprogram-paste-function’ is set to a
function that returns a string or a list of strings, and if that
function doesn’t return nil, then that string (or list) is added
to the front of the kill ring and the string (or first string in
the list) is returned as the latest kill.

If N is not zero, and if ‘yank-pop-change-selection’ is
non-nil, use ‘interprogram-cut-function’ to transfer the
kill at the new yank point into the window system selection.

If optional arg DO-NOT-MOVE is non-nil, then don’t actually
move the yanking point; just return the Nth kill forward.

(fn N &optional DO-NOT-MOVE)〉〉enditem49840〈〈kill-new〉〉:〈〈Make STRING the latest kill in the kill ring.
Set ‘kill-ring-yank-pointer’ to point to it.
If ‘interprogram-cut-function’ is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list.

When ‘save-interprogram-paste-before-kill’ and ‘interprogram-paste-function’
are non-nil, save the interprogram paste string(s) into ‘kill-ring’ before
STRING.

When the yank handler has a non-nil PARAM element, the original STRING
argument is not used by ‘insert-for-yank’.  However, since Lisp code
may access and use elements from the kill ring directly, the STRING
argument should still be a "useful" string for such uses.

(fn STRING &optional REPLACE)〉〉enditem49840〈〈kill-append〉〉:〈〈Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill instead.
If ‘interprogram-cut-function’ is non-nil, call it with the
resulting kill.
If ‘kill-append-merge-undo’ is non-nil, remove the last undo
boundary in the current buffer.

(fn STRING BEFORE-P)〉〉enditem49840〈〈symbol-function〉〉:〈〈Return SYMBOL’s function definition, or nil if that is void.

(fn SYMBOL)〉〉enditem49840〈〈fboundp〉〉:〈〈Return t if SYMBOL’s function definition is not void.

(fn SYMBOL)〉〉enditem49840〈〈fmakunbound〉〉:〈〈Make SYMBOL’s function definition be nil.
Return SYMBOL.

(fn SYMBOL)〉〉enditem49840〈〈fset〉〉:〈〈Set SYMBOL’s function definition to DEFINITION, and return DEFINITION.

(fn SYMBOL DEFINITION)〉〉enditem49840〈〈hack-local-variables〉〉:〈〈Parse and put into effect this buffer’s local variables spec.
Uses ‘hack-local-variables-apply’ to apply the variables.

If HANDLE-MODE is nil, we apply all the specified local
variables.  If HANDLE-MODE is neither nil nor t, we do the same,
except that any settings of ‘mode’ are ignored.

If HANDLE-MODE is t, all we do is check whether a "mode:"
is specified, and return the corresponding mode symbol, or nil.
In this case, we try to ignore minor-modes, and only return a
major-mode.

If ‘enable-local-variables’ or ‘local-enable-local-variables’ is nil,
this function does nothing.  If ‘inhibit-local-variables-regexps’
applies to the file in question, the file is not scanned for
local variables, but directory-local variables may still be applied.

(fn &optional HANDLE-MODE)〉〉enditem49840〈〈safe-local-variable-p〉〉:〈〈Non-nil if SYM is safe as a file-local variable with value VAL.
It is safe if any of these conditions are met:

 * There is a matching entry (SYM . VAL) in the
   ‘safe-local-variable-values’ user option.

 * The ‘safe-local-variable’ property of SYM is a function that
   evaluates to a non-nil value with VAL as an argument.

(fn SYM VAL)〉〉enditem49840〈〈risky-local-variable-p〉〉:〈〈Non-nil if SYM could be dangerous as a file-local variable.
It is dangerous if either of these conditions are met:

 * Its ‘risky-local-variable’ property is non-nil.

 * Its name ends with "hook(s)", "function(s)", "form(s)", "map",
   "program", "command(s)", "predicate(s)", "frame-alist",
   "mode-alist", "font-lock-(syntactic-)keyword*",
   "map-alist", or "bindat-spec".

(fn SYM &optional IGNORED)〉〉enditem49840〈〈keymapp〉〉:〈〈Return t if OBJECT is a keymap.

A keymap is a list (keymap . ALIST),
or a symbol whose function definition is itself a keymap.
ALIST elements look like (CHAR . DEFN) or (SYMBOL . DEFN);
a vector of densely packed bindings for small character codes
is also allowed as an element.

(fn OBJECT)〉〉enditem49840〈〈select-safe-coding-system〉〉:〈〈Ask a user to select a safe coding system from candidates.
The candidates of coding systems which can safely encode a text
between FROM and TO are shown in a popup window.  Among them, the most
proper one is suggested as the default.

The list of ‘buffer-file-coding-system’ of the current buffer, the
default ‘buffer-file-coding-system’, and the most preferred coding
system (if it corresponds to a MIME charset) is treated as the
default coding system list.  Among them, the first one that safely
encodes the text is normally selected silently and returned without
any user interaction.  See also the command ‘prefer-coding-system’.

However, the user is queried if the chosen coding system is
inconsistent with what would be selected by ‘find-auto-coding’ from
coding cookies &c. if the contents of the region were read from a
file.  (That could lead to data corruption in a file subsequently
re-visited and edited.)

Optional 3rd arg DEFAULT-CODING-SYSTEM specifies a coding system or a
list of coding systems to be prepended to the default coding system
list.  However, if DEFAULT-CODING-SYSTEM is a list and the first
element is t, the cdr part is used as the default coding system list,
i.e. current ‘buffer-file-coding-system’, default ‘buffer-file-coding-system’,
and the most preferred coding system are not used.

Optional 4th arg ACCEPT-DEFAULT-P, if non-nil, is a function to
determine the acceptability of the silently selected coding system.
It is called with that coding system, and should return nil if it
should not be silently selected and thus user interaction is required.

Optional 5th arg FILE is the file name to use for this purpose.
That is different from ‘buffer-file-name’ when handling ‘write-region’
(for example).

The variable ‘select-safe-coding-system-accept-default-p’, if non-nil,
overrides ACCEPT-DEFAULT-P.

Kludgy feature: if FROM is a string, the string is the target text,
and TO is ignored.

(fn FROM TO &optional DEFAULT-CODING-SYSTEM ACCEPT-DEFAULT-P FILE)〉〉enditem49840〈〈read-coding-system〉〉:〈〈Read a coding system from the minibuffer, prompting with string PROMPT.
If the user enters null input, return second argument DEFAULT-CODING-SYSTEM.
Ignores case when completing coding systems (all Emacs coding systems
are lower-case).

(fn PROMPT &optional DEFAULT-CODING-SYSTEM)〉〉enditem49840〈〈read-non-nil-coding-system〉〉:〈〈Read a coding system from the minibuffer, prompting with string PROMPT.

(fn PROMPT)〉〉enditem49840〈〈current-time-string〉〉:〈〈Return the current local time, as a human-readable string.
Programs can use this function to decode a time,
since the number of columns in each field is fixed
if the year is in the range 1000-9999.
The format is ‘Sun Sep 16 01:03:52 1973’.
However, see also the functions ‘decode-time’ and ‘format-time-string’
which provide a much more powerful and general facility.

If SPECIFIED-TIME is given, it is a time to format instead of the
current time.  The argument should have the form (HIGH LOW . IGNORED).
Thus, you can use times obtained from ‘current-time’ and from
‘file-attributes’.  SPECIFIED-TIME can also be a single integer number
of seconds since the epoch.  The obsolete form (HIGH . LOW) is also
still accepted.

The optional ZONE is omitted or nil for Emacs local time, t for
Universal Time, ‘wall’ for system wall clock time, or a string as in
the TZ environment variable.  It can also be a list (as from
‘current-time-zone’) or an integer (as from ‘decode-time’) applied
without consideration for daylight saving time.

(fn &optional SPECIFIED-TIME ZONE)〉〉enditem49840〈〈current-time〉〉:〈〈Return the current time, as the number of seconds since 1970-01-01 00:00:00.
The time is returned as a list of integers (HIGH LOW USEC PSEC).
HIGH has the most significant bits of the seconds, while LOW has the
least significant 16 bits.  USEC and PSEC are the microsecond and
picosecond counts.

(fn)〉〉enditem49840〈〈float-time〉〉:〈〈Return the current time, as a float number of seconds since the epoch.
If SPECIFIED-TIME is given, it is the time to convert to float
instead of the current time.  The argument should have the form
(HIGH LOW) or (HIGH LOW USEC) or (HIGH LOW USEC PSEC).  Thus,
you can use times from ‘current-time’ and from ‘file-attributes’.
SPECIFIED-TIME can also have the form (HIGH . LOW), but this is
considered obsolete.

WARNING: Since the result is floating point, it may not be exact.
If precise time stamps are required, use either ‘current-time’,
or (if you need time as a string) ‘format-time-string’.

(fn &optional SPECIFIED-TIME)〉〉enditem49840〈〈seconds-to-time〉〉:〈〈Convert SECONDS to a time value.〉〉enditem49840〈〈set-default-file-modes〉〉:〈〈Set the file permission bits for newly created files.
The argument MODE should be an integer; only the low 9 bits are used.
On Posix hosts, this setting is inherited by subprocesses.

This function works by setting the Emacs’s file mode creation mask.
Each bit that is set in the mask means that the corresponding bit
in the permissions of newly created files will be disabled.

Note that when ‘write-region’ creates a file, it resets the
execute bit, even if the mask set by this function allows that bit
by having the corresponding bit in the mask reset.

(fn MODE)〉〉enditem49840〈〈default-file-modes〉〉:〈〈Return the default file protection for created files.
The value is an integer.

(fn)〉〉enditem49840〈〈read-file-modes〉〉:〈〈Read file modes in octal or symbolic notation and return its numeric value.
PROMPT is used as the prompt, default to "File modes (octal or symbolic): ".
ORIG-FILE is the name of a file on whose mode bits to base returned
permissions if what user types requests to add, remove, or set permissions
based on existing mode bits, as in "og+rX-w".

(fn &optional PROMPT ORIG-FILE)〉〉enditem49840〈〈file-modes-symbolic-to-number〉〉:〈〈Convert symbolic file modes to numeric file modes.
MODES is the string to convert, it should match
"[ugoa]*([+-=][rwxXstugo]*)+,...".
See Info node ‘(coreutils)File permissions’ for more information on this
notation.
FROM (or 0 if nil) gives the mode bits on which to base permissions if
MODES request to add, remove, or set permissions based on existing ones,
as in "og+rX-w".

(fn MODES &optional FROM)〉〉enditem49840〈〈set-file-times〉〉:〈〈Set times of file FILENAME to TIMESTAMP.
Set both access and modification times.
Return t on success, else nil.
Use the current time if TIMESTAMP is nil.  TIMESTAMP is in the format of
‘current-time’.

(fn FILENAME &optional TIMESTAMP)〉〉enditem49840〈〈set-file-extended-attributes〉〉:〈〈Set extended attributes of file FILENAME to ATTRIBUTES.

ATTRIBUTES must be an alist of file attributes as returned by
‘file-extended-attributes’.
Value is t if the function succeeds in setting the attributes.

(fn FILENAME ATTRIBUTES)〉〉enditem49840〈〈set-file-selinux-context〉〉:〈〈Set SELinux context of file named FILENAME to CONTEXT.
CONTEXT should be a list (USER ROLE TYPE RANGE), where the list
elements are strings naming the components of a SELinux context.

Value is t if setting of SELinux context was successful, nil otherwise.

This function does nothing and returns nil if SELinux is disabled,
or if Emacs was not compiled with SELinux support.

(fn FILENAME CONTEXT)〉〉enditem49840〈〈set-file-acl〉〉:〈〈Set ACL of file named FILENAME to ACL-STRING.
ACL-STRING should contain the textual representation of the ACL
entries in a format suitable for the platform.

Value is t if setting of ACL was successful, nil otherwise.

Setting ACL for local files requires Emacs to be built with ACL
support.

(fn FILENAME ACL-STRING)〉〉enditem49840〈〈current-left-margin〉〉:〈〈Return the left margin to use for this line.
This is the value of the buffer-local variable ‘left-margin’ plus the value
of the ‘left-margin’ text-property at the start of the line.〉〉enditem49840〈〈current-fill-column〉〉:〈〈Return the fill-column to use for this line.
The fill-column to use for a buffer is stored in the variable ‘fill-column’,
but can be locally modified by the ‘right-margin’ text property, which is
subtracted from ‘fill-column’.

The fill column to use for a line is the first column at which the column
number equals or exceeds the local fill-column - right-margin difference.〉〉enditem49840〈〈delete-to-left-margin〉〉:〈〈Remove left margin indentation from a region.
This deletes to the column given by ‘current-left-margin’.
In no case will it delete non-whitespace.
Args FROM and TO are optional; default is the whole buffer.

(fn &optional FROM TO)〉〉enditem49840〈〈indent-to-left-margin〉〉:〈〈Indent current line to the column given by ‘current-left-margin’.〉〉enditem49840〈〈sort-subr〉〉:〈〈General text sorting routine to divide buffer into records and sort them.

We divide the accessible portion of the buffer into disjoint pieces
called sort records.  A portion of each sort record (perhaps all of
it) is designated as the sort key.  The records are rearranged in the
buffer in order by their sort keys.  The records may or may not be
contiguous.

Usually the records are rearranged in order of ascending sort key.
If REVERSE is non-nil, they are rearranged in order of descending sort key.
The variable ‘sort-fold-case’ determines whether alphabetic case affects
the sort order.

The next four arguments are functions to be called to move point
across a sort record.  They will be called many times from within sort-subr.

NEXTRECFUN is called with point at the end of the previous record.
It moves point to the start of the next record.
It should move point to the end of the buffer if there are no more records.
The first record is assumed to start at the position of point when sort-subr
is called.

ENDRECFUN is called with point within the record.
It should move point to the end of the record.

STARTKEYFUN moves from the start of the record to the start of the key.
It may return either a non-nil value to be used as the key, or
else the key is the substring between the values of point after
STARTKEYFUN and ENDKEYFUN are called.  If STARTKEYFUN is nil, the key
starts at the beginning of the record.

ENDKEYFUN moves from the start of the sort key to the end of the sort key.
ENDKEYFUN may be nil if STARTKEYFUN returns a value or if it would be the
same as ENDRECFUN.

PREDICATE, if non-nil, is the predicate function for comparing
keys; it is called with two arguments, the keys to compare, and
should return non-nil if the first key should sort before the
second key.  If PREDICATE is nil, comparison is done with ‘<’ if
the keys are numbers, with ‘compare-buffer-substrings’ if the
keys are cons cells (the car and cdr of each cons cell are taken
as start and end positions), and with ‘string<’ otherwise.

(fn REVERSE NEXTRECFUN ENDRECFUN &optional STARTKEYFUN ENDKEYFUN PREDICATE)〉〉enditem49840〈〈backup-file-name-p〉〉:〈〈Return non-nil if FILE is a backup file name (numeric or not).
This is a separate function so you can redefine it for customization.
You may need to redefine ‘file-name-sans-versions’ as well.

(fn FILE)〉〉enditem49840〈〈make-backup-file-name〉〉:〈〈Create the non-numeric backup file name for FILE.
This calls the function that ‘make-backup-file-name-function’ specifies,
with a single argument FILE.

(fn FILE)〉〉enditem49840〈〈find-backup-file-name〉〉:〈〈Find a file name for a backup file FN, and suggestions for deletions.
Value is a list whose car is the name for the backup file
and whose cdr is a list of old versions to consider deleting now.
If the value is nil, don’t make a backup.
Uses ‘backup-directory-alist’ in the same way as
‘make-backup-file-name--default-function’ does.

(fn FN)〉〉enditem49840〈〈file-newest-backup〉〉:〈〈Return most recent backup file for FILENAME or nil if no backups exist.

(fn FILENAME)〉〉enditem49840〈〈locate-user-emacs-file〉〉:〈〈Return an absolute per-user Emacs-specific file name.
If NEW-NAME exists in ‘user-emacs-directory’, return it.
Else if OLD-NAME is non-nil and ~/OLD-NAME exists, return ~/OLD-NAME.
Else return NEW-NAME in ‘user-emacs-directory’, creating the
directory if it does not exist.

(fn NEW-NAME &optional OLD-NAME)〉〉enditem49840〈〈convert-standard-filename〉〉:〈〈Convert a standard file’s name to something suitable for the OS.
This means to guarantee valid names and perhaps to canonicalize
certain patterns.

FILENAME should be an absolute file name since the conversion rules
sometimes vary depending on the position in the file name.  E.g. c:/foo
is a valid DOS file name, but c:/bar/c:/foo is not.

This function’s standard definition is trivial; it just returns
the argument.  However, on Windows and DOS, replace invalid
characters.  On DOS, make sure to obey the 8.3 limitations.
In the native Windows build, turn Cygwin names into native names.

See Info node ‘(elisp)Standard File Names’ for more details.

(fn FILENAME)〉〉enditem49840〈〈add-hook〉〉:〈〈Add to the value of HOOK the function FUNCTION.
FUNCTION is not added if already present.
FUNCTION is added (if necessary) at the beginning of the hook list
unless the optional argument APPEND is non-nil, in which case
FUNCTION is added at the end.

The optional fourth argument, LOCAL, if non-nil, says to modify
the hook’s buffer-local value rather than its global value.
This makes the hook buffer-local, and it makes t a member of the
buffer-local value.  That acts as a flag to run the hook
functions of the global value as well as in the local value.

HOOK should be a symbol, and FUNCTION may be any valid function.  If
HOOK is void, it is first set to nil.  If HOOK’s value is a single
function, it is changed to a list of functions.

(fn HOOK FUNCTION &optional APPEND LOCAL)〉〉enditem49840〈〈remove-hook〉〉:〈〈Remove from the value of HOOK the function FUNCTION.
HOOK should be a symbol, and FUNCTION may be any valid function.  If
FUNCTION isn’t the value of HOOK, or, if FUNCTION doesn’t appear in the
list of hooks to run in HOOK, then nothing is done.  See ‘add-hook’.

The optional third argument, LOCAL, if non-nil, says to modify
the hook’s buffer-local value rather than its default value.

(fn HOOK FUNCTION &optional LOCAL)〉〉enditem49840〈〈error-message-string〉〉:〈〈Convert an error value (ERROR-SYMBOL . DATA) to an error message.
See Info anchor ‘(elisp)Definition of signal’ for some details on how this
error message is constructed.

(fn OBJ)〉〉enditem49840〈〈window-point〉〉:〈〈Return current value of point in WINDOW.
WINDOW must be a live window and defaults to the selected one.

For a nonselected window, this is the value point would have if that
window were selected.

Note that, when WINDOW is selected, the value returned is the same as
that returned by ‘point’ for WINDOW’s buffer.  It would be more strictly
correct to return the top-level value of ‘point’, outside of any
‘save-excursion’ forms.  But that is hard to define.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-point〉〉:〈〈Make point value in WINDOW be at position POS in WINDOW’s buffer.
WINDOW must be a live window and defaults to the selected one.
Return POS.

(fn WINDOW POS)〉〉enditem49840〈〈quit-restore-window〉〉:〈〈Quit WINDOW and deal with its buffer.
WINDOW must be a live window and defaults to the selected one.

According to information stored in WINDOW’s ‘quit-restore’ window
parameter either (1) delete WINDOW and its frame, (2) delete
WINDOW, (3) restore the buffer previously displayed in WINDOW,
or (4) make WINDOW display some other buffer than the present
one.  If non-nil, reset ‘quit-restore’ parameter to nil.

Optional second argument BURY-OR-KILL tells how to proceed with
the buffer of WINDOW.  The following values are handled:

nil means to not handle the buffer in a particular way.  This
  means that if WINDOW is not deleted by this function, invoking
  ‘switch-to-prev-buffer’ will usually show the buffer again.

‘append’ means that if WINDOW is not deleted, move its buffer to
  the end of WINDOW’s previous buffers so it’s less likely that a
  future invocation of ‘switch-to-prev-buffer’ will switch to it.
  Also, move the buffer to the end of the frame’s buffer list.

‘bury’ means that if WINDOW is not deleted, remove its buffer
  from WINDOW’S list of previous buffers.  Also, move the buffer
  to the end of the frame’s buffer list.  This value provides the
  most reliable remedy to not have ‘switch-to-prev-buffer’ switch
  to this buffer again without killing the buffer.

‘kill’ means to kill WINDOW’s buffer.

(fn &optional WINDOW BURY-OR-KILL)〉〉enditem49840〈〈x-parse-geometry〉〉:〈〈Parse a display geometry string STRING.
Returns an alist of the form ((top . TOP), (left . LEFT) ... ).
The properties returned may include ‘top’, ‘left’, ‘height’, and ‘width’.
For X, the value of ‘left’ or ‘top’ may be an integer,
or a list (+ N) meaning N pixels relative to top/left corner,
or a list (- N) meaning -N pixels relative to bottom/right corner.
On Nextstep, this just calls ‘ns-parse-geometry’.

(fn STRING)〉〉enditem49840〈〈process-list〉〉:〈〈Return a list of all processes that are Emacs sub-processes.

(fn)〉〉enditem49840〈〈get-process〉〉:〈〈Return the process named NAME, or nil if there is none.

(fn NAME)〉〉enditem49840〈〈process-command〉〉:〈〈Return the command that was executed to start PROCESS.
This is a list of strings, the first string being the program executed
and the rest of the strings being the arguments given to it.
For a network or serial or pipe connection, this is nil (process is running)
or t (process is stopped).

(fn PROCESS)〉〉enditem49840〈〈process-contact〉〉:〈〈Return the contact info of PROCESS; t for a real child.
For a network or serial or pipe connection, the value depends on the
optional KEY arg.  If KEY is nil, value is a cons cell of the form
(HOST SERVICE) for a network connection or (PORT SPEED) for a serial
connection; it is t for a pipe connection.  If KEY is t, the complete
contact information for the connection is returned, else the specific
value for the keyword KEY is returned.  See ‘make-network-process’,
‘make-serial-process’, or ‘make-pipe-process’ for the list of keywords.
If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS &optional KEY)〉〉enditem49840〈〈process-id〉〉:〈〈Return the process id of PROCESS.
This is the pid of the external process which PROCESS uses or talks to.
For a network, serial, and pipe connections, this value is nil.

(fn PROCESS)〉〉enditem49840〈〈process-name〉〉:〈〈Return the name of PROCESS, as a string.
This is the name of the program invoked in PROCESS,
possibly modified to make it unique among process names.

(fn PROCESS)〉〉enditem49840〈〈process-status〉〉:〈〈Return the status of PROCESS.
The returned value is one of the following symbols:
run  -- for a process that is running.
stop -- for a process stopped but continuable.
exit -- for a process that has exited.
signal -- for a process that has got a fatal signal.
open -- for a network stream connection that is open.
listen -- for a network stream server that is listening.
closed -- for a network stream connection that is closed.
connect -- when waiting for a non-blocking connection to complete.
failed -- when a non-blocking connection has failed.
nil -- if arg is a process name and no such process exists.
PROCESS may be a process, a buffer, the name of a process, or
nil, indicating the current buffer’s process.

(fn PROCESS)〉〉enditem49840〈〈process-live-p〉〉:〈〈Returns non-nil if PROCESS is alive.
A process is considered alive if its status is ‘run’, ‘open’,
‘listen’, ‘connect’ or ‘stop’.  Value is nil if PROCESS is not a
process.

(fn PROCESS)〉〉enditem49840〈〈process-type〉〉:〈〈Return the connection type of PROCESS.
The value is either the symbol ‘real’, ‘network’, ‘serial’, or ‘pipe’.
PROCESS may be a process, a buffer, the name of a process or buffer, or
nil, indicating the current buffer’s process.

(fn PROCESS)〉〉enditem49840〈〈process-exit-status〉〉:〈〈Return the exit status of PROCESS or the signal number that killed it.
If PROCESS has not yet exited or died, return 0.

(fn PROCESS)〉〉enditem49840〈〈process-tty-name〉〉:〈〈Return the name of the terminal PROCESS uses, or nil if none.
This is the terminal that the process itself reads and writes on,
not the name of the pty that Emacs uses to talk with that terminal.

(fn PROCESS)〉〉enditem49840〈〈process-coding-system〉〉:〈〈Return a cons of coding systems for decoding and encoding of PROCESS.

(fn PROCESS)〉〉enditem49840〈〈set-process-coding-system〉〉:〈〈Set coding systems of PROCESS to DECODING and ENCODING.
DECODING will be used to decode subprocess output and ENCODING to
encode subprocess input.

(fn PROCESS &optional DECODING ENCODING)〉〉enditem49840〈〈process-get〉〉:〈〈Return the value of PROCESS’ PROPNAME property.
This is the last value stored with ‘(process-put PROCESS PROPNAME VALUE)’.

(fn PROCESS PROPNAME)〉〉enditem49840〈〈process-put〉〉:〈〈Change PROCESS’ PROPNAME property to VALUE.
It can be retrieved with ‘(process-get PROCESS PROPNAME)’.

(fn PROCESS PROPNAME VALUE)〉〉enditem49840〈〈process-plist〉〉:〈〈Return the plist of PROCESS.

(fn PROCESS)〉〉enditem49840〈〈set-process-plist〉〉:〈〈Replace the plist of PROCESS with PLIST.  Return PLIST.

(fn PROCESS PLIST)〉〉enditem49840〈〈keyboard-translate〉〉:〈〈Translate character FROM to TO on the current terminal.
This function creates a ‘keyboard-translate-table’ if necessary
and then modifies one entry in it.

(fn FROM TO)〉〉enditem49840〈〈execute-kbd-macro〉〉:〈〈Execute MACRO as string of editor command characters.
MACRO can also be a vector of keyboard events.  If MACRO is a symbol,
its function definition is used.
COUNT is a repeat count, or nil for once, or 0 for infinite loop.

Optional third arg LOOPFUNC may be a function that is called prior to
each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.

(fn MACRO &optional COUNT LOOPFUNC)〉〉enditem49840〈〈date-to-time〉〉:〈〈Parse a string DATE that represents a date-time and return a time value.
If DATE lacks timezone information, GMT is assumed.〉〉enditem49840〈〈format-time-string〉〉:〈〈Use FORMAT-STRING to format the time TIME, or now if omitted or nil.
TIME is specified as (HIGH LOW USEC PSEC), as returned by
‘current-time’ or ‘file-attributes’.  It can also be a single integer
number of seconds since the epoch.  The obsolete form (HIGH . LOW) is
also still accepted.

The optional ZONE is omitted or nil for Emacs local time, t for
Universal Time, ‘wall’ for system wall clock time, or a string as in
the TZ environment variable.  It can also be a list (as from
‘current-time-zone’) or an integer (as from ‘decode-time’) applied
without consideration for daylight saving time.

The value is a copy of FORMAT-STRING, but with certain constructs replaced
by text that describes the specified date and time in TIME:

%Y is the year, %y within the century, %C the century.
%G is the year corresponding to the ISO week, %g within the century.
%m is the numeric month.
%b and %h are the locale’s abbreviated month name, %B the full name.
 (%h is not supported on MS-Windows.)
%d is the day of the month, zero-padded, %e is blank-padded.
%u is the numeric day of week from 1 (Monday) to 7, %w from 0 (Sunday) to 6.
%a is the locale’s abbreviated name of the day of week, %A the full name.
%U is the week number starting on Sunday, %W starting on Monday,
 %V according to ISO 8601.
%j is the day of the year.

%H is the hour on a 24-hour clock, %I is on a 12-hour clock, %k is like %H
 only blank-padded, %l is like %I blank-padded.
%p is the locale’s equivalent of either AM or PM.
%q is the calendar quarter (1–4).
%M is the minute (00-59).
%S is the second (00-59; 00-60 on platforms with leap seconds)
%s is the number of seconds since 1970-01-01 00:00:00 +0000.
%N is the nanosecond, %6N the microsecond, %3N the millisecond, etc.
%Z is the time zone abbreviation, %z is the numeric form.

%c is the locale’s date and time format.
%x is the locale’s "preferred" date format.
%D is like "%m/%d/%y".
%F is the ISO 8601 date format (like "%Y-%m-%d").

%R is like "%H:%M", %T is like "%H:%M:%S", %r is like "%I:%M:%S %p".
%X is the locale’s "preferred" time format.

Finally, %n is a newline, %t is a tab, %% is a literal %, and
unrecognized %-sequences stand for themselves.

Certain flags and modifiers are available with some format controls.
The flags are ‘_’, ‘-’, ‘^’ and ‘#’.  For certain characters X,
%_X is like %X, but padded with blanks; %-X is like %X,
but without padding.  %^X is like %X, but with all textual
characters up-cased; %#X is like %X, but with letter-case of
all textual characters reversed.
%NX (where N stands for an integer) is like %X,
but takes up at least N (a number) positions.
The modifiers are ‘E’ and ‘O’.  For certain characters X,
%EX is a locale’s alternative version of %X;
%OX is like %X, but uses the locale’s number symbols.

For example, to produce full ISO 8601 format, use "%FT%T%z".

(fn FORMAT-STRING &optional TIME ZONE)〉〉enditem49840〈〈format-seconds〉〉:〈〈Use format control STRING to format the number SECONDS.
The valid format specifiers are:
%y is the number of (365-day) years.
%d is the number of days.
%h is the number of hours.
%m is the number of minutes.
%s is the number of seconds.
%z is a non-printing control flag (see below).
%% is a literal "%".

Upper-case specifiers are followed by the unit-name (e.g. "years").
Lower-case specifiers return only the unit.

"%" may be followed by a number specifying a width, with an
optional leading "." for zero-padding.  For example, "%.3Y" will
return something of the form "001 year".

The "%z" specifier does not print anything.  When it is used, specifiers
must be given in order of decreasing size.  To the left of "%z", nothing
is output until the first non-zero unit is encountered.

This function does not work for SECONDS greater than ‘most-positive-fixnum’.〉〉enditem49840〈〈make-ring〉〉:〈〈Make a ring that can contain SIZE elements.

(fn SIZE)〉〉enditem49840〈〈ring-p〉〉:〈〈Return t if X is a ring; nil otherwise.

(fn X)〉〉enditem49840〈〈ring-size〉〉:〈〈Return the size of RING, the maximum number of elements it can contain.

(fn RING)〉〉enditem49840〈〈ring-length〉〉:〈〈Return the number of elements in the RING.

(fn RING)〉〉enditem49840〈〈ring-elements〉〉:〈〈Return a list of the elements of RING, in order, newest first.

(fn RING)〉〉enditem49840〈〈ring-copy〉〉:〈〈Return a copy of RING.

(fn RING)〉〉enditem49840〈〈ring-empty-p〉〉:〈〈Return t if RING is empty; nil otherwise.

(fn RING)〉〉enditem49840〈〈ring-ref〉〉:〈〈Return RING’s INDEX element.
INDEX = 0 is the most recently inserted; higher indices
correspond to older elements.
INDEX need not be <= the ring length; the appropriate modulo operation
will be performed.

(fn RING INDEX)〉〉enditem49840〈〈ring-insert〉〉:〈〈Insert onto ring RING the item ITEM, as the newest (last) item.
If the ring is full, dump the oldest item to make room.

(fn RING ITEM)〉〉enditem49840〈〈ring-remove〉〉:〈〈Remove an item from the RING.  Return the removed item.
If optional INDEX is nil, remove the oldest item.  If it’s
numeric, remove the element indexed.

(fn RING &optional INDEX)〉〉enditem49840〈〈ring-insert-at-beginning〉〉:〈〈Add to RING the item ITEM, at the front, as the oldest item.

(fn RING ITEM)〉〉enditem49840〈〈set-window-combination-limit〉〉:〈〈Set combination limit of window WINDOW to LIMIT; return LIMIT.
WINDOW must be a valid window used in horizontal or vertical combination.
If LIMIT is nil, child windows of WINDOW can be recombined with WINDOW’s
siblings.  LIMIT t means that child windows of WINDOW are never
(re-)combined with WINDOW’s siblings.  Other values are reserved for
future use.

(fn WINDOW LIMIT)〉〉enditem49840〈〈window-combination-limit〉〉:〈〈Return combination limit of window WINDOW.
WINDOW must be a valid window used in horizontal or vertical combination.
If the return value is nil, child windows of WINDOW can be recombined with
WINDOW’s siblings.  A return value of t means that child windows of
WINDOW are never (re-)combined with WINDOW’s siblings.

(fn WINDOW)〉〉enditem49840〈〈regexp-quote〉〉:〈〈Return a regexp string which matches exactly STRING and nothing else.

(fn STRING)〉〉enditem49840〈〈regexp-opt〉〉:〈〈Return a regexp to match a string in the list STRINGS.
Each string should be unique in STRINGS and should not contain
any regexps, quoted or not.  Optional PAREN specifies how the
returned regexp is surrounded by grouping constructs.

The optional argument PAREN can be any of the following:

a string
    the resulting regexp is preceded by PAREN and followed by
    \), e.g.  use "\\(?1:" to produce an explicitly numbered
    group.

‘words’
    the resulting regexp is surrounded by \<\( and \)\>.

‘symbols’
    the resulting regexp is surrounded by \_<\( and \)\_>.

non-nil
    the resulting regexp is surrounded by \( and \).

nil
    the resulting regexp is surrounded by \(?: and \), if it is
    necessary to ensure that a postfix operator appended to it will
    apply to the whole expression.

The resulting regexp is equivalent to but usually more efficient
than that of a simplified version:

 (defun simplified-regexp-opt (strings &optional paren)
   (let ((parens
          (cond ((stringp paren)       (cons paren "\\)"))
                ((eq paren ’words)    ’("\\<\\(" . "\\)\\>"))
                ((eq paren ’symbols) ’("\\_<\\(" . "\\)\\_>"))
                ((null paren)          ’("\\(?:" . "\\)"))
                (t                       ’("\\(" . "\\)")))))
     (concat (car paren)
             (mapconcat ’regexp-quote strings "\\|")
             (cdr paren))))

(fn STRINGS &optional PAREN)〉〉enditem49840〈〈regexp-opt-depth〉〉:〈〈Return the depth of REGEXP.
This means the number of non-shy regexp grouping constructs
(parenthesized expressions) in REGEXP.

(fn REGEXP)〉〉enditem49840〈〈regexp-opt-charset〉〉:〈〈Return a regexp to match a character in CHARS.
CHARS should be a list of characters.

(fn CHARS)〉〉enditem49840〈〈provide〉〉:〈〈Announce that FEATURE is a feature of the current Emacs.
The optional argument SUBFEATURES should be a list of symbols listing
particular subfeatures supported in this version of FEATURE.

(fn FEATURE &optional SUBFEATURES)〉〉enditem49840〈〈require〉〉:〈〈If feature FEATURE is not loaded, load it from FILENAME.
If FEATURE is not a member of the list ‘features’, then the feature is
not loaded; so load the file FILENAME.

If FILENAME is omitted, the printname of FEATURE is used as the file
name, and ‘load’ will try to load this name appended with the suffix
‘.elc’, ‘.el’, or the system-dependent suffix for dynamic module
files, in that order.  The name without appended suffix will not be
used.  See ‘get-load-suffixes’ for the complete list of suffixes.

The directories in ‘load-path’ are searched when trying to find the
file name.

If the optional third argument NOERROR is non-nil, then return nil if
the file is not found instead of signaling an error.  Normally the
return value is FEATURE.

The normal messages at start and end of loading FILENAME are
suppressed.

(fn FEATURE &optional FILENAME NOERROR)〉〉enditem49840〈〈featurep〉〉:〈〈Return t if FEATURE is present in this Emacs.

Use this to conditionalize execution of lisp code based on the
presence or absence of Emacs or environment extensions.
Use ‘provide’ to declare that a feature is available.  This function
looks at the value of the variable ‘features’.  The optional argument
SUBFEATURE can be used to check a specific subfeature of FEATURE.

(fn FEATURE &optional SUBFEATURE)〉〉enditem49840〈〈backup-buffer〉〉:〈〈Make a backup of the disk file visited by the current buffer, if appropriate.
This is normally done before saving the buffer the first time.

A backup may be done by renaming or by copying; see documentation of
variable ‘make-backup-files’.  If it’s done by renaming, then the file is
no longer accessible under its old name.

The value is non-nil after a backup was made by renaming.
It has the form (MODES EXTENDED-ATTRIBUTES BACKUPNAME).
MODES is the result of ‘file-modes’ on the original
file; this means that the caller, after saving the buffer, should change
the modes of the new file to agree with the old modes.
EXTENDED-ATTRIBUTES is the result of ‘file-extended-attributes’
on the original file; this means that the caller, after saving
the buffer, should change the extended attributes of the new file
to agree with the old attributes.
BACKUPNAME is the backup file name, which is the old file renamed.〉〉enditem49840〈〈event-modifiers〉〉:〈〈Return a list of symbols representing the modifier keys in event EVENT.
The elements of the list may include ‘meta’, ‘control’,
‘shift’, ‘hyper’, ‘super’, ‘alt’, ‘click’, ‘double’, ‘triple’, ‘drag’,
and ‘down’.
EVENT may be an event or an event type.  If EVENT is a symbol
that has never been used in an event that has been read as input
in the current Emacs session, then this function may fail to include
the ‘click’ modifier.

(fn EVENT)〉〉enditem49840〈〈event-basic-type〉〉:〈〈Return the basic type of the given event (all modifiers removed).
The value is a printing character (not upper case) or a symbol.
EVENT may be an event or an event type.  If EVENT is a symbol
that has never been used in an event that has been read as input
in the current Emacs session, then this function may return nil.

(fn EVENT)〉〉enditem49840〈〈mouse-movement-p〉〉:〈〈Return non-nil if OBJECT is a mouse movement event.

(fn OBJECT)〉〉enditem49840〈〈event-convert-list〉〉:〈〈Convert the event description list EVENT-DESC to an event type.
EVENT-DESC should contain one base event type (a character or symbol)
and zero or more modifier names (control, meta, hyper, super, shift, alt,
drag, down, double or triple).  The base must be last.
The return value is an event type (a character or symbol) which
has the same base event type and all the specified modifiers.

(fn EVENT-DESC)〉〉enditem49840〈〈read-key-sequence〉〉:〈〈Read a sequence of keystrokes and return as a string or vector.
The sequence is sufficient to specify a non-prefix command in the
current local and global maps.

First arg PROMPT is a prompt string.  If nil, do not prompt specially.
Second (optional) arg CONTINUE-ECHO, if non-nil, means this key echos
as a continuation of the previous key.

The third (optional) arg DONT-DOWNCASE-LAST, if non-nil, means do not
convert the last event to lower case.  (Normally any upper case event
is converted to lower case if the original event is undefined and the lower
case equivalent is defined.)  A non-nil value is appropriate for reading
a key sequence to be defined.

A C-g typed while in this function is treated like any other character,
and ‘quit-flag’ is not set.

If the key sequence starts with a mouse click, then the sequence is read
using the keymaps of the buffer of the window clicked in, not the buffer
of the selected window as normal.

‘read-key-sequence’ drops unbound button-down events, since you normally
only care about the click or drag events which follow them.  If a drag
or multi-click event is unbound, but the corresponding click event would
be bound, ‘read-key-sequence’ turns the event into a click event at the
drag’s starting position.  This means that you don’t have to distinguish
between click and drag, double, or triple events unless you want to.

‘read-key-sequence’ prefixes mouse events on mode lines, the vertical
lines separating windows, and scroll bars with imaginary keys
‘mode-line’, ‘vertical-line’, and ‘vertical-scroll-bar’.

Optional fourth argument CAN-RETURN-SWITCH-FRAME non-nil means that this
function will process a switch-frame event if the user switches frames
before typing anything.  If the user switches frames in the middle of a
key sequence, or at the start of the sequence but CAN-RETURN-SWITCH-FRAME
is nil, then the event will be put off until after the current key sequence.

‘read-key-sequence’ checks ‘function-key-map’ for function key
sequences, where they wouldn’t conflict with ordinary bindings.  See
‘function-key-map’ for more details.

The optional fifth argument CMD-LOOP, if non-nil, means
that this key sequence is being read by something that will
read commands one after another.  It should be nil if the caller
will read just one key sequence.

(fn PROMPT &optional CONTINUE-ECHO DONT-DOWNCASE-LAST CAN-RETURN-SWITCH-FRAME CMD-LOOP)〉〉enditem49840〈〈read-key-sequence-vector〉〉:〈〈Like ‘read-key-sequence’ but always return a vector.

(fn PROMPT &optional CONTINUE-ECHO DONT-DOWNCASE-LAST CAN-RETURN-SWITCH-FRAME CMD-LOOP)〉〉enditem49840〈〈file-truename〉〉:〈〈Return the truename of FILENAME.
If FILENAME is not absolute, first expands it against ‘default-directory’.
The truename of a file name is found by chasing symbolic links
both at the level of the file and at the level of the directories
containing it, until no links are left at any level.

(fn FILENAME)〉〉enditem49840〈〈file-chase-links〉〉:〈〈Chase links in FILENAME until a name that is not a link.
Unlike ‘file-truename’, this does not check whether a parent
directory name is a symbolic link.
If the optional argument LIMIT is a number,
it means chase no more than that many links and then stop.

(fn FILENAME &optional LIMIT)〉〉enditem49840〈〈file-equal-p〉〉:〈〈Return non-nil if files FILE1 and FILE2 name the same file.
If FILE1 or FILE2 does not exist, the return value is unspecified.

(fn FILE1 FILE2)〉〉enditem49840〈〈file-in-directory-p〉〉:〈〈Return non-nil if FILE is in DIR or a subdirectory of DIR.
A directory is considered to be "in" itself.
Return nil if DIR is not an existing directory.

(fn FILE DIR)〉〉enditem49840〈〈eval〉〉:〈〈Evaluate FORM and return its value.
If LEXICAL is t, evaluate using lexical scoping.
LEXICAL can also be an actual lexical environment, in the form of an
alist mapping symbols to their value.

(fn FORM &optional LEXICAL)〉〉enditem49840〈〈frame-parameter〉〉:〈〈Return FRAME’s value for parameter PARAMETER.
If FRAME is nil, describe the currently selected frame.

(fn FRAME PARAMETER)〉〉enditem49840〈〈frame-parameters〉〉:〈〈Return the parameters-alist of frame FRAME.
It is a list of elements of the form (PARM . VALUE), where PARM is a symbol.
The meaningful PARMs depend on the kind of frame.
If FRAME is omitted or nil, return information on the currently selected frame.

(fn &optional FRAME)〉〉enditem49840〈〈modify-frame-parameters〉〉:〈〈Modify FRAME according to new values of its parameters in ALIST.
If FRAME is nil, it defaults to the selected frame.
ALIST is an alist of parameters to change and their new values.
Each element of ALIST has the form (PARM . VALUE), where PARM is a symbol.
Which PARMs are meaningful depends on the kind of frame.
The meaningful parameters are acted upon, i.e. the frame is changed
according to their new values, and are also stored in the frame’s
parameter list so that ‘frame-parameters’ will return them.
PARMs that are not meaningful are still stored in the frame’s parameter
list, but are otherwise ignored.

(fn FRAME ALIST)〉〉enditem49840〈〈set-frame-parameter〉〉:〈〈Set frame parameter PARAMETER to VALUE on FRAME.
If FRAME is nil, it defaults to the selected frame.
See ‘modify-frame-parameters’.

(fn FRAME PARAMETER VALUE)〉〉enditem49840〈〈modify-all-frames-parameters〉〉:〈〈Modify all current and future frames’ parameters according to ALIST.
This changes ‘default-frame-alist’ and possibly ‘initial-frame-alist’.
Furthermore, this function removes all parameters in ALIST from
‘window-system-default-frame-alist’.
See help of ‘modify-frame-parameters’ for more information.

(fn ALIST)〉〉enditem49840〈〈process-datagram-address〉〉:〈〈Get the current datagram address associated with PROCESS.
If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS)〉〉enditem49840〈〈set-process-datagram-address〉〉:〈〈Set the datagram address for PROCESS to ADDRESS.
Return nil upon error setting address, ADDRESS otherwise.

If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS ADDRESS)〉〉enditem49840〈〈current-window-configuration〉〉:〈〈Return an object representing the current window configuration of FRAME.
If FRAME is nil or omitted, use the selected frame.
This describes the number of windows, their sizes and current buffers,
and for each displayed buffer, where display starts, and the position of
point.  An exception is made for point in the current buffer:
its value is -not- saved.
This also records the currently selected frame, and FRAME’s focus
redirection (see ‘redirect-frame-focus’).  The variable
‘window-persistent-parameters’ specifies which window parameters are
saved by this function.

(fn &optional FRAME)〉〉enditem49840〈〈set-window-configuration〉〉:〈〈Set the configuration of windows and buffers as specified by CONFIGURATION.
CONFIGURATION must be a value previously returned
by ‘current-window-configuration’ (which see).
If CONFIGURATION was made from a frame that is now deleted,
only frame-independent values can be restored.  In this case,
the return value is nil.  Otherwise the value is t.

(fn CONFIGURATION)〉〉enditem49840〈〈window-configuration-p〉〉:〈〈Return t if OBJECT is a window-configuration object.

(fn OBJECT)〉〉enditem49840〈〈compare-window-configurations〉〉:〈〈Compare two window configurations as regards the structure of windows.
This function ignores details such as the values of point
and scrolling positions.

(fn X Y)〉〉enditem49840〈〈window-configuration-frame〉〉:〈〈Return the frame that CONFIG, a window-configuration object, is about.

(fn CONFIG)〉〉enditem49840〈〈window-state-get〉〉:〈〈Return state of WINDOW as a Lisp object.
WINDOW can be any window and defaults to the root window of the
selected frame.

Optional argument WRITABLE non-nil means do not use markers for
sampling ‘window-point’ and ‘window-start’.  Together, WRITABLE
and the variable ‘window-persistent-parameters’ specify which
window parameters are saved by this function.  WRITABLE should be
non-nil when the return value shall be written to a file and read
back in another session.  Otherwise, an application may run into
an ‘invalid-read-syntax’ error while attempting to read back the
value from file.

The return value can be used as argument for ‘window-state-put’
to put the state recorded here into an arbitrary window.  The
value can be also stored on disk and read back in a new session.

(fn &optional WINDOW WRITABLE)〉〉enditem49840〈〈window-state-put〉〉:〈〈Put window state STATE into WINDOW.
STATE should be the state of a window returned by an earlier
invocation of ‘window-state-get’.  Optional argument WINDOW must
specify a valid window and defaults to the selected one.  If
WINDOW is not live, replace WINDOW by a live one before putting
STATE into it.

Optional argument IGNORE non-nil means ignore minimum window
sizes and fixed size restrictions.  IGNORE equal ‘safe’ means
windows can get as small as ‘window-safe-min-height’ and
‘window-safe-min-width’.

(fn STATE &optional WINDOW IGNORE)〉〉enditem49840〈〈charset-after〉〉:〈〈Return charset of a character in the current buffer at position POS.
If POS is nil, it defaults to the current point.
If POS is out of range, the value is nil.

(fn &optional POS)〉〉enditem49840〈〈find-charset-region〉〉:〈〈Return a list of charsets in the region between BEG and END.
BEG and END are buffer positions.
Optional arg TABLE if non-nil is a translation table to look up.

If the current buffer is unibyte, the returned list may contain
only ‘ascii’, ‘eight-bit-control’, and ‘eight-bit-graphic’.

(fn BEG END &optional TABLE)〉〉enditem49840〈〈find-charset-string〉〉:〈〈Return a list of charsets in STR.
Optional arg TABLE if non-nil is a translation table to look up.

If STR is unibyte, the returned list may contain
only ‘ascii’, ‘eight-bit-control’, and ‘eight-bit-graphic’.

(fn STR &optional TABLE)〉〉enditem49840〈〈abbrev-table-put〉〉:〈〈Set the PROP property of abbrev table TABLE to VAL.

(fn TABLE PROP VAL)〉〉enditem49840〈〈abbrev-table-get〉〉:〈〈Get the PROP property of abbrev table TABLE.

(fn TABLE PROP)〉〉enditem49840〈〈coding-system-list〉〉:〈〈Return a list of all existing non-subsidiary coding systems.
If optional arg BASE-ONLY is non-nil, only base coding systems are
listed.  The value doesn’t include subsidiary coding systems which are
made from bases and aliases automatically for various end-of-line
formats (e.g. iso-latin-1-unix, koi8-r-dos).〉〉enditem49840〈〈coding-system-p〉〉:〈〈Return t if OBJECT is nil or a coding-system.
See the documentation of ‘define-coding-system’ for information
about coding-system objects.

(fn OBJECT)〉〉enditem49840〈〈check-coding-system〉〉:〈〈Check validity of CODING-SYSTEM.
If valid, return CODING-SYSTEM, else signal a ‘coding-system-error’ error.
It is valid if it is nil or a symbol defined as a coding system by the
function ‘define-coding-system’.

(fn CODING-SYSTEM)〉〉enditem49840〈〈coding-system-eol-type〉〉:〈〈Return eol-type of CODING-SYSTEM.
An eol-type is an integer 0, 1, 2, or a vector of coding systems.

Integer values 0, 1, and 2 indicate a format of end-of-line; LF, CRLF,
and CR respectively.

A vector value indicates that a format of end-of-line should be
detected automatically.  Nth element of the vector is the subsidiary
coding system whose eol-type is N.

(fn CODING-SYSTEM)〉〉enditem49840〈〈coding-system-change-eol-conversion〉〉:〈〈Return a coding system which differs from CODING-SYSTEM in EOL conversion.
The returned coding system converts end-of-line by EOL-TYPE
but text as the same way as CODING-SYSTEM.
EOL-TYPE should be ‘unix’, ‘dos’, ‘mac’, or nil.
If EOL-TYPE is nil, the returned coding system detects
how end-of-line is formatted automatically while decoding.

EOL-TYPE can be specified by an integer 0, 1, or 2.
They means ‘unix’, ‘dos’, and ‘mac’ respectively.

(fn CODING-SYSTEM EOL-TYPE)〉〉enditem49840〈〈coding-system-change-text-conversion〉〉:〈〈Return a coding system which differs from CODING-SYSTEM in text conversion.
The returned coding system converts text by CODING
but end-of-line as the same way as CODING-SYSTEM.
If CODING is nil, the returned coding system detects
how text is formatted automatically while decoding.

(fn CODING-SYSTEM CODING)〉〉enditem49840〈〈find-coding-systems-region〉〉:〈〈Return a list of proper coding systems to encode a text between FROM and TO.

If FROM is a string, find coding systems in that instead of the buffer.
All coding systems in the list can safely encode any multibyte characters
in the text.

If the text contains no multibyte characters, return a list of a single
element ‘undecided’.

(fn FROM TO)〉〉enditem49840〈〈find-coding-systems-string〉〉:〈〈Return a list of proper coding systems to encode STRING.
All coding systems in the list can safely encode any multibyte characters
in STRING.

If STRING contains no multibyte characters, return a list of a single
element ‘undecided’.

(fn STRING)〉〉enditem49840〈〈find-coding-systems-for-charsets〉〉:〈〈Return a list of proper coding systems to encode characters of CHARSETS.
CHARSETS is a list of character sets.

This only finds coding systems of type ‘charset’, whose
‘:charset-list’ property includes all of CHARSETS (plus ‘ascii’ for
ASCII-compatible coding systems).  It was used in older versions of
Emacs, but is unlikely to be what you really want now.

(fn CHARSETS)〉〉enditem49840〈〈check-coding-systems-region〉〉:〈〈Check if the region is encodable by coding systems.

START and END are buffer positions specifying the region.
CODING-SYSTEM-LIST is a list of coding systems to check.

The value is an alist ((CODING-SYSTEM POS0 POS1 ...) ...), where
CODING-SYSTEM is a member of CODING-SYSTEM-LIST and can’t encode the
whole region, POS0, POS1, ... are buffer positions where non-encodable
characters are found.

If all coding systems in CODING-SYSTEM-LIST can encode the region, the
value is nil.

START may be a string.  In that case, check if the string is
encodable, and the value contains indices to the string instead of
buffer positions.  END is ignored.

If the current buffer (or START if it is a string) is unibyte, the value
is nil.

(fn START END CODING-SYSTEM-LIST)〉〉enditem49840〈〈detect-coding-region〉〉:〈〈Detect coding system of the text in the region between START and END.
Return a list of possible coding systems ordered by priority.
The coding systems to try and their priorities follows what
the function ‘coding-system-priority-list’ (which see) returns.

If only ASCII characters are found (except for such ISO-2022 control
characters as ESC), it returns a list of single element ‘undecided’
or its subsidiary coding system according to a detected end-of-line
format.

If optional argument HIGHEST is non-nil, return the coding system of
highest priority.

(fn START END &optional HIGHEST)〉〉enditem49840〈〈detect-coding-string〉〉:〈〈Detect coding system of the text in STRING.
Return a list of possible coding systems ordered by priority.
The coding systems to try and their priorities follows what
the function ‘coding-system-priority-list’ (which see) returns.

If only ASCII characters are found (except for such ISO-2022 control
characters as ESC), it returns a list of single element ‘undecided’
or its subsidiary coding system according to a detected end-of-line
format.

If optional argument HIGHEST is non-nil, return the coding system of
highest priority.

(fn STRING &optional HIGHEST)〉〉enditem49840〈〈coding-system-charset-list〉〉:〈〈Return list of charsets supported by CODING-SYSTEM.
If CODING-SYSTEM supports all ISO-2022 charsets, return ‘iso-2022’.
If CODING-SYSTEM supports all emacs-mule charsets, return ‘emacs-mule’.〉〉enditem49840〈〈iter-next〉〉:〈〈Extract a value from an iterator.
YIELD-RESULT becomes the return value of ‘iter-yield’ in the
context of the generator.

This routine raises the ‘iter-end-of-sequence’ condition if the
iterator cannot supply more values.

(fn ITERATOR &optional YIELD-RESULT)〉〉enditem49840〈〈iter-close〉〉:〈〈Terminate an iterator early.
Run any unwind-protect handlers in scope at the point  ITERATOR
is blocked.

(fn ITERATOR)〉〉enditem49840〈〈locate-file〉〉:〈〈Search for FILENAME through PATH.
If found, return the absolute file name of FILENAME; otherwise
return nil.
PATH should be a list of directories to look in, like the lists in
‘exec-path’ or ‘load-path’.
If SUFFIXES is non-nil, it should be a list of suffixes to append to
file name when searching.  If SUFFIXES is nil, it is equivalent to ("").
Use ("/") to disable PATH search, but still try the suffixes in SUFFIXES.
If non-nil, PREDICATE is used instead of ‘file-readable-p’.

This function will normally skip directories, so if you want it to find
directories, make sure the PREDICATE function returns ‘dir-ok’ for them.

PREDICATE can also be an integer to pass to the ‘access’ system call,
in which case file-name handlers are ignored.  This usage is deprecated.
For compatibility, PREDICATE can also be one of the symbols
‘executable’, ‘readable’, ‘writable’, or ‘exists’, or a list of
one or more of those symbols.

(fn FILENAME PATH &optional SUFFIXES PREDICATE)〉〉enditem49840〈〈executable-find〉〉:〈〈Search for COMMAND in ‘exec-path’ and return the absolute file name.
Return nil if COMMAND is not found anywhere in ‘exec-path’.

(fn COMMAND)〉〉enditem49840〈〈symbol-name〉〉:〈〈Return SYMBOL’s name, a string.

(fn SYMBOL)〉〉enditem49840〈〈make-symbol〉〉:〈〈Return a newly allocated uninterned symbol whose name is NAME.
Its value is void, and its function definition and property list are nil.

(fn NAME)〉〉enditem49840〈〈intern〉〉:〈〈Return the canonical symbol whose name is STRING.
If there is none, one is created by this function and returned.
A second optional argument specifies the obarray to use;
it defaults to the value of ‘obarray’.

(fn STRING &optional OBARRAY)〉〉enditem49840〈〈intern-soft〉〉:〈〈Return the canonical symbol named NAME, or nil if none exists.
NAME may be a string or a symbol.  If it is a symbol, that exact
symbol is searched for.
A second optional argument specifies the obarray to use;
it defaults to the value of ‘obarray’.

(fn NAME &optional OBARRAY)〉〉enditem49840〈〈mapatoms〉〉:〈〈Call FUNCTION on every symbol in OBARRAY.
OBARRAY defaults to the value of ‘obarray’.

(fn FUNCTION &optional OBARRAY)〉〉enditem49840〈〈unintern〉〉:〈〈Delete the symbol named NAME, if any, from OBARRAY.
The value is t if a symbol was found and deleted, nil otherwise.
NAME may be a string or a symbol.  If it is a symbol, that symbol
is deleted, if it belongs to OBARRAY--no other symbol is deleted.
OBARRAY, if nil, defaults to the value of the variable ‘obarray’.

(fn NAME OBARRAY)〉〉enditem49840〈〈current-column〉〉:〈〈Return the horizontal position of point.  Beginning of line is column 0.
This is calculated by adding together the widths of all the displayed
representations of the character between the start of the previous line
and point (e.g., control characters will have a width of 2 or 4, tabs
will have a variable width).
Ignores finite width of frame, which means that this function may return
values greater than (frame-width).
Whether the line is visible (if ‘selective-display’ is t) has no effect;
however, ^M is treated as end of line when ‘selective-display’ is t.
Text that has an invisible property is considered as having width 0, unless
‘buffer-invisibility-spec’ specifies that it is replaced by an ellipsis.

(fn)〉〉enditem49840〈〈special-variable-p〉〉:〈〈Return non-nil if SYMBOL’s global binding has been declared special.
A special variable is one that will be bound dynamically, even in a
context where binding is lexical by default.

(fn SYMBOL)〉〉enditem49840〈〈accessible-keymaps〉〉:〈〈Find all keymaps accessible via prefix characters from KEYMAP.
Returns a list of elements of the form (KEYS . MAP), where the sequence
KEYS starting from KEYMAP gets you to MAP.  These elements are ordered
so that the KEYS increase in length.  The first element is ([] . KEYMAP).
An optional argument PREFIX, if non-nil, should be a key sequence;
then the value includes only maps for prefixes that start with PREFIX.

(fn KEYMAP &optional PREFIX)〉〉enditem49840〈〈map-keymap〉〉:〈〈Call FUNCTION once for each event binding in KEYMAP.
FUNCTION is called with two arguments: the event that is bound, and
the definition it is bound to.  The event may be a character range.

If KEYMAP has a parent, the parent’s bindings are included as well.
This works recursively: if the parent has itself a parent, then the
grandparent’s bindings are also included and so on.

(fn FUNCTION KEYMAP)〉〉enditem49840〈〈where-is-internal〉〉:〈〈Return list of keys that invoke DEFINITION.
If KEYMAP is a keymap, search only KEYMAP and the global keymap.
If KEYMAP is nil, search all the currently active keymaps, except
 for ‘overriding-local-map’ (which is ignored).
If KEYMAP is a list of keymaps, search only those keymaps.

If optional 3rd arg FIRSTONLY is non-nil, return the first key sequence found,
rather than a list of all possible key sequences.
If FIRSTONLY is the symbol ‘non-ascii’, return the first binding found,
no matter what it is.
If FIRSTONLY has another non-nil value, prefer bindings
that use the modifier key specified in ‘where-is-preferred-modifier’
(or their meta variants) and entirely reject menu bindings.

If optional 4th arg NOINDIRECT is non-nil, don’t extract the commands inside
menu-items.  This makes it possible to search for a menu-item itself.

The optional 5th arg NO-REMAP alters how command remapping is handled:

- If another command OTHER-COMMAND is remapped to DEFINITION, normally
  search for the bindings of OTHER-COMMAND and include them in the
  returned list.  But if NO-REMAP is non-nil, include the vector
  [remap OTHER-COMMAND] in the returned list instead, without
  searching for those other bindings.

- If DEFINITION is remapped to OTHER-COMMAND, normally return the
  bindings for OTHER-COMMAND.  But if NO-REMAP is non-nil, return the
  bindings for DEFINITION instead, ignoring its remapping.

(fn DEFINITION &optional KEYMAP FIRSTONLY NOINDIRECT NO-REMAP)〉〉enditem49840〈〈window-display-table〉〉:〈〈Return the display-table that WINDOW is using.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-display-table〉〉:〈〈Set WINDOW’s display-table to TABLE.
WINDOW must be a live window and defaults to the selected one.

(fn WINDOW TABLE)〉〉enditem49840〈〈redisplay〉〉:〈〈Perform redisplay.
Optional arg FORCE, if non-nil, prevents redisplay from being
preempted by arriving input, even if ‘redisplay-dont-pause’ is nil.
If ‘redisplay-dont-pause’ is non-nil (the default), redisplay is never
preempted by arriving input, so FORCE does nothing.

Return t if redisplay was performed, nil if redisplay was preempted
immediately by pending input.

(fn &optional FORCE)〉〉enditem49840〈〈force-window-update〉〉:〈〈Force all windows to be updated on next redisplay.
If optional arg OBJECT is a window, force redisplay of that window only.
If OBJECT is a buffer or buffer name, force redisplay of all windows
displaying that buffer.

(fn &optional OBJECT)〉〉enditem49840〈〈window-start〉〉:〈〈Return position at which display currently starts in WINDOW.
WINDOW must be a live window and defaults to the selected one.
This is updated by redisplay or by calling ‘set-window-start’.

(fn &optional WINDOW)〉〉enditem49840〈〈window-group-start〉〉:〈〈Return position at which display currently starts in the group of
windows containing WINDOW.  When a grouping mode (such as Follow Mode)
is not active, this function is identical to ‘window-start’.

WINDOW must be a live window and defaults to the selected one.
This is updated by redisplay or by calling ‘set-window*-start’.

(fn &optional WINDOW)〉〉enditem49840〈〈window-end〉〉:〈〈Return position at which display currently ends in WINDOW.
WINDOW must be a live window and defaults to the selected one.
This is updated by redisplay, when it runs to completion.
Simply changing the buffer text or setting ‘window-start’
does not update this value.
Return nil if there is no recorded value.  (This can happen if the
last redisplay of WINDOW was preempted, and did not finish.)
If UPDATE is non-nil, compute the up-to-date position
if it isn’t already recorded.

(fn &optional WINDOW UPDATE)〉〉enditem49840〈〈window-group-end〉〉:〈〈Return position at which display currently ends in the group of
windows containing WINDOW.  When a grouping mode (such as Follow Mode)
is not active, this function is identical to ‘window-end’.

WINDOW must be a live window and defaults to the selected one.
This is updated by redisplay, when it runs to completion.
Simply changing the buffer text or setting ‘window-group-start’
does not update this value.
Return nil if there is no recorded value.  (This can happen if the
last redisplay of WINDOW was preempted, and did not finish.)
If UPDATE is non-nil, compute the up-to-date position
if it isn’t already recorded.

(fn &optional WINDOW UPDATE)〉〉enditem49840〈〈set-window-start〉〉:〈〈Make display in WINDOW start at position POS in WINDOW’s buffer.
WINDOW must be a live window and defaults to the selected one.  Return
POS.  Optional third arg NOFORCE non-nil inhibits next redisplay from
overriding motion of point in order to display at this exact start.

(fn WINDOW POS &optional NOFORCE)〉〉enditem49840〈〈set-window-group-start〉〉:〈〈Make display in the group of windows containing WINDOW start at
position POS in WINDOW’s buffer.  When a grouping mode (such as Follow
Mode) is not active, this function is identical to ‘set-window-start’.

WINDOW must be a live window and defaults to the selected one.  Return
POS.  Optional third arg NOFORCE non-nil inhibits next redisplay from
overriding motion of point in order to display at this exact start.

(fn WINDOW POS &optional NOFORCE)〉〉enditem49840〈〈pos-visible-in-window-p〉〉:〈〈Return non-nil if position POS is currently on the frame in WINDOW.
WINDOW must be a live window and defaults to the selected one.

Return nil if that position is scrolled vertically out of view.  If a
character is only partially visible, nil is returned, unless the
optional argument PARTIALLY is non-nil.  If POS is only out of view
because of horizontal scrolling, return non-nil.  If POS is t, it
specifies either the first position displayed on the last visible
screen line in WINDOW, or the end-of-buffer position, whichever comes
first.  POS defaults to point in WINDOW; WINDOW defaults to the
selected window.

If POS is visible, return t if PARTIALLY is nil; if PARTIALLY is non-nil,
the return value is a list of 2 or 6 elements (X Y [RTOP RBOT ROWH VPOS]),
where X and Y are the pixel coordinates relative to the top left corner
of the window.  The remaining elements are omitted if the character after
POS is fully visible; otherwise, RTOP and RBOT are the number of pixels
off-window at the top and bottom of the screen line ("row") containing
POS, ROWH is the visible height of that row, and VPOS is the row number
(zero-based).

(fn &optional POS WINDOW PARTIALLY)〉〉enditem49840〈〈pos-visible-in-window-group-p〉〉:〈〈Return non-nil if position POS is currently on the frame in the
window group containing WINDOW.  When a grouping mode (such as Follow
Mode) is not active, this function is identical to
‘pos-visible-in-window-p’.

WINDOW must be a live window and defaults to the selected one.

Return nil if that position is scrolled vertically out of view.  If a
character is only partially visible, nil is returned, unless the
optional argument PARTIALLY is non-nil.  If POS is only out of view
because of horizontal scrolling, return non-nil.  If POS is t, it
specifies the position of the last visible glyph in the window group.
POS defaults to point in WINDOW; WINDOW defaults to the selected
window.

If POS is visible, return t if PARTIALLY is nil; if PARTIALLY is non-nil,
the return value is a list of 2 or 6 elements (X Y [RTOP RBOT ROWH VPOS]),
where X and Y are the pixel coordinates relative to the top left corner
of the window.  The remaining elements are omitted if the character after
POS is fully visible; otherwise, RTOP and RBOT are the number of pixels
off-window at the top and bottom of the screen line ("row") containing
POS, ROWH is the visible height of that row, and VPOS is the row number
(zero-based).

(fn &optional POS WINDOW PARTIALLY)〉〉enditem49840〈〈window-line-height〉〉:〈〈Return height in pixels of text line LINE in window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Return height of current line if LINE is omitted or nil.  Return height of
header or mode line if LINE is ‘header-line’ or ‘mode-line’.
Otherwise, LINE is a text line number starting from 0.  A negative number
counts from the end of the window.

Value is a list (HEIGHT VPOS YPOS OFFBOT), where HEIGHT is the height
in pixels of the visible part of the line, VPOS and YPOS are the
vertical position in lines and pixels of the line, relative to the top
of the first text line, and OFFBOT is the number of off-window pixels at
the bottom of the text line.  If there are off-window pixels at the top
of the (first) text line, YPOS is negative.

Return nil if window display is not up-to-date.  In that case, use
‘pos-visible-in-window-p’ to obtain the information.

(fn &optional LINE WINDOW)〉〉enditem49840〈〈fringe-bitmaps-at-pos〉〉:〈〈Return fringe bitmaps of row containing position POS in window WINDOW.
If WINDOW is nil, use selected window.  If POS is nil, use value of point
in that window.  Return value is a list (LEFT RIGHT OV), where LEFT
is the symbol for the bitmap in the left fringe (or nil if no bitmap),
RIGHT is similar for the right fringe, and OV is non-nil if there is an
overlay arrow in the left fringe.
Return nil if POS is not visible in WINDOW.

(fn &optional POS WINDOW)〉〉enditem49840〈〈buffer-name〉〉:〈〈Return the name of BUFFER, as a string.
BUFFER defaults to the current buffer.
Return nil if BUFFER has been killed.

(fn &optional BUFFER)〉〉enditem49840〈〈get-buffer〉〉:〈〈Return the buffer named BUFFER-OR-NAME.
BUFFER-OR-NAME must be either a string or a buffer.  If BUFFER-OR-NAME
is a string and there is no buffer with that name, return nil.  If
BUFFER-OR-NAME is a buffer, return it as given.

(fn BUFFER-OR-NAME)〉〉enditem49840〈〈generate-new-buffer-name〉〉:〈〈Return a string that is the name of no existing buffer based on NAME.
If there is no live buffer named NAME, then return NAME.
Otherwise modify name by appending ‘<NUMBER>’, incrementing NUMBER
(starting at 2) until an unused name is found, and then return that name.
Optional second argument IGNORE specifies a name that is okay to use (if
it is in the sequence to be tried) even if a buffer with that name exists.

If NAME begins with a space (i.e., a buffer that is not normally
visible to users), then if buffer NAME already exists a random number
is first appended to NAME, to speed up finding a non-existent buffer.

(fn NAME &optional IGNORE)〉〉enditem49840〈〈jit-lock-register〉〉:〈〈Register FUN as a fontification function to be called in this buffer.
FUN will be called with two arguments START and END indicating the region
that needs to be (re)fontified.
If non-nil, CONTEXTUAL means that a contextual fontification would be useful.

(fn FUN &optional CONTEXTUAL)〉〉enditem49840〈〈jit-lock-unregister〉〉:〈〈Unregister FUN as a fontification function.
Only applies to the current buffer.

(fn FUN)〉〉enditem49840〈〈file-notify-add-watch〉〉:〈〈Add a watch for filesystem events pertaining to FILE.
This arranges for filesystem events pertaining to FILE to be reported
to Emacs.  Use ‘file-notify-rm-watch’ to cancel the watch.

The returned value is a descriptor for the added watch.  If the
file cannot be watched for some reason, this function signals a
‘file-notify-error’ error.

FLAGS is a list of conditions to set what will be watched for.  It can
include the following symbols:

  ‘change’           -- watch for file changes
  ‘attribute-change’ -- watch for file attributes changes, like
                        permissions or modification time

If FILE is a directory, ‘change’ watches for file creation or
deletion in that directory.  This does not work recursively.

When any event happens, Emacs will call the CALLBACK function passing
it a single argument EVENT, which is of the form

  (DESCRIPTOR ACTION FILE [FILE1])

DESCRIPTOR is the same object as the one returned by this function.
ACTION is the description of the event.  It could be any one of the
following:

  ‘created’           -- FILE was created
  ‘deleted’           -- FILE was deleted
  ‘changed’           -- FILE has changed
  ‘renamed’           -- FILE has been renamed to FILE1
  ‘attribute-changed’ -- a FILE attribute was changed
  ‘stopped’           -- watching FILE has been stopped

FILE is the name of the file whose event is being reported.

(fn FILE FLAGS CALLBACK)〉〉enditem49840〈〈file-notify-rm-watch〉〉:〈〈Remove an existing watch specified by its DESCRIPTOR.
DESCRIPTOR should be an object returned by ‘file-notify-add-watch’.

(fn DESCRIPTOR)〉〉enditem49840〈〈file-notify-valid-p〉〉:〈〈Check a watch specified by its DESCRIPTOR.
DESCRIPTOR should be an object returned by ‘file-notify-add-watch’.

(fn DESCRIPTOR)〉〉enditem49840〈〈local-variable-p〉〉:〈〈Non-nil if VARIABLE has a local binding in buffer BUFFER.
BUFFER defaults to the current buffer.

(fn VARIABLE &optional BUFFER)〉〉enditem49840〈〈local-variable-if-set-p〉〉:〈〈Non-nil if VARIABLE is local in buffer BUFFER when set there.
BUFFER defaults to the current buffer.

More precisely, return non-nil if either VARIABLE already has a local
value in BUFFER, or if VARIABLE is automatically buffer-local (see
‘make-variable-buffer-local’).

(fn VARIABLE &optional BUFFER)〉〉enditem49840〈〈buffer-local-value〉〉:〈〈Return the value of VARIABLE in BUFFER.
If VARIABLE does not have a buffer-local binding in BUFFER, the value
is the default binding of the variable.

(fn VARIABLE BUFFER)〉〉enditem49840〈〈buffer-local-variables〉〉:〈〈Return an alist of variables that are buffer-local in BUFFER.
Most elements look like (SYMBOL . VALUE), describing one variable.
For a symbol that is locally unbound, just the symbol appears in the value.
Note that storing new VALUEs in these elements doesn’t change the variables.
No argument or nil as argument means use current buffer as BUFFER.

(fn &optional BUFFER)〉〉enditem49840〈〈kill-all-local-variables〉〉:〈〈Switch to Fundamental mode by killing current buffer’s local variables.
Most local variable bindings are eliminated so that the default values
become effective once more.  Also, the syntax table is set from
‘standard-syntax-table’, the local keymap is set to nil,
and the abbrev table from ‘fundamental-mode-abbrev-table’.
This function also forces redisplay of the mode line.

Every function to select a new major mode starts by
calling this function.

As a special exception, local variables whose names have
a non-nil ‘permanent-local’ property are not eliminated by this function.

The first thing this function does is run
the normal hook ‘change-major-mode-hook’.

(fn)〉〉enditem49840〈〈eventp〉〉:〈〈True if the argument is an event object.

(fn OBJ)〉〉enditem49840〈〈skip-chars-forward〉〉:〈〈Move point forward, stopping before a char not in STRING, or at pos LIM.
STRING is like the inside of a ‘[...]’ in a regular expression
except that ‘]’ is never special and ‘\’ quotes ‘^’, ‘-’ or ‘\’
 (but not at the end of a range; quoting is never needed there).
Thus, with arg "a-zA-Z", this skips letters stopping before first nonletter.
With arg "^a-zA-Z", skips nonletters stopping before first letter.
Char classes, e.g. ‘[:alpha:]’, are supported.

Returns the distance traveled, either zero or positive.

(fn STRING &optional LIM)〉〉enditem49840〈〈skip-chars-backward〉〉:〈〈Move point backward, stopping after a char not in STRING, or at pos LIM.
See ‘skip-chars-forward’ for details.
Returns the distance traveled, either zero or negative.

(fn STRING &optional LIM)〉〉enditem49840〈〈window-parameter〉〉:〈〈Return WINDOW’s value for PARAMETER.
WINDOW can be any window and defaults to the selected one.

(fn WINDOW PARAMETER)〉〉enditem49840〈〈window-parameters〉〉:〈〈Return the parameters of WINDOW and their values.
WINDOW must be a valid window and defaults to the selected one.  The
return value is a list of elements of the form (PARAMETER . VALUE).

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-parameter〉〉:〈〈Set WINDOW’s value of PARAMETER to VALUE.
WINDOW can be any window and defaults to the selected one.
Return VALUE.

(fn WINDOW PARAMETER VALUE)〉〉enditem49840〈〈recent-keys〉〉:〈〈Return vector of last few events, not counting those from keyboard macros.
If INCLUDE-CMDS is non-nil, include the commands that were run,
represented as events of the form (nil . COMMAND).

(fn &optional INCLUDE-CMDS)〉〉enditem49840〈〈terminal-parameters〉〉:〈〈Return the parameter-alist of terminal TERMINAL.
The value is a list of elements of the form (PARM . VALUE), where PARM
is a symbol.

TERMINAL can be a terminal object, a frame, or nil (meaning the
selected frame’s terminal).

(fn &optional TERMINAL)〉〉enditem49840〈〈terminal-parameter〉〉:〈〈Return TERMINAL’s value for parameter PARAMETER.
TERMINAL can be a terminal object, a frame, or nil (meaning the
selected frame’s terminal).

(fn TERMINAL PARAMETER)〉〉enditem49840〈〈set-terminal-parameter〉〉:〈〈Set TERMINAL’s value for parameter PARAMETER to VALUE.
Return the previous value of PARAMETER.

TERMINAL can be a terminal object, a frame or nil (meaning the
selected frame’s terminal).

(fn TERMINAL PARAMETER VALUE)〉〉enditem49840〈〈memq〉〉:〈〈Return non-nil if ELT is an element of LIST.  Comparison done with ‘eq’.
The value is actually the tail of LIST whose car is ELT.

(fn ELT LIST)〉〉enditem49840〈〈delq〉〉:〈〈Delete members of LIST which are ‘eq’ to ELT, and return the result.
More precisely, this function skips any members ‘eq’ to ELT at the
front of LIST, then removes members ‘eq’ to ELT from the remaining
sublist by modifying its list structure, then returns the resulting
list.

Write ‘(setq foo (delq element foo))’ to be sure of correctly changing
the value of a list ‘foo’.  See also ‘remq’, which does not modify the
argument.

(fn ELT LIST)〉〉enditem49840〈〈remq〉〉:〈〈Return LIST with all occurrences of ELT removed.
The comparison is done with ‘eq’.  Contrary to ‘delq’, this does not use
side-effects, and the argument LIST is not modified.

(fn ELT LIST)〉〉enditem49840〈〈memql〉〉:〈〈Return non-nil if ELT is an element of LIST.  Comparison done with ‘eql’.
The value is actually the tail of LIST whose car is ELT.

(fn ELT LIST)〉〉enditem49840〈〈member〉〉:〈〈Return non-nil if ELT is an element of LIST.  Comparison done with ‘equal’.
The value is actually the tail of LIST whose car is ELT.

(fn ELT LIST)〉〉enditem49840〈〈delete〉〉:〈〈Delete members of SEQ which are ‘equal’ to ELT, and return the result.
SEQ must be a sequence (i.e. a list, a vector, or a string).
The return value is a sequence of the same type.

If SEQ is a list, this behaves like ‘delq’, except that it compares
with ‘equal’ instead of ‘eq’.  In particular, it may remove elements
by altering the list structure.

If SEQ is not a list, deletion is never performed destructively;
instead this function creates and returns a new vector or string.

Write ‘(setq foo (delete element foo))’ to be sure of correctly
changing the value of a sequence ‘foo’.

(fn ELT SEQ)〉〉enditem49840〈〈remove〉〉:〈〈Return a copy of SEQ with all occurrences of ELT removed.
SEQ must be a list, vector, or string.  The comparison is done with ‘equal’.

(fn ELT SEQ)〉〉enditem49840〈〈member-ignore-case〉〉:〈〈Like ‘member’, but ignore differences in case and text representation.
ELT must be a string.  Upper-case and lower-case letters are treated as equal.
Unibyte strings are converted to multibyte for comparison.
Non-strings in LIST are ignored.

(fn ELT LIST)〉〉enditem49840〈〈delete-dups〉〉:〈〈Destructively remove ‘equal’ duplicates from LIST.
Store the result in LIST and return it.  LIST must be a proper list.
Of several ‘equal’ occurrences of an element in LIST, the first
one is kept.

(fn LIST)〉〉enditem49840〈〈parse-partial-sexp〉〉:〈〈Parse Lisp syntax starting at FROM until TO; return status of parse at TO.
Parsing stops at TO or when certain criteria are met;
 point is set to where parsing stops.
If fifth arg OLDSTATE is omitted or nil,
 parsing assumes that FROM is the beginning of a function.

Value is a list of elements describing final state of parsing:
 0. depth in parens.
 1. character address of start of innermost containing list; nil if none.
 2. character address of start of last complete sexp terminated.
 3. non-nil if inside a string.
    (it is the character that will terminate the string,
     or t if the string should be terminated by a generic string delimiter.)
 4. nil if outside a comment, t if inside a non-nestable comment,
    else an integer (the current comment nesting).
 5. t if following a quote character.
 6. the minimum paren-depth encountered during this scan.
 7. style of comment, if any.
 8. character address of start of comment or string; nil if not in one.
 9. List of positions of currently open parens, outermost first.
10. When the last position scanned holds the first character of a
    (potential) two character construct, the syntax of that position,
    otherwise nil.  That construct can be a two character comment
    delimiter or an Escaped or Char-quoted character.
11..... Possible further internal information used by ‘parse-partial-sexp’.

If third arg TARGETDEPTH is non-nil, parsing stops if the depth
in parentheses becomes equal to TARGETDEPTH.
Fourth arg STOPBEFORE non-nil means stop when we come to
 any character that starts a sexp.
Fifth arg OLDSTATE is a list like what this function returns.
 It is used to initialize the state of the parse.  Elements number 1, 2, 6
 are ignored.
Sixth arg COMMENTSTOP non-nil means stop after the start of a comment.
 If it is the symbol ‘syntax-table’, stop after the start of a comment or a
 string, or after end of a comment or a string.

(fn FROM TO &optional TARGETDEPTH STOPBEFORE OLDSTATE COMMENTSTOP)〉〉enditem49840〈〈get-buffer-create〉〉:〈〈Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.
If BUFFER-OR-NAME is a string and a live buffer with that name exists,
return that buffer.  If no such buffer exists, create a new buffer with
that name and return it.  If BUFFER-OR-NAME starts with a space, the new
buffer does not keep undo information.

If BUFFER-OR-NAME is a buffer instead of a string, return it as given,
even if it is dead.  The return value is never nil.

(fn BUFFER-OR-NAME)〉〉enditem49840〈〈generate-new-buffer〉〉:〈〈Create and return a buffer with a name based on NAME.
Choose the buffer’s name using ‘generate-new-buffer-name’.

(fn NAME)〉〉enditem49840〈〈current-global-map〉〉:〈〈Return the current global keymap.

(fn)〉〉enditem49840〈〈current-local-map〉〉:〈〈Return current buffer’s local keymap, or nil if it has none.
Normally the local keymap is set by the major mode with ‘use-local-map’.

(fn)〉〉enditem49840〈〈current-minor-mode-maps〉〉:〈〈Return a list of keymaps for the minor modes of the current buffer.

(fn)〉〉enditem49840〈〈use-global-map〉〉:〈〈Select KEYMAP as the global keymap.

(fn KEYMAP)〉〉enditem49840〈〈use-local-map〉〉:〈〈Select KEYMAP as the local keymap.
If KEYMAP is nil, that means no local keymap.

(fn KEYMAP)〉〉enditem49840〈〈set-transient-map〉〉:〈〈Set MAP as a temporary keymap taking precedence over other keymaps.
Normally, MAP is used only once, to look up the very next key.
However, if the optional argument KEEP-PRED is t, MAP stays
active if a key from MAP is used.  KEEP-PRED can also be a
function of no arguments: it is called from ‘pre-command-hook’ and
if it returns non-nil, then MAP stays active.

Optional arg ON-EXIT, if non-nil, specifies a function that is
called, with no arguments, after MAP is deactivated.

This uses ‘overriding-terminal-local-map’ which takes precedence over all other
keymaps.  As usual, if no match for a key is found in MAP, the normal key
lookup sequence then continues.

This returns an "exit function", which can be called with no argument
to deactivate this transient map, regardless of KEEP-PRED.

(fn MAP &optional KEEP-PRED ON-EXIT)〉〉enditem49840〈〈accept-process-output〉〉:〈〈Allow any pending output from subprocesses to be read by Emacs.
It is given to their filter functions.
Optional argument PROCESS means do not return until output has been
received from PROCESS.

Optional second argument SECONDS and third argument MILLISEC
specify a timeout; return after that much time even if there is
no subprocess output.  If SECONDS is a floating point number,
it specifies a fractional number of seconds to wait.
The MILLISEC argument is obsolete and should be avoided.

If optional fourth argument JUST-THIS-ONE is non-nil, accept output
from PROCESS only, suspending reading output from other processes.
If JUST-THIS-ONE is an integer, don’t run any timers either.
Return non-nil if we received any output from PROCESS (or, if PROCESS
is nil, from any process) before the timeout expired.

(fn &optional PROCESS SECONDS MILLISEC JUST-THIS-ONE)〉〉enditem49840〈〈skip-syntax-forward〉〉:〈〈Move point forward across chars in specified syntax classes.
SYNTAX is a string of syntax code characters.
Stop before a char whose syntax is not in SYNTAX, or at position LIM.
If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.
This function returns the distance traveled, either zero or positive.

(fn SYNTAX &optional LIM)〉〉enditem49840〈〈skip-syntax-backward〉〉:〈〈Move point backward across chars in specified syntax classes.
SYNTAX is a string of syntax code characters.
Stop on reaching a char whose syntax is not in SYNTAX, or at position LIM.
If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.
This function returns either zero or a negative number, and the absolute value
of this is the distance traveled.

(fn SYNTAX &optional LIM)〉〉enditem49840〈〈backward-prefix-chars〉〉:〈〈Move point backward over any number of chars with prefix syntax.
This includes chars with expression prefix syntax class (') and those with
the prefix syntax flag (p).

(fn)〉〉enditem49840〈〈vertical-motion〉〉:〈〈Move point to start of the screen line LINES lines down.
If LINES is negative, this means moving up.

This function is an ordinary cursor motion function
which calculates the new position based on how text would be displayed.
The new position may be the start of a line,
or just the start of a continuation line.
The function returns number of screen lines moved over;
that usually equals LINES, but may be closer to zero
if beginning or end of buffer was reached.

The optional second argument WINDOW specifies the window to use for
parameters such as width, horizontal scrolling, and so on.
The default is to use the selected window’s parameters.

LINES can optionally take the form (COLS . LINES), in which case the
motion will not stop at the start of a screen line but COLS column
from the visual start of the line (if such exists on that line, that
is).  If the line is scrolled horizontally, COLS is interpreted
visually, i.e., as addition to the columns of text beyond the left
edge of the window.

The optional third argument CUR-COL specifies the horizontal
window-relative coordinate of point, in units of frame’s canonical
character width, where the function is invoked.  If this argument is
omitted or nil, the function will determine the point coordinate by
going back to the beginning of the line.

‘vertical-motion’ always uses the current buffer,
regardless of which buffer is displayed in WINDOW.
This is consistent with other cursor motion functions
and makes it possible to use ‘vertical-motion’ in any buffer,
whether or not it is currently displayed in some window.

(fn LINES &optional WINDOW CUR-COL)〉〉enditem49840〈〈count-screen-lines〉〉:〈〈Return the number of screen lines in the region.
The number of screen lines may be different from the number of actual lines,
due to line breaking, display table, etc.

Optional arguments BEG and END default to ‘point-min’ and ‘point-max’
respectively.

If region ends with a newline, ignore it unless optional third argument
COUNT-FINAL-NEWLINE is non-nil.

The optional fourth argument WINDOW specifies the window used for obtaining
parameters such as width, horizontal scrolling, and so on.  The default is
to use the selected window’s parameters.

Like ‘vertical-motion’, ‘count-screen-lines’ always uses the current buffer,
regardless of which buffer is displayed in WINDOW.  This makes possible to use
‘count-screen-lines’ in any buffer, whether or not it is currently displayed
in some window.

(fn &optional BEG END COUNT-FINAL-NEWLINE WINDOW)〉〉enditem49840〈〈move-to-window-group-line〉〉:〈〈Position point relative to the current group of windows.
When a grouping mode (such as Follow Mode) is not active, this
function is identical to ‘move-to-window-line’.

ARG nil means position point at center of the window group.
Else, ARG specifies the vertical position within the window
group; zero means top of first window in the group, negative
means relative to the bottom of the last window in the group.

(fn ARG)〉〉enditem49840〈〈compute-motion〉〉:〈〈Scan through the current buffer, calculating screen position.
Scan the current buffer forward from offset FROM,
assuming it is at position FROMPOS--a cons of the form (HPOS . VPOS)--
to position TO or position TOPOS--another cons of the form (HPOS . VPOS)--
and return the ending buffer position and screen location.

If TOPOS is nil, the actual width and height of the window’s
text area are used.

There are three additional arguments:

WIDTH is the number of columns available to display text;
this affects handling of continuation lines.  A value of nil
corresponds to the actual number of available text columns.

OFFSETS is either nil or a cons cell (HSCROLL . TAB-OFFSET).
HSCROLL is the number of columns not being displayed at the left
margin; this is usually taken from a window’s hscroll member.
TAB-OFFSET is the number of columns of the first tab that aren’t
being displayed, perhaps because the line was continued within it.
If OFFSETS is nil, HSCROLL and TAB-OFFSET are assumed to be zero.

WINDOW is the window to operate on.  It is used to choose the display table;
if it is showing the current buffer, it is used also for
deciding which overlay properties apply.
Note that ‘compute-motion’ always operates on the current buffer.

The value is a list of five elements:
  (POS HPOS VPOS PREVHPOS CONTIN)
POS is the buffer position where the scan stopped.
VPOS is the vertical position where the scan stopped.
HPOS is the horizontal position where the scan stopped.

PREVHPOS is the horizontal position one character back from POS.
CONTIN is t if a line was continued after (or within) the previous character.

For example, to find the buffer position of column COL of line LINE
of a certain window, pass the window’s starting location as FROM
and the window’s upper-left coordinates as FROMPOS.
Pass the buffer’s (point-max) as TO, to limit the scan to the end of the
visible section of the buffer, and pass LINE and COL as TOPOS.

(fn FROM FROMPOS TO TOPOS WIDTH OFFSETS WINDOW)〉〉enditem49840〈〈file-exists-p〉〉:〈〈Return t if file FILENAME exists (whether or not you can read it.)
See also ‘file-readable-p’ and ‘file-attributes’.
This returns nil for a symlink to a nonexistent file.
Use ‘file-symlink-p’ to test for such links.

(fn FILENAME)〉〉enditem49840〈〈file-readable-p〉〉:〈〈Return t if file FILENAME exists and you can read it.
See also ‘file-exists-p’ and ‘file-attributes’.

(fn FILENAME)〉〉enditem49840〈〈file-executable-p〉〉:〈〈Return t if FILENAME can be executed by you.
For a directory, this means you can access files in that directory.
(It is generally better to use ‘file-accessible-directory-p’ for that
purpose, though.)

(fn FILENAME)〉〉enditem49840〈〈file-writable-p〉〉:〈〈Return t if file FILENAME can be written or created by you.

(fn FILENAME)〉〉enditem49840〈〈file-accessible-directory-p〉〉:〈〈Return t if FILENAME names a directory you can open.
For the value to be t, FILENAME must specify the name of a directory
as a file, and the directory must allow you to open files in it.  In
order to use a directory as a buffer’s current directory, this
predicate must return true.  A directory name spec may be given
instead; then the value is t if the directory so specified exists and
really is a readable and searchable directory.

(fn FILENAME)〉〉enditem49840〈〈access-file〉〉:〈〈Access file FILENAME, and get an error if that does not work.
The second argument STRING is prepended to the error message.
If there is no error, returns nil.

(fn FILENAME STRING)〉〉enditem49840〈〈file-ownership-preserved-p〉〉:〈〈Return t if deleting FILE and rewriting it would preserve the owner.
Return also t if FILE does not exist.  If GROUP is non-nil, check whether
the group would be preserved too.

(fn FILE &optional GROUP)〉〉enditem49840〈〈file-modes〉〉:〈〈Return mode bits of file named FILENAME, as an integer.
Return nil, if file does not exist or is not accessible.

(fn FILENAME)〉〉enditem49840〈〈open-network-stream〉〉:〈〈Open a TCP connection to HOST, optionally with encryption.
Normally, return a network process object; with a non-nil
:return-list parameter, return a list instead (see below).
Input and output work as for subprocesses; ‘delete-process’
closes it.

NAME is the name for the process.  It is modified if necessary to
 make it unique.
BUFFER is a buffer or buffer name to associate with the process.
 Process output goes at end of that buffer.  BUFFER may be nil,
 meaning that the process is not associated with any buffer.
HOST is the name or IP address of the host to connect to.
SERVICE is the name of the service desired, or an integer or
 integer string specifying a port number to connect to.

The remaining PARAMETERS should be a sequence of keywords and
values:

:type specifies the connection type, one of the following:
  nil or ‘network’
             -- Begin with an ordinary network connection, and if
                the parameters :success and :capability-command
                are also supplied, try to upgrade to an encrypted
                connection via STARTTLS.  Even if that
                fails (e.g. if HOST does not support TLS), retain
                an unencrypted connection.
  ‘plain’    -- An ordinary, unencrypted network connection.
  ‘starttls’ -- Begin with an ordinary connection, and try
                upgrading via STARTTLS.  If that fails for any
                reason, drop the connection; in that case the
                returned object is a killed process.
  ‘tls’      -- A TLS connection.
  ‘ssl’      -- Equivalent to ‘tls’.
  ‘shell’    -- A shell connection.

:return-list specifies this function’s return value.
  If omitted or nil, return a process object.  A non-nil means to
  return (PROC . PROPS), where PROC is a process object and PROPS
  is a plist of connection properties, with these keywords:
   :greeting -- the greeting returned by HOST (a string), or nil.
   :capabilities -- a string representing HOST’s capabilities,
                    or nil if none could be found.
   :type -- the resulting connection type; ‘plain’ (unencrypted)
            or ‘tls’ (TLS-encrypted).

:end-of-command specifies a regexp matching the end of a command.

:end-of-capability specifies a regexp matching the end of the
  response to the command specified for :capability-command.
  It defaults to the regexp specified for :end-of-command.

:success specifies a regexp matching a message indicating a
  successful STARTTLS negotiation.  For instance, the default
  should be "^3" for an NNTP connection.

:capability-command specifies a command used to query the HOST
  for its capabilities.  For instance, for IMAP this should be
  "1 CAPABILITY\r\n".

:starttls-function specifies a function for handling STARTTLS.
  This function should take one parameter, the response to the
  capability command, and should return the command to switch on
  STARTTLS if the server supports STARTTLS, and nil otherwise.

:always-query-capabilities says whether to query the server for
  capabilities, even if we’re doing a ‘plain’ network connection.

:client-certificate should either be a list where the first
  element is the certificate key file name, and the second
  element is the certificate file name itself, or t, which
  means that ‘auth-source’ will be queried for the key and the
  certificate.  This parameter will only be used when doing TLS
  or STARTTLS connections.

:use-starttls-if-possible is a boolean that says to do opportunistic
STARTTLS upgrades even if Emacs doesn’t have built-in TLS functionality.

:warn-unless-encrypted is a boolean which, if :return-list is
non-nil, is used warn the user if the connection isn’t encrypted.

:nogreeting is a boolean that can be used to inhibit waiting for
a greeting from the server.

:nowait, if non-nil, says the connection should be made
asynchronously, if possible.

:shell-command is a format-spec string that can be used if :type
is ‘shell’.  It has two specs, %s for host and %p for port
number.  Example: "ssh gateway nc %s %p".

:tls-parameters is a list that should be supplied if you’re
opening a TLS connection.  The first element is the TLS
type (either ‘gnutls-x509pki’ or ‘gnutls-anon’), and the
remaining elements should be a keyword list accepted by
gnutls-boot (as returned by ‘gnutls-boot-parameters’).

(fn NAME BUFFER HOST SERVICE &rest PARAMETERS)〉〉enditem49840〈〈undo-boundary〉〉:〈〈Mark a boundary between units of undo.
An undo command will stop at this point,
but another undo command will undo to the previous boundary.

(fn)〉〉enditem49840〈〈undo-auto-amalgamate〉〉:〈〈Amalgamate undo if necessary.
This function can be called before an amalgamating command.  It
removes the previous ‘undo-boundary’ if a series of such calls
have been made.  By default ‘self-insert-command’ and
‘delete-char’ are the only amalgamating commands, although this
function could be called by any command wishing to have this
behavior.〉〉enditem49840〈〈primitive-undo〉〉:〈〈Undo N records from the front of the list LIST.
Return what remains of the list.

(fn N LIST)〉〉enditem49840〈〈keyboard-coding-system〉〉:〈〈Return coding system specified for decoding keyboard input.

(fn &optional TERMINAL)〉〉enditem49840〈〈terminal-coding-system〉〉:〈〈Return coding system specified for terminal output on the given terminal.
TERMINAL may be a terminal object, a frame, or nil for the selected
frame’s terminal device.

(fn &optional TERMINAL)〉〉enditem49840〈〈symbolp〉〉:〈〈Return t if OBJECT is a symbol.

(fn OBJECT)〉〉enditem49840〈〈booleanp〉〉:〈〈Return t if OBJECT is one of the two canonical boolean values: t or nil.
Otherwise, return nil.

(fn OBJECT)〉〉enditem49840〈〈functionp〉〉:〈〈Return t if OBJECT is a function.

(fn OBJECT)〉〉enditem49840〈〈subrp〉〉:〈〈Return t if OBJECT is a built-in function.

(fn OBJECT)〉〉enditem49840〈〈byte-code-function-p〉〉:〈〈Return t if OBJECT is a byte-compiled function object.

(fn OBJECT)〉〉enditem49840〈〈subr-arity〉〉:〈〈Return minimum and maximum number of args allowed for SUBR.
SUBR must be a built-in function.
The returned value is a pair (MIN . MAX).  MIN is the minimum number
of args.  MAX is the maximum number or the symbol ‘many’, for a
function with ‘&rest’ args, or ‘unevalled’ for a special form.

(fn SUBR)〉〉enditem49840〈〈char-width〉〉:〈〈Return width of CHAR when displayed in the current buffer.
The width is measured by how many columns it occupies on the screen.
Tab is taken to occupy ‘tab-width’ columns.

(fn CHAR)〉〉enditem49840〈〈string-width〉〉:〈〈Return width of STRING when displayed in the current buffer.
Width is measured by how many columns it occupies on the screen.
When calculating width of a multibyte character in STRING,
only the base leading-code is considered; the validity of
the following bytes is not checked.  Tabs in STRING are always
taken to occupy ‘tab-width’ columns.

(fn STRING)〉〉enditem49840〈〈truncate-string-to-width〉〉:〈〈Truncate string STR to end at column END-COLUMN.
The optional 3rd arg START-COLUMN, if non-nil, specifies the starting
column; that means to return the characters occupying columns
START-COLUMN ... END-COLUMN of STR.  Both END-COLUMN and START-COLUMN
are specified in terms of character display width in the current
buffer; see also ‘char-width’.

The optional 4th arg PADDING, if non-nil, specifies a padding
character (which should have a display width of 1) to add at the end
of the result if STR doesn’t reach column END-COLUMN, or if END-COLUMN
comes in the middle of a character in STR.  PADDING is also added at
the beginning of the result if column START-COLUMN appears in the
middle of a character in STR.

If PADDING is nil, no padding is added in these cases, so
the resulting string may be narrower than END-COLUMN.

If ELLIPSIS is non-nil, it should be a string which will replace the
end of STR (including any padding) if it extends beyond END-COLUMN,
unless the display width of STR is equal to or less than the display
width of ELLIPSIS.  If it is non-nil and not a string, then ELLIPSIS
defaults to ‘truncate-string-ellipsis’.

(fn STR END-COLUMN &optional START-COLUMN PADDING ELLIPSIS)〉〉enditem49840〈〈window-text-pixel-size〉〉:〈〈Return the size of the text of WINDOW’s buffer in pixels.
WINDOW must be a live window and defaults to the selected one.  The
return value is a cons of the maximum pixel-width of any text line and
the maximum pixel-height of all text lines.

The optional argument FROM, if non-nil, specifies the first text
position and defaults to the minimum accessible position of the buffer.
If FROM is t, use the minimum accessible position that starts a
non-empty line.  TO, if non-nil, specifies the last text position and
defaults to the maximum accessible position of the buffer.  If TO is t,
use the maximum accessible position that ends a non-empty line.

The optional argument X-LIMIT, if non-nil, specifies the maximum text
width that can be returned.  X-LIMIT nil or omitted, means to use the
pixel-width of WINDOW’s body; use this if you want to know how high
WINDOW should be become in order to fit all of its buffer’s text with
the width of WINDOW unaltered.  Use the maximum width WINDOW may assume
if you intend to change WINDOW’s width.  In any case, text whose
x-coordinate is beyond X-LIMIT is ignored.  Since calculating the width
of long lines can take some time, it’s always a good idea to make this
argument as small as possible; in particular, if the buffer contains
long lines that shall be truncated anyway.

The optional argument Y-LIMIT, if non-nil, specifies the maximum text
height (excluding the height of the mode- or header-line, if any) that
can be returned.  Text lines whose y-coordinate is beyond Y-LIMIT are
ignored.  Since calculating the text height of a large buffer can take
some time, it makes sense to specify this argument if the size of the
buffer is large or unknown.

Optional argument MODE-AND-HEADER-LINE nil or omitted means do not
include the height of the mode- or header-line of WINDOW in the return
value.  If it is either the symbol ‘mode-line’ or ‘header-line’, include
only the height of that line, if present, in the return value.  If t,
include the height of both, if present, in the return value.

(fn &optional WINDOW FROM TO X-LIMIT Y-LIMIT MODE-AND-HEADER-LINE)〉〉enditem49840〈〈documentation-property〉〉:〈〈Return the documentation string that is SYMBOL’s PROP property.
Third argument RAW omitted or nil means pass the result through
‘substitute-command-keys’ if it is a string.

This differs from ‘get’ in that it can refer to strings stored in the
‘etc/DOC’ file; and that it evaluates documentation properties that
aren’t strings.

(fn SYMBOL PROP &optional RAW)〉〉enditem49840〈〈documentation〉〉:〈〈Return the documentation string of FUNCTION.
Unless a non-nil second argument RAW is given, the
string is passed through ‘substitute-command-keys’.

(fn FUNCTION &optional RAW)〉〉enditem49840〈〈face-documentation〉〉:〈〈Get the documentation string for FACE.
If FACE is a face-alias, get the documentation for the target face.

(fn FACE)〉〉enditem49840〈〈Snarf-documentation〉〉:〈〈Used during Emacs initialization to scan the ‘etc/DOC...’ file.
This searches the ‘etc/DOC...’ file for doc strings and
records them in function and variable definitions.
The function takes one argument, FILENAME, a string;
it specifies the file name (without a directory) of the DOC file.
That file is found in ‘../etc’ now; later, when the dumped Emacs is run,
the same file name is found in the ‘doc-directory’.

(fn FILENAME)〉〉enditem49840〈〈match-string〉〉:〈〈Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
 Value is nil if NUMth pair didn’t match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by ‘string-match’ on STRING.
If STRING is nil, the current buffer should be the same buffer
the search/match was performed in.

(fn NUM &optional STRING)〉〉enditem49840〈〈match-string-no-properties〉〉:〈〈Return string of text matched by last search, without text properties.
NUM specifies which parenthesized expression in the last regexp.
 Value is nil if NUMth pair didn’t match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by ‘string-match’ on STRING.
If STRING is nil, the current buffer should be the same buffer
the search/match was performed in.

(fn NUM &optional STRING)〉〉enditem49840〈〈match-beginning〉〉:〈〈Return position of start of text matched by last search.
SUBEXP, a number, specifies which parenthesized expression in the last
  regexp.
Value is nil if SUBEXPth pair didn’t match, or there were less than
  SUBEXP pairs.
Zero means the entire text matched by the whole regexp or whole string.

Return value is undefined if the last search failed.

(fn SUBEXP)〉〉enditem49840〈〈match-end〉〉:〈〈Return position of end of text matched by last search.
SUBEXP, a number, specifies which parenthesized expression in the last
  regexp.
Value is nil if SUBEXPth pair didn’t match, or there were less than
  SUBEXP pairs.
Zero means the entire text matched by the whole regexp or whole string.

Return value is undefined if the last search failed.

(fn SUBEXP)〉〉enditem49840〈〈coding-system-priority-list〉〉:〈〈Return a list of coding systems ordered by their priorities.
The list contains a subset of coding systems; i.e. coding systems
assigned to each coding category (see ‘coding-category-list’).

HIGHESTP non-nil means just return the highest priority one.

(fn &optional HIGHESTP)〉〉enditem49840〈〈set-coding-system-priority〉〉:〈〈Assign higher priority to the coding systems given as arguments.
If multiple coding systems belong to the same category,
all but the first one are ignored.

(fn &rest coding-systems)〉〉enditem49840〈〈x-popup-menu〉〉:〈〈Pop up a deck-of-cards menu and return user’s selection.
POSITION is a position specification.  This is either a mouse button event
or a list ((XOFFSET YOFFSET) WINDOW)
where XOFFSET and YOFFSET are positions in pixels from the top left
corner of WINDOW.  (WINDOW may be a window or a frame object.)
This controls the position of the top left of the menu as a whole.
If POSITION is t, it means to use the current mouse position.

MENU is a specifier for a menu.  For the simplest case, MENU is a keymap.
The menu items come from key bindings that have a menu string as well as
a definition; actually, the "definition" in such a key binding looks like
(STRING . REAL-DEFINITION).  To give the menu a title, put a string into
the keymap as a top-level element.

If REAL-DEFINITION is nil, that puts a nonselectable string in the menu.
Otherwise, REAL-DEFINITION should be a valid key binding definition.

You can also use a list of keymaps as MENU.
  Then each keymap makes a separate pane.

When MENU is a keymap or a list of keymaps, the return value is the
list of events corresponding to the user’s choice. Note that
‘x-popup-menu’ does not actually execute the command bound to that
sequence of events.

Alternatively, you can specify a menu of multiple panes
  with a list of the form (TITLE PANE1 PANE2...),
where each pane is a list of form (TITLE ITEM1 ITEM2...).
Each ITEM is normally a cons cell (STRING . VALUE);
but a string can appear as an item--that makes a nonselectable line
in the menu.
With this form of menu, the return value is VALUE from the chosen item.

If POSITION is nil, don’t display the menu at all, just precalculate the
cached information about equivalent key sequences.

If the user gets rid of the menu without making a valid choice, for
instance by clicking the mouse away from a valid choice or by typing
keyboard input, then this normally results in a quit and
‘x-popup-menu’ does not return.  But if POSITION is a mouse button
event (indicating that the user invoked the menu with the mouse) then
no quit occurs and ‘x-popup-menu’ returns nil.

(fn POSITION MENU)〉〉enditem49840〈〈-〉〉:〈〈Negate number or subtract numbers or markers and return the result.
With one arg, negates it.  With more than one arg,
subtracts all but the first from the first.

(fn &optional NUMBER-OR-MARKER &rest MORE-NUMBERS-OR-MARKERS)〉〉enditem49840〈〈mod〉〉:〈〈Return X modulo Y.
The result falls between zero (inclusive) and Y (exclusive).
Both X and Y must be numbers or markers.

(fn X Y)〉〉enditem49840〈〈symbol-file〉〉:〈〈Return the name of the file that defined SYMBOL.
The value is normally an absolute file name.  It can also be nil,
if the definition is not associated with any file.  If SYMBOL
specifies an autoloaded function, the value can be a relative
file name without extension.

If TYPE is nil, then any kind of definition is acceptable.  If
TYPE is ‘defun’, ‘defvar’, or ‘defface’, that specifies function
definition, variable definition, or face definition only.
Otherwise TYPE is assumed to be a symbol property.

(fn SYMBOL &optional TYPE)〉〉enditem49840〈〈command-line〉〉:〈〈A subroutine of ‘normal-top-level’.
Amongst another things, it parses the command-line arguments.〉〉enditem49840〈〈get-load-suffixes〉〉:〈〈Return the suffixes that ‘load’ should try if a suffix is required.
This uses the variables ‘load-suffixes’ and ‘load-file-rep-suffixes’.

(fn)〉〉enditem49840〈〈defalias〉〉:〈〈Set SYMBOL’s function definition to DEFINITION.
Associates the function with the current load file, if any.
The optional third argument DOCSTRING specifies the documentation string
for SYMBOL; if it is omitted or nil, SYMBOL uses the documentation string
determined by DEFINITION.

Internally, this normally uses ‘fset’, but if SYMBOL has a
‘defalias-fset-function’ property, the associated value is used instead.

The return value is undefined.

(fn SYMBOL DEFINITION &optional DOCSTRING)〉〉enditem49840〈〈define-button-type〉〉:〈〈Define a ‘button type’ called NAME (a symbol).
The remaining arguments form a sequence of PROPERTY VALUE pairs,
specifying properties to use as defaults for buttons with this type
(a button’s type may be set by giving it a ‘type’ property when
creating the button, using the :type keyword argument).

In addition, the keyword argument :supertype may be used to specify a
button-type from which NAME inherits its default property values
(however, the inheritance happens only when NAME is defined; subsequent
changes to a supertype are not reflected in its subtypes).〉〉enditem49840〈〈custom-set-variables〉〉:〈〈Install user customizations of variable values specified in ARGS.
These settings are registered as theme ‘user’.
The arguments should each be a list of the form:

  (SYMBOL EXP [NOW [REQUEST [COMMENT]]])

This stores EXP (without evaluating it) as the saved value for SYMBOL.
If NOW is present and non-nil, then also evaluate EXP and set
the default value for the SYMBOL to the value of EXP.

REQUEST is a list of features we must require in order to
handle SYMBOL properly.
COMMENT is a comment string about SYMBOL.〉〉enditem49840〈〈custom-set-faces〉〉:〈〈Apply a list of face specs for user customizations.
This works by calling ‘custom-theme-set-faces’ for the ‘user’
theme, a special theme referring to settings made via Customize.
The arguments should be a list where each entry has the form:

  (FACE SPEC [NOW [COMMENT]])

See the documentation of ‘custom-theme-set-faces’ for details.〉〉enditem49840〈〈interactive-form〉〉:〈〈Return the interactive form of CMD or nil if none.
If CMD is not a command, the return value is nil.
Value, if non-nil, is a list (interactive SPEC).

(fn CMD)〉〉enditem49840〈〈encode-coding-string〉〉:〈〈Encode STRING to CODING-SYSTEM, and return the result.

Optional third arg NOCOPY non-nil means it is OK to return STRING
itself if the encoding operation is trivial.

Optional fourth arg BUFFER non-nil means that the encoded text is
inserted in that buffer after point (point does not move).  In this
case, the return value is the length of the encoded text.

This function sets ‘last-coding-system-used’ to the precise coding system
used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
not fully specified.)

(fn STRING CODING-SYSTEM &optional NOCOPY BUFFER)〉〉enditem49840〈〈decode-coding-string〉〉:〈〈Decode STRING which is encoded in CODING-SYSTEM, and return the result.

Optional third arg NOCOPY non-nil means it is OK to return STRING itself
if the decoding operation is trivial.

Optional fourth arg BUFFER non-nil means that the decoded text is
inserted in that buffer after point (point does not move).  In this
case, the return value is the length of the decoded text.

This function sets ‘last-coding-system-used’ to the precise coding system
used (which may be different from CODING-SYSTEM if CODING-SYSTEM is
not fully specified.)

(fn STRING CODING-SYSTEM &optional NOCOPY BUFFER)〉〉enditem49840〈〈decode-coding-inserted-region〉〉:〈〈Decode the region between FROM and TO as if it is read from file FILENAME.
The idea is that the text between FROM and TO was just inserted somehow.
Optional arguments VISIT, BEG, END, and REPLACE are the same as those
of the function ‘insert-file-contents’.
Part of the job of this function is setting ‘buffer-undo-list’ appropriately.〉〉enditem49840〈〈make-hash-table〉〉:〈〈Create and return a new hash table.

Arguments are specified as keyword/argument pairs.  The following
arguments are defined:

:test TEST -- TEST must be a symbol that specifies how to compare
keys.  Default is ‘eql’.  Predefined are the tests ‘eq’, ‘eql’, and
‘equal’.  User-supplied test and hash functions can be specified via
‘define-hash-table-test’.

:size SIZE -- A hint as to how many elements will be put in the table.
Default is 65.

:rehash-size REHASH-SIZE - Indicates how to expand the table when it
fills up.  If REHASH-SIZE is an integer, increase the size by that
amount.  If it is a float, it must be > 1.0, and the new size is the
old size multiplied by that factor.  Default is 1.5.

:rehash-threshold THRESHOLD -- THRESHOLD must a float > 0, and <= 1.0.
Resize the hash table when the ratio (table entries / table size)
exceeds an approximation to THRESHOLD.  Default is 0.8125.

:weakness WEAK -- WEAK must be one of nil, t, ‘key’, ‘value’,
‘key-or-value’, or ‘key-and-value’.  If WEAK is not nil, the table
returned is a weak table.  Key/value pairs are removed from a weak
hash table when there are no non-weak references pointing to their
key, value, one of key or value, or both key and value, depending on
WEAK.  WEAK t is equivalent to ‘key-and-value’.  Default value of WEAK
is nil.

:purecopy PURECOPY -- If PURECOPY is non-nil, the table can be copied
to pure storage when Emacs is being dumped, making the contents of the
table read only. Any further changes to purified tables will result
in an error.

(fn &rest KEYWORD-ARGS)〉〉enditem49840〈〈secure-hash〉〉:〈〈Return the secure hash of OBJECT, a buffer or string.
ALGORITHM is a symbol specifying the hash to use:
md5, sha1, sha224, sha256, sha384 or sha512.

The two optional arguments START and END are positions specifying for
which part of OBJECT to compute the hash.  If nil or omitted, uses the
whole OBJECT.

The full list of algorithms can be obtained with ‘secure-hash-algorithms’.

If BINARY is non-nil, returns a string in binary form.

(fn ALGORITHM OBJECT &optional START END BINARY)〉〉enditem49840〈〈frame-geometry〉〉:〈〈Return geometric attributes of FRAME.
FRAME must be a live frame and defaults to the selected one.  The return
value is an association list of the attributes listed below.  All height
and width values are in pixels.

‘outer-position’ is a cons of the outer left and top edges of FRAME
  relative to the origin - the position (0, 0) - of FRAME’s display.

‘outer-size’ is a cons of the outer width and height of FRAME.  The
  outer size includes the title bar and the external borders as well as
  any menu and/or tool bar of frame.

‘external-border-size’ is a cons of the horizontal and vertical width of
  FRAME’s external borders as supplied by the window manager.

‘title-bar-size’ is a cons of the width and height of the title bar of
  FRAME as supplied by the window manager.  If both of them are zero,
  FRAME has no title bar.  If only the width is zero, Emacs was not
  able to retrieve the width information.

‘menu-bar-external’, if non-nil, means the menu bar is external (never
  included in the inner edges of FRAME).

‘menu-bar-size’ is a cons of the width and height of the menu bar of
  FRAME.

‘tool-bar-external’, if non-nil, means the tool bar is external (never
  included in the inner edges of FRAME).

‘tool-bar-position’ tells on which side the tool bar on FRAME is and can
  be one of ‘left’, ‘top’, ‘right’ or ‘bottom’.  If this is nil, FRAME
  has no tool bar.

‘tool-bar-size’ is a cons of the width and height of the tool bar of
  FRAME.

‘internal-border-width’ is the width of the internal border of
  FRAME.

(fn &optional FRAME)〉〉enditem49840〈〈frame-edges〉〉:〈〈Return coordinates of FRAME’s edges.
FRAME must be a live frame and defaults to the selected one.  The
list returned has the form (LEFT TOP RIGHT BOTTOM) where all
values are in pixels relative to the origin - the position (0, 0)
- of FRAME’s display.  For terminal frames all values are
relative to LEFT and TOP which are both zero.

Optional argument TYPE specifies the type of the edges.  TYPE
‘outer-edges’ means to return the outer edges of FRAME.  TYPE
‘native-edges’ (or nil) means to return the native edges of
FRAME.  TYPE ‘inner-edges’ means to return the inner edges of
FRAME.

(fn &optional FRAME TYPE)〉〉enditem49840〈〈buffer-narrowed-p〉〉:〈〈Return non-nil if the current buffer is narrowed.〉〉enditem49840〈〈locale-info〉〉:〈〈Access locale data ITEM for the current C locale, if available.
ITEM should be one of the following:

‘codeset’, returning the character set as a string (locale item CODESET);

‘days’, returning a 7-element vector of day names (locale items DAY_n);

‘months’, returning a 12-element vector of month names (locale items MON_n);

‘paper’, returning a list (WIDTH HEIGHT) for the default paper size,
  both measured in millimeters (locale items PAPER_WIDTH, PAPER_HEIGHT).

If the system can’t provide such information through a call to
‘nl_langinfo’, or if ITEM isn’t from the list above, return nil.

See also Info node ‘(libc)Locales’.

The data read from the system are decoded using ‘locale-coding-system’.

(fn ITEM)〉〉enditem49840〈〈keymap-prompt〉〉:〈〈Return the prompt-string of a keymap MAP.
If non-nil, the prompt is shown in the echo-area
when reading a key-sequence to be looked-up in this keymap.

(fn MAP)〉〉enditem49840〈〈set-window-margins〉〉:〈〈Set width of marginal areas of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Second arg LEFT-WIDTH specifies the number of character cells to
reserve for the left marginal area.  Optional third arg RIGHT-WIDTH
does the same for the right marginal area.  A nil width parameter
means no margin.

Return t if any margin was actually changed and nil otherwise.

(fn WINDOW LEFT-WIDTH &optional RIGHT-WIDTH)〉〉enditem49840〈〈window-margins〉〉:〈〈Get width of marginal areas of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Value is a cons of the form (LEFT-WIDTH . RIGHT-WIDTH).
If a marginal area does not exist, its width will be returned
as nil.

(fn &optional WINDOW)〉〉enditem49840〈〈try-completion〉〉:〈〈Return common substring of all completions of STRING in COLLECTION.
Test each possible completion specified by COLLECTION
to see if it begins with STRING.  The possible completions may be
strings or symbols.  Symbols are converted to strings before testing,
see ‘symbol-name’.
All that match STRING are compared together; the longest initial sequence
common to all these matches is the return value.
If there is no match at all, the return value is nil.
For a unique match which is exact, the return value is t.

If COLLECTION is an alist, the keys (cars of elements) are the
possible completions.  If an element is not a cons cell, then the
element itself is the possible completion.
If COLLECTION is a hash-table, all the keys that are strings or symbols
are the possible completions.
If COLLECTION is an obarray, the names of all symbols in the obarray
are the possible completions.

COLLECTION can also be a function to do the completion itself.
It receives three arguments: the values STRING, PREDICATE and nil.
Whatever it returns becomes the value of ‘try-completion’.

If optional third argument PREDICATE is non-nil,
it is used to test each possible match.
The match is a candidate only if PREDICATE returns non-nil.
The argument given to PREDICATE is the alist element
or the symbol from the obarray.  If COLLECTION is a hash-table,
predicate is called with two arguments: the key and the value.
Additionally to this predicate, ‘completion-regexp-list’
is used to further constrain the set of candidates.

(fn STRING COLLECTION &optional PREDICATE)〉〉enditem49840〈〈all-completions〉〉:〈〈Search for partial matches to STRING in COLLECTION.
Test each of the possible completions specified by COLLECTION
to see if it begins with STRING.  The possible completions may be
strings or symbols.  Symbols are converted to strings before testing,
see ‘symbol-name’.
The value is a list of all the possible completions that match STRING.

If COLLECTION is an alist, the keys (cars of elements) are the
possible completions.  If an element is not a cons cell, then the
element itself is the possible completion.
If COLLECTION is a hash-table, all the keys that are strings or symbols
are the possible completions.
If COLLECTION is an obarray, the names of all symbols in the obarray
are the possible completions.

COLLECTION can also be a function to do the completion itself.
It receives three arguments: the values STRING, PREDICATE and t.
Whatever it returns becomes the value of ‘all-completions’.

If optional third argument PREDICATE is non-nil,
it is used to test each possible match.
The match is a candidate only if PREDICATE returns non-nil.
The argument given to PREDICATE is the alist element
or the symbol from the obarray.  If COLLECTION is a hash-table,
predicate is called with two arguments: the key and the value.
Additionally to this predicate, ‘completion-regexp-list’
is used to further constrain the set of candidates.

An obsolete optional fourth argument HIDE-SPACES is still accepted for
backward compatibility.  If non-nil, strings in COLLECTION that start
with a space are ignored unless STRING itself starts with a space.

(fn STRING COLLECTION &optional PREDICATE HIDE-SPACES)〉〉enditem49840〈〈test-completion〉〉:〈〈Return non-nil if STRING is a valid completion.
Takes the same arguments as ‘all-completions’ and ‘try-completion’.
If COLLECTION is a function, it is called with three arguments:
the values STRING, PREDICATE and ‘lambda’.

(fn STRING COLLECTION &optional PREDICATE)〉〉enditem49840〈〈completion-boundaries〉〉:〈〈Return the boundaries of text on which COLLECTION will operate.
STRING is the string on which completion will be performed.
SUFFIX is the string after point.
If COLLECTION is a function, it is called with 3 arguments: STRING,
PRED, and a cons cell of the form (boundaries . SUFFIX).

The result is of the form (START . END) where START is the position
in STRING of the beginning of the completion field and END is the position
in SUFFIX of the end of the completion field.
E.g. for simple completion tables, the result is always (0 . (length SUFFIX))
and for file names the result is the positions delimited by
the closest directory separators.

(fn STRING COLLECTION PRED SUFFIX)〉〉enditem49840〈〈add-to-invisibility-spec〉〉:〈〈Add ELEMENT to ‘buffer-invisibility-spec’.
See documentation for ‘buffer-invisibility-spec’ for the kind of elements
that can be added.

(fn ELEMENT)〉〉enditem49840〈〈remove-from-invisibility-spec〉〉:〈〈Remove ELEMENT from ‘buffer-invisibility-spec’.

(fn ELEMENT)〉〉enditem49840〈〈invisible-p〉〉:〈〈Non-nil if text properties at POS cause text there to be currently invisible.
POS should be a marker or a buffer position; the value of the ‘invisible’
property at that position in the current buffer is examined.
POS can also be the actual value of the ‘invisible’ text or overlay
property of the text of interest, in which case the value itself is
examined.

The non-nil value returned can be t for currently invisible text that is
entirely hidden on display, or some other non-nil, non-t value if the
text is replaced by an ellipsis.

Note that whether text with ‘invisible’ property is actually hidden on
display may depend on ‘buffer-invisibility-spec’, which see.

(fn POS)〉〉enditem49840〈〈char-after〉〉:〈〈Return character in current buffer at position POS.
POS is an integer or a marker and defaults to point.
If POS is out of range, the value is nil.

(fn &optional POS)〉〉enditem49840〈〈char-before〉〉:〈〈Return character in current buffer preceding position POS.
POS is an integer or a marker and defaults to point.
If POS is out of range, the value is nil.

(fn &optional POS)〉〉enditem49840〈〈following-char〉〉:〈〈Return the character following point, as a number.
At the end of the buffer or accessible region, return 0.

(fn)〉〉enditem49840〈〈preceding-char〉〉:〈〈Return the character preceding point, as a number.
At the beginning of the buffer or accessible region, return 0.

(fn)〉〉enditem49840〈〈bobp〉〉:〈〈Return t if point is at the beginning of the buffer.
If the buffer is narrowed, this means the beginning of the narrowed part.

(fn)〉〉enditem49840〈〈eobp〉〉:〈〈Return t if point is at the end of the buffer.
If the buffer is narrowed, this means the end of the narrowed part.

(fn)〉〉enditem49840〈〈bolp〉〉:〈〈Return t if point is at the beginning of a line.

(fn)〉〉enditem49840〈〈eolp〉〉:〈〈Return t if point is at the end of a line.
‘End of a line’ includes point being at the end of the buffer.

(fn)〉〉enditem49840〈〈coding-system-get〉〉:〈〈Extract a value from CODING-SYSTEM’s property list for property PROP.
For compatibility with Emacs 20/21, this accepts old-style symbols
like ‘mime-charset’ as well as the current style like ‘:mime-charset’.〉〉enditem49840〈〈coding-system-aliases〉〉:〈〈Return the list of aliases of CODING-SYSTEM.

(fn CODING-SYSTEM)〉〉enditem49840〈〈defvaralias〉〉:〈〈Make NEW-ALIAS a variable alias for symbol BASE-VARIABLE.
Aliased variables always have the same value; setting one sets the other.
Third arg DOCSTRING, if non-nil, is documentation for NEW-ALIAS.  If it is
omitted or nil, NEW-ALIAS gets the documentation string of BASE-VARIABLE,
or of the variable at the end of the chain of aliases, if BASE-VARIABLE is
itself an alias.  If NEW-ALIAS is bound, and BASE-VARIABLE is not,
then the value of BASE-VARIABLE is set to that of NEW-ALIAS.
The return value is BASE-VARIABLE.

(fn NEW-ALIAS BASE-VARIABLE &optional DOCSTRING)〉〉enditem49840〈〈make-obsolete-variable〉〉:〈〈Make the byte-compiler warn that OBSOLETE-NAME is obsolete.
The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the ‘use instead’ message.
WHEN should be a string indicating when the variable
was first made obsolete, for example a date or a release number.
ACCESS-TYPE if non-nil should specify the kind of access that will trigger
  obsolescence warnings; it can be either ‘get’ or ‘set’.

(fn OBSOLETE-NAME CURRENT-NAME &optional WHEN ACCESS-TYPE)〉〉enditem49840〈〈indirect-variable〉〉:〈〈Return the variable at the end of OBJECT’s variable chain.
If OBJECT is a symbol, follow its variable indirections (if any), and
return the variable at the end of the chain of aliases.  See Info node
‘(elisp)Variable Aliases’.

If OBJECT is not a symbol, just return it.  If there is a loop in the
chain of aliases, signal a ‘cyclic-variable-indirection’ error.

(fn OBJECT)〉〉enditem49840〈〈read-file-name〉〉:〈〈Read file name, prompting with PROMPT and completing in directory DIR.
The return value is not expanded---you must call ‘expand-file-name’ yourself.

DIR is the directory to use for completing relative file names.
It should be an absolute directory name, or nil (which means the
current buffer’s value of ‘default-directory’).

DEFAULT-FILENAME specifies the default file name to return if the
user exits the minibuffer with the same non-empty string inserted
by this function.  If DEFAULT-FILENAME is a string, that serves
as the default.  If DEFAULT-FILENAME is a list of strings, the
first string is the default.  If DEFAULT-FILENAME is omitted or
nil, then if INITIAL is non-nil, the default is DIR combined with
INITIAL; otherwise, if the current buffer is visiting a file,
that file serves as the default; otherwise, the default is simply
the string inserted into the minibuffer.

If the user exits with an empty minibuffer, return an empty
string.  (This happens only if the user erases the pre-inserted
contents, or if ‘insert-default-directory’ is nil.)

Fourth arg MUSTMATCH can take the following values:
- nil means that the user can exit with any input.
- t means that the user is not allowed to exit unless
  the input is (or completes to) an existing file.
- ‘confirm’ means that the user can exit with any input, but she needs
  to confirm her choice if the input is not an existing file.
- ‘confirm-after-completion’ means that the user can exit with any
  input, but she needs to confirm her choice if she called
  ‘minibuffer-complete’ right before ‘minibuffer-complete-and-exit’
  and the input is not an existing file.
- anything else behaves like t except that typing RET does not exit if it
  does non-null completion.

Fifth arg INITIAL specifies text to start with.

Sixth arg PREDICATE, if non-nil, should be a function of one
argument; then a file name is considered an acceptable completion
alternative only if PREDICATE returns non-nil with the file name
as its argument.

If this command was invoked with the mouse, use a graphical file
dialog if ‘use-dialog-box’ is non-nil, and the window system or X
toolkit in use provides a file dialog box, and DIR is not a
remote file.  For graphical file dialogs, any of the special values
of MUSTMATCH ‘confirm’ and ‘confirm-after-completion’ are
treated as equivalent to nil.  Some graphical file dialogs respect
a MUSTMATCH value of t, and some do not (or it only has a cosmetic
effect, and does not actually prevent the user from entering a
non-existent file).

See also ‘read-file-name-completion-ignore-case’
and ‘read-file-name-function’.

(fn PROMPT &optional DIR DEFAULT-FILENAME MUSTMATCH INITIAL PREDICATE)〉〉enditem49840〈〈read-directory-name〉〉:〈〈Read directory name, prompting with PROMPT and completing in directory DIR.
Value is not expanded---you must call ‘expand-file-name’ yourself.
Default name to DEFAULT-DIRNAME if user exits with the same
non-empty string that was inserted by this function.
 (If DEFAULT-DIRNAME is omitted, DIR combined with INITIAL is used,
  or just DIR if INITIAL is nil.)
If the user exits with an empty minibuffer, this function returns
an empty string.  (This can only happen if the user erased the
pre-inserted contents or if ‘insert-default-directory’ is nil.)
Fourth arg MUSTMATCH non-nil means require existing directory’s name.
 Non-nil and non-t means also require confirmation after completion.
Fifth arg INITIAL specifies text to start with.
DIR should be an absolute directory name.  It defaults to
the value of ‘default-directory’.

(fn PROMPT &optional DIR DEFAULT-DIRNAME MUSTMATCH INITIAL)〉〉enditem49840〈〈read-shell-command〉〉:〈〈Read a shell command from the minibuffer.
The arguments are the same as the ones of ‘read-from-minibuffer’,
except READ and KEYMAP are missing and HIST defaults
to ‘shell-command-history’.

(fn PROMPT &optional INITIAL-CONTENTS HIST &rest ARGS)〉〉enditem49840〈〈select-window〉〉:〈〈Select WINDOW which must be a live window.
Also make WINDOW’s frame the selected frame and WINDOW that frame’s
selected window.  In addition, make WINDOW’s buffer current and set its
buffer’s value of ‘point’ to the value of WINDOW’s ‘window-point’.
Return WINDOW.

Optional second arg NORECORD non-nil means do not put this buffer at the
front of the buffer list and do not make this window the most recently
selected one.  Also, do not mark WINDOW for redisplay unless NORECORD
equals the special symbol ‘mark-for-redisplay’.

Run ‘buffer-list-update-hook’ unless NORECORD is non-nil.  Note that
applications and internal routines often select a window temporarily for
various purposes; mostly, to simplify coding.  As a rule, such
selections should be not recorded and therefore will not pollute
‘buffer-list-update-hook’.  Selections that "really count" are those
causing a visible change in the next redisplay of WINDOW’s frame and
should be always recorded.  So if you think of running a function each
time a window gets selected put it on ‘buffer-list-update-hook’.

Also note that the main editor command loop sets the current buffer to
the buffer of the selected window before each command.

(fn WINDOW &optional NORECORD)〉〉enditem49840〈〈frame-selected-window〉〉:〈〈Return the selected window of FRAME-OR-WINDOW.
If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.
Else if FRAME-OR-WINDOW denotes a valid window, return the selected
window of that window’s frame.  If FRAME-OR-WINDOW denotes a live frame,
return the selected window of that frame.

(fn &optional FRAME-OR-WINDOW)〉〉enditem49840〈〈set-frame-selected-window〉〉:〈〈Set selected window of FRAME to WINDOW.
FRAME must be a live frame and defaults to the selected one.  If FRAME
is the selected frame, this makes WINDOW the selected window.  Optional
argument NORECORD non-nil means to neither change the order of recently
selected windows nor the buffer list.  WINDOW must denote a live window.
Return WINDOW.

(fn FRAME WINDOW &optional NORECORD)〉〉enditem49840〈〈window-use-time〉〉:〈〈Return the use time of window WINDOW.
WINDOW must be a live window and defaults to the selected one.
The window with the highest use time is the most recently selected
one.  The window with the lowest use time is the least recently
selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈make-glyph-code〉〉:〈〈Return a glyph code representing char CHAR with face FACE.〉〉enditem49840〈〈glyph-char〉〉:〈〈Return the character of glyph code GLYPH.〉〉enditem49840〈〈glyph-face〉〉:〈〈Return the face of glyph code GLYPH, or nil if glyph has default face.〉〉enditem49840〈〈command-remapping〉〉:〈〈Return the remapping for command COMMAND.
Returns nil if COMMAND is not remapped (or not a symbol).

If the optional argument POSITION is non-nil, it specifies a mouse
position as returned by ‘event-start’ and ‘event-end’, and the
remapping occurs in the keymaps associated with it.  It can also be a
number or marker, in which case the keymap properties at the specified
buffer position instead of point are used.  The KEYMAPS argument is
ignored if POSITION is non-nil.

If the optional argument KEYMAPS is non-nil, it should be a list of
keymaps to search for command remapping.  Otherwise, search for the
remapping in all currently active keymaps.

(fn COMMAND &optional POSITION KEYMAPS)〉〉enditem49840〈〈help-buffer〉〉:〈〈Return the name of a buffer for inserting help.
If ‘help-xref-following’ is non-nil, this is the name of the
current buffer.  Signal an error if this buffer is not derived
from ‘help-mode’.
Otherwise, return "*Help*", creating a buffer with that name if
it does not already exist.〉〉enditem49840〈〈help-setup-xref〉〉:〈〈Invoked from commands using the "*Help*" buffer to install some xref info.

ITEM is a (FUNCTION . ARGS) pair appropriate for recreating the help
buffer after following a reference.  INTERACTIVE-P is non-nil if the
calling command was invoked interactively.  In this case the stack of
items for help buffer "back" buttons is cleared.

This should be called very early, before the output buffer is cleared,
because we want to record the "previous" position of point so we can
restore it properly when going back.〉〉enditem49840〈〈downcase〉〉:〈〈Convert argument to lower case and return that.
The argument may be a character or string.  The result has the same type.
The argument object is not altered--the value is a copy.

(fn OBJ)〉〉enditem49840〈〈upcase〉〉:〈〈Convert argument to upper case and return that.
The argument may be a character or string.  The result has the same type.
The argument object is not altered--the value is a copy.  If argument
is a character, characters which map to multiple code points when
cased, e.g. ﬁ, are returned unchanged.
See also ‘capitalize’, ‘downcase’ and ‘upcase-initials’.

(fn OBJ)〉〉enditem49840〈〈capitalize〉〉:〈〈Convert argument to capitalized form and return that.
This means that each word’s first character is converted to either
title case or upper case, and the rest to lower case.
The argument may be a character or string.  The result has the same type.
The argument object is not altered--the value is a copy.  If argument
is a character, characters which map to multiple code points when
cased, e.g. ﬁ, are returned unchanged.

(fn OBJ)〉〉enditem49840〈〈upcase-initials〉〉:〈〈Convert the initial of each word in the argument to upper case.
This means that each word’s first character is converted to either
title case or upper case, and the rest are left unchanged.
The argument may be a character or string.  The result has the same type.
The argument object is not altered--the value is a copy.  If argument
is a character, characters which map to multiple code points when
cased, e.g. ﬁ, are returned unchanged.

(fn OBJ)〉〉enditem49840〈〈redraw-frame〉〉:〈〈Clear frame FRAME and output again what is supposed to appear on it.
If FRAME is omitted or nil, the selected frame is used.

(fn &optional FRAME)〉〉enditem49840〈〈characterp〉〉:〈〈Return non-nil if OBJECT is a character.
In Emacs Lisp, characters are represented by character codes, which
are non-negative integers.  The function ‘max-char’ returns the
maximum character code.

(fn OBJECT)〉〉enditem49840〈〈max-char〉〉:〈〈Return the character of the maximum code.

(fn)〉〉enditem49840〈〈get-byte〉〉:〈〈Return a byte value of a character at point.
Optional 1st arg POSITION, if non-nil, is a position of a character to get
a byte value.
Optional 2nd arg STRING, if non-nil, is a string of which first
character is a target to get a byte value.  In this case, POSITION, if
non-nil, is an index of a target character in the string.

If the current buffer (or STRING) is multibyte, and the target
character is not ASCII nor 8-bit character, an error is signaled.

(fn &optional POSITION STRING)〉〉enditem49840〈〈float〉〉:〈〈Return the floating point number equal to ARG.

(fn ARG)〉〉enditem49840〈〈truncate〉〉:〈〈Truncate a floating point number to an int.
Rounds ARG toward zero.
With optional DIVISOR, truncate ARG/DIVISOR.

(fn ARG &optional DIVISOR)〉〉enditem49840〈〈floor〉〉:〈〈Return the largest integer no greater than ARG.
This rounds the value towards -inf.
With optional DIVISOR, return the largest integer no greater than ARG/DIVISOR.

(fn ARG &optional DIVISOR)〉〉enditem49840〈〈ceiling〉〉:〈〈Return the smallest integer no less than ARG.
This rounds the value towards +inf.
With optional DIVISOR, return the smallest integer no less than ARG/DIVISOR.

(fn ARG &optional DIVISOR)〉〉enditem49840〈〈round〉〉:〈〈Return the nearest integer to ARG.
With optional DIVISOR, return the nearest integer to ARG/DIVISOR.

Rounding a value equidistant between two integers may choose the
integer closer to zero, or it may prefer an even integer, depending on
your machine.  For example, (round 2.5) can return 3 on some
systems, but 2 on others.

(fn ARG &optional DIVISOR)〉〉enditem49840〈〈window-vscroll〉〉:〈〈Return the amount by which WINDOW is scrolled vertically.
If WINDOW is omitted or nil, it defaults to the selected window.
Normally, value is a multiple of the canonical character height of WINDOW;
optional second arg PIXELS-P means value is measured in pixels.

(fn &optional WINDOW PIXELS-P)〉〉enditem49840〈〈set-window-vscroll〉〉:〈〈Set amount by which WINDOW should be scrolled vertically to VSCROLL.
WINDOW nil means use the selected window.  Normally, VSCROLL is a
non-negative multiple of the canonical character height of WINDOW;
optional third arg PIXELS-P non-nil means that VSCROLL is in pixels.
If PIXELS-P is nil, VSCROLL may have to be rounded so that it
corresponds to an integral number of pixels.  The return value is the
result of this rounding.
If PIXELS-P is non-nil, the return value is VSCROLL.

(fn WINDOW VSCROLL &optional PIXELS-P)〉〉enditem49840〈〈selected-frame〉〉:〈〈Return the frame that is now selected.

(fn)〉〉enditem49840〈〈select-frame-set-input-focus〉〉:〈〈Select FRAME, raise it, and set input focus, if possible.
If ‘mouse-autoselect-window’ is non-nil, also move mouse pointer
to FRAME’s selected window.  Otherwise, if ‘focus-follows-mouse’
is non-nil, move mouse cursor to FRAME.

Optional argument NORECORD means to neither change the order of
recently selected windows nor the buffer list.

(fn FRAME &optional NORECORD)〉〉enditem49840〈〈redirect-frame-focus〉〉:〈〈Arrange for keystrokes typed at FRAME to be sent to FOCUS-FRAME.
In other words, switch-frame events caused by events in FRAME will
request a switch to FOCUS-FRAME, and ‘last-event-frame’ will be
FOCUS-FRAME after reading an event typed at FRAME.

If FOCUS-FRAME is nil, any existing redirection is canceled, and the
frame again receives its own keystrokes.

Focus redirection is useful for temporarily redirecting keystrokes to
a surrogate minibuffer frame when a frame doesn’t have its own
minibuffer window.

A frame’s focus redirection can be changed by ‘select-frame’.  If frame
FOO is selected, and then a different frame BAR is selected, any
frames redirecting their focus to FOO are shifted to redirect their
focus to BAR.  This allows focus redirection to work properly when the
user switches from one frame to another using ‘select-window’.

This means that a frame whose focus is redirected to itself is treated
differently from a frame whose focus is redirected to nil; the former
is affected by ‘select-frame’, while the latter is not.

The redirection lasts until ‘redirect-frame-focus’ is called to change it.

(fn FRAME &optional FOCUS-FRAME)〉〉enditem49840〈〈image-multi-frame-p〉〉:〈〈Return non-nil if IMAGE contains more than one frame.
The actual return value is a cons (NIMAGES . DELAY), where NIMAGES is
the number of frames (or sub-images) in the image and DELAY is the delay
in seconds that the image specifies between each frame.  DELAY may be nil,
in which case you might want to use ‘image-default-frame-delay’.

(fn IMAGE)〉〉enditem49840〈〈image-current-frame〉〉:〈〈The current frame number of IMAGE, indexed from 0.

(fn IMAGE)〉〉enditem49840〈〈image-show-frame〉〉:〈〈Show frame N of IMAGE.
Frames are indexed from 0.  Optional argument NOCHECK non-nil means
do not check N is within the range of frames present in the image.

(fn IMAGE N &optional NOCHECK)〉〉enditem49840〈〈image-animate〉〉:〈〈Start animating IMAGE.
Animation occurs by destructively altering the IMAGE spec list.

With optional INDEX, begin animating from that animation frame.
LIMIT specifies how long to animate the image.  If omitted or
nil, play the animation until the end.  If t, loop forever.  If a
number, play until that number of seconds has elapsed.

(fn IMAGE &optional INDEX LIMIT)〉〉enditem49840〈〈image-animate-timer〉〉:〈〈Return the animation timer for image IMAGE.

(fn IMAGE)〉〉enditem49840〈〈replace-regexp-in-string〉〉:〈〈Replace all matches for REGEXP with REP in STRING.

Return a new string containing the replacements.

Optional arguments FIXEDCASE, LITERAL and SUBEXP are like the
arguments with the same names of function ‘replace-match’.  If START
is non-nil, start replacements at that index in STRING.

REP is either a string used as the NEWTEXT arg of ‘replace-match’ or a
function.  If it is a function, it is called with the actual text of each
match, and its value is used as the replacement text.  When REP is called,
the match data are the result of matching REGEXP against a substring
of STRING, the same substring that is the actual text of the match which
is passed to REP as its argument.

To replace only the first match (if any), make REGEXP match up to \'
and replace a sub-expression, e.g.
  (replace-regexp-in-string "\\(foo\\).*\\'" "bar" " foo foo" nil nil 1)
    => " bar foo"

(fn REGEXP REP STRING &optional FIXEDCASE LITERAL SUBEXP START)〉〉enditem49840〈〈perform-replace〉〉:〈〈Subroutine of ‘query-replace’.  Its complexity handles interactive queries.
Don’t use this in your own program unless you want to query and set the mark
just as ‘query-replace’ does.  Instead, write a simple loop like this:

  (while (re-search-forward "foo[ \t]+bar" nil t)
    (replace-match "foobar" nil nil))

which will run faster and probably do exactly what you want.  Please
see the documentation of ‘replace-match’ to find out how to simulate
‘case-replace’.

This function returns nil if and only if there were no matches to
make, or the user didn’t cancel the call.

REPLACEMENTS is either a string, a list of strings, or a cons cell
containing a function and its first argument.  The function is
called to generate each replacement like this:
  (funcall (car replacements) (cdr replacements) replace-count)
It must return a string.

(fn FROM-STRING REPLACEMENTS QUERY-FLAG REGEXP-FLAG DELIMITED-FLAG &optional REPEAT-COUNT MAP START END BACKWARD REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈current-idle-time〉〉:〈〈Return the current length of Emacs idleness, or nil.
The value when Emacs is idle is a list of four integers (HIGH LOW USEC PSEC)
in the same style as (current-time).

The value when Emacs is not idle is nil.

PSEC is a multiple of the system clock resolution.

(fn)〉〉enditem49840〈〈subst-char-in-region〉〉:〈〈From START to END, replace FROMCHAR with TOCHAR each time it occurs.
If optional arg NOUNDO is non-nil, don’t record this change for undo
and don’t mark the buffer as really changed.
Both characters must have the same length of multi-byte form.

(fn START END FROMCHAR TOCHAR &optional NOUNDO)〉〉enditem49840〈〈derived-mode-p〉〉:〈〈Non-nil if the current major mode is derived from one of MODES.
Uses the ‘derived-mode-parent’ property of the symbol to trace backwards.

(fn &rest MODES)〉〉enditem49840〈〈dom-node〉〉:〈〈Return a DOM node with TAG and ATTRIBUTES.

(fn TAG &optional ATTRIBUTES &rest CHILDREN)〉〉enditem49840〈〈face-attribute〉〉:〈〈Return the value of FACE’s ATTRIBUTE on FRAME.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.

If INHERIT is nil, only attributes directly defined by FACE are considered,
  so the return value may be ‘unspecified’, or a relative value.
If INHERIT is non-nil, FACE’s definition of ATTRIBUTE is merged with the
  faces specified by its ‘:inherit’ attribute; however the return value
  may still be ‘unspecified’ or relative.
If INHERIT is a face or a list of faces, then the result is further merged
  with that face (or faces), until it becomes specified and absolute.

To ensure that the return value is always specified and absolute, use a
value of ‘default’ for INHERIT; this will resolve any unspecified or
relative values by merging with the ‘default’ face (which is always
completely specified).

(fn FACE ATTRIBUTE &optional FRAME INHERIT)〉〉enditem49840〈〈face-attribute-relative-p〉〉:〈〈Check whether a face attribute value is relative.
Specifically, this function returns t if the attribute ATTRIBUTE
with the value VALUE is relative.

A relative value is one that doesn’t entirely override whatever is
inherited from another face.  For most possible attributes,
the only relative value that users see is ‘unspecified’.
However, for :height, floating point values are also relative.

(fn ATTRIBUTE VALUE)〉〉enditem49840〈〈face-all-attributes〉〉:〈〈Return an alist stating the attributes of FACE.
Each element of the result has the form (ATTR-NAME . ATTR-VALUE).
If FRAME is omitted or nil the value describes the default attributes,
but if you specify FRAME, the value describes the attributes
of FACE on FRAME.

(fn FACE &optional FRAME)〉〉enditem49840〈〈merge-face-attribute〉〉:〈〈Return face ATTRIBUTE VALUE1 merged with VALUE2.
If VALUE1 or VALUE2 are absolute (see ‘face-attribute-relative-p’), then
the result will be absolute, otherwise it will be relative.

(fn ATTRIBUTE VALUE1 VALUE2)〉〉enditem49840〈〈set-face-attribute〉〉:〈〈Set attributes of FACE on FRAME from ARGS.
This function overrides the face attributes specified by FACE’s
face spec.  It is mostly intended for internal use only.

If FRAME is nil, set the attributes for all existing frames, as
well as the default for new frames.  If FRAME is t, change the
default for new frames only.

ARGS must come in pairs ATTRIBUTE VALUE.  ATTRIBUTE must be a
valid face attribute name.  All attributes can be set to
‘unspecified’; this fact is not further mentioned below.

The following attributes are recognized:

‘:family’

VALUE must be a string specifying the font family
(e.g. "Monospace").

‘:foundry’

VALUE must be a string specifying the font foundry,
e.g., "adobe".  If a font foundry is specified, wild-cards ‘*’
and ‘?’ are allowed.

‘:width’

VALUE specifies the relative proportionate width of the font to use.
It must be one of the symbols ‘ultra-condensed’, ‘extra-condensed’,
‘condensed’, ‘semi-condensed’, ‘normal’, ‘semi-expanded’, ‘expanded’,
‘extra-expanded’, or ‘ultra-expanded’.

‘:height’

VALUE specifies the relative or absolute height of the font.  An
absolute height is an integer, and specifies font height in units
of 1/10 pt.  A relative height is either a floating point number,
which specifies a scaling factor for the underlying face height;
or a function that takes a single argument (the underlying face
height) and returns the new height.  Note that for the ‘default’
face, you must specify an absolute height (since there is nothing
for it to be relative to).

‘:weight’

VALUE specifies the weight of the font to use.  It must be one of the
symbols ‘ultra-bold’, ‘extra-bold’, ‘bold’, ‘semi-bold’, ‘normal’,
‘semi-light’, ‘light’, ‘extra-light’, ‘ultra-light’.

‘:slant’

VALUE specifies the slant of the font to use.  It must be one of the
symbols ‘italic’, ‘oblique’, ‘normal’, ‘reverse-italic’, or
‘reverse-oblique’.

‘:foreground’, ‘:background’

VALUE must be a color name, a string.

‘:underline’

VALUE specifies whether characters in FACE should be underlined.
If VALUE is t, underline with foreground color of the face.
If VALUE is a string, underline with that color.
If VALUE is nil, explicitly don’t underline.

Otherwise, VALUE must be a property list of the form:

‘(:color COLOR :style STYLE)’.

COLOR can be either a color name string or ‘foreground-color’.
STYLE can be either ‘line’ or ‘wave’.
If a keyword/value pair is missing from the property list, a
default value will be used for the value.
The default value of COLOR is the foreground color of the face.
The default value of STYLE is ‘line’.

‘:overline’

VALUE specifies whether characters in FACE should be overlined.  If
VALUE is t, overline with foreground color of the face.  If VALUE is a
string, overline with that color.  If VALUE is nil, explicitly don’t
overline.

‘:strike-through’

VALUE specifies whether characters in FACE should be drawn with a line
striking through them.  If VALUE is t, use the foreground color of the
face.  If VALUE is a string, strike-through with that color.  If VALUE
is nil, explicitly don’t strike through.

‘:box’

VALUE specifies whether characters in FACE should have a box drawn
around them.  If VALUE is nil, explicitly don’t draw boxes.  If
VALUE is t, draw a box with lines of width 1 in the foreground color
of the face.  If VALUE is a string, the string must be a color name,
and the box is drawn in that color with a line width of 1.  Otherwise,
VALUE must be a property list of the form ‘(:line-width WIDTH
:color COLOR :style STYLE)’.  If a keyword/value pair is missing from
the property list, a default value will be used for the value, as
specified below.  WIDTH specifies the width of the lines to draw; it
defaults to 1.  If WIDTH is negative, the absolute value is the width
of the lines, and draw top/bottom lines inside the characters area,
not around it.  COLOR is the name of the color to draw in, default is
the foreground color of the face for simple boxes, and the background
color of the face for 3D boxes.  STYLE specifies whether a 3D box
should be draw.  If STYLE is ‘released-button’, draw a box looking
like a released 3D button.  If STYLE is ‘pressed-button’ draw a box
that appears like a pressed button.  If STYLE is nil, the default if
the property list doesn’t contain a style specification, draw a 2D
box.

‘:inverse-video’

VALUE specifies whether characters in FACE should be displayed in
inverse video.  VALUE must be one of t or nil.

‘:stipple’

If VALUE is a string, it must be the name of a file of pixmap data.
The directories listed in the ‘x-bitmap-file-path’ variable are
searched.  Alternatively, VALUE may be a list of the form (WIDTH
HEIGHT DATA) where WIDTH and HEIGHT are the size in pixels, and DATA
is a string containing the raw bits of the bitmap.  VALUE nil means
explicitly don’t use a stipple pattern.

For convenience, attributes ‘:family’, ‘:foundry’, ‘:width’,
‘:height’, ‘:weight’, and ‘:slant’ may also be set in one step
from an X font name:

‘:font’

Set font-related face attributes from VALUE.
VALUE must be a valid font name or font object.  It can also
be a fontset name.  Setting this attribute will also set
the ‘:family’, ‘:foundry’, ‘:width’, ‘:height’, ‘:weight’,
and ‘:slant’ attributes.

‘:inherit’

VALUE is the name of a face from which to inherit attributes, or
a list of face names.  Attributes from inherited faces are merged
into the face like an underlying face would be, with higher
priority than underlying faces.

For backward compatibility, the keywords ‘:bold’ and ‘:italic’
can be used to specify weight and slant respectively.  This usage
is considered obsolete.  For these two keywords, the VALUE must
be either t or nil.  A value of t for ‘:bold’ is equivalent to
setting ‘:weight’ to ‘bold’, and a value of t for ‘:italic’ is
equivalent to setting ‘:slant’ to ‘italic’.  But if ‘:weight’ is
specified in the face spec, ‘:bold’ is ignored, and if ‘:slant’
is specified, ‘:italic’ is ignored.

(fn FACE FRAME &rest ARGS)〉〉enditem49840〈〈set-face-bold〉〉:〈〈Specify whether face FACE is bold.
BOLD-P non-nil means FACE should explicitly display bold.
BOLD-P nil means FACE should explicitly display non-bold.
FRAME nil or not specified means change face on all frames.
Use ‘set-face-attribute’ or ‘modify-face’ for finer control.

(fn FACE BOLD-P &optional FRAME)〉〉enditem49840〈〈set-face-italic〉〉:〈〈Specify whether face FACE is italic.
ITALIC-P non-nil means FACE should explicitly display italic.
ITALIC-P nil means FACE should explicitly display non-italic.
FRAME nil or not specified means change face on all frames.
Use ‘set-face-attribute’ or ‘modify-face’ for finer control.

(fn FACE ITALIC-P &optional FRAME)〉〉enditem49840〈〈set-face-underline〉〉:〈〈Specify whether face FACE is underlined.
UNDERLINE nil means FACE explicitly doesn’t underline.
UNDERLINE t means FACE underlines with its foreground color.
If UNDERLINE is a string, underline with that color.

UNDERLINE may also be a list of the form (:color COLOR :style STYLE),
where COLOR is a string or ‘foreground-color’, and STYLE is either
‘line’ or ‘wave’.  :color may be omitted, which means to use the
foreground color.  :style may be omitted, which means to use a line.

FRAME nil or not specified means change face on all frames.
Use ‘set-face-attribute’ to "unspecify" underlining.

(fn FACE UNDERLINE &optional FRAME)〉〉enditem49840〈〈set-face-inverse-video〉〉:〈〈Specify whether face FACE is in inverse video.
INVERSE-VIDEO-P non-nil means FACE displays explicitly in inverse video.
INVERSE-VIDEO-P nil means FACE explicitly is not in inverse video.
FRAME nil or not specified means change face on all frames.
Use ‘set-face-attribute’ to "unspecify" the inverse video attribute.

(fn FACE INVERSE-VIDEO-P &optional FRAME)〉〉enditem49840〈〈face-font〉〉:〈〈Return the font name of face FACE, or nil if it is unspecified.
The font name is, by default, for ASCII characters.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
  The font default for a face is either nil, or a list
  of the form (bold), (italic) or (bold italic).
If FRAME is omitted or nil, use the selected frame.  And, in this case,
if the optional third argument CHARACTER is given,
return the font name used for CHARACTER.

(fn FACE &optional FRAME CHARACTER)〉〉enditem49840〈〈face-foreground〉〉:〈〈Return the foreground color name of FACE, or nil if unspecified.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.

If INHERIT is nil, only a foreground color directly defined by FACE is
  considered, so the return value may be nil.
If INHERIT is t, and FACE doesn’t define a foreground color, then any
  foreground color that FACE inherits through its ‘:inherit’ attribute
  is considered as well; however the return value may still be nil.
If INHERIT is a face or a list of faces, then it is used to try to
  resolve an unspecified foreground color.

To ensure that a valid color is always returned, use a value of
‘default’ for INHERIT; this will resolve any unspecified values by
merging with the ‘default’ face (which is always completely specified).

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-background〉〉:〈〈Return the background color name of FACE, or nil if unspecified.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.

If INHERIT is nil, only a background color directly defined by FACE is
  considered, so the return value may be nil.
If INHERIT is t, and FACE doesn’t define a background color, then any
  background color that FACE inherits through its ‘:inherit’ attribute
  is considered as well; however the return value may still be nil.
If INHERIT is a face or a list of faces, then it is used to try to
  resolve an unspecified background color.

To ensure that a valid color is always returned, use a value of
‘default’ for INHERIT; this will resolve any unspecified values by
merging with the ‘default’ face (which is always completely specified).

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-stipple〉〉:〈〈Return the stipple pixmap name of FACE, or nil if unspecified.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.

If INHERIT is nil, only a stipple directly defined by FACE is
  considered, so the return value may be nil.
If INHERIT is t, and FACE doesn’t define a stipple, then any stipple
  that FACE inherits through its ‘:inherit’ attribute is considered as
  well; however the return value may still be nil.
If INHERIT is a face or a list of faces, then it is used to try to
  resolve an unspecified stipple.

To ensure that a valid stipple or nil is always returned, use a value of
‘default’ for INHERIT; this will resolve any unspecified values by merging
with the ‘default’ face (which is always completely specified).

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-bold-p〉〉:〈〈Return non-nil if the font of FACE is bold on FRAME.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.
Optional argument INHERIT is passed to ‘face-attribute’.
Use ‘face-attribute’ for finer control.

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-italic-p〉〉:〈〈Return non-nil if the font of FACE is italic on FRAME.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.
Optional argument INHERIT is passed to ‘face-attribute’.
Use ‘face-attribute’ for finer control.

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-underline-p〉〉:〈〈Return non-nil if FACE specifies a non-nil underlining.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.
Optional argument INHERIT is passed to ‘face-attribute’.

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈face-inverse-video-p〉〉:〈〈Return non-nil if FACE specifies a non-nil inverse-video.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.
Optional argument INHERIT is passed to ‘face-attribute’.

(fn FACE &optional FRAME INHERIT)〉〉enditem49840〈〈file-name-all-completions〉〉:〈〈Return a list of all completions of file name FILE in directory DIRECTORY.
These are all file names in directory DIRECTORY which begin with FILE.

This function ignores some of the possible completions as determined
by ‘completion-regexp-list’, which see.  ‘completion-regexp-list’
is matched against file and directory names relative to DIRECTORY.

(fn FILE DIRECTORY)〉〉enditem49840〈〈file-name-completion〉〉:〈〈Complete file name FILE in directory DIRECTORY.
Returns the longest string
common to all file names in DIRECTORY that start with FILE.
If there is only one and FILE matches it exactly, returns t.
Returns nil if DIRECTORY contains no name starting with FILE.

If PREDICATE is non-nil, call PREDICATE with each possible
completion (in absolute form) and ignore it if PREDICATE returns nil.

This function ignores some of the possible completions as determined
by the variables ‘completion-regexp-list’ and
‘completion-ignored-extensions’, which see.  ‘completion-regexp-list’
is matched against file and directory names relative to DIRECTORY.

(fn FILE DIRECTORY &optional PREDICATE)〉〉enditem49840〈〈make-string〉〉:〈〈Return a newly created string of length LENGTH, with INIT in each element.
LENGTH must be an integer.
INIT must be an integer that represents a character.

(fn LENGTH INIT)〉〉enditem49840〈〈string〉〉:〈〈Concatenate all the argument characters and make the result a string.

(fn &rest CHARACTERS)〉〉enditem49840〈〈substring〉〉:〈〈Return a new string whose contents are a substring of STRING.
The returned string consists of the characters between index FROM
(inclusive) and index TO (exclusive) of STRING.  FROM and TO are
zero-indexed: 0 means the first character of STRING.  Negative values
are counted from the end of STRING.  If TO is nil, the substring runs
to the end of STRING.

The STRING argument may also be a vector.  In that case, the return
value is a new vector that contains the elements between index FROM
(inclusive) and index TO (exclusive) of that vector argument.

With one argument, just copy STRING (with properties, if any).

(fn STRING &optional FROM TO)〉〉enditem49840〈〈substring-no-properties〉〉:〈〈Return a substring of STRING, without text properties.
It starts at index FROM and ends before TO.
TO may be nil or omitted; then the substring runs to the end of STRING.
If FROM is nil or omitted, the substring starts at the beginning of STRING.
If FROM or TO is negative, it counts from the end.

With one argument, just copy STRING without its properties.

(fn STRING &optional FROM TO)〉〉enditem49840〈〈concat〉〉:〈〈Concatenate all the arguments and make the result a string.
The result is a string whose elements are the elements of all the arguments.
Each argument may be a string or a list or vector of characters (integers).

(fn &rest SEQUENCES)〉〉enditem49840〈〈split-string〉〉:〈〈Split STRING into substrings bounded by matches for SEPARATORS.

The beginning and end of STRING, and each match for SEPARATORS, are
splitting points.  The substrings matching SEPARATORS are removed, and
the substrings between the splitting points are collected as a list,
which is returned.

If SEPARATORS is non-nil, it should be a regular expression matching text
which separates, but is not part of, the substrings.  If nil it defaults to
‘split-string-default-separators’, normally "[ \f\t\n\r\v]+", and
OMIT-NULLS is forced to t.

If OMIT-NULLS is t, zero-length substrings are omitted from the list (so
that for the default value of SEPARATORS leading and trailing whitespace
are effectively trimmed).  If nil, all zero-length substrings are retained,
which correctly parses CSV format, for example.

If TRIM is non-nil, it should be a regular expression to match
text to trim from the beginning and end of each substring.  If trimming
makes the substring empty, it is treated as null.

If you want to trim whitespace from the substrings, the reliably correct
way is using TRIM.  Making SEPARATORS match that whitespace gives incorrect
results when there is whitespace at the start or end of STRING.  If you
see such calls to ‘split-string’, please fix them.

Note that the effect of ‘(split-string STRING)’ is the same as
‘(split-string STRING split-string-default-separators t)’.  In the rare
case that you wish to retain zero-length substrings when splitting on
whitespace, use ‘(split-string STRING split-string-default-separators)’.

Modifies the match data; use ‘save-match-data’ if necessary.

(fn STRING &optional SEPARATORS OMIT-NULLS TRIM)〉〉enditem49840〈〈window-buffer〉〉:〈〈Return the buffer displayed in window WINDOW.
If WINDOW is omitted or nil, it defaults to the selected window.
Return nil for an internal window or a deleted window.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-buffer〉〉:〈〈Make WINDOW display BUFFER-OR-NAME.
WINDOW must be a live window and defaults to the selected one.
BUFFER-OR-NAME must be a buffer or the name of an existing buffer.

Optional third argument KEEP-MARGINS non-nil means that WINDOW’s current
display margins, fringe widths, and scroll bar settings are preserved;
the default is to reset these from the local settings for BUFFER-OR-NAME
or the frame defaults.  Return nil.

This function throws an error when WINDOW is strongly dedicated to its
buffer (that is ‘window-dedicated-p’ returns t for WINDOW) and does not
already display BUFFER-OR-NAME.

This function runs ‘window-scroll-functions’ before running
‘window-configuration-change-hook’.

(fn WINDOW BUFFER-OR-NAME &optional KEEP-MARGINS)〉〉enditem49840〈〈get-buffer-window〉〉:〈〈Return a window currently displaying BUFFER-OR-NAME, or nil if none.
BUFFER-OR-NAME may be a buffer or a buffer name and defaults to
the current buffer.

The optional argument ALL-FRAMES specifies the frames to consider:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames.

- 0 (the number zero) means consider all windows on all visible
    and iconified frames.

- A frame means consider all windows on that frame only.

Any other value of ALL-FRAMES means consider all windows on the
selected frame and no others.

(fn &optional BUFFER-OR-NAME ALL-FRAMES)〉〉enditem49840〈〈get-buffer-window-list〉〉:〈〈Return list of all windows displaying BUFFER-OR-NAME, or nil if none.
BUFFER-OR-NAME may be a buffer or the name of an existing buffer
and defaults to the current buffer.  If the selected window displays
BUFFER-OR-NAME, it will be the first in the resulting list.

MINIBUF t means include the minibuffer window even if the
minibuffer is not active.  MINIBUF nil or omitted means include
the minibuffer window only if the minibuffer is active.  Any
other value means do not include the minibuffer window even if
the minibuffer is active.

ALL-FRAMES nil or omitted means consider all windows on the
selected frame, plus the minibuffer window if specified by the
MINIBUF argument.  If the minibuffer counts, consider all windows
on all frames that share that minibuffer too.  The following
non-nil values of ALL-FRAMES have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on the selected frame
and no others.

(fn &optional BUFFER-OR-NAME MINIBUF ALL-FRAMES)〉〉enditem49840〈〈process-query-on-exit-flag〉〉:〈〈Return the current value of query-on-exit flag for PROCESS.

(fn PROCESS)〉〉enditem49840〈〈set-process-query-on-exit-flag〉〉:〈〈Specify if query is needed for PROCESS when Emacs is exited.
If the second argument FLAG is non-nil, Emacs will query the user before
exiting or killing a buffer if PROCESS is running.  This function
returns FLAG.

(fn PROCESS FLAG)〉〉enditem49840〈〈process-send-string〉〉:〈〈Send PROCESS the contents of STRING as input.
PROCESS may be a process, a buffer, the name of a process or buffer, or
nil, indicating the current buffer’s process.
If STRING is more than 500 characters long,
it is sent in several bunches.  This may happen even for shorter strings.
Output from processes can arrive in between bunches.

If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS STRING)〉〉enditem49840〈〈process-send-region〉〉:〈〈Send current contents of region as input to PROCESS.
PROCESS may be a process, a buffer, the name of a process or buffer, or
nil, indicating the current buffer’s process.
Called from program, takes three arguments, PROCESS, START and END.
If the region is more than 500 characters long,
it is sent in several bunches.  This may happen even for shorter regions.
Output from processes can arrive in between bunches.

If PROCESS is a non-blocking network process that hasn’t been fully
set up yet, this function will block until socket setup has completed.

(fn PROCESS START END)〉〉enditem49840〈〈process-send-eof〉〉:〈〈Make PROCESS see end-of-file in its input.
EOF comes after any text already sent to it.
PROCESS may be a process, a buffer, the name of a process or buffer, or
nil, indicating the current buffer’s process.
If PROCESS is a network connection, or is a process communicating
through a pipe (as opposed to a pty), then you cannot send any more
text to PROCESS after you call this function.
If PROCESS is a serial process, wait until all output written to the
process has been transmitted to the serial port.

(fn &optional PROCESS)〉〉enditem49840〈〈process-running-child-p〉〉:〈〈Return non-nil if PROCESS has given the terminal to a
child.  If the operating system does not make it possible to find out,
return t.  If we can find out, return the numeric ID of the foreground
process group.

(fn &optional PROCESS)〉〉enditem49840〈〈frame-position〉〉:〈〈Return top left corner of FRAME in pixels.
FRAME must be a live frame and defaults to the selected one.  The return
value is a cons (x, y) of the coordinates of the top left corner of
FRAME’s outer frame, in pixels relative to an origin (0, 0) of FRAME’s
display.

(fn &optional FRAME)〉〉enditem49840〈〈set-frame-position〉〉:〈〈Set position of FRAME to (X, Y).
FRAME must be a live frame and defaults to the selected one.  X and Y,
if positive, specify the coordinate of the left and top edge of FRAME’s
outer frame in pixels relative to an origin (0, 0) of FRAME’s display.
If any of X or Y is negative, it specifies the coordinates of the right
or bottom edge of the outer frame of FRAME relative to the right or
bottom edge of FRAME’s display.

(fn FRAME X Y)〉〉enditem49840〈〈frame-pixel-height〉〉:〈〈Return FRAME’s native height in pixels.
If FRAME is omitted or nil, the selected frame is used.  The exact value
of the result depends on the window-system and toolkit in use:

In the Gtk+ and NS versions, it includes only any window (including the
minibuffer or echo area), mode line, and header line.  It does not
include the tool bar or menu bar.  With other graphical versions, it may
also include the tool bar and the menu bar.

For a text terminal, it includes the menu bar.  In this case, the
result is really in characters rather than pixels (i.e., is identical
to ‘frame-height’).

(fn &optional FRAME)〉〉enditem49840〈〈frame-pixel-width〉〉:〈〈Return FRAME’s native width in pixels.
For a terminal frame, the result really gives the width in characters.
If FRAME is omitted or nil, the selected frame is used.

(fn &optional FRAME)〉〉enditem49840〈〈frame-text-height〉〉:〈〈Return text area height of FRAME in pixels.

(fn &optional FRAME)〉〉enditem49840〈〈frame-text-width〉〉:〈〈Return text area width of FRAME in pixels.

(fn &optional FRAME)〉〉enditem49840〈〈frame-height〉〉:〈〈Return number of lines available for display on FRAME.
If FRAME is omitted, describe the currently selected frame.
Exactly what is included in the return value depends on the
window-system and toolkit in use - see ‘frame-pixel-height’ for
more details.  The lines are in units of the default font height.

The result is roughly related to the frame pixel height via
height in pixels = height in lines * ‘frame-char-height’.
However, this is only approximate, and is complicated e.g. by the
fact that individual window lines and menu bar lines can have
differing font heights.

(fn &optional FRAME)〉〉enditem49840〈〈frame-width〉〉:〈〈Return number of columns available for display on FRAME.
If FRAME is omitted, describe the currently selected frame.

(fn &optional FRAME)〉〉enditem49840〈〈set-frame-size〉〉:〈〈Set text size of FRAME to WIDTH by HEIGHT, measured in characters.
Optional argument PIXELWISE non-nil means to measure in pixels.  Note:
When ‘frame-resize-pixelwise’ is nil, some window managers may refuse to
honor a WIDTH that is not an integer multiple of the default frame font
width or a HEIGHT that is not an integer multiple of the default frame
font height.

(fn FRAME WIDTH HEIGHT &optional PIXELWISE)〉〉enditem49840〈〈set-frame-height〉〉:〈〈Set text height of frame FRAME to HEIGHT lines.
Optional third arg PRETEND non-nil means that redisplay should use
HEIGHT lines but that the idea of the actual height of the frame should
not be changed.

Optional fourth argument PIXELWISE non-nil means that FRAME should be
HEIGHT pixels high.  Note: When ‘frame-resize-pixelwise’ is nil, some
window managers may refuse to honor a HEIGHT that is not an integer
multiple of the default frame font height.

(fn FRAME HEIGHT &optional PRETEND PIXELWISE)〉〉enditem49840〈〈set-frame-width〉〉:〈〈Set text width of frame FRAME to WIDTH columns.
Optional third arg PRETEND non-nil means that redisplay should use WIDTH
columns but that the idea of the actual width of the frame should not
be changed.

Optional fourth argument PIXELWISE non-nil means that FRAME should be
WIDTH pixels wide.  Note: When ‘frame-resize-pixelwise’ is nil, some
window managers may refuse to honor a WIDTH that is not an integer
multiple of the default frame font width.

(fn FRAME WIDTH &optional PRETEND PIXELWISE)〉〉enditem49840〈〈recursion-depth〉〉:〈〈Return the current depth in recursive edits.

(fn)〉〉enditem49840〈〈buffer-substring〉〉:〈〈Return the contents of part of the current buffer as a string.
The two arguments START and END are character positions;
they can be in either order.
The string returned is multibyte if the buffer is multibyte.

This function copies the text properties of that part of the buffer
into the result string; if you don’t want the text properties,
use ‘buffer-substring-no-properties’ instead.

(fn START END)〉〉enditem49840〈〈buffer-substring-no-properties〉〉:〈〈Return the characters of part of the buffer, without the text properties.
The two arguments START and END are character positions;
they can be in either order.

(fn START END)〉〉enditem49840〈〈buffer-string〉〉:〈〈Return the contents of the current buffer as a string.
If narrowing is in effect, this function returns only the visible part
of the buffer.

(fn)〉〉enditem49840〈〈filter-buffer-substring〉〉:〈〈Return the buffer substring between BEG and END, after filtering.
If DELETE is non-nil, delete the text between BEG and END from the buffer.

This calls the function that ‘filter-buffer-substring-function’ specifies
(passing the same three arguments that it received) to do the work,
and returns whatever it does.  The default function does no filtering,
unless a hook has been set.

Use ‘filter-buffer-substring’ instead of ‘buffer-substring’,
‘buffer-substring-no-properties’, or ‘delete-and-extract-region’ when
you want to allow filtering to take place.  For example, major or minor
modes can use ‘filter-buffer-substring-function’ to extract characters
that are special to a buffer, and should not be copied into other buffers.

(fn BEG END &optional DELETE)〉〉enditem49840〈〈current-word〉〉:〈〈Return the word at or near point, as a string.
The return value includes no text properties.

If optional arg STRICT is non-nil, return nil unless point is
within or adjacent to a word, otherwise look for a word within
point’s line.  If there is no word anywhere on point’s line, the
value is nil regardless of STRICT.

By default, this function treats as a single word any sequence of
characters that have either word or symbol syntax.  If optional
arg REALLY-WORD is non-nil, only characters of word syntax can
constitute a word.

(fn &optional STRICT REALLY-WORD)〉〉enditem49840〈〈thing-at-point〉〉:〈〈Return the THING at point.
THING should be a symbol specifying a type of syntactic entity.
Possibilities include ‘symbol’, ‘list’, ‘sexp’, ‘defun’,
‘filename’, ‘url’, ‘email’, ‘word’, ‘sentence’, ‘whitespace’,
‘line’, ‘number’, and ‘page’.

When the optional argument NO-PROPERTIES is non-nil,
strip text properties from the return value.

See the file ‘thingatpt.el’ for documentation on how to define
a symbol as a valid THING.

(fn THING &optional NO-PROPERTIES)〉〉enditem49840〈〈bufferp〉〉:〈〈Return t if OBJECT is an editor buffer.

(fn OBJECT)〉〉enditem49840〈〈random〉〉:〈〈Return a pseudo-random number.
All integers representable in Lisp, i.e. between ‘most-negative-fixnum’
and ‘most-positive-fixnum’, inclusive, are equally likely.

With positive integer LIMIT, return random number in interval [0,LIMIT).
With argument t, set the random number seed from the system’s entropy
pool if available, otherwise from less-random volatile data such as the time.
With a string argument, set the seed based on the string’s contents.
Other values of LIMIT are ignored.

See Info node ‘(elisp)Random Numbers’ for more details.

(fn &optional LIMIT)〉〉enditem49840〈〈processp〉〉:〈〈Return t if OBJECT is a process.

(fn OBJECT)〉〉enditem49840〈〈case-table-p〉〉:〈〈Return t if OBJECT is a case table.
See ‘set-case-table’ for more information on these data structures.

(fn OBJECT)〉〉enditem49840〈〈set-standard-case-table〉〉:〈〈Select a new standard case table for new buffers.
See ‘set-case-table’ for more info on case tables.

(fn TABLE)〉〉enditem49840〈〈standard-case-table〉〉:〈〈Return the standard case table.
This is the one used for new buffers.

(fn)〉〉enditem49840〈〈current-case-table〉〉:〈〈Return the case table of the current buffer.

(fn)〉〉enditem49840〈〈set-case-table〉〉:〈〈Select a new case table for the current buffer.
A case table is a char-table which maps characters
to their lower-case equivalents.  It also has three "extra" slots
which may be additional char-tables or nil.
These slots are called UPCASE, CANONICALIZE and EQUIVALENCES.
UPCASE maps each non-upper-case character to its upper-case equivalent.
 (The value in UPCASE for an upper-case character is never used.)
 If lower and upper case characters are in 1-1 correspondence,
 you may use nil and the upcase table will be deduced from DOWNCASE.
CANONICALIZE maps each character to a canonical equivalent;
 any two characters that are related by case-conversion have the same
 canonical equivalent character; it may be nil, in which case it is
 deduced from DOWNCASE and UPCASE.
EQUIVALENCES is a map that cyclically permutes each equivalence class
 (of characters with the same canonical equivalent); it may be nil,
 in which case it is deduced from CANONICALIZE.

(fn TABLE)〉〉enditem49840〈〈set-case-syntax-pair〉〉:〈〈Make characters UC and LC a pair of inter-case-converting letters.
This sets the entries for characters UC and LC in TABLE, which is a string
that will be used as the downcase part of a case table.
It also modifies ‘standard-syntax-table’ to give them the syntax of
word constituents.

(fn UC LC TABLE)〉〉enditem49840〈〈set-case-syntax-delims〉〉:〈〈Make characters L and R a matching pair of non-case-converting delimiters.
This sets the entries for L and R in TABLE, which is a string
that will be used as the downcase part of a case table.
It also modifies ‘standard-syntax-table’ to
indicate left and right delimiters.

(fn L R TABLE)〉〉enditem49840〈〈set-case-syntax〉〉:〈〈Make character C case-invariant with syntax SYNTAX.
This sets the entry for character C in TABLE, which is a string
that will be used as the downcase part of a case table.
It also modifies ‘standard-syntax-table’.
SYNTAX should be " ", "w", "." or "_".

(fn C SYNTAX TABLE)〉〉enditem49840〈〈window-prev-buffers〉〉:〈〈Return buffers previously shown in WINDOW.
WINDOW must be a live window and defaults to the selected one.

The return value is a list of elements (BUFFER WINDOW-START POS),
where BUFFER is a buffer, WINDOW-START is the start position of the
window for that buffer, and POS is a window-specific point value.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-prev-buffers〉〉:〈〈Set WINDOW’s previous buffers to PREV-BUFFERS.
WINDOW must be a live window and defaults to the selected one.

PREV-BUFFERS should be a list of elements (BUFFER WINDOW-START POS),
where BUFFER is a buffer, WINDOW-START is the start position of the
window for that buffer, and POS is a window-specific point value.

(fn WINDOW PREV-BUFFERS)〉〉enditem49840〈〈window-next-buffers〉〉:〈〈Return list of buffers recently re-shown in WINDOW.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-next-buffers〉〉:〈〈Set WINDOW’s next buffers to NEXT-BUFFERS.
WINDOW must be a live window and defaults to the selected one.
NEXT-BUFFERS should be a list of buffers.

(fn WINDOW NEXT-BUFFERS)〉〉enditem49840〈〈read-passwd〉〉:〈〈Read a password, prompting with PROMPT, and return it.
If optional CONFIRM is non-nil, read the password twice to make sure.
Optional DEFAULT is a default password to use instead of empty input.

This function echoes ‘.’ for each character that the user types.
You could let-bind ‘read-hide-char’ to another hiding character, though.

Once the caller uses the password, it can erase the password
by doing (clear-string STRING).

(fn PROMPT &optional CONFIRM DEFAULT)〉〉enditem49840〈〈frame-list〉〉:〈〈Return a list of all live frames.

(fn)〉〉enditem49840〈〈visible-frame-list〉〉:〈〈Return a list of all frames now "visible" (being updated).

(fn)〉〉enditem49840〈〈next-frame〉〉:〈〈Return the next frame in the frame list after FRAME.
It considers only frames on the same terminal as FRAME.
By default, skip minibuffer-only frames.
If omitted, FRAME defaults to the selected frame.
If optional argument MINIFRAME is nil, exclude minibuffer-only frames.
If MINIFRAME is a window, include only its own frame
and any frame now using that window as the minibuffer.
If MINIFRAME is ‘visible’, include all visible frames.
If MINIFRAME is 0, include all visible and iconified frames.
Otherwise, include all frames.

(fn &optional FRAME MINIFRAME)〉〉enditem49840〈〈previous-frame〉〉:〈〈Return the previous frame in the frame list before FRAME.
It considers only frames on the same terminal as FRAME.
By default, skip minibuffer-only frames.
If omitted, FRAME defaults to the selected frame.
If optional argument MINIFRAME is nil, exclude minibuffer-only frames.
If MINIFRAME is a window, include only its own frame
and any frame now using that window as the minibuffer.
If MINIFRAME is ‘visible’, include all visible frames.
If MINIFRAME is 0, include all visible and iconified frames.
Otherwise, include all frames.

(fn &optional FRAME MINIFRAME)〉〉enditem49840〈〈face-list〉〉:〈〈Return a list of all defined faces.〉〉enditem49840〈〈face-id〉〉:〈〈Return the internal ID of face with name FACE.
If FACE is a face-alias, return the ID of the target face.
The optional argument FRAME is ignored, since the internal face ID
of a face name is the same for all frames.

(fn FACE &optional FRAME)〉〉enditem49840〈〈face-equal〉〉:〈〈Non-nil if faces FACE1 and FACE2 are equal.
Faces are considered equal if all their attributes are equal.
If the optional argument FRAME is given, report on FACE1 and FACE2 in that frame.
If FRAME is t, report on the defaults for FACE1 and FACE2 (for new frames).
If FRAME is omitted or nil, use the selected frame.

(fn FACE1 FACE2 &optional FRAME)〉〉enditem49840〈〈face-differs-from-default-p〉〉:〈〈Return non-nil if FACE displays differently from the default face.
If the optional argument FRAME is given, report on face FACE in that frame.
If FRAME is t, report on the defaults for face FACE (for new frames).
If FRAME is omitted or nil, use the selected frame.

(fn FACE &optional FRAME)〉〉enditem49840〈〈file-symlink-p〉〉:〈〈Return non-nil if file FILENAME is the name of a symbolic link.
The value is the link target, as a string.
Otherwise it returns nil.

This function does not check whether the link target exists.

(fn FILENAME)〉〉enditem49840〈〈file-directory-p〉〉:〈〈Return t if FILENAME names an existing directory.
Symbolic links to directories count as directories.
See ‘file-symlink-p’ to distinguish symlinks.

(fn FILENAME)〉〉enditem49840〈〈file-regular-p〉〉:〈〈Return t if FILENAME names a regular file.
This is the sort of file that holds an ordinary stream of data bytes.
Symbolic links to regular files count as regular files.
See ‘file-symlink-p’ to distinguish symlinks.

(fn FILENAME)〉〉enditem49840〈〈find-file-noselect〉〉:〈〈Read file FILENAME into a buffer and return the buffer.
If a buffer exists visiting FILENAME, return that one, but
verify that the file has not changed since visited or saved.
The buffer is not selected, just returned to the caller.
Optional second arg NOWARN non-nil means suppress any warning messages.
Optional third arg RAWFILE non-nil means the file is read literally.
Optional fourth arg WILDCARDS non-nil means do wildcard processing
and visit all the matching files.  When wildcards are actually
used and expanded, return a list of buffers that are visiting
the various files.

(fn FILENAME &optional NOWARN RAWFILE WILDCARDS)〉〉enditem49840〈〈event-click-count〉〉:〈〈Return the multi-click count of EVENT, a click or drag event.
The return value is a positive integer.

(fn EVENT)〉〉enditem49840〈〈fontp〉〉:〈〈Return t if OBJECT is a font-spec, font-entity, or font-object.
Return nil otherwise.
Optional 2nd argument EXTRA-TYPE, if non-nil, specifies to check
which kind of font it is.  It must be one of ‘font-spec’, ‘font-entity’,
‘font-object’.

(fn OBJECT &optional EXTRA-TYPE)〉〉enditem49840〈〈font-at〉〉:〈〈Return a font-object for displaying a character at POSITION.
Optional second arg WINDOW, if non-nil, is a window displaying
the current buffer.  It defaults to the currently selected window.
Optional third arg STRING, if non-nil, is a string containing the target
character at index specified by POSITION.

(fn POSITION &optional WINDOW STRING)〉〉enditem49840〈〈font-spec〉〉:〈〈Return a newly created font-spec with arguments as properties.

ARGS must come in pairs KEY VALUE of font properties.  KEY must be a
valid font property name listed below:

‘:family’, ‘:weight’, ‘:slant’, ‘:width’

They are the same as face attributes of the same name.  See
‘set-face-attribute’.

‘:foundry’

VALUE must be a string or a symbol specifying the font foundry, e.g. ‘misc’.

‘:adstyle’

VALUE must be a string or a symbol specifying the additional
typographic style information of a font, e.g. ‘sans’.

‘:registry’

VALUE must be a string or a symbol specifying the charset registry and
encoding of a font, e.g. ‘iso8859-1’.

‘:size’

VALUE must be a non-negative integer or a floating point number
specifying the font size.  It specifies the font size in pixels (if
VALUE is an integer), or in points (if VALUE is a float).

‘:name’

VALUE must be a string of XLFD-style or fontconfig-style font name.

‘:script’

VALUE must be a symbol representing a script that the font must
support.  It may be a symbol representing a subgroup of a script
listed in the variable ‘script-representative-chars’.

‘:lang’

VALUE must be a symbol whose name is a two-letter ISO-639 language
name, e.g. ‘ja’.  The value is matched against the "Additional Style"
field of the XLFD spec of a font, if it’s non-empty, on X, and
against the codepages supported by the font on w32.

‘:otf’

VALUE must be a list (SCRIPT-TAG LANGSYS-TAG GSUB [ GPOS ]) to specify
required OpenType features.

  SCRIPT-TAG: OpenType script tag symbol (e.g. ‘deva’).
  LANGSYS-TAG: OpenType language system tag symbol,
     or nil for the default language system.
  GSUB: List of OpenType GSUB feature tag symbols, or nil if none required.
  GPOS: List of OpenType GPOS feature tag symbols, or nil if none required.

GSUB and GPOS may contain nil elements.  In such a case, the font
must not have any of the remaining elements.

For instance, if the VALUE is ‘(thai nil nil (mark))’, the font must
be an OpenType font whose GPOS table of ‘thai’ script’s default
language system must contain ‘mark’ feature.

(fn ARGS...)〉〉enditem49840〈〈font-put〉〉:〈〈Set one property of FONT: give property KEY value VAL.
FONT is a font-spec, a font-entity, or a font-object.

If FONT is a font-spec, KEY can be any symbol.  But if KEY is the one
accepted by the function ‘font-spec’ (which see), VAL must be what
allowed in ‘font-spec’.

If FONT is a font-entity or a font-object, KEY must not be the one
accepted by ‘font-spec’.

(fn FONT PROP VAL)〉〉enditem49840〈〈find-font〉〉:〈〈Return a font-entity matching with FONT-SPEC on the current frame.
Optional 2nd argument FRAME, if non-nil, specifies the target frame.

(fn FONT-SPEC &optional FRAME)〉〉enditem49840〈〈list-fonts〉〉:〈〈List available fonts matching FONT-SPEC on the current frame.
Optional 2nd argument FRAME specifies the target frame.
Optional 3rd argument NUM, if non-nil, limits the number of returned fonts.
Optional 4th argument PREFER, if non-nil, is a font-spec to
control the order of the returned list.  Fonts are sorted by
how close they are to PREFER.

(fn FONT-SPEC &optional FRAME NUM PREFER)〉〉enditem49840〈〈font-get〉〉:〈〈Return the value of FONT’s property KEY.
FONT is a font-spec, a font-entity, or a font-object.
KEY is any symbol, but these are reserved for specific meanings:
  :family, :weight, :slant, :width, :foundry, :adstyle, :registry,
  :size, :name, :script, :otf
See the documentation of ‘font-spec’ for their meanings.
In addition, if FONT is a font-entity or a font-object, values of
:script and :otf are different from those of a font-spec as below:

The value of :script may be a list of scripts that are supported by the font.

The value of :otf is a cons (GSUB . GPOS) where GSUB and GPOS are lists
representing the OpenType features supported by the font by this form:
  ((SCRIPT (LANGSYS FEATURE ...) ...) ...)
SCRIPT, LANGSYS, and FEATURE are all symbols representing OpenType
Layout tags.

In addition to the keys listed abobe, the following keys are reserved
for the specific meanings as below:

The value of :combining-capability is non-nil if the font-backend of
FONT supports rendering of combining characters for non-OTF fonts.

(fn FONT KEY)〉〉enditem49840〈〈font-face-attributes〉〉:〈〈Return a plist of face attributes generated by FONT.
FONT is a font name, a font-spec, a font-entity, or a font-object.
The return value is a list of the form

(:family FAMILY :height HEIGHT :weight WEIGHT :slant SLANT :width WIDTH)

where FAMILY, HEIGHT, WEIGHT, SLANT, and WIDTH are face attribute values
compatible with ‘set-face-attribute’.  Some of these key-attribute pairs
may be omitted from the list if they are not specified by FONT.

The optional argument FRAME specifies the frame that the face attributes
are to be displayed on.  If omitted, the selected frame is used.

(fn FONT &optional FRAME)〉〉enditem49840〈〈font-xlfd-name〉〉:〈〈Return XLFD name of FONT.
FONT is a font-spec, font-entity, or font-object.
If the name is too long for XLFD (maximum 255 chars), return nil.
If the 2nd optional arg FOLD-WILDCARDS is non-nil,
the consecutive wildcards are folded into one.

(fn FONT &optional FOLD-WILDCARDS)〉〉enditem49840〈〈font-info〉〉:〈〈Return information about a font named NAME on frame FRAME.
If FRAME is omitted or nil, use the selected frame.

The returned value is a vector of 14 elements:
  [ OPENED-NAME FULL-NAME SIZE HEIGHT BASELINE-OFFSET RELATIVE-COMPOSE
    DEFAULT-ASCENT MAX-WIDTH ASCENT DESCENT SPACE-WIDTH AVERAGE-WIDTH
    FILENAME CAPABILITY ]
where
  OPENED-NAME is the name used for opening the font,
  FULL-NAME is the full name of the font,
  SIZE is the pixelsize of the font,
  HEIGHT is the pixel-height of the font (i.e., ascent + descent),
  BASELINE-OFFSET is the upward offset pixels from ASCII baseline,
  RELATIVE-COMPOSE and DEFAULT-ASCENT are the numbers controlling
    how to compose characters,
  MAX-WIDTH is the maximum advance width of the font,
  ASCENT, DESCENT, SPACE-WIDTH, and AVERAGE-WIDTH are metrics of
    the font in pixels,
  FILENAME is the font file name, a string (or nil if the font backend
    doesn’t provide a file name).
  CAPABILITY is a list whose first element is a symbol representing the
    font format, one of ‘x’, ‘opentype’, ‘truetype’, ‘type1’, ‘pcf’, or ‘bdf’.
    The remaining elements describe the details of the font capabilities,
    as follows:

      If the font is OpenType font, the form of the list is
        (opentype GSUB GPOS)
      where GSUB shows which "GSUB" features the font supports, and GPOS
      shows which "GPOS" features the font supports.  Both GSUB and GPOS are
      lists of the form:
	((SCRIPT (LANGSYS FEATURE ...) ...) ...)

      where
        SCRIPT is a symbol representing OpenType script tag.
        LANGSYS is a symbol representing OpenType langsys tag, or nil
         representing the default langsys.
        FEATURE is a symbol representing OpenType feature tag.

      If the font is not an OpenType font, there are no elements
      in CAPABILITY except the font format symbol.

If the named font is not yet loaded, return nil.

(fn NAME &optional FRAME)〉〉enditem49840〈〈query-font〉〉:〈〈Return information about FONT-OBJECT.
The value is a vector:
  [ NAME FILENAME PIXEL-SIZE SIZE ASCENT DESCENT SPACE-WIDTH AVERAGE-WIDTH
    CAPABILITY ]

NAME is the font name, a string (or nil if the font backend doesn’t
provide a name).

FILENAME is the font file name, a string (or nil if the font backend
doesn’t provide a file name).

PIXEL-SIZE is a pixel size by which the font is opened.

SIZE is a maximum advance width of the font in pixels.

ASCENT, DESCENT, SPACE-WIDTH, AVERAGE-WIDTH are metrics of the font in
pixels.

CAPABILITY is a list whose first element is a symbol representing the
font format (x, opentype, truetype, type1, pcf, or bdf) and the
remaining elements describe the details of the font capability.

If the font is OpenType font, the form of the list is
  (opentype GSUB GPOS)
where GSUB shows which "GSUB" features the font supports, and GPOS
shows which "GPOS" features the font supports.  Both GSUB and GPOS are
lists of the format:
  ((SCRIPT (LANGSYS FEATURE ...) ...) ...)

If the font is not OpenType font, currently the length of the form is
one.

SCRIPT is a symbol representing OpenType script tag.

LANGSYS is a symbol representing OpenType langsys tag, or nil
representing the default langsys.

FEATURE is a symbol representing OpenType feature tag.

If the font is not OpenType font, CAPABILITY is nil.

(fn FONT-OBJECT)〉〉enditem49840〈〈default-font-width〉〉:〈〈Return the width in pixels of the current buffer’s default face font.

If the default font is remapped (see ‘face-remapping-alist’), the
function returns the width of the remapped face.〉〉enditem49840〈〈default-font-height〉〉:〈〈Return the height in pixels of the current buffer’s default face font.

If the default font is remapped (see ‘face-remapping-alist’), the
function returns the height of the remapped face.〉〉enditem49840〈〈window-font-width〉〉:〈〈Return average character width for the font of FACE used in WINDOW.
WINDOW must be a live window and defaults to the selected one.

If FACE is nil or omitted, the default face is used.  If FACE is
remapped (see ‘face-remapping-alist’), the function returns the
information for the remapped face.

(fn &optional WINDOW FACE)〉〉enditem49840〈〈window-font-height〉〉:〈〈Return character height for the font of FACE used in WINDOW.
WINDOW must be a live window and defaults to the selected one.

If FACE is nil or omitted, the default face is used.  If FACE is
remapped (see ‘face-remapping-alist’), the function returns the
information for the remapped face.

(fn &optional WINDOW FACE)〉〉enditem49840〈〈kbd〉〉:〈〈Convert KEYS to the internal Emacs key representation.
KEYS should be a string in the format returned by commands such
as ‘C-h k’ (‘describe-key’).
This is the same format used for saving keyboard macros (see
‘edmacro-mode’).

For an approximate inverse of this, see ‘key-description’.

(fn KEYS)〉〉enditem49840〈〈terminal-name〉〉:〈〈Return the name of the terminal device TERMINAL.
It is not guaranteed that the returned value is unique among opened devices.

TERMINAL may be a terminal object, a frame, or nil (meaning the
selected frame’s terminal).

(fn &optional TERMINAL)〉〉enditem49840〈〈terminal-list〉〉:〈〈Return a list of all terminal devices.

(fn)〉〉enditem49840〈〈get-device-terminal〉〉:〈〈Return the terminal corresponding to DEVICE.
DEVICE can be a terminal, a frame, nil (meaning the selected frame’s terminal),
the name of an X display device (HOST.SERVER.SCREEN) or a tty device file.

(fn DEVICE)〉〉enditem49840〈〈delete-terminal〉〉:〈〈Delete TERMINAL by deleting all frames on it and closing the terminal.
TERMINAL may be a terminal object, a frame, or nil (meaning the
selected frame’s terminal).

Normally, you may not delete a display if all other displays are suspended,
but if the second argument FORCE is non-nil, you may do so.

(fn &optional TERMINAL FORCE)〉〉enditem49840〈〈x-display-list〉〉:〈〈Return the list of display names that Emacs has connections to.

(fn)〉〉enditem49840〈〈x-open-connection〉〉:〈〈Open a connection to a display server.
DISPLAY is the name of the display to connect to.
Optional second arg XRM-STRING is a string of resources in xrdb format.
If the optional third arg MUST-SUCCEED is non-nil,
terminate Emacs if we can’t open the connection.
(In the Nextstep version, the last two arguments are currently ignored.)

(fn DISPLAY &optional RESOURCE-STRING MUST-SUCCEED)〉〉enditem49840〈〈x-close-connection〉〉:〈〈Close the connection to TERMINAL’s Nextstep display server.
For TERMINAL, specify a terminal object, a frame or a display name (a
string).  If TERMINAL is nil, that stands for the selected frame’s
terminal.

(fn TERMINAL)〉〉enditem49840〈〈display-monitor-attributes-list〉〉:〈〈Return a list of physical monitor attributes on DISPLAY.
DISPLAY can be a display name, a terminal name, or a frame.
If DISPLAY is omitted or nil, it defaults to the selected frame’s display.
Each element of the list represents the attributes of a physical
monitor.  The first element corresponds to the primary monitor.

The attributes for a physical monitor are represented as an alist
of attribute keys and values as follows:

 geometry -- Position and size in pixels in the form of (X Y WIDTH HEIGHT)
 workarea -- Position and size of the work area in pixels in the
	     form of (X Y WIDTH HEIGHT)
 mm-size  -- Width and height in millimeters in the form of
 	     (WIDTH HEIGHT)
 frames   -- List of frames dominated by the physical monitor
 name (*) -- Name of the physical monitor as a string
 source (*) -- Source of multi-monitor information as a string

where X, Y, WIDTH, and HEIGHT are integers.  X and Y are coordinates
of the top-left corner, and might be negative for monitors other than
the primary one.  Keys labeled with (*) are optional.

The "work area" is a measure of the "usable" display space.
It may be less than the total screen size, owing to space taken up
by window manager features (docks, taskbars, etc.).  The precise
details depend on the platform and environment.

The ‘source’ attribute describes the source from which the information
was obtained.  On X, this may be one of: "Gdk", "XRandr", "Xinerama",
or "fallback".

A frame is dominated by a physical monitor when either the
largest area of the frame resides in the monitor, or the monitor
is the closest to the frame if the frame does not intersect any
physical monitors.  Every (non-tooltip) frame (including invisible ones)
in a graphical display is dominated by exactly one physical
monitor at a time, though it can span multiple (or no) physical
monitors.

(fn &optional DISPLAY)〉〉enditem49840〈〈frame-monitor-attributes〉〉:〈〈Return the attributes of the physical monitor dominating FRAME.
If FRAME is omitted or nil, describe the currently selected frame.

A frame is dominated by a physical monitor when either the
largest area of the frame resides in the monitor, or the monitor
is the closest to the frame if the frame does not intersect any
physical monitors.

See ‘display-monitor-attributes-list’ for the list of attribute
keys and their meanings.

(fn &optional FRAME)〉〉enditem49840〈〈read-event〉〉:〈〈Read an event object from the input stream.
If the optional argument PROMPT is non-nil, display that as a prompt.
If the optional argument INHERIT-INPUT-METHOD is non-nil and some
input method is turned on in the current buffer, that input method
is used for reading a character.
If the optional argument SECONDS is non-nil, it should be a number
specifying the maximum number of seconds to wait for input.  If no
input arrives in that time, return nil.  SECONDS may be a
floating-point value.

(fn &optional PROMPT INHERIT-INPUT-METHOD SECONDS)〉〉enditem49840〈〈read-char〉〉:〈〈Read a character from the command input (keyboard or macro).
It is returned as a number.
If the character has modifiers, they are resolved and reflected to the
character code if possible (e.g. C-SPC -> 0).

If the user generates an event which is not a character (i.e. a mouse
click or function key event), ‘read-char’ signals an error.  As an
exception, switch-frame events are put off until non-character events
can be read.
If you want to read non-character events, or ignore them, call
‘read-event’ or ‘read-char-exclusive’ instead.

If the optional argument PROMPT is non-nil, display that as a prompt.
If the optional argument INHERIT-INPUT-METHOD is non-nil and some
input method is turned on in the current buffer, that input method
is used for reading a character.
If the optional argument SECONDS is non-nil, it should be a number
specifying the maximum number of seconds to wait for input.  If no
input arrives in that time, return nil.  SECONDS may be a
floating-point value.

(fn &optional PROMPT INHERIT-INPUT-METHOD SECONDS)〉〉enditem49840〈〈read-char-exclusive〉〉:〈〈Read a character from the command input (keyboard or macro).
It is returned as a number.  Non-character events are ignored.
If the character has modifiers, they are resolved and reflected to the
character code if possible (e.g. C-SPC -> 0).

If the optional argument PROMPT is non-nil, display that as a prompt.
If the optional argument INHERIT-INPUT-METHOD is non-nil and some
input method is turned on in the current buffer, that input method
is used for reading a character.
If the optional argument SECONDS is non-nil, it should be a number
specifying the maximum number of seconds to wait for input.  If no
input arrives in that time, return nil.  SECONDS may be a
floating-point value.

(fn &optional PROMPT INHERIT-INPUT-METHOD SECONDS)〉〉enditem49840〈〈read-key〉〉:〈〈Read a key from the keyboard.
Contrary to ‘read-event’ this will not return a raw event but instead will
obey the input decoding and translations usually done by ‘read-key-sequence’.
So escape sequences and keyboard encoding are taken into account.
When there’s an ambiguity because the key looks like the prefix of
some sort of escape sequence, the ambiguity is resolved via ‘read-key-delay’.

(fn &optional PROMPT)〉〉enditem49840〈〈read-char-choice〉〉:〈〈Read and return one of CHARS, prompting for PROMPT.
Any input that is not one of CHARS is ignored.

If optional argument INHIBIT-KEYBOARD-QUIT is non-nil, ignore
keyboard-quit events while waiting for a valid input.

(fn PROMPT CHARS &optional INHIBIT-KEYBOARD-QUIT)〉〉enditem49840〈〈backtrace-debug〉〉:〈〈Set the debug-on-exit flag of eval frame LEVEL levels down to FLAG.
The debugger is entered when that frame exits, if the flag is non-nil.

(fn LEVEL FLAG)〉〉enditem49840〈〈backtrace-frame〉〉:〈〈Return the function and arguments NFRAMES up from current execution point.
If non-nil, BASE should be a function, and NFRAMES counts from its
nearest activation frame.
If the frame has not evaluated the arguments yet (or is a special form),
the value is (nil FUNCTION ARG-FORMS...).
If the frame has evaluated its arguments and called its function already,
the value is (t FUNCTION ARG-VALUES...).
A &rest arg is represented as the tail of the list ARG-VALUES.
FUNCTION is whatever was supplied as car of evaluated list,
or a lambda expression for macro calls.
If NFRAMES is more than the number of frames, the value is nil.

(fn NFRAMES &optional BASE)〉〉enditem49840〈〈directory-files〉〉:〈〈Return a list of names of files in DIRECTORY.
There are three optional arguments:
If FULL is non-nil, return absolute file names.  Otherwise return names
 that are relative to the specified directory.
If MATCH is non-nil, mention only file names that match the regexp MATCH.
If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
 Otherwise, the list returned is sorted with ‘string-lessp’.
 NOSORT is useful if you plan to sort the result yourself.

(fn DIRECTORY &optional FULL MATCH NOSORT)〉〉enditem49840〈〈directory-files-recursively〉〉:〈〈Return list of all files under DIR that have file names matching REGEXP.
This function works recursively.  Files are returned in "depth first"
order, and files from each directory are sorted in alphabetical order.
Each file name appears in the returned list in its absolute form.
Optional argument INCLUDE-DIRECTORIES non-nil means also include in the
output directories whose names match REGEXP.

(fn DIR REGEXP &optional INCLUDE-DIRECTORIES)〉〉enditem49840〈〈directory-files-and-attributes〉〉:〈〈Return a list of names of files and their attributes in DIRECTORY.
There are four optional arguments:
If FULL is non-nil, return absolute file names.  Otherwise return names
 that are relative to the specified directory.
If MATCH is non-nil, mention only file names that match the regexp MATCH.
If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
 NOSORT is useful if you plan to sort the result yourself.
ID-FORMAT specifies the preferred format of attributes uid and gid, see
‘file-attributes’ for further documentation.
On MS-Windows, performance depends on ‘w32-get-true-file-attributes’,
which see.

(fn DIRECTORY &optional FULL MATCH NOSORT ID-FORMAT)〉〉enditem49840〈〈file-expand-wildcards〉〉:〈〈Expand wildcard pattern PATTERN.
This returns a list of file names which match the pattern.
Files are sorted in ‘string<’ order.

If PATTERN is written as an absolute file name,
the values are absolute also.

If PATTERN is written as a relative file name, it is interpreted
relative to the current default directory, ‘default-directory’.
The file names returned are normally also relative to the current
default directory.  However, if FULL is non-nil, they are absolute.

(fn PATTERN &optional FULL)〉〉enditem49840〈〈insert-directory〉〉:〈〈Insert directory listing for FILE, formatted according to SWITCHES.
Leaves point after the inserted text.
SWITCHES may be a string of options, or a list of strings
representing individual options.
Optional third arg WILDCARD means treat FILE as shell wildcard.
Optional fourth arg FULL-DIRECTORY-P means file is a directory and
switches do not contain ‘d’, so that a full listing is expected.

This works by running a directory listing program
whose name is in the variable ‘insert-directory-program’.
If WILDCARD, it also runs the shell specified by ‘shell-file-name’.

When SWITCHES contains the long ‘--dired’ option, this function
treats it specially, for the sake of dired.  However, the
normally equivalent short ‘-D’ option is just passed on to
‘insert-directory-program’, as any other option.

(fn FILE SWITCHES &optional WILDCARD FULL-DIRECTORY-P)〉〉enditem49840〈〈scan-lists〉〉:〈〈Scan from character number FROM by COUNT lists.
Scan forward if COUNT is positive, backward if COUNT is negative.
Return the character number of the position thus found.

A "list", in this context, refers to a balanced parenthetical
grouping, as determined by the syntax table.

If DEPTH is nonzero, treat that as the nesting depth of the starting
point (i.e. the starting point is DEPTH parentheses deep).  This
function scans over parentheses until the depth goes to zero COUNT
times.  Hence, positive DEPTH moves out that number of levels of
parentheses, while negative DEPTH moves to a deeper level.

Comments are ignored if ‘parse-sexp-ignore-comments’ is non-nil.

If we reach the beginning or end of the accessible part of the buffer
before we have scanned over COUNT lists, return nil if the depth at
that point is zero, and signal an error if the depth is nonzero.

(fn FROM COUNT DEPTH)〉〉enditem49840〈〈scan-sexps〉〉:〈〈Scan from character number FROM by COUNT balanced expressions.
If COUNT is negative, scan backwards.
Returns the character number of the position thus found.

Comments are ignored if ‘parse-sexp-ignore-comments’ is non-nil.

If the beginning or end of (the accessible part of) the buffer is reached
in the middle of a parenthetical grouping, an error is signaled.
If the beginning or end is reached between groupings
but before count is used up, nil is returned.

(fn FROM COUNT)〉〉enditem49840〈〈forward-comment〉〉:〈〈Move forward across up to COUNT comments.  If COUNT is negative, move backward.
Stop scanning if we find something other than a comment or whitespace.
Set point to where scanning stops.
If COUNT comments are found as expected, with nothing except whitespace
between them, return t; otherwise return nil.

(fn COUNT)〉〉enditem49840〈〈tq-create〉〉:〈〈Create and return a transaction queue communicating with PROCESS.
PROCESS should be a subprocess capable of sending and receiving
streams of bytes.  It may be a local process, or it may be connected
to a tcp server on another machine.

(fn PROCESS)〉〉enditem49840〈〈set-window-fringes〉〉:〈〈Set the fringe widths of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Second arg LEFT-WIDTH specifies the number of pixels to reserve for
the left fringe.  Optional third arg RIGHT-WIDTH specifies the right
fringe width.  If a fringe width arg is nil, that means to use the
frame’s default fringe width.  Default fringe widths can be set with
the command ‘set-fringe-style’.
If optional fourth arg OUTSIDE-MARGINS is non-nil, draw the fringes
outside of the display margins.  By default, fringes are drawn between
display marginal areas and the text area.

Return t if any fringe was actually changed and nil otherwise.

(fn WINDOW LEFT-WIDTH &optional RIGHT-WIDTH OUTSIDE-MARGINS)〉〉enditem49840〈〈window-fringes〉〉:〈〈Get width of fringes of window WINDOW.
WINDOW must be a live window and defaults to the selected one.

Value is a list of the form (LEFT-WIDTH RIGHT-WIDTH OUTSIDE-MARGINS).

(fn &optional WINDOW)〉〉enditem49840〈〈commandp〉〉:〈〈Non-nil if FUNCTION makes provisions for interactive calling.
This means it contains a description for how to read arguments to give it.
The value is nil for an invalid function or a symbol with no function
definition.

Interactively callable functions include strings and vectors (treated
as keyboard macros), lambda-expressions that contain a top-level call
to ‘interactive’, autoload definitions made by ‘autoload’ with non-nil
fourth argument, and some of the built-in functions of Lisp.

Also, a symbol satisfies ‘commandp’ if its function definition does so.

If the optional argument FOR-CALL-INTERACTIVELY is non-nil,
then strings and vectors are not accepted.

(fn FUNCTION &optional FOR-CALL-INTERACTIVELY)〉〉enditem49840〈〈call-interactively〉〉:〈〈Call FUNCTION, providing args according to its interactive calling specs.
Return the value FUNCTION returns.
The function contains a specification of how to do the argument reading.
In the case of user-defined functions, this is specified by placing a call
to the function ‘interactive’ at the top level of the function body.
See ‘interactive’.

Optional second arg RECORD-FLAG non-nil
means unconditionally put this command in the command-history.
Otherwise, this is done only if an arg is read using the minibuffer.

Optional third arg KEYS, if given, specifies the sequence of events to
supply, as a vector, if the command inquires which events were used to
invoke it.  If KEYS is omitted or nil, the return value of
‘this-command-keys-vector’ is used.

(fn FUNCTION &optional RECORD-FLAG KEYS)〉〉enditem49840〈〈funcall-interactively〉〉:〈〈Like ‘funcall’ but marks the call as interactive.
I.e. arrange that within the called function ‘called-interactively-p’ will
return non-nil.

(fn FUNCTION &rest ARGUMENTS)〉〉enditem49840〈〈command-execute〉〉:〈〈Execute CMD as an editor command.
CMD must be a symbol that satisfies the ‘commandp’ predicate.
Optional second arg RECORD-FLAG non-nil
means unconditionally put this command in the variable ‘command-history’.
Otherwise, that is done only if an arg is read using the minibuffer.
The argument KEYS specifies the value to use instead of (this-command-keys)
when reading the arguments; if it is nil, (this-command-keys) is used.
The argument SPECIAL, if non-nil, means that this command is executing
a special event, so ignore the prefix argument and don’t clear it.

(fn CMD &optional RECORD-FLAG KEYS SPECIAL)〉〉enditem49840〈〈make-bool-vector〉〉:〈〈Return a new bool-vector of length LENGTH, using INIT for each element.
LENGTH must be a number.  INIT matters only in whether it is t or nil.

(fn LENGTH INIT)〉〉enditem49840〈〈bool-vector〉〉:〈〈Return a new bool-vector with specified arguments as elements.
Any number of arguments, even zero arguments, are allowed.

(fn &rest OBJECTS)〉〉enditem49840〈〈bool-vector-p〉〉:〈〈Return t if OBJECT is a bool-vector.

(fn OBJECT)〉〉enditem49840〈〈bool-vector-exclusive-or〉〉:〈〈Return A ^ B, bitwise exclusive or.
If optional third argument C is given, store result into C.
A, B, and C must be bool vectors of the same length.
Return the destination vector if it changed or nil otherwise.

(fn A B &optional C)〉〉enditem49840〈〈bool-vector-union〉〉:〈〈Return A | B, bitwise or.
If optional third argument C is given, store result into C.
A, B, and C must be bool vectors of the same length.
Return the destination vector if it changed or nil otherwise.

(fn A B &optional C)〉〉enditem49840〈〈bool-vector-intersection〉〉:〈〈Return A & B, bitwise and.
If optional third argument C is given, store result into C.
A, B, and C must be bool vectors of the same length.
Return the destination vector if it changed or nil otherwise.

(fn A B &optional C)〉〉enditem49840〈〈bool-vector-set-difference〉〉:〈〈Return A &~ B, set difference.
If optional third argument C is given, store result into C.
A, B, and C must be bool vectors of the same length.
Return the destination vector if it changed or nil otherwise.

(fn A B &optional C)〉〉enditem49840〈〈bool-vector-not〉〉:〈〈Compute ~A, set complement.
If optional second argument B is given, store result into B.
A and B must be bool vectors of the same length.
Return the destination vector.

(fn A &optional B)〉〉enditem49840〈〈bool-vector-subsetp〉〉:〈〈Return t if every t value in A is also t in B, nil otherwise.
A and B must be bool vectors of the same length.

(fn A B)〉〉enditem49840〈〈bool-vector-count-consecutive〉〉:〈〈Count how many consecutive elements in A equal B starting at I.
A is a bool vector, B is t or nil, and I is an index into A.

(fn A B I)〉〉enditem49840〈〈bool-vector-count-population〉〉:〈〈Count how many elements in A are t.
A is a bool vector.  To count A’s nil elements, subtract the return
value from A’s length.

(fn A)〉〉enditem49840〈〈current-active-maps〉〉:〈〈Return a list of the currently active keymaps.
OLP if non-nil indicates that we should obey ‘overriding-local-map’ and
‘overriding-terminal-local-map’.  POSITION can specify a click position
like in the respective argument of ‘key-binding’.

(fn &optional OLP POSITION)〉〉enditem49840〈〈key-binding〉〉:〈〈Return the binding for command KEY in current keymaps.
KEY is a string or vector, a sequence of keystrokes.
The binding is probably a symbol with a function definition.

Normally, ‘key-binding’ ignores bindings for t, which act as default
bindings, used when nothing else in the keymap applies; this makes it
usable as a general function for probing keymaps.  However, if the
optional second argument ACCEPT-DEFAULT is non-nil, ‘key-binding’ does
recognize the default bindings, just as ‘read-key-sequence’ does.

Like the normal command loop, ‘key-binding’ will remap the command
resulting from looking up KEY by looking up the command in the
current keymaps.  However, if the optional third argument NO-REMAP
is non-nil, ‘key-binding’ returns the unmapped command.

If KEY is a key sequence initiated with the mouse, the used keymaps
will depend on the clicked mouse position with regard to the buffer
and possible local keymaps on strings.

If the optional argument POSITION is non-nil, it specifies a mouse
position as returned by ‘event-start’ and ‘event-end’, and the lookup
occurs in the keymaps associated with it instead of KEY.  It can also
be a number or marker, in which case the keymap properties at the
specified buffer position instead of point are used.

(fn KEY &optional ACCEPT-DEFAULT NO-REMAP POSITION)〉〉enditem49840〈〈byte-compile〉〉:〈〈If FORM is a symbol, byte-compile its function definition.
If FORM is a lambda or a macro, byte-compile it as a function.

(fn FORM)〉〉enditem49840〈〈batch-byte-compile〉〉:〈〈Run ‘byte-compile-file’ on the files remaining on the command line.
Use this from the command line, with ‘-batch’;
it won’t work in an interactive Emacs.
Each file is processed even if an error occurred previously.
For example, invoke "emacs -batch -f batch-byte-compile $emacs/ ~/*.el".
If NOFORCE is non-nil, don’t recompile a file that seems to be
already up-to-date.

(fn &optional NOFORCE)〉〉enditem49840〈〈tooltip-mode〉〉:〈〈Toggle Tooltip mode.
With a prefix argument ARG, enable Tooltip mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

When this global minor mode is enabled, Emacs displays help
text (e.g. for buttons and menu items that you put the mouse on)
in a pop-up window.

When Tooltip mode is disabled, Emacs displays help text in the
echo area, instead of making a pop-up window.〉〉enditem49840〈〈tooltip-event-buffer〉〉:〈〈Return the buffer over which event EVENT occurred.
This might return nil if the event did not occur over a buffer.〉〉enditem49840〈〈gap-position〉〉:〈〈Return the position of the gap, in the current buffer.
See also ‘gap-size’.

(fn)〉〉enditem49840〈〈gap-size〉〉:〈〈Return the size of the current buffer’s gap.
See also ‘gap-position’.

(fn)〉〉enditem49840〈〈fetch-bytecode〉〉:〈〈If byte-compiled OBJECT is lazy-loaded, fetch it now.

(fn OBJECT)〉〉enditem49840〈〈define-key-after〉〉:〈〈Add binding in KEYMAP for KEY => DEFINITION, right after AFTER’s binding.
This is like ‘define-key’ except that the binding for KEY is placed
just after the binding for the event AFTER, instead of at the beginning
of the map.  Note that AFTER must be an event type (like KEY), NOT a command
(like DEFINITION).

If AFTER is t or omitted, the new binding goes at the end of the keymap.
AFTER should be a single event type--a symbol or a character, not a sequence.

Bindings are always added before any inherited map.

The order of bindings in a keymap only matters when it is used as
a menu, so this function is not useful for non-menu keymaps.

(fn KEYMAP KEY DEFINITION &optional AFTER)〉〉enditem49840〈〈set-process-filter〉〉:〈〈Give PROCESS the filter function FILTER; nil means default.
A value of t means stop accepting output from the process.

When a process has a non-default filter, its buffer is not used for output.
Instead, each time it does output, the entire string of output is
passed to the filter.

The filter gets two arguments: the process and the string of output.
The string argument is normally a multibyte string, except:
- if the process’s input coding system is no-conversion or raw-text,
  it is a unibyte string (the non-converted input), or else
- if ‘default-enable-multibyte-characters’ is nil, it is a unibyte
  string (the result of converting the decoded input multibyte
  string to unibyte with ‘string-make-unibyte’).

(fn PROCESS FILTER)〉〉enditem49840〈〈process-filter〉〉:〈〈Return the filter function of PROCESS.
See ‘set-process-filter’ for more info on filter functions.

(fn PROCESS)〉〉enditem49840〈〈read-minibuffer〉〉:〈〈Return a Lisp object read using the minibuffer, unevaluated.
Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS
is a string to insert in the minibuffer before reading.
(INITIAL-CONTENTS can also be a cons of a string and an integer.
Such arguments are used as in ‘read-from-minibuffer’.)

(fn PROMPT &optional INITIAL-CONTENTS)〉〉enditem49840〈〈eval-minibuffer〉〉:〈〈Return value of Lisp expression read using the minibuffer.
Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS
is a string to insert in the minibuffer before reading.
(INITIAL-CONTENTS can also be a cons of a string and an integer.
Such arguments are used as in ‘read-from-minibuffer’.)

(fn PROMPT &optional INITIAL-CONTENTS)〉〉enditem49840〈〈edit-and-eval-command〉〉:〈〈Prompting with PROMPT, let user edit COMMAND and eval result.
COMMAND is a Lisp expression.  Let user edit that expression in
the minibuffer, then read and evaluate the result.

(fn PROMPT COMMAND)〉〉enditem49840〈〈verify-visited-file-modtime〉〉:〈〈Return t if last mod time of BUF’s visited file matches what BUF records.
This means that the file has not been changed since it was visited or saved.
If BUF is omitted or nil, it defaults to the current buffer.
See Info node ‘(elisp)Modification Time’ for more details.

(fn &optional BUF)〉〉enditem49840〈〈clear-visited-file-modtime〉〉:〈〈Clear out records of last mod time of visited file.
Next attempt to save will not complain of a discrepancy.〉〉enditem49840〈〈visited-file-modtime〉〉:〈〈Return the current buffer’s recorded visited file modification time.
The value is a list of the form (HIGH LOW USEC PSEC), like the time values that
‘file-attributes’ returns.  If the current buffer has no recorded file
modification time, this function returns 0.  If the visited file
doesn’t exist, return -1.
See Info node ‘(elisp)Modification Time’ for more details.

(fn)〉〉enditem49840〈〈set-visited-file-modtime〉〉:〈〈Update buffer’s recorded modification time from the visited file’s time.
Useful if the buffer was not read from the file normally
or if the file itself has been changed for some known benign reason.
An argument specifies the modification time value to use
(instead of that of the visited file), in the form of a list
(HIGH LOW USEC PSEC) or an integer flag as returned by
‘visited-file-modtime’.

(fn &optional TIME-FLAG)〉〉enditem49840〈〈ask-user-about-supersession-threat〉〉:〈〈Ask a user who is about to modify an obsolete buffer what to do.
This function has two choices: it can return, in which case the modification
of the buffer will proceed, or it can (signal 'file-supersession (file)),
in which case the proposed buffer modification will not be made.

You can rewrite this to use any criterion you like to choose which one to do.
The buffer in question is current when this function is called.

(fn FN)〉〉enditem49840〈〈string-to-multibyte〉〉:〈〈Return a multibyte string with the same individual chars as STRING.
If STRING is multibyte, the result is STRING itself.
Otherwise it is a newly created string, with no text properties.

If STRING is unibyte and contains an 8-bit byte, it is converted to
the corresponding multibyte character of charset ‘eight-bit’.

This differs from ‘string-as-multibyte’ by converting each byte of a correct
utf-8 sequence to an eight-bit character, not just bytes that don’t form a
correct sequence.

(fn STRING)〉〉enditem49840〈〈string-to-unibyte〉〉:〈〈Return a unibyte string with the same individual chars as STRING.
If STRING is unibyte, the result is STRING itself.
Otherwise it is a newly created string, with no text properties,
where each ‘eight-bit’ character is converted to the corresponding byte.
If STRING contains a non-ASCII, non-‘eight-bit’ character,
an error is signaled.

(fn STRING)〉〉enditem49840〈〈byte-to-string〉〉:〈〈Convert arg BYTE to a unibyte string containing that byte.

(fn BYTE)〉〉enditem49840〈〈multibyte-char-to-unibyte〉〉:〈〈Convert the multibyte character CH to a byte.
If the multibyte character does not represent a byte, return -1.

(fn CH)〉〉enditem49840〈〈unibyte-char-to-multibyte〉〉:〈〈Convert the byte CH to multibyte character.

(fn CH)〉〉enditem49840〈〈syntax-ppss〉〉:〈〈Parse-Partial-Sexp State at POS, defaulting to point.
The returned value is the same as that of ‘parse-partial-sexp’
run from ‘point-min’ to POS except that values at positions 2 and 6
in the returned list (counting from 0) cannot be relied upon.
Point is at POS when this function returns.

It is necessary to call ‘syntax-ppss-flush-cache’ explicitly if
this function is called while ‘before-change-functions’ is
temporarily let-bound, or if the buffer is modified without
running the hook.

(fn &optional POS)〉〉enditem49840〈〈syntax-ppss-flush-cache〉〉:〈〈Flush the cache of ‘syntax-ppss’ starting at position BEG.

(fn BEG &rest IGNORED)〉〉enditem49840〈〈read〉〉:〈〈Read one Lisp expression as text from STREAM, return as Lisp object.
If STREAM is nil, use the value of ‘standard-input’ (which see).
STREAM or the value of ‘standard-input’ may be:
 a buffer (read from point and advance it)
 a marker (read from where it points and advance it)
 a function (call it with no arguments for each character,
     call it with a char as argument to push a char back)
 a string (takes text from string, starting at the beginning)
 t (read text line using minibuffer and use it, or read from
    standard input in batch mode).

(fn &optional STREAM)〉〉enditem49840〈〈read-from-string〉〉:〈〈Read one Lisp expression which is represented as text by STRING.
Returns a cons: (OBJECT-READ . FINAL-STRING-INDEX).
FINAL-STRING-INDEX is an integer giving the position of the next
remaining character in STRING.  START and END optionally delimit
a substring of STRING from which to read;  they default to 0 and
(length STRING) respectively.  Negative values are counted from
the end of STRING.

(fn STRING &optional START END)〉〉enditem49840〈〈set-binary-mode〉〉:〈〈Switch STREAM to binary I/O mode or text I/O mode.
STREAM can be one of the symbols ‘stdin’, ‘stdout’, or ‘stderr’.
If MODE is non-nil, switch STREAM to binary mode, otherwise switch
it to text mode.

As a side effect, this function flushes any pending STREAM’s data.

Value is the previous value of STREAM’s I/O mode, nil for text mode,
non-nil for binary mode.

On MS-Windows and MS-DOS, binary mode is needed to read or write
arbitrary binary data, and for disabling translation between CR-LF
pairs and a single newline character.  Examples include generation
of text files with Unix-style end-of-line format using ‘princ’ in
batch mode, with standard output redirected to a file.

On Posix systems, this function always returns non-nil, and has no
effect except for flushing STREAM’s data.

(fn STREAM MODE)〉〉enditem49840〈〈event-start〉〉:〈〈Return the starting position of EVENT.
EVENT should be a mouse click, drag, or key press event.  If
EVENT is nil, the value of ‘posn-at-point’ is used instead.

The following accessor functions are used to access the elements
of the position:

‘posn-window’: The window the event is in.
‘posn-area’: A symbol identifying the area the event occurred in,
or nil if the event occurred in the text area.
‘posn-point’: The buffer position of the event.
‘posn-x-y’: The pixel-based coordinates of the event.
‘posn-col-row’: The estimated column and row corresponding to the
position of the event.
‘posn-actual-col-row’: The actual column and row corresponding to the
position of the event.
‘posn-string’: The string object of the event, which is either
nil or (STRING . POSITION)’.
‘posn-image’: The image object of the event, if any.
‘posn-object’: The image or string object of the event, if any.
‘posn-timestamp’: The time the event occurred, in milliseconds.

For more information, see Info node ‘(elisp)Click Events’.

(fn EVENT)〉〉enditem49840〈〈event-end〉〉:〈〈Return the ending position of EVENT.
EVENT should be a click, drag, or key press event.

See ‘event-start’ for a description of the value returned.

(fn EVENT)〉〉enditem49840〈〈posnp〉〉:〈〈Return non-nil if OBJ appears to be a valid ‘posn’ object specifying a window.
A ‘posn’ object is returned from functions such as ‘event-start’.
If OBJ is a valid ‘posn’ object, but specifies a frame rather
than a window, return nil.

(fn OBJ)〉〉enditem49840〈〈posn-window〉〉:〈〈Return the window in POSITION.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-area〉〉:〈〈Return the window area recorded in POSITION, or nil for the text area.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-point〉〉:〈〈Return the buffer location in POSITION.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.
Returns nil if POSITION does not correspond to any buffer location (e.g.
a click on a scroll bar).

(fn POSITION)〉〉enditem49840〈〈posn-x-y〉〉:〈〈Return the x and y coordinates in POSITION.
The return value has the form (X . Y), where X and Y are given in
pixels.  POSITION should be a list of the form returned by
‘event-start’ and ‘event-end’.

(fn POSITION)〉〉enditem49840〈〈posn-col-row〉〉:〈〈Return the nominal column and row in POSITION, measured in characters.
The column and row values are approximations calculated from the x
and y coordinates in POSITION and the frame’s default character width
and default line height, including spacing.
For a scroll-bar event, the result column is 0, and the row
corresponds to the vertical position of the click in the scroll bar.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-actual-col-row〉〉:〈〈Return the window row number in POSITION and character number in that row.

Return nil if POSITION does not contain the actual position; in that case
‘posn-col-row’ can be used to get approximate values.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

This function does not account for the width on display, like the
number of visual columns taken by a TAB or image.  If you need
the coordinates of POSITION in character units, you should use
‘posn-col-row’, not this function.

(fn POSITION)〉〉enditem49840〈〈posn-string〉〉:〈〈Return the string object of POSITION.
Value is a cons (STRING . STRING-POS), or nil if not a string.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-image〉〉:〈〈Return the image object of POSITION.
Value is a list (image ...), or nil if not an image.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-object〉〉:〈〈Return the object (image or string) of POSITION.
Value is a list (image ...) for an image object, a cons cell
(STRING . STRING-POS) for a string object, and nil for a buffer position.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-object-x-y〉〉:〈〈Return the x and y coordinates relative to the object of POSITION.
The return value has the form (DX . DY), where DX and DY are
given in pixels.  POSITION should be a list of the form returned
by ‘event-start’ and ‘event-end’.

(fn POSITION)〉〉enditem49840〈〈posn-object-width-height〉〉:〈〈Return the pixel width and height of the object of POSITION.
The return value has the form (WIDTH . HEIGHT).  POSITION should
be a list of the form returned by ‘event-start’ and ‘event-end’.

(fn POSITION)〉〉enditem49840〈〈posn-timestamp〉〉:〈〈Return the timestamp of POSITION.
POSITION should be a list of the form returned by the ‘event-start’
and ‘event-end’ functions.

(fn POSITION)〉〉enditem49840〈〈posn-at-point〉〉:〈〈Return position information for buffer position POS in WINDOW.
POS defaults to point in WINDOW; WINDOW defaults to the selected window.

Return nil if POS is not visible in WINDOW.  Otherwise,
the return value is similar to that returned by ‘event-start’ for
a mouse click at the upper left corner of the glyph corresponding
to POS:
   (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)
    IMAGE (DX . DY) (WIDTH . HEIGHT))
The ‘posn-’ functions access elements of such lists.

(fn &optional POS WINDOW)〉〉enditem49840〈〈posn-at-x-y〉〉:〈〈Return position information for pixel coordinates X and Y.
By default, X and Y are relative to text area of the selected window.
Optional third arg FRAME-OR-WINDOW non-nil specifies frame or window.
If optional fourth arg WHOLE is non-nil, X is relative to the left
edge of the window.

The return value is similar to a mouse click position:
   (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)
    IMAGE (DX . DY) (WIDTH . HEIGHT))
The ‘posn-’ functions access elements of such lists.

(fn X Y &optional FRAME-OR-WINDOW WHOLE)〉〉enditem49840〈〈image-flush〉〉:〈〈Flush the image with specification SPEC on frame FRAME.
This removes the image from the Emacs image cache.  If SPEC specifies
an image file, the next redisplay of this image will read from the
current contents of that file.

FRAME nil or omitted means use the selected frame.
FRAME t means refresh the image on all frames.

(fn SPEC &optional FRAME)〉〉enditem49840〈〈clear-image-cache〉〉:〈〈Clear the image cache.
FILTER nil or a frame means clear all images in the selected frame.
FILTER t means clear the image caches of all frames.
Anything else, means only clear those images which refer to FILTER,
which is then usually a filename.

(fn &optional FILTER)〉〉enditem49840〈〈sentence-end〉〉:〈〈Return the regexp describing the end of a sentence.

This function returns either the value of the variable ‘sentence-end’
if it is non-nil, or the default value constructed from the
variables ‘sentence-end-base’, ‘sentence-end-double-space’,
‘sentence-end-without-period’ and ‘sentence-end-without-space’.

The default value specifies that in order to be recognized as the
end of a sentence, the ending period, question mark, or exclamation point
must be followed by two spaces, with perhaps some closing delimiters
in between.  See Info node ‘(elisp)Standard Regexps’.〉〉enditem49840〈〈system-name〉〉:〈〈Return the host name of the machine you are running on, as a string.

(fn)〉〉enditem49840〈〈parse-colon-path〉〉:〈〈Explode a search path into a list of directory names.
Directories are separated by ‘path-separator’ (which is colon in
GNU and Unix systems).  Substitute environment variables into the
resulting list of directory names.  For an empty path element (i.e.,
a leading or trailing separator, or two adjacent separators), return
nil (meaning ‘default-directory’) as the associated list element.

(fn SEARCH-PATH)〉〉enditem49840〈〈load-average〉〉:〈〈Return list of 1 minute, 5 minute and 15 minute load averages.

Each of the three load averages is multiplied by 100, then converted
to integer.

When USE-FLOATS is non-nil, floats will be used instead of integers.
These floats are not multiplied by 100.

If the 5-minute or 15-minute load averages are not available, return a
shortened list, containing only those averages which are available.

An error is thrown if the load average can’t be obtained.  In some
cases making it work would require Emacs being installed setuid or
setgid so that it can read kernel information, and that usually isn’t
advisable.

(fn &optional USE-FLOATS)〉〉enditem49840〈〈emacs-pid〉〉:〈〈Return the process ID of Emacs, as a number.

(fn)〉〉enditem49840〈〈y-or-n-p〉〉:〈〈Ask user a "y or n" question.
Return t if answer is "y" and nil if it is "n".
PROMPT is the string to display to ask the question.  It should
end in a space; ‘y-or-n-p’ adds "(y or n) " to it.

No confirmation of the answer is requested; a single character is
enough.  SPC also means yes, and DEL means no.

To be precise, this function translates user input into responses
by consulting the bindings in ‘query-replace-map’; see the
documentation of that variable for more information.  In this
case, the useful bindings are ‘act’, ‘skip’, ‘recenter’,
‘scroll-up’, ‘scroll-down’, and ‘quit’.
An ‘act’ response means yes, and a ‘skip’ response means no.
A ‘quit’ response means to invoke ‘keyboard-quit’.
If the user enters ‘recenter’, ‘scroll-up’, or ‘scroll-down’
responses, perform the requested window recentering or scrolling
and ask again.

Under a windowing system a dialog box will be used if ‘last-nonmenu-event’
is nil and ‘use-dialog-box’ is non-nil.

(fn PROMPT)〉〉enditem49840〈〈y-or-n-p-with-timeout〉〉:〈〈Like (y-or-n-p PROMPT), with a timeout.
If the user does not answer after SECONDS seconds, return DEFAULT-VALUE.

(fn PROMPT SECONDS DEFAULT-VALUE)〉〉enditem49840〈〈yes-or-no-p〉〉:〈〈Ask user a "y or n" question.
Return t if answer is "y" and nil if it is "n".
PROMPT is the string to display to ask the question.  It should
end in a space; ‘y-or-n-p’ adds "(y or n) " to it.

No confirmation of the answer is requested; a single character is
enough.  SPC also means yes, and DEL means no.

To be precise, this function translates user input into responses
by consulting the bindings in ‘query-replace-map’; see the
documentation of that variable for more information.  In this
case, the useful bindings are ‘act’, ‘skip’, ‘recenter’,
‘scroll-up’, ‘scroll-down’, and ‘quit’.
An ‘act’ response means yes, and a ‘skip’ response means no.
A ‘quit’ response means to invoke ‘keyboard-quit’.
If the user enters ‘recenter’, ‘scroll-up’, or ‘scroll-down’
responses, perform the requested window recentering or scrolling
and ask again.

Under a windowing system a dialog box will be used if ‘last-nonmenu-event’
is nil and ‘use-dialog-box’ is non-nil.

(fn PROMPT)〉〉enditem49840〈〈hash-table-p〉〉:〈〈Return t if OBJ is a Lisp hash table object.

(fn OBJ)〉〉enditem49840〈〈copy-hash-table〉〉:〈〈Return a copy of hash table TABLE.

(fn TABLE)〉〉enditem49840〈〈hash-table-count〉〉:〈〈Return the number of elements in TABLE.

(fn TABLE)〉〉enditem49840〈〈hash-table-test〉〉:〈〈Return the test TABLE uses.

(fn TABLE)〉〉enditem49840〈〈hash-table-weakness〉〉:〈〈Return the weakness of TABLE.

(fn TABLE)〉〉enditem49840〈〈hash-table-rehash-size〉〉:〈〈Return the current rehash size of TABLE.

(fn TABLE)〉〉enditem49840〈〈hash-table-rehash-threshold〉〉:〈〈Return the current rehash threshold of TABLE.

(fn TABLE)〉〉enditem49840〈〈hash-table-size〉〉:〈〈Return the size of TABLE.
The size can be used as an argument to ‘make-hash-table’ to create
a hash table than can hold as many elements as TABLE holds
without need for resizing.

(fn TABLE)〉〉enditem49840〈〈custom-initialize-delay〉〉:〈〈Delay initialization of SYMBOL to the next Emacs start.
This is used in files that are preloaded (or for autoloaded
variables), so that the initialization is done in the run-time
context rather than the build-time context.  This also has the
side-effect that the (delayed) initialization is performed with
the :set function.

For variables in preloaded files, you can simply use this
function for the :initialize property.  For autoloaded variables,
you will also need to add an autoload stanza calling this
function, and another one setting the standard-value property.
Or you can wrap the defcustom in a progn, to force the autoloader
to include all of it.〉〉enditem49840〈〈dump-emacs〉〉:〈〈Dump current state of Emacs into executable file FILENAME.
Take symbols from SYMFILE (presumably the file you executed to run Emacs).
This is used in the file ‘loadup.el’ when building Emacs.

You must run Emacs in batch mode in order to dump it.

(fn FILENAME SYMFILE)〉〉enditem49840〈〈define-error〉〉:〈〈Define NAME as a new error signal.
MESSAGE is a string that will be output to the echo area if such an error
is signaled without being caught by a ‘condition-case’.
PARENT is either a signal or a list of signals from which it inherits.
Defaults to ‘error’.

(fn NAME MESSAGE &optional PARENT)〉〉enditem49840〈〈set-auto-mode〉〉:〈〈Select major mode appropriate for current buffer.

To find the right major mode, this function checks for a -*- mode tag
checks for a ‘mode:’ entry in the Local Variables section of the file,
checks if it uses an interpreter listed in ‘interpreter-mode-alist’,
matches the buffer beginning against ‘magic-mode-alist’,
compares the filename against the entries in ‘auto-mode-alist’,
then matches the buffer beginning against ‘magic-fallback-mode-alist’.

If ‘enable-local-variables’ is nil, or if the file name matches
‘inhibit-local-variables-regexps’, this function does not check
for any mode: tag anywhere in the file.  If ‘local-enable-local-variables’
is nil, then the only mode: tag that can be relevant is a -*- one.

If the optional argument KEEP-MODE-IF-SAME is non-nil, then we
set the major mode only if that would change it.  In other words
we don’t actually set it to the same mode the buffer already has.

(fn &optional KEEP-MODE-IF-SAME)〉〉enditem49840〈〈set-buffer-major-mode〉〉:〈〈Set an appropriate major mode for BUFFER.
For the *scratch* buffer, use ‘initial-major-mode’, otherwise choose a mode
according to the default value of ‘major-mode’.
Use this function before selecting the buffer, since it may need to inspect
the current buffer’s major mode.

(fn BUFFER)〉〉enditem49840〈〈next-window〉〉:〈〈Return live window after WINDOW in the cyclic ordering of windows.
WINDOW must be a live window and defaults to the selected one.  The
optional arguments MINIBUF and ALL-FRAMES specify the set of windows to
consider.

MINIBUF nil or omitted means consider the minibuffer window only if the
minibuffer is active.  MINIBUF t means consider the minibuffer window
even if the minibuffer is not active.  Any other value means do not
consider the minibuffer window even if the minibuffer is active.

ALL-FRAMES nil or omitted means consider all windows on WINDOW’s frame,
plus the minibuffer window if specified by the MINIBUF argument.  If the
minibuffer counts, consider all windows on all frames that share that
minibuffer too.  The following non-nil values of ALL-FRAMES have special
meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames.

- 0 (the number zero) means consider all windows on all visible and
  iconified frames.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on WINDOW’s frame and no
others.

If you use consistent values for MINIBUF and ALL-FRAMES, you can use
‘next-window’ to iterate through the entire cycle of acceptable
windows, eventually ending up back at the window you started with.
‘previous-window’ traverses the same cycle, in the reverse order.

(fn &optional WINDOW MINIBUF ALL-FRAMES)〉〉enditem49840〈〈previous-window〉〉:〈〈Return live window before WINDOW in the cyclic ordering of windows.
WINDOW must be a live window and defaults to the selected one.  The
optional arguments MINIBUF and ALL-FRAMES specify the set of windows to
consider.

MINIBUF nil or omitted means consider the minibuffer window only if the
minibuffer is active.  MINIBUF t means consider the minibuffer window
even if the minibuffer is not active.  Any other value means do not
consider the minibuffer window even if the minibuffer is active.

ALL-FRAMES nil or omitted means consider all windows on WINDOW’s frame,
plus the minibuffer window if specified by the MINIBUF argument.  If the
minibuffer counts, consider all windows on all frames that share that
minibuffer too.  The following non-nil values of ALL-FRAMES have special
meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames.

- 0 (the number zero) means consider all windows on all visible and
  iconified frames.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on WINDOW’s frame and no
others.

If you use consistent values for MINIBUF and ALL-FRAMES, you can
use ‘previous-window’ to iterate through the entire cycle of
acceptable windows, eventually ending up back at the window you
started with.  ‘next-window’ traverses the same cycle, in the
reverse order.

(fn &optional WINDOW MINIBUF ALL-FRAMES)〉〉enditem49840〈〈walk-windows〉〉:〈〈Cycle through all live windows, calling FUN for each one.
FUN must specify a function with a window as its sole argument.
The optional arguments MINIBUF and ALL-FRAMES specify the set of
windows to include in the walk.

MINIBUF t means include the minibuffer window even if the
minibuffer is not active.  MINIBUF nil or omitted means include
the minibuffer window only if the minibuffer is active.  Any
other value means do not include the minibuffer window even if
the minibuffer is active.

ALL-FRAMES nil or omitted means consider all windows on the
selected frame, plus the minibuffer window if specified by the
MINIBUF argument.  If the minibuffer counts, consider all windows
on all frames that share that minibuffer too.  The following
non-nil values of ALL-FRAMES have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on the selected frame
and no others.

This function changes neither the order of recently selected
windows nor the buffer list.

(fn FUN &optional MINIBUF ALL-FRAMES)〉〉enditem49840〈〈one-window-p〉〉:〈〈Return non-nil if the selected window is the only window.
Optional arg NOMINI non-nil means don’t count the minibuffer
even if it is active.  Otherwise, the minibuffer is counted
when it is active.

Optional argument ALL-FRAMES specifies the set of frames to
consider, see also ‘next-window’.  ALL-FRAMES nil or omitted
means consider windows on the selected frame only, plus the
minibuffer window if specified by the NOMINI argument.  If the
minibuffer counts, consider all windows on all frames that share
that minibuffer too.  The remaining non-nil values of ALL-FRAMES
with a special meaning are:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on the selected frame
and no others.

(fn &optional NOMINI ALL-FRAMES)〉〉enditem49840〈〈get-lru-window〉〉:〈〈Return the least recently used window on frames specified by ALL-FRAMES.
Return a full-width window if possible.  A minibuffer window is
never a candidate.  A dedicated window is never a candidate
unless DEDICATED is non-nil, so if all windows are dedicated, the
value is nil.  Avoid returning the selected window if possible.
Optional argument NOT-SELECTED non-nil means never return the
selected window.

The following non-nil values of the optional argument ALL-FRAMES
have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Any other value of ALL-FRAMES means consider all windows on the
selected frame and no others.

(fn &optional ALL-FRAMES DEDICATED NOT-SELECTED)〉〉enditem49840〈〈get-mru-window〉〉:〈〈Return the most recently used window on frames specified by ALL-FRAMES.
A minibuffer window is never a candidate.  A dedicated window is
never a candidate unless DEDICATED is non-nil, so if all windows
are dedicated, the value is nil.  Optional argument NOT-SELECTED
non-nil means never return the selected window.

The following non-nil values of the optional argument ALL-FRAMES
have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Any other value of ALL-FRAMES means consider all windows on the
selected frame and no others.

(fn &optional ALL-FRAMES DEDICATED NOT-SELECTED)〉〉enditem49840〈〈get-largest-window〉〉:〈〈Return the largest window on frames specified by ALL-FRAMES.
A minibuffer window is never a candidate.  A dedicated window is
never a candidate unless DEDICATED is non-nil, so if all windows
are dedicated, the value is nil.  Optional argument NOT-SELECTED
non-nil means never return the selected window.

The following non-nil values of the optional argument ALL-FRAMES
have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Any other value of ALL-FRAMES means consider all windows on the
selected frame and no others.

(fn &optional ALL-FRAMES DEDICATED NOT-SELECTED)〉〉enditem49840〈〈get-window-with-predicate〉〉:〈〈Return a live window satisfying PREDICATE.
More precisely, cycle through all windows calling the function
PREDICATE on each one of them with the window as its sole
argument.  Return the first window for which PREDICATE returns
non-nil.  Windows are scanned starting with the window following
the selected window.  If no window satisfies PREDICATE, return
DEFAULT.

MINIBUF t means include the minibuffer window even if the
minibuffer is not active.  MINIBUF nil or omitted means include
the minibuffer window only if the minibuffer is active.  Any
other value means do not include the minibuffer window even if
the minibuffer is active.

ALL-FRAMES nil or omitted means consider all windows on the selected
frame, plus the minibuffer window if specified by the MINIBUF
argument.  If the minibuffer counts, consider all windows on all
frames that share that minibuffer too.  The following non-nil
values of ALL-FRAMES have special meanings:

- t means consider all windows on all existing frames.

- ‘visible’ means consider all windows on all visible frames on
  the current terminal.

- 0 (the number zero) means consider all windows on all visible
  and iconified frames on the current terminal.

- A frame means consider all windows on that frame only.

Anything else means consider all windows on the selected frame
and no others.

(fn PREDICATE &optional MINIBUF ALL-FRAMES DEFAULT)〉〉enditem49840〈〈list-system-processes〉〉:〈〈Return a list of numerical process IDs of all running processes.
If this functionality is unsupported, return nil.

See ‘process-attributes’ for getting attributes of a process given its ID.

(fn)〉〉enditem49840〈〈process-attributes〉〉:〈〈Return attributes of the process given by its PID, a number.

Value is an alist where each element is a cons cell of the form

    (KEY . VALUE)

If this functionality is unsupported, the value is nil.

See ‘list-system-processes’ for getting a list of all process IDs.

The KEYs of the attributes that this function may return are listed
below, together with the type of the associated VALUE (in parentheses).
Not all platforms support all of these attributes; unsupported
attributes will not appear in the returned alist.
Unless explicitly indicated otherwise, numbers can have either
integer or floating point values.

 euid    -- Effective user User ID of the process (number)
 user    -- User name corresponding to euid (string)
 egid    -- Effective user Group ID of the process (number)
 group   -- Group name corresponding to egid (string)
 comm    -- Command name (executable name only) (string)
 state   -- Process state code, such as "S", "R", or "T" (string)
 ppid    -- Parent process ID (number)
 pgrp    -- Process group ID (number)
 sess    -- Session ID, i.e. process ID of session leader (number)
 ttname  -- Controlling tty name (string)
 tpgid   -- ID of foreground process group on the process’s tty (number)
 minflt  -- number of minor page faults (number)
 majflt  -- number of major page faults (number)
 cminflt -- cumulative number of minor page faults (number)
 cmajflt -- cumulative number of major page faults (number)
 utime   -- user time used by the process, in (current-time) format,
              which is a list of integers (HIGH LOW USEC PSEC)
 stime   -- system time used by the process (current-time)
 time    -- sum of utime and stime (current-time)
 cutime  -- user time used by the process and its children (current-time)
 cstime  -- system time used by the process and its children (current-time)
 ctime   -- sum of cutime and cstime (current-time)
 pri     -- priority of the process (number)
 nice    -- nice value of the process (number)
 thcount -- process thread count (number)
 start   -- time the process started (current-time)
 vsize   -- virtual memory size of the process in KB’s (number)
 rss     -- resident set size of the process in KB’s (number)
 etime   -- elapsed time the process is running, in (HIGH LOW USEC PSEC) format
 pcpu    -- percents of CPU time used by the process (floating-point number)
 pmem    -- percents of total physical memory used by process’s resident set
              (floating-point number)
 args    -- command line which invoked the process (string).

(fn PID)〉〉enditem49840〈〈define-abbrev〉〉:〈〈Define an abbrev in TABLE named NAME, to expand to EXPANSION and call HOOK.
NAME must be a string, and should be lower-case.
EXPANSION should usually be a string.
To undefine an abbrev, define it with EXPANSION = nil.
If HOOK is non-nil, it should be a function of no arguments;
it is called after EXPANSION is inserted.
If EXPANSION is not a string (and not nil), the abbrev is a
 special one, which does not expand in the usual way but only
 runs HOOK.

If HOOK is a non-nil symbol with a non-nil ‘no-self-insert’ property,
it can control whether the character that triggered abbrev expansion
is inserted.  If such a HOOK returns non-nil, the character is not
inserted.  If such a HOOK returns nil, then so does ‘abbrev-insert’
(and ‘expand-abbrev’), as if no abbrev expansion had taken place.

PROPS is a property list.  The following properties are special:
- ‘:count’: the value for the abbrev’s usage-count, which is incremented each
  time the abbrev is used (the default is zero).
- ‘:system’: if non-nil, says that this is a "system" abbreviation
  which should not be saved in the user’s abbreviation file.
  Unless ‘:system’ is ‘force’, a system abbreviation will not
  overwrite a non-system abbreviation of the same name.
- ‘:case-fixed’: non-nil means that abbreviations are looked up without
  case-folding, and the expansion is not capitalized/upcased.
- ‘:enable-function’: a function of no argument which returns non-nil if the
  abbrev should be used for a particular call of ‘expand-abbrev’.

An obsolete but still supported calling form is:

(define-abbrev TABLE NAME EXPANSION &optional HOOK COUNT SYSTEM).

(fn TABLE NAME EXPANSION &optional HOOK &rest PROPS)〉〉enditem49840〈〈find-auto-coding〉〉:〈〈Find a coding system for a file FILENAME of which SIZE bytes follow point.
These bytes should include at least the first 1k of the file
and the last 3k of the file, but the middle may be omitted.

The function checks FILENAME against the variable ‘auto-coding-alist’.
If FILENAME doesn’t match any entries in the variable, it checks the
contents of the current buffer following point against
‘auto-coding-regexp-alist’.  If no match is found, it checks for a
‘coding:’ tag in the first one or two lines following point.  If no
‘coding:’ tag is found, it checks any local variables list in the last
3K bytes out of the SIZE bytes.  Finally, if none of these methods
succeed, it checks to see if any function in ‘auto-coding-functions’
gives a match.

If a coding system is specified, the return value is a cons
(CODING . SOURCE), where CODING is the specified coding system and
SOURCE is a symbol ‘auto-coding-alist’, ‘auto-coding-regexp-alist’,
‘:coding’, or ‘auto-coding-functions’ indicating by what CODING is
specified.  Note that the validity of CODING is not checked;
it’s the caller’s responsibility to check it.

If nothing is specified, the return value is nil.〉〉enditem49840〈〈set-auto-coding〉〉:〈〈Return coding system for a file FILENAME of which SIZE bytes follow point.
See ‘find-auto-coding’ for how the coding system is found.
Return nil if an invalid coding system is found.

The variable ‘set-auto-coding-function’ (which see) is set to this
function by default.〉〉enditem49840〈〈find-operation-coding-system〉〉:〈〈Choose a coding system for an operation based on the target name.
The value names a pair of coding systems: (DECODING-SYSTEM . ENCODING-SYSTEM).
DECODING-SYSTEM is the coding system to use for decoding
(in case OPERATION does decoding), and ENCODING-SYSTEM is the coding system
for encoding (in case OPERATION does encoding).

The first argument OPERATION specifies an I/O primitive:
  For file I/O, ‘insert-file-contents’ or ‘write-region’.
  For process I/O, ‘call-process’, ‘call-process-region’, or ‘start-process’.
  For network I/O, ‘open-network-stream’.

The remaining arguments should be the same arguments that were passed
to the primitive.  Depending on which primitive, one of those arguments
is selected as the TARGET.  For example, if OPERATION does file I/O,
whichever argument specifies the file name is TARGET.

TARGET has a meaning which depends on OPERATION:
  For file I/O, TARGET is a file name (except for the special case below).
  For process I/O, TARGET is a process name.
  For network I/O, TARGET is a service name or a port number.

This function looks up what is specified for TARGET in
‘file-coding-system-alist’, ‘process-coding-system-alist’,
or ‘network-coding-system-alist’ depending on OPERATION.
They may specify a coding system, a cons of coding systems,
or a function symbol to call.
In the last case, we call the function with one argument,
which is a list of all the arguments given to this function.
If the function can’t decide a coding system, it can return
‘undecided’ so that the normal code-detection is performed.

If OPERATION is ‘insert-file-contents’, the argument corresponding to
TARGET may be a cons (FILENAME . BUFFER).  In that case, FILENAME is a
file name to look up, and BUFFER is a buffer that contains the file’s
contents (not yet decoded).  If ‘file-coding-system-alist’ specifies a
function to call for FILENAME, that function should examine the
contents of BUFFER instead of reading the file.

(fn OPERATION ARGUMENTS...)〉〉enditem49840〈〈listify-key-sequence〉〉:〈〈Convert a key sequence to a list of events.

(fn KEY)〉〉enditem49840〈〈input-pending-p〉〉:〈〈Return t if command input is currently available with no wait.
Actually, the value is nil only if we can be sure that no input is available;
if there is a doubt, the value is t.

If CHECK-TIMERS is non-nil, timers that are ready to run will do so.

(fn &optional CHECK-TIMERS)〉〉enditem49840〈〈discard-input〉〉:〈〈Discard the contents of the terminal input buffer.
Also end any kbd macro being defined.

(fn)〉〉enditem49840〈〈messages-buffer〉〉:〈〈Return the "*Messages*" buffer.
If it does not exist, create and it switch it to ‘messages-buffer-mode’.〉〉enditem49840〈〈set〉〉:〈〈Set SYMBOL’s value to NEWVAL, and return NEWVAL.

(fn SYMBOL NEWVAL)〉〉enditem49840〈〈auto-save-file-name-p〉〉:〈〈Return non-nil if FILENAME can be yielded by ‘make-auto-save-file-name’.
FILENAME should lack slashes.  You can redefine this for customization.

(fn FILENAME)〉〉enditem49840〈〈make-auto-save-file-name〉〉:〈〈Return file name to use for auto-saves of current buffer.
Does not consider ‘auto-save-visited-file-name’ as that variable is checked
before calling this function.  You can redefine this for customization.
See also ‘auto-save-file-name-p’.〉〉enditem49840〈〈recent-auto-save-p〉〉:〈〈Return t if current buffer has been auto-saved recently.
More precisely, if it has been auto-saved since last read from or saved
in the visited file.  If the buffer has no visited file,
then any auto-save counts as "recent".

(fn)〉〉enditem49840〈〈set-buffer-auto-saved〉〉:〈〈Mark current buffer as auto-saved with its current text.
No auto-save file will be written until the buffer changes again.

(fn)〉〉enditem49840〈〈delete-auto-save-file-if-necessary〉〉:〈〈Delete auto-save file for current buffer if ‘delete-auto-save-files’ is t.
Normally delete only if the file was written by this Emacs since
the last real save, but optional arg FORCE non-nil means delete anyway.

(fn &optional FORCE)〉〉enditem49840〈〈rename-auto-save-file〉〉:〈〈Adjust current buffer’s auto save file name for current conditions.
Also rename any existing auto save file, if it was made in this session.〉〉enditem49840〈〈abbrev-put〉〉:〈〈Set the property PROP of abbrev ABBREV to value VAL.
See ‘define-abbrev’ for the effect of some special properties.

(fn ABBREV PROP VAL)〉〉enditem49840〈〈abbrev-get〉〉:〈〈Get the property PROP of abbrev ABBREV

(fn ABBREV PROP)〉〉enditem49840〈〈forward-word-strictly〉〉:〈〈Move point forward ARG words (backward if ARG is negative).
If ARG is omitted or nil, move point forward one word.
Normally returns t.
If an edge of the buffer or a field boundary is reached, point is left there
and the function returns nil.  Field boundaries are not noticed if
‘inhibit-field-text-motion’ is non-nil.

This function is like ‘forward-word’, but it is not affected
by ‘find-word-boundary-function-table’.  It is also not interactive.

(fn &optional ARG)〉〉enditem49840〈〈backward-word-strictly〉〉:〈〈Move backward until encountering the beginning of a word.
With argument ARG, do this that many times.
If ARG is omitted or nil, move point backward one word.

This function is like ‘forward-word’, but it is not affected
by ‘find-word-boundary-function-table’.  It is also not interactive.

(fn &optional ARG)〉〉enditem49840〈〈advice-add〉〉:〈〈Like ‘add-function’ but for the function named SYMBOL.
Contrary to ‘add-function’, this will properly handle the cases where SYMBOL
is defined as a macro, alias, command, ...

(fn SYMBOL WHERE FUNCTION &optional PROPS)〉〉enditem49840〈〈advice-remove〉〉:〈〈Like ‘remove-function’ but for the function named SYMBOL.
Contrary to ‘remove-function’, this also works when SYMBOL is a macro
or an autoload and it preserves ‘fboundp’.
Instead of the actual function to remove, FUNCTION can also be the ‘name’
of the piece of advice.

(fn SYMBOL FUNCTION)〉〉enditem49840〈〈advice-member-p〉〉:〈〈Return non-nil if ADVICE has been added to SYMBOL.
Instead of ADVICE being the actual function, it can also be the ‘name’
of the piece of advice.

(fn ADVICE SYMBOL)〉〉enditem49840〈〈advice-mapc〉〉:〈〈Apply FUN to every advice function in SYMBOL.
FUN is called with a two arguments: the function that was added, and the
properties alist that was specified when it was added.

(fn FUN SYMBOL)〉〉enditem49840〈〈store-substring〉〉:〈〈Embed OBJ (string or character) at index IDX of STRING.

(fn STRING IDX OBJ)〉〉enditem49840〈〈clear-string〉〉:〈〈Clear the contents of STRING.
This makes STRING unibyte and may change its length.

(fn STRING)〉〉enditem49840〈〈user-login-name〉〉:〈〈Return the name under which the user logged in, as a string.
This is based on the effective uid, not the real uid.
Also, if the environment variables LOGNAME or USER are set,
that determines the value of this function.

If optional argument UID is an integer or a float, return the login name
of the user with that uid, or nil if there is no such user.

(fn &optional UID)〉〉enditem49840〈〈user-real-login-name〉〉:〈〈Return the name of the user’s real uid, as a string.
This ignores the environment variables LOGNAME and USER, so it differs from
‘user-login-name’ when running under ‘su’.

(fn)〉〉enditem49840〈〈user-full-name〉〉:〈〈Return the full name of the user logged in, as a string.
If the full name corresponding to Emacs’s userid is not known,
return "unknown".

If optional argument UID is an integer or float, return the full name
of the user with that uid, or nil if there is no such user.
If UID is a string, return the full name of the user with that login
name, or nil if there is no such user.

(fn &optional UID)〉〉enditem49840〈〈user-real-uid〉〉:〈〈Return the real uid of Emacs.
Value is an integer or a float, depending on the value.

(fn)〉〉enditem49840〈〈user-uid〉〉:〈〈Return the effective uid of Emacs.
Value is an integer or a float, depending on the value.

(fn)〉〉enditem49840〈〈group-gid〉〉:〈〈Return the effective gid of Emacs.
Value is an integer or a float, depending on the value.

(fn)〉〉enditem49840〈〈group-real-gid〉〉:〈〈Return the real gid of Emacs.
Value is an integer or a float, depending on the value.

(fn)〉〉enditem49840〈〈system-users〉〉:〈〈Return a list of user names currently registered in the system.
If we don’t know how to determine that on this platform, just
return a list with one element, taken from ‘user-real-login-name’.

(fn)〉〉enditem49840〈〈system-groups〉〉:〈〈Return a list of user group names currently registered in the system.
The value may be nil if not supported on this platform.

(fn)〉〉enditem49840〈〈play-sound〉〉:〈〈SOUND is a list of the form ‘(sound KEYWORD VALUE...)’.
The following keywords are recognized:

  :file FILE - read sound data from FILE.  If FILE isn’t an
absolute file name, it is searched in ‘data-directory’.

  :data DATA - read sound data from string DATA.

Exactly one of :file or :data must be present.

  :volume VOL - set volume to VOL.  VOL must an integer in the
range 0..100 or a float in the range 0..1.0.  If not specified,
don’t change the volume setting of the sound device.

  :device DEVICE - play sound on DEVICE.  If not specified,
a system-dependent default device name is used.

Note: :data and :device are currently not supported on Windows.

(fn SOUND)〉〉enditem49840〈〈overlays-at〉〉:〈〈Return a list of the overlays that contain the character at POS.
If SORTED is non-nil, then sort them by decreasing priority.

(fn POS &optional SORTED)〉〉enditem49840〈〈overlays-in〉〉:〈〈Return a list of the overlays that overlap the region BEG ... END.
Overlap means that at least one character is contained within the overlay
and also contained within the specified region.
Empty overlays are included in the result if they are located at BEG,
between BEG and END, or at END provided END denotes the position at the
end of the buffer.

(fn BEG END)〉〉enditem49840〈〈next-overlay-change〉〉:〈〈Return the next position after POS where an overlay starts or ends.
If there are no overlay boundaries from POS to (point-max),
the value is (point-max).

(fn POS)〉〉enditem49840〈〈previous-overlay-change〉〉:〈〈Return the previous position before POS where an overlay starts or ends.
If there are no overlay boundaries from (point-min) to POS,
the value is (point-min).

(fn POS)〉〉enditem49840〈〈next-property-change〉〉:〈〈Return the position of next property change.
Scans characters forward from POSITION in OBJECT till it finds
a change in some text property, then returns the position of the change.
If the optional second argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.
Return nil if LIMIT is nil or omitted, and the property is constant all
the way to the end of OBJECT; if the value is non-nil, it is a position
greater than POSITION, never equal.

If the optional third argument LIMIT is non-nil, don’t search
past position LIMIT; return LIMIT if nothing is found before LIMIT.

(fn POSITION &optional OBJECT LIMIT)〉〉enditem49840〈〈previous-property-change〉〉:〈〈Return the position of previous property change.
Scans characters backwards from POSITION in OBJECT till it finds
a change in some text property, then returns the position of the change.
If the optional second argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.
Return nil if LIMIT is nil or omitted, and the property is constant all
the way to the start of OBJECT; if the value is non-nil, it is a position
less than POSITION, never equal.

If the optional third argument LIMIT is non-nil, don’t search
back past position LIMIT; return LIMIT if nothing is found until LIMIT.

(fn POSITION &optional OBJECT LIMIT)〉〉enditem49840〈〈next-single-property-change〉〉:〈〈Return the position of next property change for a specific property.
Scans characters forward from POSITION till it finds
a change in the PROP property, then returns the position of the change.
If the optional third argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.
The property values are compared with ‘eq’.
Return nil if LIMIT is nil or omitted, and the property is constant all
the way to the end of OBJECT; if the value is non-nil, it is a position
greater than POSITION, never equal.

If the optional fourth argument LIMIT is non-nil, don’t search
past position LIMIT; return LIMIT if nothing is found before LIMIT.

(fn POSITION PROP &optional OBJECT LIMIT)〉〉enditem49840〈〈previous-single-property-change〉〉:〈〈Return the position of previous property change for a specific property.
Scans characters backward from POSITION till it finds
a change in the PROP property, then returns the position of the change.
If the optional third argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.
The property values are compared with ‘eq’.
Return nil if LIMIT is nil or omitted, and the property is constant all
the way to the start of OBJECT; if the value is non-nil, it is a position
less than POSITION, never equal.

If the optional fourth argument LIMIT is non-nil, don’t search
back past position LIMIT; return LIMIT if nothing is found until LIMIT.

(fn POSITION PROP &optional OBJECT LIMIT)〉〉enditem49840〈〈next-char-property-change〉〉:〈〈Return the position of next text property or overlay change.
This scans characters forward in the current buffer from POSITION till
it finds a change in some text property, or the beginning or end of an
overlay, and returns the position of that.
If none is found, and LIMIT is nil or omitted, the function
returns (point-max).

If the optional second argument LIMIT is non-nil, the function doesn’t
search past position LIMIT, and returns LIMIT if nothing is found
before LIMIT.  LIMIT is a no-op if it is greater than (point-max).

(fn POSITION &optional LIMIT)〉〉enditem49840〈〈previous-char-property-change〉〉:〈〈Return the position of previous text property or overlay change.
Scans characters backward in the current buffer from POSITION till it
finds a change in some text property, or the beginning or end of an
overlay, and returns the position of that.
If none is found, and LIMIT is nil or omitted, the function
returns (point-min).

If the optional second argument LIMIT is non-nil, the function doesn’t
search before position LIMIT, and returns LIMIT if nothing is found
before LIMIT.  LIMIT is a no-op if it is less than (point-min).

(fn POSITION &optional LIMIT)〉〉enditem49840〈〈next-single-char-property-change〉〉:〈〈Return the position of next text property or overlay change for a specific property.
Scans characters forward from POSITION till it finds
a change in the PROP property, then returns the position of the change.
If the optional third argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.

In a string, scan runs to the end of the string, unless LIMIT is non-nil.
In a buffer, if LIMIT is nil or omitted, it runs to (point-max), and the
value cannot exceed that.
If the optional fourth argument LIMIT is non-nil, don’t search
past position LIMIT; return LIMIT if nothing is found before LIMIT.

The property values are compared with ‘eq’.
If the property is constant all the way to the end of OBJECT, return the
last valid position in OBJECT.

(fn POSITION PROP &optional OBJECT LIMIT)〉〉enditem49840〈〈previous-single-char-property-change〉〉:〈〈Return the position of previous text property or overlay change for a specific property.
Scans characters backward from POSITION till it finds
a change in the PROP property, then returns the position of the change.
If the optional third argument OBJECT is a buffer (or nil, which means
the current buffer), POSITION is a buffer position (integer or marker).
If OBJECT is a string, POSITION is a 0-based index into it.

In a string, scan runs to the start of the string, unless LIMIT is non-nil.
In a buffer, if LIMIT is nil or omitted, it runs to (point-min), and the
value cannot be less than that.
If the optional fourth argument LIMIT is non-nil, don’t search back past
position LIMIT; return LIMIT if nothing is found before reaching LIMIT.

The property values are compared with ‘eq’.
If the property is constant all the way to the start of OBJECT, return the
first valid position in OBJECT.

(fn POSITION PROP &optional OBJECT LIMIT)〉〉enditem49840〈〈text-property-any〉〉:〈〈Check text from START to END for property PROPERTY equaling VALUE.
If so, return the position of the first character whose property PROPERTY
is ‘eq’ to VALUE.  Otherwise return nil.
If the optional fifth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.

(fn START END PROPERTY VALUE &optional OBJECT)〉〉enditem49840〈〈text-property-not-all〉〉:〈〈Check text from START to END for property PROPERTY not equaling VALUE.
If so, return the position of the first character whose property PROPERTY
is not ‘eq’ to VALUE.  Otherwise, return nil.
If the optional fifth argument OBJECT is a buffer (or nil, which means
the current buffer), START and END are buffer positions (integers or
markers).  If OBJECT is a string, START and END are 0-based indices into it.

(fn START END PROPERTY VALUE &optional OBJECT)〉〉enditem49840〈〈symbol-value〉〉:〈〈Return SYMBOL’s value.  Error if that is void.
Note that if ‘lexical-binding’ is in effect, this returns the
global value outside of any lexical scope.

(fn SYMBOL)〉〉enditem49840〈〈make-abbrev-table〉〉:〈〈Create a new, empty abbrev table object.
PROPS is a list of properties.

(fn &optional PROPS)〉〉enditem49840〈〈abbrev-table-p〉〉:〈〈Return non-nil if OBJECT is an abbrev table.

(fn OBJECT)〉〉enditem49840〈〈clear-abbrev-table〉〉:〈〈Undefine all abbrevs in abbrev table TABLE, leaving it empty.

(fn TABLE)〉〉enditem49840〈〈copy-abbrev-table〉〉:〈〈Make a new abbrev-table with the same abbrevs as TABLE.
Does not copy property lists.

(fn TABLE)〉〉enditem49840〈〈define-abbrev-table〉〉:〈〈Define TABLENAME (a symbol) as an abbrev table name.
Define abbrevs in it according to DEFINITIONS, which is a list of elements
of the form (ABBREVNAME EXPANSION ...) that are passed to ‘define-abbrev’.
PROPS is a property list to apply to the table.
Properties with special meaning:
- ‘:parents’ contains a list of abbrev tables from which this table inherits
  abbreviations.
- ‘:case-fixed’ non-nil means that abbreviations are looked up without
  case-folding, and the expansion is not capitalized/upcased.
- ‘:regexp’ is a regular expression that specifies how to extract the
  name of the abbrev before point.  The submatch 1 is treated
  as the potential name of an abbrev.  If :regexp is nil, the default
  behavior uses ‘backward-word’ and ‘forward-word’ to extract the name
  of the abbrev, which can therefore only be a single word.
- ‘:enable-function’ can be set to a function of no argument which returns
  non-nil if and only if the abbrevs in this table should be used for this
  instance of ‘expand-abbrev’.

(fn TABLENAME DEFINITIONS &optional DOCSTRING &rest PROPS)〉〉enditem49840〈〈insert-abbrev-table-description〉〉:〈〈Insert before point a full description of abbrev table named NAME.
NAME is a symbol whose value is an abbrev table.
If optional 2nd arg READABLE is non-nil, a human-readable description
is inserted.  Otherwise the description is an expression,
a call to ‘define-abbrev-table’, which would
define the abbrev table NAME exactly as it is currently defined.

Abbrevs marked as "system abbrevs" are omitted.

(fn NAME &optional READABLE)〉〉enditem49840〈〈advice-function-member-p〉〉:〈〈Return non-nil if ADVICE is already in FUNCTION-DEF.
Instead of ADVICE being the actual function, it can also be the ‘name’
of the piece of advice.

(fn ADVICE FUNCTION-DEF)〉〉enditem49840〈〈advice-function-mapc〉〉:〈〈Apply F to every advice function in FUNCTION-DEF.
F is called with two arguments: the function that was added, and the
properties alist that was specified when it was added.

(fn F FUNCTION-DEF)〉〉enditem49840〈〈advice-eval-interactive-spec〉〉:〈〈Evaluate the interactive spec SPEC.

(fn SPEC)〉〉enditem49840〈〈display-buffer-same-window〉〉:〈〈Display BUFFER in the selected window.
This fails if ALIST has a non-nil ‘inhibit-same-window’ entry, or
if the selected window is a minibuffer window or is dedicated to
another buffer; in that case, return nil.  Otherwise, return the
selected window.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-reuse-window〉〉:〈〈Return a window that is already displaying BUFFER.
Return nil if no usable window is found.

If ALIST has a non-nil ‘inhibit-same-window’ entry, the selected
window is not eligible for reuse.

If ALIST contains a ‘reusable-frames’ entry, its value determines
which frames to search for a reusable window:
  nil -- the selected frame (actually the last non-minibuffer frame)
  A frame   -- just that frame
  ‘visible’ -- all visible frames
  0   -- all frames on the current terminal
  t   -- all frames.

If ALIST contains no ‘reusable-frames’ entry, search just the
selected frame if ‘display-buffer-reuse-frames’ and
‘pop-up-frames’ are both nil; search all frames on the current
terminal if either of those variables is non-nil.

If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the
event that a window on another frame is chosen, avoid raising
that frame.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-pop-up-frame〉〉:〈〈Display BUFFER in a new frame.
This works by calling ‘pop-up-frame-function’.  If successful,
return the window used; otherwise return nil.

If ALIST has a non-nil ‘inhibit-switch-frame’ entry, avoid
raising the new frame.

If ALIST has a non-nil ‘pop-up-frame-parameters’ entry, the
corresponding value is an alist of frame parameters to give the
new frame.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-use-some-frame〉〉:〈〈Display BUFFER in an existing frame that meets a predicate
(by default any frame other than the current frame).  If
successful, return the window used; otherwise return nil.

If ALIST has a non-nil ‘inhibit-switch-frame’ entry, avoid
raising the frame.

If ALIST has a non-nil ‘frame-predicate’ entry, its value is a
function taking one argument (a frame), returning non-nil if the
frame is a candidate; this function replaces the default
predicate.

If ALIST has a non-nil ‘inhibit-same-window’ entry, avoid using
the currently selected window (only useful with a frame-predicate
that allows the selected frame).

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-pop-up-window〉〉:〈〈Display BUFFER by popping up a new window.
The new window is created on the selected frame, or in
‘last-nonminibuffer-frame’ if no windows can be created there.
If successful, return the new window; otherwise return nil.

If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the
event that the new window is created on another frame, avoid
raising the frame.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-below-selected〉〉:〈〈Try displaying BUFFER in a window below the selected window.
If there is a window below the selected one and that window
already displays BUFFER, use that window.  Otherwise, try to
create a new window below the selected one and show BUFFER there.
If that attempt fails as well and there is a non-dedicated window
below the selected one, use that window.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-in-previous-window〉〉:〈〈Display BUFFER in a window previously showing it.
If ALIST has a non-nil ‘inhibit-same-window’ entry, the selected
window is not eligible for reuse.

If ALIST contains a ‘reusable-frames’ entry, its value determines
which frames to search for a reusable window:
  nil -- the selected frame (actually the last non-minibuffer frame)
  A frame   -- just that frame
  ‘visible’ -- all visible frames
  0   -- all frames on the current terminal
  t   -- all frames.

If ALIST contains no ‘reusable-frames’ entry, search just the
selected frame if ‘display-buffer-reuse-frames’ and
‘pop-up-frames’ are both nil; search all frames on the current
terminal if either of those variables is non-nil.

If ALIST has a ‘previous-window’ entry, the window specified by
that entry will override any other window found by the methods
above, even if that window never showed BUFFER before.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-at-bottom〉〉:〈〈Try displaying BUFFER in a window at the bottom of the selected frame.
This either reuses such a window provided it shows BUFFER
already, splits a window at the bottom of the frame or the
frame’s root window, or reuses some window at the bottom of the
selected frame.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-use-some-window〉〉:〈〈Display BUFFER in an existing window.
Search for a usable window, set that window to the buffer, and
return the window.  If no suitable window is found, return nil.

If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the
event that a window in another frame is chosen, avoid raising
that frame.

(fn BUFFER ALIST)〉〉enditem49840〈〈display-buffer-no-window〉〉:〈〈Display BUFFER in no window.
If ALIST has a non-nil ‘allow-no-window’ entry, then don’t display
a window at all.  This makes possible to override the default action
and avoid displaying the buffer.  It is assumed that when the caller
specifies a non-nil ‘allow-no-window’ then it can handle a nil value
returned from ‘display-buffer’ in this case.

(fn BUFFER ALIST)〉〉enditem49840〈〈isnan〉〉:〈〈Return non nil if argument X is a NaN.

(fn X)〉〉enditem49840〈〈frexp〉〉:〈〈Get significand and exponent of a floating point number.
Breaks the floating point number X into its binary significand SGNFCAND
(a floating point value between 0.5 (included) and 1.0 (excluded))
and an integral exponent EXP for 2, such that:

  X = SGNFCAND * 2^EXP

The function returns the cons cell (SGNFCAND . EXP).
If X is zero, both parts (SGNFCAND and EXP) are zero.

(fn X)〉〉enditem49840〈〈ldexp〉〉:〈〈Return SGNFCAND * 2**EXPONENT, as a floating point number.
EXPONENT must be an integer.

(fn SGNFCAND EXPONENT)〉〉enditem49840〈〈copysign〉〉:〈〈Copy sign of X2 to value of X1, and return the result.
Cause an error if X1 or X2 is not a float.

(fn X1 X2)〉〉enditem49840〈〈logb〉〉:〈〈Returns largest integer <= the base 2 log of the magnitude of ARG.
This is the same as the exponent of a float.

(fn ARG)〉〉enditem49840〈〈file-newer-than-file-p〉〉:〈〈Return t if file FILE1 is newer than file FILE2.
If FILE1 does not exist, the answer is nil;
otherwise, if FILE2 does not exist, the answer is t.

(fn FILE1 FILE2)〉〉enditem49840〈〈file-attributes〉〉:〈〈Return a list of attributes of file FILENAME.
Value is nil if specified file cannot be opened.

ID-FORMAT specifies the preferred format of attributes uid and gid (see
below) - valid values are ‘string’ and ‘integer’.  The latter is the
default, but we plan to change that, so you should specify a non-nil value
for ID-FORMAT if you use the returned uid or gid.

To access the elements returned, the following access functions are
provided: ‘file-attribute-type’, ‘file-attribute-link-number’,
‘file-attribute-user-id’, ‘file-attribute-group-id’,
‘file-attribute-access-time’, ‘file-attribute-modification-time’,
‘file-attribute-status-change-time’, ‘file-attribute-size’,
‘file-attribute-modes’, ‘file-attribute-inode-number’, and
‘file-attribute-device-number’.

Elements of the attribute list are:
 0. t for directory, string (name linked to) for symbolic link, or nil.
 1. Number of links to file.
 2. File uid as a string or a number.  If a string value cannot be
  looked up, a numeric value, either an integer or a float, is returned.
 3. File gid, likewise.
 4. Last access time, as a list of integers (HIGH LOW USEC PSEC) in the
  same style as (current-time).
  (See a note below about access time on FAT-based filesystems.)
 5. Last modification time, likewise.  This is the time of the last
  change to the file’s contents.
 6. Last status change time, likewise.  This is the time of last change
  to the file’s attributes: owner and group, access mode bits, etc.
 7. Size in bytes.
  This is a floating point number if the size is too large for an integer.
 8. File modes, as a string of ten letters or dashes as in ls -l.
 9. An unspecified value, present only for backward compatibility.
10. inode number.  If it is larger than what an Emacs integer can hold,
  this is of the form (HIGH . LOW): first the high bits, then the low 16 bits.
  If even HIGH is too large for an Emacs integer, this is instead of the form
  (HIGH MIDDLE . LOW): first the high bits, then the middle 24 bits,
  and finally the low 16 bits.
11. Filesystem device number.  If it is larger than what the Emacs
  integer can hold, this is a cons cell, similar to the inode number.

On most filesystems, the combination of the inode and the device
number uniquely identifies the file.

On MS-Windows, performance depends on ‘w32-get-true-file-attributes’,
which see.

On some FAT-based filesystems, only the date of last access is recorded,
so last access time will always be midnight of that day.

(fn FILENAME &optional ID-FORMAT)〉〉enditem49840〈〈file-nlinks〉〉:〈〈Return number of names file FILENAME has.

(fn FILENAME)〉〉enditem49840〈〈barf-if-buffer-read-only〉〉:〈〈Signal a ‘buffer-read-only’ error if the current buffer is read-only.
If the text under POSITION (which defaults to point) has the
‘inhibit-read-only’ text property set, the error will not be raised.

(fn &optional POSITION)〉〉enditem49840〈〈file-acl〉〉:〈〈Return ACL entries of file named FILENAME.
The entries are returned in a format suitable for use in ‘set-file-acl’
but is otherwise undocumented and subject to change.
Return nil if file does not exist or is not accessible, or if Emacs
was unable to determine the ACL entries.

(fn FILENAME)〉〉enditem49840〈〈file-selinux-context〉〉:〈〈Return SELinux context of file named FILENAME.
The return value is a list (USER ROLE TYPE RANGE), where the list
elements are strings naming the user, role, type, and range of the
file’s SELinux security context.

Return (nil nil nil nil) if the file is nonexistent or inaccessible,
or if SELinux is disabled, or if Emacs lacks SELinux support.

(fn FILENAME)〉〉enditem49840〈〈file-extended-attributes〉〉:〈〈Return an alist of extended attributes of file FILENAME.

Extended attributes are platform-specific metadata about the file,
such as SELinux context, list of ACL entries, etc.

(fn FILENAME)〉〉enditem49840〈〈zlib-available-p〉〉:〈〈Return t if zlib decompression is available in this instance of Emacs.

(fn)〉〉enditem49840〈〈zlib-decompress-region〉〉:〈〈Decompress a gzip- or zlib-compressed region.
Replace the text in the region by the decompressed data.
On failure, return nil and leave the data in place.
This function can be called only in unibyte buffers.

(fn START END)〉〉enditem49840〈〈window-preserve-size〉〉:〈〈Preserve height of window WINDOW.
WINDOW must be a live window and defaults to the selected one.
Optional argument HORIZONTAL non-nil means preserve the width of
WINDOW.

PRESERVE t means to preserve the current height/width of WINDOW’s
body in frame and window resizing operations whenever possible.
The height/width of WINDOW will change only if Emacs has no other
choice.  Resizing a window whose height/width is preserved never
throws an error.

PRESERVE nil means to stop preserving the height/width of WINDOW,
lifting the respective restraint induced by a previous call of
‘window-preserve-size’ for WINDOW.  Calling ‘enlarge-window’,
‘shrink-window’, ‘split-window’ or ‘fit-window-to-buffer’ with
WINDOW as argument also removes the respective restraint.

Other values of PRESERVE are reserved for future use.

(fn &optional WINDOW HORIZONTAL PRESERVE)〉〉enditem49840〈〈window-preserved-size〉〉:〈〈Return preserved height of window WINDOW.
WINDOW must be a live window and defaults to the selected one.
Optional argument HORIZONTAL non-nil means to return preserved
width of WINDOW.

(fn &optional WINDOW HORIZONTAL)〉〉enditem49840〈〈load〉〉:〈〈Execute a file of Lisp code named FILE.
First try FILE with ‘.elc’ appended, then try with ‘.el’, then try
with a system-dependent suffix of dynamic modules (see ‘load-suffixes’),
then try FILE unmodified (the exact suffixes in the exact order are
determined by ‘load-suffixes’).  Environment variable references in
FILE are replaced with their values by calling ‘substitute-in-file-name’.
This function searches the directories in ‘load-path’.

If optional second arg NOERROR is non-nil,
report no error if FILE doesn’t exist.
Print messages at start and end of loading unless
optional third arg NOMESSAGE is non-nil (but ‘force-load-messages’
overrides that).
If optional fourth arg NOSUFFIX is non-nil, don’t try adding
suffixes to the specified name FILE.
If optional fifth arg MUST-SUFFIX is non-nil, insist on
the suffix ‘.elc’ or ‘.el’ or the module suffix; don’t accept just
FILE unless it ends in one of those suffixes or includes a directory name.

If NOSUFFIX is nil, then if a file could not be found, try looking for
a different representation of the file by adding non-empty suffixes to
its name, before trying another file.  Emacs uses this feature to find
compressed versions of files when Auto Compression mode is enabled.
If NOSUFFIX is non-nil, disable this feature.

The suffixes that this function tries out, when NOSUFFIX is nil, are
given by the return value of ‘get-load-suffixes’ and the values listed
in ‘load-file-rep-suffixes’.  If MUST-SUFFIX is non-nil, only the
return value of ‘get-load-suffixes’ is used, i.e. the file name is
required to have a non-empty suffix.

When searching suffixes, this function normally stops at the first
one that exists.  If the option ‘load-prefer-newer’ is non-nil,
however, it tries all suffixes, and uses whichever file is the newest.

Loading a file records its definitions, and its ‘provide’ and
‘require’ calls, in an element of ‘load-history’ whose
car is the file name loaded.  See ‘load-history’.

While the file is in the process of being loaded, the variable
‘load-in-progress’ is non-nil and the variable ‘load-file-name’
is bound to the file’s name.

Return t if the file exists and loads successfully.

(fn FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)〉〉enditem49840〈〈arrayp〉〉:〈〈Return t if OBJECT is an array (string or vector).

(fn OBJECT)〉〉enditem49840〈〈aref〉〉:〈〈Return the element of ARRAY at index IDX.
ARRAY may be a vector, a string, a char-table, a bool-vector, a record,
or a byte-code object.  IDX starts at 0.

(fn ARRAY IDX)〉〉enditem49840〈〈aset〉〉:〈〈Store into the element of ARRAY at index IDX the value NEWELT.
Return NEWELT.  ARRAY may be a vector, a string, a char-table or a
bool-vector.  IDX starts at 0.

(fn ARRAY IDX NEWELT)〉〉enditem49840〈〈fillarray〉〉:〈〈Store each element of ARRAY with ITEM.
ARRAY is a vector, string, char-table, or bool-vector.

(fn ARRAY ITEM)〉〉enditem49840〈〈delete-process〉〉:〈〈Delete PROCESS: kill it and forget about it immediately.
PROCESS may be a process, a buffer, the name of a process or buffer, or
nil, indicating the current buffer’s process.

(fn PROCESS)〉〉enditem49840〈〈image-mask-p〉〉:〈〈Return t if image SPEC has a mask bitmap.
FRAME is the frame on which the image will be displayed.  FRAME nil
or omitted means use the selected frame.

(fn SPEC &optional FRAME)〉〉enditem49840〈〈interrupt-process〉〉:〈〈Interrupt process PROCESS.
PROCESS may be a process, a buffer, or the name of a process or buffer.
No arg or nil means current buffer’s process.
Second arg CURRENT-GROUP non-nil means send signal to
the current process-group of the process’s controlling terminal
rather than to the process’s own process group.
If the process is a shell, this means interrupt current subjob
rather than the shell.

If CURRENT-GROUP is ‘lambda’, and if the shell owns the terminal,
don’t send the signal.

This function calls the functions of ‘interrupt-process-functions’ in
the order of the list, until one of them returns non-‘nil’.

(fn &optional PROCESS CURRENT-GROUP)〉〉enditem49840〈〈kill-process〉〉:〈〈Kill process PROCESS.  May be process or name of one.
See function ‘interrupt-process’ for more details on usage.

(fn &optional PROCESS CURRENT-GROUP)〉〉enditem49840〈〈quit-process〉〉:〈〈Send QUIT signal to process PROCESS.  May be process or name of one.
See function ‘interrupt-process’ for more details on usage.

(fn &optional PROCESS CURRENT-GROUP)〉〉enditem49840〈〈stop-process〉〉:〈〈Stop process PROCESS.  May be process or name of one.
See function ‘interrupt-process’ for more details on usage.
If PROCESS is a network or serial or pipe connection, inhibit handling
of incoming traffic.

(fn &optional PROCESS CURRENT-GROUP)〉〉enditem49840〈〈continue-process〉〉:〈〈Continue process PROCESS.  May be process or name of one.
See function ‘interrupt-process’ for more details on usage.
If PROCESS is a network or serial process, resume handling of incoming
traffic.

(fn &optional PROCESS CURRENT-GROUP)〉〉enditem49840〈〈minibuffer-depth〉〉:〈〈Return current depth of activations of minibuffer, a nonnegative integer.

(fn)〉〉enditem49840〈〈gethash〉〉:〈〈Look up KEY in TABLE and return its associated value.
If KEY is not found, return DFLT which defaults to nil.

(fn KEY TABLE &optional DFLT)〉〉enditem49840〈〈puthash〉〉:〈〈Associate KEY with VALUE in hash table TABLE.
If KEY is already present in table, replace its current value with
VALUE.  In any case, return VALUE.

(fn KEY VALUE TABLE)〉〉enditem49840〈〈remhash〉〉:〈〈Remove KEY from TABLE.

(fn KEY TABLE)〉〉enditem49840〈〈clrhash〉〉:〈〈Clear hash table TABLE and return it.

(fn TABLE)〉〉enditem49840〈〈maphash〉〉:〈〈Call FUNCTION for all entries in hash table TABLE.
FUNCTION is called with two arguments, KEY and VALUE.
‘maphash’ always returns nil.

(fn FUNCTION TABLE)〉〉enditem49840〈〈read-quoted-char〉〉:〈〈Like ‘read-char’, but do not allow quitting.
Also, if the first character read is an octal digit,
we read any number of octal digits and return the
specified character code.  Any nondigit terminates the sequence.
If the terminator is RET, it is discarded;
any other terminator is used itself as input.

The optional argument PROMPT specifies a string to use to prompt the user.
The variable ‘read-quoted-char-radix’ controls which radix to use
for numeric input.

(fn &optional PROMPT)〉〉enditem49840〈〈eql〉〉:〈〈Return t if the two args are the same Lisp object.
Floating-point numbers of equal value are ‘eql’, but they may not be ‘eq’.

(fn OBJ1 OBJ2)〉〉enditem49840〈〈max〉〉:〈〈Return largest of all the arguments (which must be numbers or markers).
The value is always a number; markers are converted to numbers.

(fn NUMBER-OR-MARKER &rest NUMBERS-OR-MARKERS)〉〉enditem49840〈〈min〉〉:〈〈Return smallest of all the arguments (which must be numbers or markers).
The value is always a number; markers are converted to numbers.

(fn NUMBER-OR-MARKER &rest NUMBERS-OR-MARKERS)〉〉enditem49840〈〈abs〉〉:〈〈Return the absolute value of ARG.

(fn ARG)〉〉enditem49840〈〈framep〉〉:〈〈Return non-nil if OBJECT is a frame.
Value is:
  t for a termcap frame (a character-only terminal),
 ‘x’ for an Emacs frame that is really an X window,
 ‘w32’ for an Emacs frame that is a window on MS-Windows display,
 ‘ns’ for an Emacs frame on a GNUstep or Macintosh Cocoa display,
 ‘pc’ for a direct-write MS-DOS frame.
See also ‘frame-live-p’.

(fn OBJECT)〉〉enditem49840〈〈frame-terminal〉〉:〈〈Return the terminal that FRAME is displayed on.
If FRAME is nil, the selected frame is used.

The terminal device is represented by its integer identifier.

(fn &optional FRAME)〉〉enditem49840〈〈terminal-live-p〉〉:〈〈Return non-nil if OBJECT is a terminal which has not been deleted.
Value is nil if OBJECT is not a live display terminal.
If object is a live display terminal, the return value indicates what
sort of output terminal it uses.  See the documentation of ‘framep’ for
possible return values.

(fn OBJECT)〉〉enditem49840〈〈image-type-available-p〉〉:〈〈Return non-nil if image type TYPE is available.
Image types are symbols like ‘xbm’ or ‘jpeg’.

(fn TYPE)〉〉enditem49840〈〈mapcar〉〉:〈〈Apply FUNCTION to each element of SEQUENCE, and make a list of the results.
The result is a list just as long as SEQUENCE.
SEQUENCE may be a list, a vector, a bool-vector, or a string.

(fn FUNCTION SEQUENCE)〉〉enditem49840〈〈mapc〉〉:〈〈Apply FUNCTION to each element of SEQUENCE for side effects only.
Unlike ‘mapcar’, don’t accumulate the results.  Return SEQUENCE.
SEQUENCE may be a list, a vector, a bool-vector, or a string.

(fn FUNCTION SEQUENCE)〉〉enditem49840〈〈mapconcat〉〉:〈〈Apply FUNCTION to each element of SEQUENCE, and concat the results as strings.
In between each pair of results, stick in SEPARATOR.  Thus, " " as
SEPARATOR results in spaces between the values returned by FUNCTION.
SEQUENCE may be a list, a vector, a bool-vector, or a string.

(fn FUNCTION SEQUENCE SEPARATOR)〉〉enditem49840〈〈purecopy〉〉:〈〈Make a copy of object OBJ in pure storage.
Recursively copies contents of vectors and cons cells.
Does not copy symbols.  Copies strings without text properties.

(fn OBJ)〉〉enditem49840〈〈current-bidi-paragraph-direction〉〉:〈〈Return paragraph direction at point in BUFFER.
Value is either ‘left-to-right’ or ‘right-to-left’.
If BUFFER is omitted or nil, it defaults to the current buffer.

Paragraph direction determines how the text in the paragraph is displayed.
In left-to-right paragraphs, text begins at the left margin of the window
and the reading direction is generally left to right.  In right-to-left
paragraphs, text begins at the right margin and is read from right to left.

See also ‘bidi-paragraph-direction’.

(fn &optional BUFFER)〉〉enditem49840〈〈move-point-visually〉〉:〈〈Move point in the visual order in the specified DIRECTION.
DIRECTION can be 1, meaning move to the right, or -1, which moves to the
left.

Value is the new character position of point.

(fn DIRECTION)〉〉enditem49840〈〈bidi-string-mark-left-to-right〉〉:〈〈Return a string that can be safely inserted in left-to-right text.

Normally, inserting a string with right-to-left (RTL) script into
a buffer may cause some subsequent text to be displayed as part
of the RTL segment (usually this affects punctuation characters).
This function returns a string which displays as STR but forces
subsequent text to be displayed as left-to-right.

If STR contains any RTL character, this function returns a string
consisting of STR followed by an invisible left-to-right mark
(LRM) character.  Otherwise, it returns STR.

(fn STR)〉〉enditem49840〈〈bidi-find-overridden-directionality〉〉:〈〈Return position between FROM and TO where directionality was overridden.

This function returns the first character position in the specified
region of OBJECT where there is a character whose ‘bidi-class’ property
is ‘L’, but which was forced to display as ‘R’ by a directional
override, and likewise with characters whose ‘bidi-class’ is ‘R’
or ‘AL’ that were forced to display as ‘L’.

If no such character is found, the function returns nil.

OBJECT is a Lisp string or buffer to search for overridden
directionality, and defaults to the current buffer if nil or omitted.
OBJECT can also be a window, in which case the function will search
the buffer displayed in that window.  Passing the window instead of
a buffer is preferable when the buffer is displayed in some window,
because this function will then be able to correctly account for
window-specific overlays, which can affect the results.

Strong directional characters ‘L’, ‘R’, and ‘AL’ can have their
intrinsic directionality overridden by directional override
control characters RLO (u+202e) and LRO (u+202d).  See the
function ‘get-char-code-property’ for a way to inquire about
the ‘bidi-class’ property of a character.

(fn FROM TO &optional OBJECT)〉〉enditem49840〈〈buffer-substring-with-bidi-context〉〉:〈〈Return portion of current buffer between START and END with bidi context.

This function works similar to ‘buffer-substring’, but it prepends and
appends to the text bidi directional control characters necessary to
preserve the visual appearance of the text if it is inserted at another
place.  This is useful when the buffer substring includes bidirectional
text and control characters that cause non-trivial reordering on display.
If copied verbatim, such text can have a very different visual appearance,
and can also change the visual appearance of the surrounding text at the
destination of the copy.

Optional argument NO-PROPERTIES, if non-nil, means copy the text without
the text properties.

(fn START END &optional NO-PROPERTIES)〉〉enditem49840〈〈special-form-p〉〉:〈〈Non-nil if and only if OBJECT is a special form.

(fn OBJECT)〉〉enditem49840〈〈type-of〉〉:〈〈Return a symbol representing the type of OBJECT.
The symbol returned names the object’s basic type;
for example, (type-of 1) returns ‘integer’.

(fn OBJECT)〉〉enditem49840〈〈syntax-ppss-toplevel-pos〉〉:〈〈Get the latest syntactically outermost position found in a syntactic scan.
PPSS is a scan state, as returned by ‘parse-partial-sexp’ or ‘syntax-ppss’.
An "outermost position" means one that it is outside of any syntactic entity:
outside of any parentheses, comments, or strings encountered in the scan.
If no such position is recorded in PPSS (because the end of the scan was
itself at the outermost level), return nil.

(fn PPSS)〉〉enditem49840〈〈shell-quote-argument〉〉:〈〈Quote ARGUMENT for passing as argument to an inferior shell.

This function is designed to work with the syntax of your system’s
standard shell, and might produce incorrect results with unusual shells.
See Info node ‘(elisp)Security Considerations’.

(fn ARGUMENT)〉〉enditem49840〈〈split-string-and-unquote〉〉:〈〈Split the STRING into a list of strings.
It understands Emacs Lisp quoting within STRING, such that
  (split-string-and-unquote (combine-and-quote-strings strs)) == strs
The SEPARATOR regexp defaults to "\s-+".

(fn STRING &optional SEPARATOR)〉〉enditem49840〈〈combine-and-quote-strings〉〉:〈〈Concatenate the STRINGS, adding the SEPARATOR (default " ").
This tries to quote the strings to avoid ambiguity such that
  (split-string-and-unquote (combine-and-quote-strings strs)) == strs
Only some SEPARATORs will work properly.

Note that this is not intended to protect STRINGS from
interpretation by shells, use ‘shell-quote-argument’ for that.

(fn STRINGS &optional SEPARATOR)〉〉enditem49840〈〈posix-looking-at〉〉:〈〈Return t if text after point matches regular expression REGEXP.
Find the longest match, in accord with Posix regular expression rules.
This function modifies the match data that ‘match-beginning’,
‘match-end’ and ‘match-data’ access; save and restore the match
data if you want to preserve them.

(fn REGEXP)〉〉enditem49840〈〈posix-string-match〉〉:〈〈Return index of start of first match for REGEXP in STRING, or nil.
Find the longest match, in accord with Posix regular expression rules.
Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.
If third arg START is non-nil, start search at that index in STRING.
For index of first char beyond the match, do (match-end 0).
‘match-end’ and ‘match-beginning’ also give indices of substrings
matched by parenthesis constructs in the pattern.

(fn REGEXP STRING &optional START)〉〉enditem49840〈〈define-hash-table-test〉〉:〈〈Define a new hash table test with name NAME, a symbol.

In hash tables created with NAME specified as test, use TEST to
compare keys, and HASH for computing hash codes of keys.

TEST must be a function taking two arguments and returning non-nil if
both arguments are the same.  HASH must be a function taking one
argument and returning an object that is the hash code of the argument.
It should be the case that if (eq (funcall HASH x1) (funcall HASH x2))
returns nil, then (funcall TEST x1 x2) also returns nil.

(fn NAME TEST HASH)〉〉enditem49840〈〈sxhash〉〉:〈〈Return an integer hash code for OBJ suitable for ‘equal’.
If (equal A B), then (= (sxhash-equal A) (sxhash-equal B)).

(fn OBJ)〉〉enditem49840〈〈window-system〉〉:〈〈The name of the window system that FRAME is displaying through.
The value is a symbol:
 nil for a termcap frame (a character-only terminal),
 ‘x’ for an Emacs frame that is really an X window,
 ‘w32’ for an Emacs frame that is a window on MS-Windows display,
 ‘ns’ for an Emacs frame on a GNUstep or Macintosh Cocoa display,
 ‘pc’ for a direct-write MS-DOS frame.

FRAME defaults to the currently selected frame.

Use of this function as a predicate is deprecated.  Instead,
use ‘display-graphic-p’ or any of the other ‘display-*-p’
predicates which report frame’s specific UI-related capabilities.

(fn &optional FRAME)〉〉enditem49840〈〈setcar〉〉:〈〈Set the car of CELL to be NEWCAR.  Returns NEWCAR.

(fn CELL NEWCAR)〉〉enditem49840〈〈read-buffer〉〉:〈〈Read the name of a buffer and return as a string.
Prompt with PROMPT.
Optional second arg DEF is value to return if user enters an empty line.
 If DEF is a list of default values, return its first element.
Optional third arg REQUIRE-MATCH determines whether non-existing
 buffer names are allowed.  It has the same meaning as the
 REQUIRE-MATCH argument of ‘completing-read’.
The argument PROMPT should be a string ending with a colon and a space.
If ‘read-buffer-completion-ignore-case’ is non-nil, completion ignores
case while reading the buffer name.
If ‘read-buffer-function’ is non-nil, this works by calling it as a
function, instead of the usual behavior.
Optional arg PREDICATE if non-nil is a function limiting the buffers that can
be considered.

(fn PROMPT &optional DEF REQUIRE-MATCH PREDICATE)〉〉enditem49840〈〈read-command〉〉:〈〈Read the name of a command and return as a symbol.
Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element
if it is a list.

(fn PROMPT &optional DEFAULT-VALUE)〉〉enditem49840〈〈read-variable〉〉:〈〈Read the name of a user option and return it as a symbol.
Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element
if it is a list.
A user option, or customizable variable, is one for which
‘custom-variable-p’ returns non-nil.

(fn PROMPT &optional DEFAULT-VALUE)〉〉enditem49840〈〈force-mode-line-update〉〉:〈〈Force redisplay of the current buffer’s mode line and header line.
With optional non-nil ALL, force redisplay of all mode lines and
header lines.  This function also forces recomputation of the
menu bar menus and the frame title.

(fn &optional ALL)〉〉enditem49840〈〈file-locked-p〉〉:〈〈Return a value indicating whether FILENAME is locked.
The value is nil if the FILENAME is not locked,
t if it is locked by you, else a string saying which user has locked it.

(fn FILENAME)〉〉enditem49840〈〈lock-buffer〉〉:〈〈Lock FILE, if current buffer is modified.
FILE defaults to current buffer’s visited file,
or else nothing is done if current buffer isn’t visiting a file.

If the option ‘create-lockfiles’ is nil, this does nothing.

(fn &optional FILE)〉〉enditem49840〈〈unlock-buffer〉〉:〈〈Unlock the file visited in the current buffer.
If the buffer is not modified, this does nothing because the file
should not be locked in that case.

(fn)〉〉enditem49840〈〈ask-user-about-lock〉〉:〈〈Ask user what to do when he wants to edit FILE but it is locked by OPPONENT.
This function has a choice of three things to do:
  do (signal 'file-locked (list FILE OPPONENT))
    to refrain from editing the file
  return t (grab the lock on the file)
  return nil (edit the file even though it is locked).
You can redefine this function to choose among those three alternatives
in any way you like.

(fn FILE OPPONENT)〉〉enditem49840〈〈make-display-table〉〉:〈〈Return a new, empty display table.〉〉enditem49840〈〈display-table-slot〉〉:〈〈Return the value of the extra slot in DISPLAY-TABLE named SLOT.
SLOT may be a number from 0 to 5 inclusive, or a slot name (symbol).
Valid symbols are ‘truncation’, ‘wrap’, ‘escape’, ‘control’,
‘selective-display’, and ‘vertical-border’.〉〉enditem49840〈〈set-display-table-slot〉〉:〈〈Set the value of the extra slot in DISPLAY-TABLE named SLOT to VALUE.
SLOT may be a number from 0 to 5 inclusive, or a name (symbol).
Valid symbols are ‘truncation’, ‘wrap’, ‘escape’, ‘control’,
‘selective-display’, and ‘vertical-border’.〉〉enditem49840〈〈describe-display-table〉〉:〈〈Describe the display table DT in a help buffer.〉〉enditem49840〈〈get〉〉:〈〈Return the value of SYMBOL’s PROPNAME property.
This is the last value stored with ‘(put SYMBOL PROPNAME VALUE)’.

(fn SYMBOL PROPNAME)〉〉enditem49840〈〈put〉〉:〈〈Store SYMBOL’s PROPNAME property with value VALUE.
It can be retrieved with ‘(get SYMBOL PROPNAME)’.

(fn SYMBOL PROPNAME VALUE)〉〉enditem49840〈〈symbol-plist〉〉:〈〈Return SYMBOL’s property list.

(fn SYMBOL)〉〉enditem49840〈〈setplist〉〉:〈〈Set SYMBOL’s property list to NEWPLIST, and return NEWPLIST.

(fn SYMBOL NEWPLIST)〉〉enditem49840〈〈function-get〉〉:〈〈Return the value of property PROP of function F.
If AUTOLOAD is non-nil and F is autoloaded, try to autoload it
in the hope that it will set PROP.  If AUTOLOAD is ‘macro’, only do it
if it’s an autoloaded macro.

(fn F PROP &optional AUTOLOAD)〉〉enditem49840〈〈function-put〉〉:〈〈Set FUNCTION’s property PROP to VALUE.
The namespace for PROP is shared with symbols.
So far, FUNCTION can only be a symbol, not a lambda expression.

(fn FUNCTION PROP VALUE)〉〉enditem49840〈〈process-buffer〉〉:〈〈Return the buffer PROCESS is associated with.
The default process filter inserts output from PROCESS into this buffer.

(fn PROCESS)〉〉enditem49840〈〈process-mark〉〉:〈〈Return the marker for the end of the last output from PROCESS.

(fn PROCESS)〉〉enditem49840〈〈set-process-buffer〉〉:〈〈Set buffer associated with PROCESS to BUFFER (a buffer, or nil).
Return BUFFER.

(fn PROCESS BUFFER)〉〉enditem49840〈〈get-buffer-process〉〉:〈〈Return the (or a) live process associated with BUFFER.
BUFFER may be a buffer or the name of one.
Return nil if all processes associated with BUFFER have been
deleted or killed.

(fn BUFFER)〉〉enditem49840〈〈set-process-window-size〉〉:〈〈Tell PROCESS that it has logical window size WIDTH by HEIGHT.
Value is t if PROCESS was successfully told about the window size,
nil otherwise.

(fn PROCESS HEIGHT WIDTH)〉〉enditem49840〈〈current-indentation〉〉:〈〈Return the indentation of the current line.
This is the horizontal position of the character
following any initial whitespace.

(fn)〉〉enditem49840〈〈read-input-method-name〉〉:〈〈Read a name of input method from a minibuffer prompting with PROMPT.
If DEFAULT is non-nil, use that as the default,
and substitute it into PROMPT at the first ‘%s’.
If INHIBIT-NULL is non-nil, null input signals an error.

The return value is a string.

(fn PROMPT &optional DEFAULT INHIBIT-NULL)〉〉enditem49840〈〈make-obsolete〉〉:〈〈Make the byte-compiler warn that function OBSOLETE-NAME is obsolete.
OBSOLETE-NAME should be a function name or macro name (a symbol).

The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the ‘use instead’ message
(it should end with a period, and not start with a capital).
WHEN should be a string indicating when the function
was first made obsolete, for example a date or a release number.

(fn OBSOLETE-NAME CURRENT-NAME &optional WHEN)〉〉enditem49840〈〈set-advertised-calling-convention〉〉:〈〈Set the advertised SIGNATURE of FUNCTION.
This will allow the byte-compiler to warn the programmer when she uses
an obsolete calling convention.  WHEN specifies since when the calling
convention was modified.

(fn FUNCTION SIGNATURE WHEN)〉〉enditem49840〈〈suspend-tty〉〉:〈〈Suspend the terminal device TTY.

The device is restored to its default state, and Emacs ceases all
access to the tty device.  Frames that use the device are not deleted,
but input is not read from them and if they change, their display is
not updated.

TTY may be a terminal object, a frame, or nil for the terminal device
of the currently selected frame.

This function runs ‘suspend-tty-functions’ after suspending the
device.  The functions are run with one arg, the id of the suspended
terminal device.

‘suspend-tty’ does nothing if it is called on a device that is already
suspended.

A suspended tty may be resumed by calling ‘resume-tty’ on it.

(fn &optional TTY)〉〉enditem49840〈〈resume-tty〉〉:〈〈Resume the previously suspended terminal device TTY.
The terminal is opened and reinitialized.  Frames that are on the
suspended terminal are revived.

It is an error to resume a terminal while another terminal is active
on the same device.

This function runs ‘resume-tty-functions’ after resuming the terminal.
The functions are run with one arg, the id of the resumed terminal
device.

‘resume-tty’ does nothing if it is called on a device that is not
suspended.

TTY may be a terminal object, a frame, or nil (meaning the selected
frame’s terminal).

(fn &optional TTY)〉〉enditem49840〈〈controlling-tty-p〉〉:〈〈Return non-nil if TERMINAL is the controlling tty of the Emacs process.

TERMINAL can be a terminal object, a frame, or nil (meaning the
selected frame’s terminal).  This function always returns nil if
TERMINAL is not on a tty device.

(fn &optional TERMINAL)〉〉enditem49840〈〈overlayp〉〉:〈〈Return t if OBJECT is an overlay.

(fn OBJECT)〉〉enditem49840〈〈make-overlay〉〉:〈〈Create a new overlay with range BEG to END in BUFFER and return it.
If omitted, BUFFER defaults to the current buffer.
BEG and END may be integers or markers.
The fourth arg FRONT-ADVANCE, if non-nil, makes the marker
for the front of the overlay advance when text is inserted there
(which means the text *is not* included in the overlay).
The fifth arg REAR-ADVANCE, if non-nil, makes the marker
for the rear of the overlay advance when text is inserted there
(which means the text *is* included in the overlay).

(fn BEG END &optional BUFFER FRONT-ADVANCE REAR-ADVANCE)〉〉enditem49840〈〈overlay-start〉〉:〈〈Return the position at which OVERLAY starts.

(fn OVERLAY)〉〉enditem49840〈〈overlay-end〉〉:〈〈Return the position at which OVERLAY ends.

(fn OVERLAY)〉〉enditem49840〈〈overlay-buffer〉〉:〈〈Return the buffer OVERLAY belongs to.
Return nil if OVERLAY has been deleted.

(fn OVERLAY)〉〉enditem49840〈〈delete-overlay〉〉:〈〈Delete the overlay OVERLAY from its buffer.

(fn OVERLAY)〉〉enditem49840〈〈move-overlay〉〉:〈〈Set the endpoints of OVERLAY to BEG and END in BUFFER.
If BUFFER is omitted, leave OVERLAY in the same buffer it inhabits now.
If BUFFER is omitted, and OVERLAY is in no buffer, put it in the current
buffer.

(fn OVERLAY BEG END &optional BUFFER)〉〉enditem49840〈〈remove-overlays〉〉:〈〈Clear BEG and END of overlays whose property NAME has value VAL.
Overlays might be moved and/or split.
BEG and END default respectively to the beginning and end of buffer.

(fn &optional BEG END NAME VAL)〉〉enditem49840〈〈copy-overlay〉〉:〈〈Return a copy of overlay O.

(fn O)〉〉enditem49840〈〈overlay-recenter〉〉:〈〈Recenter the overlays of the current buffer around position POS.
That makes overlay lookup faster for positions near POS (but perhaps slower
for positions far away from POS).

(fn POS)〉〉enditem49840〈〈nconc〉〉:〈〈Concatenate any number of lists by altering them.
Only the last argument is not altered, and need not be a list.

(fn &rest LISTS)〉〉enditem49840〈〈expand-file-name〉〉:〈〈Convert filename NAME to absolute, and canonicalize it.
Second arg DEFAULT-DIRECTORY is directory to start with if NAME is relative
(does not start with slash or tilde); both the directory name and
a directory’s file name are accepted.  If DEFAULT-DIRECTORY is nil or
missing, the current buffer’s value of ‘default-directory’ is used.
NAME should be a string that is a valid file name for the underlying
filesystem.
File name components that are ‘.’ are removed, and
so are file name components followed by ‘..’, along with the ‘..’ itself;
note that these simplifications are done without checking the resulting
file names in the file system.
Multiple consecutive slashes are collapsed into a single slash,
except at the beginning of the file name when they are significant (e.g.,
UNC file names on MS-Windows.)
An initial ‘~/’ expands to your home directory.
An initial ‘~USER/’ expands to USER’s home directory.
See also the function ‘substitute-in-file-name’.

For technical reasons, this function can return correct but
non-intuitive results for the root directory; for instance,
(expand-file-name ".." "/") returns "/..".  For this reason, use
(directory-file-name (file-name-directory dirname)) to traverse a
filesystem tree, not (expand-file-name ".." dirname).  Note: make
sure DIRNAME in this example doesn’t end in a slash, unless it’s
the root directory.

(fn NAME &optional DEFAULT-DIRECTORY)〉〉enditem49840〈〈substitute-in-file-name〉〉:〈〈Substitute environment variables referred to in FILENAME.
‘$FOO’ where FOO is an environment variable name means to substitute
the value of that variable.  The variable name should be terminated
with a character not a letter, digit or underscore; otherwise, enclose
the entire variable name in braces.

If ‘/~’ appears, all of FILENAME through that ‘/’ is discarded.
If ‘//’ appears, everything up to and including the first of
those ‘/’ is discarded.

(fn FILENAME)〉〉enditem49840〈〈prefix-numeric-value〉〉:〈〈Return numeric meaning of raw prefix argument RAW.
A raw prefix argument is what you get from ‘(interactive "P")’.
Its numeric meaning is what you would get from ‘(interactive "p")’.

(fn RAW)〉〉enditem49840〈〈lsh〉〉:〈〈Return VALUE with its bits shifted left by COUNT.
If COUNT is negative, shifting is actually to the right.
In this case, zeros are shifted in on the left.

(fn VALUE COUNT)〉〉enditem49840〈〈ash〉〉:〈〈Return VALUE with its bits shifted left by COUNT.
If COUNT is negative, shifting is actually to the right.
In this case, the sign bit is duplicated.

(fn VALUE COUNT)〉〉enditem49840〈〈logand〉〉:〈〈Return bitwise-and of all the arguments.
Arguments may be integers, or markers converted to integers.

(fn &rest INTS-OR-MARKERS)〉〉enditem49840〈〈logior〉〉:〈〈Return bitwise-or of all the arguments.
Arguments may be integers, or markers converted to integers.

(fn &rest INTS-OR-MARKERS)〉〉enditem49840〈〈logxor〉〉:〈〈Return bitwise-exclusive-or of all the arguments.
Arguments may be integers, or markers converted to integers.

(fn &rest INTS-OR-MARKERS)〉〉enditem49840〈〈lognot〉〉:〈〈Return the bitwise complement of NUMBER.  NUMBER must be an integer.

(fn NUMBER)〉〉enditem49840〈〈display-warning〉〉:〈〈Display a warning message, MESSAGE.
TYPE is the warning type: either a custom group name (a symbol),
or a list of symbols whose first element is a custom group name.
(The rest of the symbols represent subcategories, for warning purposes
only, and you can use whatever symbols you like.)

LEVEL should be either :debug, :warning, :error, or :emergency
(but see ‘warning-minimum-level’ and ‘warning-minimum-log-level’).
Default is :warning.

:emergency -- a problem that will seriously impair Emacs operation soon
	      if you do not attend to it promptly.
:error     -- data or circumstances that are inherently wrong.
:warning   -- data or circumstances that are not inherently wrong,
	      but raise suspicion of a possible problem.
:debug     -- info for debugging only.

BUFFER-NAME, if specified, is the name of the buffer for logging
the warning.  By default, it is ‘*Warnings*’.  If this function
has to create the buffer, it disables undo in the buffer.

See the ‘warnings’ custom group for user customization features.

See also ‘warning-series’, ‘warning-prefix-function’ and
‘warning-fill-prefix’ for additional programming features.

(fn TYPE MESSAGE &optional LEVEL BUFFER-NAME)〉〉enditem49840〈〈lwarn〉〉:〈〈Display a warning message made from (format-message MESSAGE ARGS...).

Aside from generating the message with ‘format-message’,
this is equivalent to ‘display-warning’.

TYPE is the warning type: either a custom group name (a symbol),
or a list of symbols whose first element is a custom group name.
(The rest of the symbols represent subcategories and
can be whatever you like.)

LEVEL should be either :debug, :warning, :error, or :emergency
(but see ‘warning-minimum-level’ and ‘warning-minimum-log-level’).

:emergency -- a problem that will seriously impair Emacs operation soon
	      if you do not attend to it promptly.
:error     -- invalid data or circumstances.
:warning   -- suspicious data or circumstances.
:debug     -- info for debugging only.

(fn TYPE LEVEL MESSAGE &rest ARGS)〉〉enditem49840〈〈warn〉〉:〈〈Display a warning message made from (format-message MESSAGE ARGS...).
Aside from generating the message with ‘format-message’,
this is equivalent to ‘display-warning’, using
‘emacs’ as the type and ‘:warning’ as the level.

(fn MESSAGE &rest ARGS)〉〉enditem49840〈〈next-button〉〉:〈〈Return the next button after position POS in the current buffer.
If COUNT-CURRENT is non-nil, count any button at POS in the search,
instead of starting at the next button.〉〉enditem49840〈〈previous-button〉〉:〈〈Return the previous button before position POS in the current buffer.
If COUNT-CURRENT is non-nil, count any button at POS in the search,
instead of starting at the next button.〉〉enditem49840〈〈font-lock-add-keywords〉〉:〈〈Add highlighting KEYWORDS for MODE.

MODE should be a symbol, the major mode command name, such as ‘c-mode’
or nil.  If nil, highlighting keywords are added for the current buffer.
KEYWORDS should be a list; see the variable ‘font-lock-keywords’.
By default they are added at the beginning of the current highlighting list.
If optional argument HOW is ‘set’, they are used to replace the current
highlighting list.  If HOW is any other non-nil value, they are added at the
end of the current highlighting list.

For example:

 (font-lock-add-keywords 'c-mode
  '(("\\<\\(FIXME\\):" 1 'font-lock-warning-face prepend)
    ("\\<\\(and\\|or\\|not\\)\\>" . 'font-lock-keyword-face)))

adds two fontification patterns for C mode, to fontify ‘FIXME:’ words, even in
comments, and to fontify ‘and’, ‘or’ and ‘not’ words as keywords.

The above procedure will only add the keywords for C mode, not
for modes derived from C mode.  To add them for derived modes too,
pass nil for MODE and add the call to c-mode-hook.

For example:

 (add-hook 'c-mode-hook
  (lambda ()
   (font-lock-add-keywords nil
    '(("\\<\\(FIXME\\):" 1 'font-lock-warning-face prepend)
      ("\\<\\(and\\|or\\|not\\)\\>" .
       'font-lock-keyword-face)))))

The above procedure may fail to add keywords to derived modes if
some involved major mode does not follow the standard conventions.
File a bug report if this happens, so the major mode can be corrected.

Note that some modes have specialized support for additional patterns, e.g.,
see the variables ‘c-font-lock-extra-types’, ‘c++-font-lock-extra-types’,
‘objc-font-lock-extra-types’ and ‘java-font-lock-extra-types’.〉〉enditem49840〈〈font-lock-remove-keywords〉〉:〈〈Remove highlighting KEYWORDS for MODE.

MODE should be a symbol, the major mode command name, such as
‘c-mode’ or nil.  If nil, highlighting keywords are removed for
the current buffer.

For a description of KEYWORDS, see ‘font-lock-add-keywords’.

To make the removal apply to modes derived from MODE as well,
pass nil for MODE and add the call to MODE-hook.  This may fail
for some derived modes if some involved major mode does not
follow the standard conventions.  File a bug report if this
happens, so the major mode can be corrected.〉〉enditem49840〈〈current-justification〉〉:〈〈How should we justify this line?
This returns the value of the text-property ‘justification’,
or the variable ‘default-justification’ if there is no text-property.
However, it returns nil rather than ‘none’ to mean "don’t justify".〉〉enditem49840〈〈display-completion-list〉〉:〈〈Display the list of completions, COMPLETIONS, using ‘standard-output’.
Each element may be just a symbol or string
or may be a list of two strings to be printed as if concatenated.
If it is a list of two strings, the first is the actual completion
alternative, the second serves as annotation.
‘standard-output’ must be a buffer.
The actual completion alternatives, as inserted, are given ‘mouse-face’
properties of ‘highlight’.
At the end, this runs the normal hook ‘completion-setup-hook’.
It can find the completion buffer in ‘standard-output’.

(fn COMPLETIONS &optional COMMON-SUBSTRING)〉〉enditem49840〈〈make-sparse-keymap〉〉:〈〈Construct and return a new sparse keymap.
Its car is ‘keymap’ and its cdr is an alist of (CHAR . DEFINITION),
which binds the character CHAR to DEFINITION, or (SYMBOL . DEFINITION),
which binds the function key or mouse event SYMBOL to DEFINITION.
Initially the alist is nil.

The optional arg STRING supplies a menu name for the keymap
in case you use it as a menu with ‘x-popup-menu’.

(fn &optional STRING)〉〉enditem49840〈〈make-keymap〉〉:〈〈Construct and return a new keymap, of the form (keymap CHARTABLE . ALIST).
CHARTABLE is a char-table that holds the bindings for all characters
without modifiers.  All entries in it are initially nil, meaning
"command undefined".  ALIST is an assoc-list which holds bindings for
function keys, mouse events, and any other things that appear in the
input stream.  Initially, ALIST is nil.

The optional arg STRING supplies a menu name for the keymap
in case you use it as a menu with ‘x-popup-menu’.

(fn &optional STRING)〉〉enditem49840〈〈copy-keymap〉〉:〈〈Return a copy of the keymap KEYMAP.

Note that this is almost never needed.  If you want a keymap that’s like
another yet with a few changes, you should use map inheritance rather
than copying.  I.e. something like:

    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map <theirmap>)
      (define-key map ...)
      ...)

After performing ‘copy-keymap’, the copy starts out with the same definitions
of KEYMAP, but changing either the copy or KEYMAP does not affect the other.
Any key definitions that are subkeymaps are recursively copied.
However, a key definition which is a symbol whose definition is a keymap
is not copied.

(fn KEYMAP)〉〉enditem49840〈〈window-right-divider-width〉〉:〈〈Return the width in pixels of WINDOW’s right divider.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈window-bottom-divider-width〉〉:〈〈Return the width in pixels of WINDOW’s bottom divider.
WINDOW must be a live window and defaults to the selected one.

(fn &optional WINDOW)〉〉enditem49840〈〈autoload〉〉:〈〈Define FUNCTION to autoload from FILE.
FUNCTION is a symbol; FILE is a file name string to pass to ‘load’.
Third arg DOCSTRING is documentation for the function.
Fourth arg INTERACTIVE if non-nil says function can be called interactively.
Fifth arg TYPE indicates the type of the object:
   nil or omitted says FUNCTION is a function,
   ‘keymap’ says FUNCTION is really a keymap, and
   ‘macro’ or t says FUNCTION is really a macro.
Third through fifth args give info about the real definition.
They default to nil.
If FUNCTION is already defined other than as an autoload,
this does nothing and returns nil.

(fn FUNCTION FILE &optional DOCSTRING INTERACTIVE TYPE)〉〉enditem49840〈〈autoloadp〉〉:〈〈Non-nil if OBJECT is an autoload.

(fn OBJECT)〉〉enditem49840〈〈autoload-do-load〉〉:〈〈Load FUNDEF which should be an autoload.
If non-nil, FUNNAME should be the symbol whose function value is FUNDEF,
in which case the function returns the new autoloaded function value.
If equal to ‘macro’, MACRO-ONLY specifies that FUNDEF should only be loaded if
it defines a macro.

(fn FUNDEF &optional FUNNAME MACRO-ONLY)〉〉enditem49840〈〈syntax-table-p〉〉:〈〈Return t if OBJECT is a syntax table.
Currently, any char-table counts as a syntax table.

(fn OBJECT)〉〉enditem49840〈〈standard-syntax-table〉〉:〈〈Return the standard syntax table.
This is the one used for new buffers.

(fn)〉〉enditem49840〈〈throw〉〉:〈〈Throw to the catch for TAG and return VALUE from it.
Both TAG and VALUE are evalled.

(fn TAG VALUE)〉〉enditem49840〈〈facep〉〉:〈〈Return non-nil if FACE is a face name; nil otherwise.
A face name can be a string or a symbol.

(fn FACE)〉〉enditem49840〈〈x-get-resource〉〉:〈〈Return the value of ATTRIBUTE, of class CLASS, from the X defaults database.
This uses ‘INSTANCE.ATTRIBUTE’ as the key and ‘Emacs.CLASS’ as the
class, where INSTANCE is the name under which Emacs was invoked, or
the name specified by the ‘-name’ or ‘-rn’ command-line arguments.

The optional arguments COMPONENT and SUBCLASS add to the key and the
class, respectively.  You must specify both of them or neither.
If you specify them, the key is ‘INSTANCE.COMPONENT.ATTRIBUTE’
and the class is ‘Emacs.CLASS.SUBCLASS’.

(fn ATTRIBUTE CLASS &optional COMPONENT SUBCLASS)〉〉enditem49840〈〈set-marker-insertion-type〉〉:〈〈Set the insertion-type of MARKER to TYPE.
If TYPE is t, it means the marker advances when you insert text at it.
If TYPE is nil, it means the marker stays behind when you insert text at it.

(fn MARKER TYPE)〉〉enditem49840〈〈marker-insertion-type〉〉:〈〈Return insertion type of MARKER: t if it stays after inserted text.
The value nil means the marker stays before text inserted there.

(fn MARKER)〉〉enditem49840〈〈format-mode-line〉〉:〈〈Format a string out of a mode line format specification.
First arg FORMAT specifies the mode line format (see ‘mode-line-format’
for details) to use.

By default, the format is evaluated for the currently selected window.

Optional second arg FACE specifies the face property to put on all
characters for which no face is specified.  The value nil means the
default face.  The value t means whatever face the window’s mode line
currently uses (either ‘mode-line’ or ‘mode-line-inactive’,
depending on whether the window is the selected window or not).
An integer value means the value string has no text
properties.

Optional third and fourth args WINDOW and BUFFER specify the window
and buffer to use as the context for the formatting (defaults
are the selected window and the WINDOW’s buffer).

(fn FORMAT &optional FACE WINDOW BUFFER)〉〉enditem49840〈〈quietly-read-abbrev-file〉〉:〈〈Read abbrev definitions from file written with ‘write-abbrev-file’.
Optional argument FILE is the name of the file to read;
it defaults to the value of ‘abbrev-file-name’.
Does not display any message.

(fn &optional FILE)〉〉enditem49840〈〈window-dedicated-p〉〉:〈〈Return non-nil when WINDOW is dedicated to its buffer.
More precisely, return the value assigned by the last call of
‘set-window-dedicated-p’ for WINDOW.  Return nil if that function was
never called with WINDOW as its argument, or the value set by that
function was internally reset since its last call.  WINDOW must be a
live window and defaults to the selected one.

When a window is dedicated to its buffer, ‘display-buffer’ will refrain
from displaying another buffer in it.  ‘get-lru-window’ and
‘get-largest-window’ treat dedicated windows specially.
‘delete-windows-on’, ‘replace-buffer-in-windows’, ‘quit-window’ and
‘kill-buffer’ can delete a dedicated window and the containing frame.

Functions like ‘set-window-buffer’ may change the buffer displayed by a
window, unless that window is "strongly" dedicated to its buffer, that
is the value returned by ‘window-dedicated-p’ is t.

(fn &optional WINDOW)〉〉enditem49840〈〈set-window-dedicated-p〉〉:〈〈Mark WINDOW as dedicated according to FLAG.
WINDOW must be a live window and defaults to the selected one.  FLAG
non-nil means mark WINDOW as dedicated to its buffer.  FLAG nil means
mark WINDOW as non-dedicated.  Return FLAG.

When a window is dedicated to its buffer, ‘display-buffer’ will refrain
from displaying another buffer in it.  ‘get-lru-window’ and
‘get-largest-window’ treat dedicated windows specially.
‘delete-windows-on’, ‘replace-buffer-in-windows’, ‘quit-window’,
‘quit-restore-window’ and ‘kill-buffer’ can delete a dedicated window
and the containing frame.

As a special case, if FLAG is t, mark WINDOW as "strongly" dedicated to
its buffer.  Functions like ‘set-window-buffer’ may change the buffer
displayed by a window, unless that window is strongly dedicated to its
buffer.  If and when ‘set-window-buffer’ displays another buffer in a
window, it also makes sure that the window is no more dedicated.

(fn WINDOW FLAG)〉〉enditem49840〈〈cancel-timer〉〉:〈〈Remove TIMER from the list of active timers.

(fn TIMER)〉〉enditem49840〈〈make-network-process〉〉:〈〈Create and return a network server or client process.

In Emacs, network connections are represented by process objects, so
input and output work as for subprocesses and ‘delete-process’ closes
a network connection.  However, a network process has no process id,
it cannot be signaled, and the status codes are different from normal
processes.

Arguments are specified as keyword/argument pairs.  The following
arguments are defined:

:name NAME -- NAME is name for process.  It is modified if necessary
to make it unique.

:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate
with the process.  Process output goes at end of that buffer, unless
you specify a filter function to handle the output.  BUFFER may be
also nil, meaning that this process is not associated with any buffer.

:host HOST -- HOST is name of the host to connect to, or its IP
address.  The symbol ‘local’ specifies the local host.  If specified
for a server process, it must be a valid name or address for the local
host, and only clients connecting to that address will be accepted.

:service SERVICE -- SERVICE is name of the service desired, or an
integer specifying a port number to connect to.  If SERVICE is t,
a random port number is selected for the server.  A port number can
be specified as an integer string, e.g., "80", as well as an integer.

:type TYPE -- TYPE is the type of connection.  The default (nil) is a
stream type connection, ‘datagram’ creates a datagram type connection,
‘seqpacket’ creates a reliable datagram connection.

:family FAMILY -- FAMILY is the address (and protocol) family for the
service specified by HOST and SERVICE.  The default (nil) is to use
whatever address family (IPv4 or IPv6) that is defined for the host
and port number specified by HOST and SERVICE.  Other address families
supported are:
  local -- for a local (i.e. UNIX) address specified by SERVICE.
  ipv4  -- use IPv4 address family only.
  ipv6  -- use IPv6 address family only.

:local ADDRESS -- ADDRESS is the local address used for the connection.
This parameter is ignored when opening a client process. When specified
for a server process, the FAMILY, HOST and SERVICE args are ignored.

:remote ADDRESS -- ADDRESS is the remote partner’s address for the
connection.  This parameter is ignored when opening a stream server
process.  For a datagram server process, it specifies the initial
setting of the remote datagram address.  When specified for a client
process, the FAMILY, HOST, and SERVICE args are ignored.

The format of ADDRESS depends on the address family:
- An IPv4 address is represented as a vector of integers [A B C D P]
corresponding to numeric IP address A.B.C.D and port number P.
- A local address is represented as a string with the address in the
local address space.
- An "unsupported family" address is represented by a cons (F . AV)
where F is the family number and AV is a vector containing the socket
address data with one element per address data byte.  Do not rely on
this format in portable code, as it may depend on implementation
defined constants, data sizes, and data structure alignment.

:coding CODING -- If CODING is a symbol, it specifies the coding
system used for both reading and writing for this process.  If CODING
is a cons (DECODING . ENCODING), DECODING is used for reading, and
ENCODING is used for writing.

:nowait BOOL -- If NOWAIT is non-nil for a stream type client
process, return without waiting for the connection to complete;
instead, the sentinel function will be called with second arg matching
"open" (if successful) or "failed" when the connect completes.
Default is to use a blocking connect (i.e. wait) for stream type
connections.

:noquery BOOL -- Query the user unless BOOL is non-nil, and process is
running when Emacs is exited.

:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.
In the stopped state, a server process does not accept new
connections, and a client process does not handle incoming traffic.
The stopped state is cleared by ‘continue-process’ and set by
‘stop-process’.

:filter FILTER -- Install FILTER as the process filter.

:filter-multibyte BOOL -- If BOOL is non-nil, strings given to the
process filter are multibyte, otherwise they are unibyte.
If this keyword is not specified, the strings are multibyte if
the default value of ‘enable-multibyte-characters’ is non-nil.

:sentinel SENTINEL -- Install SENTINEL as the process sentinel.

:log LOG -- Install LOG as the server process log function.  This
function is called when the server accepts a network connection from a
client.  The arguments are SERVER, CLIENT, and MESSAGE, where SERVER
is the server process, CLIENT is the new process for the connection,
and MESSAGE is a string.

:plist PLIST -- Install PLIST as the new process’s initial plist.

:tls-parameters LIST -- is a list that should be supplied if you’re
opening a TLS connection.  The first element is the TLS type (either
‘gnutls-x509pki’ or ‘gnutls-anon’), and the remaining elements should
be a keyword list accepted by gnutls-boot (as returned by
‘gnutls-boot-parameters’).

:server QLEN -- if QLEN is non-nil, create a server process for the
specified FAMILY, SERVICE, and connection type (stream or datagram).
If QLEN is an integer, it is used as the max. length of the server’s
pending connection queue (also known as the backlog); the default
queue length is 5.  Default is to create a client process.

The following network options can be specified for this connection:

:broadcast BOOL    -- Allow send and receive of datagram broadcasts.
:dontroute BOOL    -- Only send to directly connected hosts.
:keepalive BOOL    -- Send keep-alive messages on network stream.
:linger BOOL or TIMEOUT -- Send queued messages before closing.
:oobinline BOOL    -- Place out-of-band data in receive data stream.
:priority INT      -- Set protocol defined priority for sent packets.
:reuseaddr BOOL    -- Allow reusing a recently used local address
                      (this is allowed by default for a server process).
:bindtodevice NAME -- bind to interface NAME.  Using this may require
                      special privileges on some systems.
:use-external-socket BOOL -- Use any pre-allocated sockets that have
                             been passed to Emacs.  If Emacs wasn’t
                             passed a socket, this option is silently
                             ignored.


Consult the relevant system programmer’s manual pages for more
information on using these options.


A server process will listen for and accept connections from clients.
When a client connection is accepted, a new network process is created
for the connection with the following parameters:

- The client’s process name is constructed by concatenating the server
process’s NAME and a client identification string.
- If the FILTER argument is non-nil, the client process will not get a
separate process buffer; otherwise, the client’s process buffer is a newly
created buffer named after the server process’s BUFFER name or process
NAME concatenated with the client identification string.
- The connection type and the process filter and sentinel parameters are
inherited from the server process’s TYPE, FILTER and SENTINEL.
- The client process’s contact info is set according to the client’s
addressing information (typically an IP address and a port number).
- The client process’s plist is initialized from the server’s plist.

Notice that the FILTER and SENTINEL args are never used directly by
the server process.  Also, the BUFFER argument is not used directly by
the server process, but via the optional :log function, accepted (and
failed) connections may be logged in the server process’s buffer.

The original argument list, modified with the actual connection
information, is available via the ‘process-contact’ function.

(fn &rest ARGS)〉〉enditem49840〈〈time-less-p〉〉:〈〈Return non-nil if time value T1 is earlier than time value T2.
A nil value for either argument stands for the current time.
See ‘current-time-string’ for the various forms of a time value.

(fn T1 T2)〉〉enditem49840〈〈time-subtract〉〉:〈〈Return the difference between two time values A and B, as a time value.
Use ‘float-time’ to convert the difference into elapsed seconds.
A nil value for either argument stands for the current time.
See ‘current-time-string’ for the various forms of a time value.

(fn A B)〉〉enditem49840〈〈time-add〉〉:〈〈Return the sum of two time values A and B, as a time value.
A nil value for either argument stands for the current time.
See ‘current-time-string’ for the various forms of a time value.

(fn A B)〉〉enditem49840〈〈time-to-days〉〉:〈〈The number of days between the Gregorian date 0001-12-31bce and TIME.
TIME should be a time value.
The Gregorian date Sunday, December 31, 1bce is imaginary.〉〉enditem49840〈〈time-to-day-in-year〉〉:〈〈Return the day number within the year corresponding to TIME.〉〉enditem49840〈〈date-leap-year-p〉〉:〈〈Return t if YEAR is a leap year.〉〉enditem49840〈〈buffer-swap-text〉〉:〈〈Swap the text between current buffer and BUFFER.
Using this function from ‘save-excursion’ might produce surprising
results, see Info node ‘(elisp)Swapping Text’.

(fn BUFFER)〉〉enditem49840〈〈mark〉〉:〈〈Return this buffer’s mark value as integer, or nil if never set.

In Transient Mark mode, this function signals an error if
the mark is not active.  However, if ‘mark-even-if-inactive’ is non-nil,
or the argument FORCE is non-nil, it disregards whether the mark
is active, and returns an integer or nil in the usual way.

If you are using this in an editing command, you are most likely making
a mistake; see the documentation of ‘set-mark’.

(fn &optional FORCE)〉〉enditem49840〈〈mark-marker〉〉:〈〈Return this buffer’s mark, as a marker object.
Watch out!  Moving this marker changes the mark position.
If you set the marker not to point anywhere, the buffer will have no mark.

(fn)〉〉enditem49840〈〈set-mark〉〉:〈〈Set this buffer’s mark to POS.  Don’t use this function!
That is to say, don’t use this function unless you want
the user to see that the mark has moved, and you want the previous
mark position to be lost.

Normally, when a new mark is set, the old one should go on the stack.
This is why most applications should use ‘push-mark’, not ‘set-mark’.

Novice Emacs Lisp programmers often try to use the mark for the wrong
purposes.  The mark saves a location for the user’s convenience.
Most editing commands should not alter the mark.
To remember a location for internal use in the Lisp program,
store it in a Lisp variable.  Example:

   (let ((beg (point))) (forward-line 1) (delete-region beg (point))).

(fn POS)〉〉enditem49840〈〈push-mark〉〉:〈〈Set mark at LOCATION (point, by default) and push old mark on mark ring.
If the last global mark pushed was not in the current buffer,
also push LOCATION on the global mark ring.
Display ‘Mark set’ unless the optional second arg NOMSG is non-nil.

Novice Emacs Lisp programmers often try to use the mark for the wrong
purposes.  See the documentation of ‘set-mark’ for more information.

In Transient Mark mode, activate mark if optional third arg ACTIVATE non-nil.

(fn &optional LOCATION NOMSG ACTIVATE)〉〉enditem49840〈〈pop-mark〉〉:〈〈Pop off mark ring into the buffer’s actual mark.
Does not set point.  Does nothing if mark ring is empty.〉〉enditem49840〈〈deactivate-mark〉〉:〈〈Deactivate the mark.
If Transient Mark mode is disabled, this function normally does
nothing; but if FORCE is non-nil, it deactivates the mark anyway.

Deactivating the mark sets ‘mark-active’ to nil, updates the
primary selection according to ‘select-active-regions’, and runs
‘deactivate-mark-hook’.

If Transient Mark mode was temporarily enabled, reset the value
of the variable ‘transient-mark-mode’; if this causes Transient
Mark mode to be disabled, don’t change ‘mark-active’ to nil or
run ‘deactivate-mark-hook’.

(fn &optional FORCE)〉〉enditem49840〈〈handle-shift-selection〉〉:〈〈Activate/deactivate mark depending on invocation thru shift translation.
This function is called by ‘call-interactively’ when a command
with a ‘^’ character in its ‘interactive’ spec is invoked, before
running the command itself.

If ‘shift-select-mode’ is enabled and the command was invoked
through shift translation, set the mark and activate the region
temporarily, unless it was already set in this way.  See
‘this-command-keys-shift-translated’ for the meaning of shift
translation.

Otherwise, if the region has been activated temporarily,
deactivate it, and restore the variable ‘transient-mark-mode’ to
its earlier value.〉〉enditem49840〈〈cons〉〉:〈〈Create a new cons, give it CAR and CDR as components, and return it.

(fn CAR CDR)〉〉enditem49840〈〈list〉〉:〈〈Return a newly created list with specified arguments as elements.
Any number of arguments, even zero arguments, are allowed.

(fn &rest OBJECTS)〉〉enditem49840〈〈make-list〉〉:〈〈Return a newly created list of length LENGTH, with each element being INIT.

(fn LENGTH INIT)〉〉enditem49840〈〈append〉〉:〈〈Concatenate all the arguments and make the result a list.
The result is a list whose elements are the elements of all the arguments.
Each argument may be a list, vector or string.
The last argument is not copied, just used as the tail of the new list.

(fn &rest SEQUENCES)〉〉enditem49840〈〈copy-tree〉〉:〈〈Make a copy of TREE.
If TREE is a cons cell, this recursively copies both its car and its cdr.
Contrast to ‘copy-sequence’, which copies only along the cdrs.  With second
argument VECP, this copies vectors as well as conses.

(fn TREE &optional VECP)〉〉enditem49840〈〈number-sequence〉〉:〈〈Return a sequence of numbers from FROM to TO (both inclusive) as a list.
INC is the increment used between numbers in the sequence and defaults to 1.
So, the Nth element of the list is (+ FROM (* N INC)) where N counts from
zero.  TO is only included if there is an N for which TO = FROM + N * INC.
If TO is nil or numerically equal to FROM, return (FROM).
If INC is positive and TO is less than FROM, or INC is negative
and TO is larger than FROM, return nil.
If INC is zero and TO is neither nil nor numerically equal to
FROM, signal an error.

This function is primarily designed for integer arguments.
Nevertheless, FROM, TO and INC can be integer or float.  However,
floating point arithmetic is inexact.  For instance, depending on
the machine, it may quite well happen that
(number-sequence 0.4 0.6 0.2) returns the one element list (0.4),
whereas (number-sequence 0.4 0.8 0.2) returns a list with three
elements.  Thus, if some of the arguments are floats and one wants
to make sure that TO is included, one may have to explicitly write
TO as (+ FROM (* N INC)) or use a variable whose value was
computed with this exact expression.  Alternatively, you can,
of course, also replace TO with a slightly larger value
(or a slightly more negative value if INC is negative).

(fn FROM &optional TO INC)〉〉enditem49840〈〈line-beginning-position〉〉:〈〈Return the character position of the first character on the current line.
With optional argument N, scan forward N - 1 lines first.
If the scan reaches the end of the buffer, return that position.

This function ignores text display directionality; it returns the
position of the first character in logical order, i.e. the smallest
character position on the line.

This function constrains the returned position to the current field
unless that position would be on a different line than the original,
unconstrained result.  If N is nil or 1, and a front-sticky field
starts at point, the scan stops as soon as it starts.  To ignore field
boundaries, bind ‘inhibit-field-text-motion’ to t.

This function does not move point.

(fn &optional N)〉〉enditem49840〈〈line-end-position〉〉:〈〈Return the character position of the last character on the current line.
With argument N not nil or 1, move forward N - 1 lines first.
If scan reaches end of buffer, return that position.

This function ignores text display directionality; it returns the
position of the last character in logical order, i.e. the largest
character position on the line.

This function constrains the returned position to the current field
unless that would be on a different line than the original,
unconstrained result.  If N is nil or 1, and a rear-sticky field ends
at point, the scan stops as soon as it starts.  To ignore field
boundaries bind ‘inhibit-field-text-motion’ to t.

This function does not move point.

(fn &optional N)〉〉enditem49840〈〈count-lines〉〉:〈〈Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line.

(fn START END)〉〉enditem49840〈〈line-number-at-pos〉〉:〈〈Return buffer line number at position POS.
If POS is nil, use current buffer location.

If ABSOLUTE is nil, the default, counting starts
at (point-min), so the value refers to the contents of the
accessible portion of the (potentially narrowed) buffer.  If
ABSOLUTE is non-nil, ignore any narrowing and return the
absolute line number.

(fn &optional POS ABSOLUTE)〉〉enditem49840〈〈completion-in-region〉〉:〈〈Complete the text between START and END using COLLECTION.
Point needs to be somewhere between START and END.
PREDICATE (a function called with no arguments) says when to exit.
This calls the function that ‘completion-in-region-function’ specifies
(passing the same four arguments that it received) to do the work,
and returns whatever it does.  The return value should be nil
if there was no valid completion, else t.

(fn START END COLLECTION &optional PREDICATE)〉〉enditem49840〈〈make-marker〉〉:〈〈Return a newly allocated marker which does not point at any place.

(fn)〉〉enditem49840〈〈point-marker〉〉:〈〈Return value of point, as a marker object.

(fn)〉〉enditem49840〈〈point-min-marker〉〉:〈〈Return a marker to the minimum permissible value of point in this buffer.
This is the beginning, unless narrowing (a buffer restriction) is in effect.

(fn)〉〉enditem49840〈〈point-max-marker〉〉:〈〈Return a marker to the maximum permissible value of point in this buffer.
This is (1+ (buffer-size)), unless narrowing (a buffer restriction)
is in effect, in which case it is less.

(fn)〉〉enditem49840〈〈copy-marker〉〉:〈〈Return a new marker pointing at the same place as MARKER.
If argument is a number, makes a new marker pointing
at that position in the current buffer.
If MARKER is not specified, the new marker does not point anywhere.
The optional argument TYPE specifies the insertion type of the new marker;
see ‘marker-insertion-type’.

(fn &optional MARKER TYPE)〉〉enditem49840〈〈defcustom〉〉:〈〈Declare SYMBOL as a customizable variable.
SYMBOL is the variable name; it should not be quoted.
STANDARD is an expression specifying the variable’s standard
value.  It should not be quoted.  It is evaluated once by
‘defcustom’, and the value is assigned to SYMBOL if the variable
is unbound.  The expression itself is also stored, so that
Customize can re-evaluate it later to get the standard value.
DOC is the variable documentation.

This macro uses ‘defvar’ as a subroutine, which also marks the
variable as "special", so that it is always dynamically bound
even when ‘lexical-binding’ is t.

The remaining arguments to ‘defcustom’ should have the form

   [KEYWORD VALUE]...

The following keywords are meaningful:

:type	VALUE should be a widget type for editing the symbol’s value.
	Every ‘defcustom’ should specify a value for this keyword.
:options VALUE should be a list of valid members of the widget type.
:initialize
	VALUE should be a function used to initialize the
	variable.  It takes two arguments, the symbol and value
	given in the ‘defcustom’ call.  The default is
	‘custom-initialize-reset’.
:set	VALUE should be a function to set the value of the symbol
	when using the Customize user interface.  It takes two arguments,
	the symbol to set and the value to give it.  The function should
	not modify its value argument destructively.  The default choice
	of function is ‘set-default’.
:get	VALUE should be a function to extract the value of symbol.
	The function takes one argument, a symbol, and should return
	the current value for that symbol.  The default choice of function
	is ‘default-value’.
:require
	VALUE should be a feature symbol.  If you save a value
	for this option, then when your init file loads the value,
	it does (require VALUE) first.
:set-after VARIABLES
	Specifies that SYMBOL should be set after the list of variables
        VARIABLES when both have been customized.
:risky	Set SYMBOL’s ‘risky-local-variable’ property to VALUE.
:safe	Set SYMBOL’s ‘safe-local-variable’ property to VALUE.
        See Info node ‘(elisp) File Local Variables’.

The following common keywords are also meaningful.

:group  VALUE should be a customization group.
        Add SYMBOL (or FACE with ‘defface’) to that group.
:link LINK-DATA
        Include an external link after the documentation string for this
        item.  This is a sentence containing an active field which
        references some other documentation.

        There are several alternatives you can use for LINK-DATA:

        (custom-manual INFO-NODE)
             Link to an Info node; INFO-NODE is a string which specifies
             the node name, as in "(emacs)Top".

        (info-link INFO-NODE)
             Like ‘custom-manual’ except that the link appears in the
             customization buffer with the Info node name.

        (url-link URL)
             Link to a web page; URL is a string which specifies the URL.

        (emacs-commentary-link LIBRARY)
             Link to the commentary section of LIBRARY.

        (emacs-library-link LIBRARY)
             Link to an Emacs Lisp LIBRARY file.

        (file-link FILE)
             Link to FILE.

        (function-link FUNCTION)
             Link to the documentation of FUNCTION.

        (variable-link VARIABLE)
             Link to the documentation of VARIABLE.

        (custom-group-link GROUP)
             Link to another customization GROUP.

        You can specify the text to use in the customization buffer by
        adding ‘:tag NAME’ after the first element of the LINK-DATA; for
        example, (info-link :tag "foo" "(emacs)Top") makes a link to the
        Emacs manual which appears in the buffer as ‘foo’.

        An item can have more than one external link; however, most items
        have none at all.
:version
        VALUE should be a string specifying that the variable was
        first introduced, or its default value was changed, in Emacs
        version VERSION.
:package-version
        VALUE should be a list with the form (PACKAGE . VERSION)
        specifying that the variable was first introduced, or its
        default value was changed, in PACKAGE version VERSION.  This
        keyword takes priority over :version.  For packages which
        are bundled with Emacs releases, the PACKAGE and VERSION
        must appear in the alist ‘customize-package-emacs-version-alist’.
        Since PACKAGE must be unique and the user might see it in an
        error message, a good choice is the official name of the
        package, such as MH-E or Gnus.
:tag LABEL
        Use LABEL, a string, instead of the item’s name, to label the item
        in customization menus and buffers.
:load FILE
        Load file FILE (a string) before displaying this customization
        item.  Loading is done with ‘load’, and only if the file is
        not already loaded.

If SYMBOL has a local binding, then this form affects the local
binding.  This is normally not what you want.  Thus, if you need
to load a file defining variables with this form, or with
‘defvar’ or ‘defconst’, you should always load that file
_outside_ any bindings for these variables.  (‘defvar’ and
‘defconst’ behave similarly in this respect.)

See Info node ‘(elisp) Customization’ in the Emacs Lisp manual
for more information.〉〉enditem49840〈〈deftheme〉〉:〈〈Declare THEME to be a Custom theme.
The optional argument DOC is a doc string describing the theme.

Any theme ‘foo’ should be defined in a file called ‘foo-theme.el’;
see ‘custom-make-theme-feature’ for more information.〉〉enditem49840〈〈provide-theme〉〉:〈〈Indicate that this file provides THEME.
This calls ‘provide’ to provide the feature name stored in THEME’s
property ‘theme-feature’ (which is usually a symbol created by
‘custom-make-theme-feature’).〉〉enditem49840〈〈push〉〉:〈〈Add NEWELT to the list stored in the generalized variable PLACE.
This is morally equivalent to (setf PLACE (cons NEWELT PLACE)),
except that PLACE is only evaluated once (after NEWELT).

(fn NEWELT PLACE)〉〉enditem49840〈〈save-match-data〉〉:〈〈Execute the BODY forms, restoring the global value of the match data.
The value returned is the value of the last form in BODY.

(fn &rest BODY)〉〉enditem49840〈〈pop〉〉:〈〈Return the first element of PLACE’s value, and remove it from the list.
PLACE must be a generalized variable whose value is a list.
If the value is nil, ‘pop’ returns nil but does not actually
change the list.

(fn PLACE)〉〉enditem49840〈〈defsubst〉〉:〈〈Define an inline function.  The syntax is just like that of ‘defun’.

(fn NAME ARGLIST &optional DOCSTRING DECL &rest BODY)〉〉enditem49840〈〈define-alternatives〉〉:〈〈Define the new command ‘COMMAND’.

The argument ‘COMMAND’ should be a symbol.

Running ‘M-x COMMAND RET’ for the first time prompts for which
alternative to use and records the selected command as a custom
variable.

Running ‘C-u M-x COMMAND RET’ prompts again for an alternative
and overwrites the previous choice.

The variable ‘COMMAND-alternatives’ contains an alist with
alternative implementations of COMMAND.  ‘define-alternatives’
does not have any effect until this variable is set.

CUSTOMIZATIONS, if non-nil, should be composed of alternating
‘defcustom’ keywords and values to add to the declaration of
‘COMMAND-alternatives’ (typically :group and :version).

(fn COMMAND &rest CUSTOMIZATIONS)〉〉enditem49840〈〈with-output-to-temp-buffer〉〉:〈〈Bind ‘standard-output’ to buffer BUFNAME, eval BODY, then show that buffer.

This construct makes buffer BUFNAME empty before running BODY.
It does not make the buffer current for BODY.
Instead it binds ‘standard-output’ to that buffer, so that output
generated with ‘prin1’ and similar functions in BODY goes into
the buffer.

At the end of BODY, this marks buffer BUFNAME unmodified and displays
it in a window, but does not select it.  The normal way to do this is
by calling ‘display-buffer’, then running ‘temp-buffer-show-hook’.
However, if ‘temp-buffer-show-function’ is non-nil, it calls that
function instead (and does not run ‘temp-buffer-show-hook’).  The
function gets one argument, the buffer to display.

The return value of ‘with-output-to-temp-buffer’ is the value of the
last form in BODY.  If BODY does not finish normally, the buffer
BUFNAME is not displayed.

This runs the hook ‘temp-buffer-setup-hook’ before BODY,
with the buffer BUFNAME temporarily current.  It runs the hook
‘temp-buffer-show-hook’ after displaying buffer BUFNAME, with that
buffer temporarily current, and the window that was used to display it
temporarily selected.  But it doesn’t run ‘temp-buffer-show-hook’
if it uses ‘temp-buffer-show-function’.

By default, the setup hook puts the buffer into Help mode before running BODY.
If BODY does not change the major mode, the show hook makes the buffer
read-only, and scans it for function and variable names to make them into
clickable cross-references.

See the related form ‘with-temp-buffer-window’.

(fn BUFNAME &rest BODY)〉〉enditem49840〈〈with-temp-buffer-window〉〉:〈〈Bind ‘standard-output’ to BUFFER-OR-NAME, eval BODY, show the buffer.
BUFFER-OR-NAME must specify either a live buffer, or the name of
a buffer (if it does not exist, this macro creates it).

Make the buffer specified by BUFFER-OR-NAME empty before running
BODY and bind ‘standard-output’ to that buffer, so that output
generated with ‘prin1’ and similar functions in BODY goes into
that buffer.  Do not make that buffer current for running the
forms in BODY.  Use ‘with-current-buffer-window’ instead if you
need to run BODY with that buffer current.

At the end of BODY, mark the specified buffer unmodified and
read-only, and display it in a window (but do not select it).
The display happens by calling ‘display-buffer’ passing it the
ACTION argument.  If ‘temp-buffer-resize-mode’ is enabled, the
corresponding window may be resized automatically.

Return the value returned by BODY, unless QUIT-FUNCTION specifies
a function.  In that case, run that function with two arguments -
the window showing the specified buffer and the value returned by
BODY - and return the value returned by that function.

If the buffer is displayed on a new frame, the window manager may
decide to select that frame.  In that case, it’s usually a good
strategy if QUIT-FUNCTION selects the window showing the buffer
before reading any value from the minibuffer; for example, when
asking a ‘yes-or-no-p’ question.

This runs the hook ‘temp-buffer-window-setup-hook’ before BODY,
with the specified buffer temporarily current.  It runs the hook
‘temp-buffer-window-show-hook’ after displaying the buffer, with
that buffer temporarily current, and the window that was used to
display it temporarily selected.

This construct is similar to ‘with-output-to-temp-buffer’ but,
neither runs ‘temp-buffer-setup-hook’ which usually puts the
buffer in Help mode, nor ‘temp-buffer-show-function’ (the ACTION
argument replaces this).

(fn BUFFER-OR-NAME ACTION QUIT-FUNCTION &rest BODY)〉〉enditem49840〈〈with-current-buffer-window〉〉:〈〈Evaluate BODY with a buffer BUFFER-OR-NAME current and show that buffer.
This construct is like ‘with-temp-buffer-window’ but unlike that
makes the buffer specified by BUFFER-OR-NAME current for running
BODY.

(fn BUFFER-OR-NAME ACTION QUIT-FUNCTION &rest BODY)〉〉enditem49840〈〈with-displayed-buffer-window〉〉:〈〈Show a buffer BUFFER-OR-NAME and evaluate BODY in that buffer.
This construct is like ‘with-current-buffer-window’ but unlike that
displays the buffer specified by BUFFER-OR-NAME before running BODY.

(fn BUFFER-OR-NAME ACTION QUIT-FUNCTION &rest BODY)〉〉enditem49840〈〈pcase〉〉:〈〈Evaluate EXP and attempt to match it against structural patterns.
CASES is a list of elements of the form (PATTERN CODE...).

A structural PATTERN describes a template that identifies a class
of values.  For example, the pattern `(,foo ,bar) matches any
two element list, binding its elements to symbols named ‘foo’ and
‘bar’ -- in much the same way that ‘cl-destructuring-bind’ would.

A significant difference from ‘cl-destructuring-bind’ is that, if
a pattern match fails, the next case is tried until either a
successful match is found or there are no more cases.  The CODE
expression corresponding to the matching pattern determines the
return value.  If there is no match the returned value is nil.

Another difference is that pattern elements may be quoted,
meaning they must match exactly: The pattern '(foo bar)
matches only against two element lists containing the symbols
‘foo’ and ‘bar’ in that order.  (As a short-hand, atoms always
match themselves, such as numbers or strings, and need not be
quoted.)

Lastly, a pattern can be logical, such as (pred numberp), that
matches any number-like element; or the symbol ‘_’, that matches
anything.  Also, when patterns are backquoted, a comma may be
used to introduce logical patterns inside backquoted patterns.

The complete list of standard patterns is as follows:

  _		matches anything.
  SYMBOL	matches anything and binds it to SYMBOL.
                If a SYMBOL is used twice in the same pattern
                the second occurrence becomes an ‘eq’uality test.
  (or PAT...)	matches if any of the patterns matches.
  (and PAT...)	matches if all the patterns match.
  'VAL		matches if the object is ‘equal’ to VAL.
  ATOM		is a shorthand for 'ATOM.
		   ATOM can be a keyword, an integer, or a string.
  (pred FUN)	matches if FUN applied to the object returns non-nil.
  (guard BOOLEXP)	matches if BOOLEXP evaluates to non-nil.
  (let PAT EXP)	matches if EXP matches PAT.
  (app FUN PAT)	matches if FUN applied to the object matches PAT.

Additional patterns can be defined using ‘pcase-defmacro’.

The FUN argument in the ‘app’ pattern may have the following forms:
  SYMBOL or (lambda ARGS BODY)  in which case it’s called with one argument.
  (F ARG1 .. ARGn) in which case F gets called with an n+1’th argument
                        which is the value being matched.
So a FUN of the form SYMBOL is equivalent to (FUN).
FUN can refer to variables bound earlier in the pattern.

See Info node ‘(elisp) Pattern matching case statement’ in the
Emacs Lisp manual for more information and examples.

(fn EXP &rest CASES)〉〉enditem49840〈〈pcase-defmacro〉〉:〈〈Define a new kind of pcase PATTERN, by macro expansion.
Patterns of the form (NAME ...) will be expanded according
to this macro.

(fn NAME ARGS &rest BODY)〉〉enditem49840〈〈with-temp-message〉〉:〈〈Display MESSAGE temporarily if non-nil while BODY is evaluated.
The original message is restored to the echo area after BODY has finished.
The value returned is the value of the last form in BODY.
MESSAGE is written to the message log buffer if ‘message-log-max’ is non-nil.
If MESSAGE is nil, the echo area and message log buffer are unchanged.
Use a MESSAGE of "" to temporarily clear the echo area.

(fn MESSAGE &rest BODY)〉〉enditem49840〈〈declare-function〉〉:〈〈Tell the byte-compiler that function FN is defined, in FILE.
The FILE argument is not used by the byte-compiler, but by the
‘check-declare’ package, which checks that FILE contains a
definition for FN.

FILE can be either a Lisp file (in which case the ".el"
extension is optional), or a C file.  C files are expanded
relative to the Emacs "src/" directory.  Lisp files are
searched for using ‘locate-library’, and if that fails they are
expanded relative to the location of the file containing the
declaration.  A FILE with an "ext:" prefix is an external file.
‘check-declare’ will check such files if they are found, and skip
them without error if they are not.

Optional ARGLIST specifies FN’s arguments, or is t to not specify
FN’s arguments.  An omitted ARGLIST defaults to t, not nil: a nil
ARGLIST specifies an empty argument list, and an explicit t
ARGLIST is a placeholder that allows supplying a later arg.

Optional FILEONLY non-nil means that ‘check-declare’ will check
only that FILE exists, not that it defines FN.  This is intended
for function definitions that ‘check-declare’ does not recognize,
e.g., ‘defstruct’.

Note that for the purposes of ‘check-declare’, this statement
must be the first non-whitespace on a line.

For more information, see Info node ‘(elisp)Declaring Functions’.

(fn FN FILE &rest ARGS)〉〉enditem49840〈〈defimage〉〉:〈〈Define SYMBOL as an image, and return SYMBOL.

SPECS is a list of image specifications.  DOC is an optional
documentation string.

Each image specification in SPECS is a property list.  The contents of
a specification are image type dependent.  All specifications must at
least contain the properties ‘:type TYPE’ and either ‘:file FILE’ or
‘:data DATA’, where TYPE is a symbol specifying the image type,
e.g. ‘xbm’, FILE is the file to load the image from, and DATA is a
string containing the actual image data.  The first image
specification whose TYPE is supported, and FILE exists, is used to
define SYMBOL.

Example:

   (defimage test-image ((:type xpm :file "~/test1.xpm")
                         (:type xbm :file "~/test1.xbm")))

(fn SYMBOL SPECS &optional DOC)〉〉enditem49840〈〈setf〉〉:〈〈Set each PLACE to the value of its VAL.
This is a generalized version of ‘setq’; the PLACEs may be symbolic
references such as (car x) or (aref x i), as well as plain symbols.
For example, (setf (cadr x) y) is equivalent to (setcar (cdr x) y).
The return value is the last VAL in the list.

(fn PLACE VAL PLACE VAL ...)〉〉enditem49840〈〈with-output-to-string〉〉:〈〈Execute BODY, return the text it sent to ‘standard-output’, as a string.

(fn &rest BODY)〉〉enditem49840〈〈with-syntax-table〉〉:〈〈Evaluate BODY with syntax table of current buffer set to TABLE.
The syntax table of the current buffer is saved, BODY is evaluated, and the
saved table is restored, even in case of an abnormal exit.
Value is what BODY returns.

(fn TABLE &rest BODY)〉〉enditem49840〈〈seq-doseq〉〉:〈〈Loop over a sequence.
Evaluate BODY with VAR bound to each element of SEQUENCE, in turn.

Similar to ‘dolist’ but can be applied to lists, strings, and vectors.

(fn (VAR SEQUENCE) BODY...)〉〉enditem49840〈〈seq-let〉〉:〈〈Bind the variables in ARGS to the elements of SEQUENCE, then evaluate BODY.

ARGS can also include the ‘&rest’ marker followed by a variable
name to be bound to the rest of SEQUENCE.

(fn ARGS SEQUENCE &rest BODY)〉〉enditem49840〈〈with-eval-after-load〉〉:〈〈Execute BODY after FILE is loaded.
FILE is normally a feature name, but it can also be a file name,
in case that file does not provide any feature.  See ‘eval-after-load’
for more details about the different forms of FILE and their semantics.

(fn FILE &rest BODY)〉〉enditem49840〈〈defface〉〉:〈〈Declare FACE as a customizable face that defaults to SPEC.
FACE does not need to be quoted.

Third argument DOC is the face documentation.

If FACE has been set with ‘custom-theme-set-faces’, set the face
attributes as specified by that function, otherwise set the face
attributes according to SPEC.

The remaining arguments should have the form [KEYWORD VALUE]...
For a list of valid keywords, see the common keywords listed in
‘defcustom’.

SPEC should be a "face spec", i.e., an alist of the form

   ((DISPLAY . ATTS)...)

where DISPLAY is a form specifying conditions to match certain
terminals and ATTS is a property list (ATTR VALUE ATTR VALUE...)
specifying face attributes and values for frames on those
terminals.  On each terminal, the first element with a matching
DISPLAY specification takes effect, and the remaining elements in
SPEC are disregarded.

As a special exception, in the first element of SPEC, DISPLAY can
be the special value ‘default’.  Then the ATTS in that element
act as defaults for all the following elements.

For backward compatibility, elements of SPEC can be written
as (DISPLAY ATTS) instead of (DISPLAY . ATTS).

Each DISPLAY can have the following values:
 - ‘default’ (only in the first element).
 - The symbol t, which matches all terminals.
 - An alist of conditions.  Each alist element must have the form
   (REQ ITEM...).  A matching terminal must satisfy each
   specified condition by matching one of its ITEMs.  Each REQ
   must be one of the following:
   - ‘type’ (the terminal type).
     Each ITEM must be one of the values returned by
     ‘window-system’.  Under X, additional allowed values are
     ‘motif’, ‘lucid’, ‘gtk’ and ‘x-toolkit’.
   - ‘class’ (the terminal’s color support).
     Each ITEM should be one of ‘color’, ‘grayscale’, or ‘mono’.
   - ‘background’ (what color is used for the background text)
     Each ITEM should be one of ‘light’ or ‘dark’.
   - ‘min-colors’ (the minimum number of supported colors)
     Each ITEM should be an integer, which is compared with the
     result of ‘display-color-cells’.
   - ‘supports’ (match terminals supporting certain attributes).
     Each ITEM should be a list of face attributes.  See
     ‘display-supports-face-attributes-p’ for more information on
     exactly how testing is done.

In the ATTS property list, possible attributes are ‘:family’,
‘:width’, ‘:height’, ‘:weight’, ‘:slant’, ‘:underline’,
‘:overline’, ‘:strike-through’, ‘:box’, ‘:foreground’,
‘:background’, ‘:stipple’, ‘:inverse-video’, and ‘:inherit’.

See Info node ‘(elisp) Faces’ in the Emacs Lisp manual for more
information.〉〉enditem49840〈〈dotimes-with-progress-reporter〉〉:〈〈Loop a certain number of times and report progress in the echo area.
Evaluate BODY with VAR bound to successive integers running from
0, inclusive, to COUNT, exclusive.  Then evaluate RESULT to get
the return value (nil if RESULT is omitted).

At each iteration MESSAGE followed by progress percentage is
printed in the echo area.  After the loop is finished, MESSAGE
followed by word "done" is printed.  This macro is a
convenience wrapper around ‘make-progress-reporter’ and friends.

(fn (VAR COUNT [RESULT]) MESSAGE BODY...)〉〉enditem49840〈〈with-current-buffer〉〉:〈〈Execute the forms in BODY with BUFFER-OR-NAME temporarily current.
BUFFER-OR-NAME must be a buffer or the name of an existing buffer.
The value returned is the value of the last form in BODY.  See
also ‘with-temp-buffer’.

(fn BUFFER-OR-NAME &rest BODY)〉〉enditem49840〈〈with-temp-buffer〉〉:〈〈Create a temporary buffer, and evaluate BODY there like ‘progn’.
See also ‘with-temp-file’ and ‘with-output-to-string’.

(fn &rest BODY)〉〉enditem49840〈〈delay-mode-hooks〉〉:〈〈Execute BODY, but delay any ‘run-mode-hooks’.
These hooks will be executed by the first following call to
‘run-mode-hooks’ that occurs outside any ‘delay-mode-hooks’ form.
Only affects hooks run in the current buffer.

(fn &rest BODY)〉〉enditem49840〈〈cl-defgeneric〉〉:〈〈Create a generic function NAME.
DOC-STRING is the base documentation for this class.  A generic
function has no body, as its purpose is to decide which method body
is appropriate to use.  Specific methods are defined with ‘cl-defmethod’.
With this implementation the ARGS are currently ignored.
OPTIONS-AND-METHODS currently understands:
- (:documentation DOCSTRING)
- (declare DECLARATIONS)
- (:argument-precedence-order &rest ARGS)
- (:method [QUALIFIERS...] ARGS &rest BODY)
DEFAULT-BODY, if present, is used as the body of a default method.

(fn NAME ARGS [DOC-STRING] [OPTIONS-AND-METHODS...] &rest DEFAULT-BODY)〉〉enditem49840〈〈cl-defmethod〉〉:〈〈Define a new method for generic function NAME.
I.e. it defines the implementation of NAME to use for invocations where the
values of the dispatch arguments match the specified TYPEs.
The dispatch arguments have to be among the mandatory arguments, and
all methods of NAME have to use the same set of arguments for dispatch.
Each dispatch argument and TYPE are specified in ARGS where the corresponding
formal argument appears as (VAR TYPE) rather than just VAR.

The optional second argument QUALIFIER is a specifier that
modifies how the method is combined with other methods, including:
   :before  - Method will be called before the primary
   :after   - Method will be called after the primary
   :around  - Method will be called around everything else
The absence of QUALIFIER means this is a "primary" method.
The set of acceptable qualifiers and their meaning is defined
(and can be extended) by the methods of ‘cl-generic-combine-methods’.

ARGS can also include so-called context specializers, introduced by
‘&context’ (which should appear right after the mandatory arguments,
before any &optional or &rest).  They have the form (EXPR TYPE) where
EXPR is an Elisp expression whose value should match TYPE for the
method to be applicable.

The set of acceptable TYPEs (also called "specializers") is defined
(and can be extended) by the various methods of ‘cl-generic-generalizers’.

	Currently supported forms for TYPE:

Support for the catch-all t specializer which always matches.

Support for (head VAL) specializers.
These match if the argument is a cons cell whose car is ‘eql’ to VAL.

Support for (eql VAL) specializers.
These match if the argument is ‘eql’ to VAL.

Support for dispatch on types defined by ‘cl-defstruct’.

Support for dispatch on builtin types.
See the full list and their hierarchy in ‘cl--generic-typeof-types’.

Support for (derived-mode MODE) specializers.
Used internally for the (major-mode MODE) context specializers.

Support for dispatch on types defined by EIEIO’s ‘defclass’.

Support for (subclass CLASS) specializers.
These match if the argument is the name of a subclass of CLASS.

(fn NAME [QUALIFIER] ARGS &rest [DOCSTRING] BODY)〉〉enditem49840〈〈gv-define-simple-setter〉〉:〈〈Define a simple setter method for generalized variable NAME.
This macro is an easy-to-use substitute for ‘gv-define-expander’ that works
well for simple place forms.  Assignments of VAL to (NAME ARGS...) are
turned into calls of the form (SETTER ARGS... VAL).

If FIX-RETURN is non-nil, then SETTER is not assumed to return VAL and
instead the assignment is turned into something equivalent to
  (let ((temp VAL))
    (SETTER ARGS... temp)
    temp)
so as to preserve the semantics of ‘setf’.

(fn NAME SETTER &optional FIX-RETURN)〉〉enditem49840〈〈gv-define-setter〉〉:〈〈Define a setter method for generalized variable NAME.
This macro is an easy-to-use substitute for ‘gv-define-expander’ that works
well for simple place forms.
Assignments of VAL to (NAME ARGS...) are expanded by binding the argument
forms (VAL ARGS...) according to ARGLIST, then executing BODY, which must
return a Lisp form that does the assignment.
The first arg in ARGLIST (the one that receives VAL) receives an expression
which can do arbitrary things, whereas the other arguments are all guaranteed
to be pure and copyable.  Example use:
  (gv-define-setter aref (v a i) `(aset ,a ,i ,v))

(fn NAME ARGLIST &rest BODY)〉〉enditem49840〈〈defmacro〉〉:〈〈Define NAME as a macro.
When the macro is called, as in (NAME ARGS...),
the function (lambda ARGLIST BODY...) is applied to
the list ARGS... as it appears in the expression,
and the result should be a form to be evaluated instead of the original.
DECL is a declaration, optional, of the form (declare DECLS...) where
DECLS is a list of elements of the form (PROP . VALUES).  These are
interpreted according to ‘macro-declarations-alist’.
The return value is undefined.

(fn NAME ARGLIST &optional DOCSTRING DECL &rest BODY)〉〉enditem49840〈〈with-file-modes〉〉:〈〈Execute BODY with default file permissions temporarily set to MODES.
MODES is as for ‘set-default-file-modes’.

(fn MODES &rest BODY)〉〉enditem49840〈〈condition-case-unless-debug〉〉:〈〈Like ‘condition-case’ except that it does not prevent debugging.
More specifically if ‘debug-on-error’ is set then the debugger will be invoked
even if this catches the signal.

(fn VAR BODYFORM &rest HANDLERS)〉〉enditem49840〈〈ignore-errors〉〉:〈〈Execute BODY; if an error occurs, return nil.
Otherwise, return result of last form in BODY.
See also ‘with-demoted-errors’ that does something similar
without silencing all errors.

(fn &rest BODY)〉〉enditem49840〈〈with-demoted-errors〉〉:〈〈Run BODY and demote any errors to simple messages.
FORMAT is a string passed to ‘message’ to format any error message.
It should contain a single %-sequence; e.g., "Error: %S".

If ‘debug-on-error’ is non-nil, run BODY without catching its errors.
This is to be used around code which is not expected to signal an error
but which should be robust in the unexpected case that an error is signaled.

For backward compatibility, if FORMAT is not a constant string, it
is assumed to be part of BODY, in which case the message format
used is "Error: %S".

(fn FORMAT &rest BODY)〉〉enditem49840〈〈easy-menu-define〉〉:〈〈Define a pop-up menu and/or menu bar menu specified by MENU.
If SYMBOL is non-nil, define SYMBOL as a function to pop up the
submenu defined by MENU, with DOC as its doc string.

MAPS, if non-nil, should be a keymap or a list of keymaps; add
the submenu defined by MENU to the keymap or each of the keymaps,
as a top-level menu bar item.

The first element of MENU must be a string.  It is the menu bar
item name.  It may be followed by the following keyword argument
pairs:

 :filter FUNCTION
    FUNCTION must be a function which, if called with one
    argument---the list of the other menu items---returns the
    items to actually display.

 :visible INCLUDE
    INCLUDE is an expression.  The menu is visible if the
    expression evaluates to a non-nil value.  ‘:included’ is an
    alias for ‘:visible’.

 :active ENABLE
    ENABLE is an expression.  The menu is enabled for selection
    if the expression evaluates to a non-nil value.  ‘:enable’ is
    an alias for ‘:active’.

The rest of the elements in MENU are menu items.
A menu item can be a vector of three elements:

  [NAME CALLBACK ENABLE]

NAME is a string--the menu item name.

CALLBACK is a command to run when the item is chosen, or an
expression to evaluate when the item is chosen.

ENABLE is an expression; the item is enabled for selection if the
expression evaluates to a non-nil value.

Alternatively, a menu item may have the form:

   [ NAME CALLBACK [ KEYWORD ARG ]... ]

where NAME and CALLBACK have the same meanings as above, and each
optional KEYWORD and ARG pair should be one of the following:

 :keys KEYS
    KEYS is a string; a keyboard equivalent to the menu item.
    This is normally not needed because keyboard equivalents are
    usually computed automatically.  KEYS is expanded with
    ‘substitute-command-keys’ before it is used.

 :key-sequence KEYS
    KEYS is a hint for speeding up Emacs’s first display of the
    menu.  It should be nil if you know that the menu item has no
    keyboard equivalent; otherwise it should be a string or
    vector specifying a keyboard equivalent for the menu item.

 :active ENABLE
    ENABLE is an expression; the item is enabled for selection
    whenever this expression’s value is non-nil.  ‘:enable’ is an
    alias for ‘:active’.

 :visible INCLUDE
    INCLUDE is an expression; this item is only visible if this
    expression has a non-nil value.  ‘:included’ is an alias for
    ‘:visible’.

 :label FORM
    FORM is an expression that is dynamically evaluated and whose
    value serves as the menu item’s label (the default is NAME).

 :suffix FORM
    FORM is an expression that is dynamically evaluated and whose
    value is concatenated with the menu entry’s label.

 :style STYLE
    STYLE is a symbol describing the type of menu item; it should
    be ‘toggle’ (a checkbox), or ‘radio’ (a radio button), or any
    other value (meaning an ordinary menu item).

 :selected SELECTED
    SELECTED is an expression; the checkbox or radio button is
    selected whenever the expression’s value is non-nil.

 :help HELP
    HELP is a string, the help to display for the menu item.

Alternatively, a menu item can be a string.  Then that string
appears in the menu as unselectable text.  A string consisting
solely of dashes is displayed as a menu separator.

Alternatively, a menu item can be a list with the same format as
MENU.  This is a submenu.

(fn SYMBOL MAPS DOC MENU)〉〉enditem49840〈〈save-window-excursion〉〉:〈〈Execute BODY, then restore previous window configuration.
This macro saves the window configuration on the selected frame,
executes BODY, then calls ‘set-window-configuration’ to restore
the saved window configuration.  The return value is the last
form in BODY.  The window configuration is also restored if BODY
exits nonlocally.

BEWARE: Most uses of this macro introduce bugs.
E.g. it should not be used to try and prevent some code from opening
a new window, since that window may sometimes appear in another frame,
in which case ‘save-window-excursion’ cannot help.

(fn &rest BODY)〉〉enditem49840〈〈iter-defun〉〉:〈〈Creates a generator NAME.
When called as a function, NAME returns an iterator value that
encapsulates the state of a computation that produces a sequence
of values.  Callers can retrieve each value using ‘iter-next’.

(fn NAME ARGLIST &rest BODY)〉〉enditem49840〈〈iter-lambda〉〉:〈〈Return a lambda generator.
‘iter-lambda’ is to ‘iter-defun’ as ‘lambda’ is to ‘defun’.

(fn ARGLIST &rest BODY)〉〉enditem49840〈〈iter-yield〉〉:〈〈When used inside a generator, yield control to caller.
The caller of ‘iter-next’ receives VALUE, and the next call to
‘iter-next’ resumes execution at the previous
‘iter-yield’ point.

(fn VALUE)〉〉enditem49840〈〈iter-yield-from〉〉:〈〈When used inside a generator function, delegate to a sub-iterator.
The values that the sub-iterator yields are passed directly to
the caller, and values supplied to ‘iter-next’ are sent to the
sub-iterator.  ‘iter-yield-from’ evaluates to the value that the
sub-iterator function returns via ‘iter-end-of-sequence’.

(fn VALUE)〉〉enditem49840〈〈iter-do〉〉:〈〈Loop over values from an iterator.
Evaluate BODY with VAR bound to each value from ITERATOR.
Return the value with which ITERATOR finished iteration.

(fn (VAR ITERATOR) &rest BODY)〉〉enditem49840〈〈setq-local〉〉:〈〈Set variable VAR to value VAL in current buffer.

(fn VAR VAL)〉〉enditem49840〈〈defvar-local〉〉:〈〈Define VAR as a buffer-local variable with default value VAL.
Like ‘defvar’ but additionally marks the variable as being automatically
buffer-local wherever it is set.

(fn VAR VAL &optional DOCSTRING)〉〉enditem49840〈〈define-generic-mode〉〉:〈〈Create a new generic mode MODE.

MODE is the name of the command for the generic mode; don’t quote it.
The optional DOCSTRING is the documentation for the mode command.  If
you do not supply it, ‘define-generic-mode’ uses a default
documentation string instead.

COMMENT-LIST is a list in which each element is either a character, a
string of one or two characters, or a cons cell.  A character or a
string is set up in the mode’s syntax table as a "comment starter".
If the entry is a cons cell, the ‘car’ is set up as a "comment
starter" and the ‘cdr’ as a "comment ender".  (Use nil for the
latter if you want comments to end at the end of the line.)  Note that
the syntax table has limitations about what comment starters and
enders are actually possible.

KEYWORD-LIST is a list of keywords to highlight with
‘font-lock-keyword-face’.  Each keyword should be a string.

FONT-LOCK-LIST is a list of additional expressions to highlight.  Each
element of this list should have the same form as an element of
‘font-lock-keywords’.

AUTO-MODE-LIST is a list of regular expressions to add to
‘auto-mode-alist’.  These regular expressions are added when Emacs
runs the macro expansion.

FUNCTION-LIST is a list of functions to call to do some additional
setup.  The mode command calls these functions just before it runs the
mode hook ‘MODE-hook’.

See the file generic-x.el for some examples of ‘define-generic-mode’.

(fn MODE COMMENT-LIST KEYWORD-LIST FONT-LOCK-LIST AUTO-MODE-LIST FUNCTION-LIST &optional DOCSTRING)〉〉enditem49840〈〈with-local-quit〉〉:〈〈Execute BODY, allowing quits to terminate BODY but not escape further.
When a quit terminates BODY, ‘with-local-quit’ returns nil but
requests another quit.  That quit will be processed as soon as quitting
is allowed once again.  (Immediately, if ‘inhibit-quit’ is nil.)

(fn &rest BODY)〉〉enditem49840〈〈dolist〉〉:〈〈:around advice: ‘cl--wrap-in-nil-block’

Loop over a list.
Evaluate BODY with VAR bound to each car from LIST, in turn.
Then evaluate RESULT to get return value, default nil.

(fn (VAR LIST [RESULT]) BODY...)〉〉enditem49840〈〈dotimes〉〉:〈〈:around advice: ‘cl--wrap-in-nil-block’

Loop a certain number of times.
Evaluate BODY with VAR bound to successive integers running from 0,
inclusive, to COUNT, exclusive.  Then evaluate RESULT to get
the return value (nil if RESULT is omitted).

(fn (VAR COUNT [RESULT]) BODY...)〉〉enditem49840〈〈save-mark-and-excursion〉〉:〈〈Like ‘save-excursion’, but also save and restore the mark state.
This macro does what ‘save-excursion’ did before Emacs 25.1.

(fn &rest BODY)〉〉enditem49840〈〈with-coding-priority〉〉:〈〈Execute BODY like ‘progn’ with CODING-SYSTEMS at the front of priority list.
CODING-SYSTEMS is a list of coding systems.  See ‘set-coding-system-priority’.
This affects the implicit sorting of lists of coding systems returned by
operations such as ‘find-coding-systems-region’.

(fn CODING-SYSTEMS &rest BODY)〉〉enditem49840〈〈defun〉〉:〈〈Define NAME as a function.
The definition is (lambda ARGLIST [DOCSTRING] BODY...).
See also the function ‘interactive’.
DECL is a declaration, optional, of the form (declare DECLS...) where
DECLS is a list of elements of the form (PROP . VALUES).  These are
interpreted according to ‘defun-declarations-alist’.
The return value is undefined.

(fn NAME ARGLIST &optional DOCSTRING DECL &rest BODY)〉〉enditem49840〈〈define-inline〉〉:〈〈Define an inline function NAME with arguments ARGS and body in BODY.

This is like ‘defmacro’, but has several advantages.
See Info node ‘(elisp)Defining Functions’ for more details.

(fn NAME ARGS &rest BODY)〉〉enditem49840〈〈define-minor-mode〉〉:〈〈Define a new minor mode MODE.
This defines the toggle command MODE and (by default) a control variable
MODE (you can override this with the :variable keyword, see below).
DOC is the documentation for the mode toggle command.

The defined mode command takes one optional (prefix) argument.
Interactively with no prefix argument, it toggles the mode.
A prefix argument enables the mode if the argument is positive,
and disables it otherwise.

When called from Lisp, the mode command toggles the mode if the
argument is ‘toggle’, disables the mode if the argument is a
non-positive integer, and enables the mode otherwise (including
if the argument is omitted or nil or a positive integer).

If DOC is nil, give the mode command a basic doc-string
documenting what its argument does.

Optional INIT-VALUE is the initial value of the mode’s variable.
Optional LIGHTER is displayed in the mode line when the mode is on.
Optional KEYMAP is the default keymap bound to the mode keymap.
  If non-nil, it should be a variable name (whose value is a keymap),
  or an expression that returns either a keymap or a list of
  (KEY . BINDING) pairs where KEY and BINDING are suitable for
  ‘define-key’.  If you supply a KEYMAP argument that is not a
  symbol, this macro defines the variable MODE-map and gives it
  the value that KEYMAP specifies.

BODY contains code to execute each time the mode is enabled or disabled.
  It is executed after toggling the mode, and before running MODE-hook.
  Before the actual body code, you can write keyword arguments, i.e.
  alternating keywords and values.  If you provide BODY, then you must
  provide (even if just nil) INIT-VALUE, LIGHTER, and KEYMAP, or provide
  at least one keyword argument, or both; otherwise, BODY would be
  misinterpreted as the first omitted argument.  The following special
  keywords are supported (other keywords are passed to ‘defcustom’ if
  the minor mode is global):

:group GROUP	Custom group name to use in all generated ‘defcustom’ forms.
		Defaults to MODE without the possible trailing "-mode".
		Don’t use this default group name unless you have written a
		‘defgroup’ to define that group properly.
:global GLOBAL	If non-nil specifies that the minor mode is not meant to be
		buffer-local, so don’t make the variable MODE buffer-local.
		By default, the mode is buffer-local.
:init-value VAL	Same as the INIT-VALUE argument.
		Not used if you also specify :variable.
:lighter SPEC	Same as the LIGHTER argument.
:keymap MAP	Same as the KEYMAP argument.
:require SYM	Same as in ‘defcustom’.
:variable PLACE	The location to use instead of the variable MODE to store
		the state of the mode.	This can be simply a different
		named variable, or a generalized variable.
		PLACE can also be of the form (GET . SET), where GET is
		an expression that returns the current state, and SET is
		a function that takes one argument, the new state, and
		sets it.  If you specify a :variable, this function does
		not define a MODE variable (nor any of the terms used
		in :variable).

:after-hook     A single lisp form which is evaluated after the mode hooks
                have been run.  It should not be quoted.

For example, you could write
  (define-minor-mode foo-mode "If enabled, foo on you!"
    :lighter " Foo" :require 'foo :global t :group 'hassle :version "27.5"
    ...BODY CODE...)〉〉enditem49840〈〈define-globalized-minor-mode〉〉:〈〈Make a global mode GLOBAL-MODE corresponding to buffer-local minor MODE.
TURN-ON is a function that will be called with no args in every buffer
  and that should try to turn MODE on if applicable for that buffer.
KEYS is a list of CL-style keyword arguments.  As the minor mode
  defined by this function is always global, any :global keyword is
  ignored.  Other keywords have the same meaning as in ‘define-minor-mode’,
  which see.  In particular, :group specifies the custom group.
  The most useful keywords are those that are passed on to the
  ‘defcustom’.  It normally makes no sense to pass the :lighter
  or :keymap keywords to ‘define-globalized-minor-mode’, since these
  are usually passed to the buffer-local version of the minor mode.

If MODE’s set-up depends on the major mode in effect when it was
enabled, then disabling and reenabling MODE should make MODE work
correctly with the current major mode.  This is important to
prevent problems with derived modes, that is, major modes that
call another major mode in their body.

When a major mode is initialized, MODE is actually turned on just
after running the major mode’s hook.  However, MODE is not turned
on if the hook has explicitly disabled it.〉〉enditem49840〈〈lazy-completion-table〉〉:〈〈Initialize variable VAR as a lazy completion table.
If the completion table VAR is used for the first time (e.g., by passing VAR
as an argument to ‘try-completion’), the function FUN is called with no
arguments.  FUN must return the completion table that will be stored in VAR.
If completion is requested in the minibuffer, FUN will be called in the buffer
from which the minibuffer was entered.  The return value of
‘lazy-completion-table’ must be used to initialize the value of VAR.

You should give VAR a non-nil ‘risky-local-variable’ property.

(fn VAR FUN)〉〉enditem49840〈〈define-obsolete-variable-alias〉〉:〈〈Make OBSOLETE-NAME a variable alias for CURRENT-NAME and mark it obsolete.
This uses ‘defvaralias’ and ‘make-obsolete-variable’ (which see).
See the Info node ‘(elisp)Variable Aliases’ for more details.

If CURRENT-NAME is a defcustom or a defvar (more generally, any variable
where OBSOLETE-NAME may be set, e.g. in an init file, before the
alias is defined), then the define-obsolete-variable-alias
statement should be evaluated before the defcustom, if user
customizations are to be respected.  The simplest way to achieve
this is to place the alias statement before the defcustom (this
is not necessary for aliases that are autoloaded, or in files
dumped with Emacs).  This is so that any user customizations are
applied before the defcustom tries to initialize the
variable (this is due to the way ‘defvaralias’ works).

If provided, WHEN should be a string indicating when the variable
was first made obsolete, for example a date or a release number.

For the benefit of ‘custom-set-variables’, if OBSOLETE-NAME has
any of the following properties, they are copied to
CURRENT-NAME, if it does not already have them:
‘saved-value’, ‘saved-variable-comment’.

(fn OBSOLETE-NAME CURRENT-NAME &optional WHEN DOCSTRING)〉〉enditem49840〈〈save-selected-window〉〉:〈〈Execute BODY, then select the previously selected window.
The value returned is the value of the last form in BODY.

This macro saves and restores the selected window, as well as the
selected window in each frame.  If the previously selected window
is no longer live, then whatever window is selected at the end of
BODY remains selected.  If the previously selected window of some
frame is no longer live at the end of BODY, that frame’s selected
window is left alone.

This macro saves and restores the current buffer, since otherwise
its normal operation could make a different buffer current.  The
order of recently selected windows and the buffer list ordering
are not altered by this macro (unless they are altered in BODY).

(fn &rest BODY)〉〉enditem49840〈〈with-selected-window〉〉:〈〈Execute the forms in BODY with WINDOW as the selected window.
The value returned is the value of the last form in BODY.

This macro saves and restores the selected window, as well as the
selected window of each frame.  It does not change the order of
recently selected windows.  If the previously selected window of
some frame is no longer live at the end of BODY, that frame’s
selected window is left alone.  If the selected window is no
longer live, then whatever window is selected at the end of BODY
remains selected.

This macro uses ‘save-current-buffer’ to save and restore the
current buffer, since otherwise its normal operation could
potentially make a different buffer current.  It does not alter
the buffer list ordering.

(fn WINDOW &rest BODY)〉〉enditem49840〈〈declare〉〉:〈〈:after advice: ‘cl--pass-args-to-cl-declare’

Do not evaluate any arguments, and return nil.
If a ‘declare’ form appears as the first form in the body of a
‘defun’ or ‘defmacro’ form, SPECS specifies various additional
information about the function or macro; these go into effect
during the evaluation of the ‘defun’ or ‘defmacro’ form.

The possible values of SPECS are specified by
‘defun-declarations-alist’ and ‘macro-declarations-alist’.

For more information, see info node ‘(elisp)Declare Form’.

(fn &rest SPECS)〉〉enditem49840〈〈with-help-window〉〉:〈〈Evaluate BODY, send output to BUFFER-OR-NAME and show in a help window.
This construct is like ‘with-temp-buffer-window’ but unlike that
puts the buffer specified by BUFFER-OR-NAME in ‘help-mode’ and
displays a message about how to delete the help window when it’s no
longer needed.  The help window will be selected if
‘help-window-select’ is non-nil.
Most of this  is done by ‘help-window-setup’, which see.〉〉enditem49840〈〈define-derived-mode〉〉:〈〈Create a new mode as a variant of an existing mode.

The arguments to this command are as follow:

CHILD:     the name of the command for the derived mode.
PARENT:    the name of the command for the parent mode (e.g. ‘text-mode’)
           or nil if there is no parent.
NAME:      a string which will appear in the status line (e.g. "Hypertext")
DOCSTRING: an optional documentation string--if you do not supply one,
           the function will attempt to invent something useful.
BODY:      forms to execute just before running the
           hooks for the new mode.  Do not use ‘interactive’ here.

BODY can start with a bunch of keyword arguments.  The following keyword
  arguments are currently understood:
:group GROUP
	Declare the customization group that corresponds to this mode.
	The command ‘customize-mode’ uses this.
:syntax-table TABLE
	Use TABLE instead of the default (CHILD-syntax-table).
	A nil value means to simply use the same syntax-table as the parent.
:abbrev-table TABLE
	Use TABLE instead of the default (CHILD-abbrev-table).
	A nil value means to simply use the same abbrev-table as the parent.
:after-hook FORM
	A single lisp form which is evaluated after the mode hooks have been
	run.  It should not be quoted.

Here is how you could define LaTeX-Thesis mode as a variant of LaTeX mode:

  (define-derived-mode LaTeX-thesis-mode LaTeX-mode "LaTeX-Thesis")

You could then make new key bindings for ‘LaTeX-thesis-mode-map’
without changing regular LaTeX mode.  In this example, BODY is empty,
and DOCSTRING is generated by default.

On a more complicated level, the following command uses ‘sgml-mode’ as
the parent, and then sets the variable ‘case-fold-search’ to nil:

  (define-derived-mode article-mode sgml-mode "Article"
    "Major mode for editing technical articles."
    (setq case-fold-search nil))

Note that if the documentation string had been left out, it would have
been generated automatically, with a reference to the keymap.

The new mode runs the hook constructed by the function
‘derived-mode-hook-name’.

See Info node ‘(elisp)Derived Modes’ for more details.〉〉enditem49840〈〈when〉〉:〈〈If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.

(fn COND BODY...)〉〉enditem49840〈〈unless〉〉:〈〈If COND yields nil, do BODY, else return nil.
When COND yields nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.

(fn COND BODY...)〉〉enditem49840〈〈combine-after-change-calls〉〉:〈〈Execute BODY, but don’t call the after-change functions till the end.
If BODY makes changes in the buffer, they are recorded
and the functions on ‘after-change-functions’ are called several times
when BODY is finished.
The return value is the value of the last form in BODY.

If ‘before-change-functions’ is non-nil, then calls to the after-change
functions can’t be deferred, so in that case this macro has no effect.

Do not alter ‘after-change-functions’ or ‘before-change-functions’
in BODY.

(fn &rest BODY)〉〉enditem49840〈〈with-case-table〉〉:〈〈Execute the forms in BODY with TABLE as the current case table.
The value returned is the value of the last form in BODY.

(fn TABLE &rest BODY)〉〉enditem49840〈〈define-obsolete-face-alias〉〉:〈〈Make OBSOLETE-FACE a face alias for CURRENT-FACE and mark it obsolete.
If provided, WHEN should be a string indicating when the face
was first made obsolete, for example a date or a release number.

(fn OBSOLETE-FACE CURRENT-FACE WHEN)〉〉enditem49840〈〈noreturn〉〉:〈〈Evaluate FORM, expecting it not to return.
If FORM does return, signal an error.

(fn FORM)〉〉enditem49840〈〈def-edebug-spec〉〉:〈〈Set the ‘edebug-form-spec’ property of SYMBOL according to SPEC.
Both SYMBOL and SPEC are unevaluated.  The SPEC can be:
0 (instrument no arguments); t (instrument all arguments);
a symbol (naming a function with an Edebug specification); or a list.
The elements of the list describe the argument types; see
Info node ‘(elisp)Specification List’ for details.

(fn SYMBOL SPEC)〉〉enditem49840〈〈while-no-input〉〉:〈〈Execute BODY only as long as there’s no pending input.
If input arrives, that ends the execution of BODY,
and ‘while-no-input’ returns t.  Quitting makes it return nil.
If BODY finishes, ‘while-no-input’ returns whatever value BODY produced.

(fn &rest BODY)〉〉enditem49840〈〈define-advice〉〉:〈〈Define an advice and add it to function named SYMBOL.
See ‘advice-add’ and ‘add-function’ for explanation on the
arguments.  Note if NAME is nil the advice is anonymous;
otherwise it is named ‘SYMBOL@NAME’.

(fn SYMBOL (WHERE LAMBDA-LIST &optional NAME DEPTH) &rest BODY)〉〉enditem49840〈〈add-function〉〉:〈〈Add a piece of advice on the function stored at PLACE.
FUNCTION describes the code to add.  WHERE describes where to add it.
WHERE can be explained by showing the resulting new function, as the
result of combining FUNCTION and the previous value of PLACE, which we
call OLDFUN here:
‘:before’	(lambda (&rest r) (apply FUNCTION r) (apply OLDFUN r))
‘:after’	(lambda (&rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))
‘:around’	(lambda (&rest r) (apply FUNCTION OLDFUN r))
‘:override’	(lambda (&rest r) (apply FUNCTION r))
‘:before-while’	(lambda (&rest r) (and (apply FUNCTION r) (apply OLDFUN r)))
‘:before-until’	(lambda (&rest r) (or  (apply FUNCTION r) (apply OLDFUN r)))
‘:after-while’	(lambda (&rest r) (and (apply OLDFUN r) (apply FUNCTION r)))
‘:after-until’	(lambda (&rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))
‘:filter-args’	(lambda (&rest r) (apply OLDFUN (funcall FUNCTION r)))
‘:filter-return’(lambda (&rest r) (funcall FUNCTION (apply OLDFUN r)))
If FUNCTION was already added, do nothing.
PROPS is an alist of additional properties, among which the following have
a special meaning:
- ‘name’: a string or symbol.  It can be used to refer to this piece of advice.
- ‘depth’: a number indicating a preference w.r.t ordering.
  The default depth is 0.  By convention, a depth of 100 means that
  the advice  should be innermost (i.e. at the end of the list),
  whereas a depth of -100 means that the advice should be outermost.

If PLACE is a symbol, its ‘default-value’ will be affected.
Use (local 'SYMBOL) if you want to apply FUNCTION to SYMBOL buffer-locally.
Use (var VAR) if you want to apply FUNCTION to the (lexical) VAR.
If you are trying to modify an existing named function rather
than a function value, you probably want to use ‘advice-add’
instead (see Info node ‘(elisp) Advising Named Functions’).

If one of FUNCTION or OLDFUN is interactive, then the resulting function
is also interactive.  There are 3 cases:
- FUNCTION is not interactive: the interactive spec of OLDFUN is used.
- The interactive spec of FUNCTION is itself a function: it should take one
  argument (the interactive spec of OLDFUN, which it can pass to
  ‘advice-eval-interactive-spec’) and return the list of arguments to use.
- Else, use the interactive spec of FUNCTION and ignore the one of OLDFUN.

(fn WHERE PLACE FUNCTION &optional PROPS)〉〉enditem49840〈〈remove-function〉〉:〈〈Remove the FUNCTION piece of advice from PLACE.
If FUNCTION was not added to PLACE, do nothing.
Instead of FUNCTION being the actual function, it can also be the ‘name’
of the piece of advice.

(fn PLACE FUNCTION)〉〉enditem49840〈〈lambda〉〉:〈〈Return a lambda expression.
A call of the form (lambda ARGS DOCSTRING INTERACTIVE BODY) is
self-quoting; the result of evaluating the lambda expression is the
expression itself.  The lambda expression may then be treated as a
function, i.e., stored as the function value of a symbol, passed to
‘funcall’ or ‘mapcar’, etc.

ARGS should take the same form as an argument list for a ‘defun’.
DOCSTRING is an optional documentation string.
 If present, it should describe how to call the function.
 But documentation strings are usually not useful in nameless functions.
INTERACTIVE should be a call to the function ‘interactive’, which see.
It may also be omitted.
BODY should be a list of Lisp expressions.

(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)〉〉enditem49840〈〈define-obsolete-function-alias〉〉:〈〈Set OBSOLETE-NAME’s function definition to CURRENT-NAME and mark it obsolete.

(define-obsolete-function-alias 'old-fun 'new-fun "22.1" "old-fun’s doc.")

is equivalent to the following two lines of code:

(defalias 'old-fun 'new-fun "old-fun’s doc.")
(make-obsolete 'old-fun 'new-fun "22.1")

If provided, WHEN should be a string indicating when the function
was first made obsolete, for example a date or a release number.

See the docstrings of ‘defalias’ and ‘make-obsolete’ for more details.

(fn OBSOLETE-NAME CURRENT-NAME &optional WHEN DOCSTRING)〉〉enditem49840〈〈with-temp-file〉〉:〈〈Create a new buffer, evaluate BODY there, and write the buffer to FILE.
The value returned is the value of the last form in BODY.
See also ‘with-temp-buffer’.

(fn FILE &rest BODY)〉〉enditem49840〈〈defgroup〉〉:〈〈Declare SYMBOL as a customization group containing MEMBERS.
SYMBOL does not need to be quoted.

Third argument DOC is the group documentation.  This should be a short
description of the group, beginning with a capital and ending with
a period.  Words other than the first should not be capitalized, if they
are not usually written so.

MEMBERS should be an alist of the form ((NAME WIDGET)...) where
NAME is a symbol and WIDGET is a widget for editing that symbol.
Useful widgets are ‘custom-variable’ for editing variables,
‘custom-face’ for editing faces, and ‘custom-group’ for editing groups.

The remaining arguments should have the form

   [KEYWORD VALUE]...

For a list of valid keywords, see the common keywords listed in
‘defcustom’.

See Info node ‘(elisp) Customization’ in the Emacs Lisp manual
for more information.〉〉enditem49840〈〈with-timeout〉〉:〈〈Run BODY, but if it doesn’t finish in SECONDS seconds, give up.
If we give up, we run the TIMEOUT-FORMS and return the value of the last one.
The timeout is checked whenever Emacs waits for some kind of external
event (such as keyboard input, input from subprocesses, or a certain time);
if the program loops without waiting in any way, the timeout will not
be detected.

(fn (SECONDS TIMEOUT-FORMS...) BODY)〉〉enditem49840〈〈catch〉〉:〈〈Eval BODY allowing nonlocal exits using ‘throw’.
TAG is evalled to get the tag to use; it must not be nil.

Then the BODY is executed.
Within BODY, a call to ‘throw’ with the same TAG exits BODY and this ‘catch’.
If no throw happens, ‘catch’ returns the value of the last BODY form.
If a throw happens, it specifies the value to return from ‘catch’.

(fn TAG BODY...)〉〉enditem49840〈〈function〉〉:〈〈Like ‘quote’, but preferred for objects which are functions.
In byte compilation, ‘function’ causes its argument to be compiled.
‘quote’ cannot do that.

(fn ARG)〉〉enditem49840〈〈setq〉〉:〈〈Set each SYM to the value of its VAL.
The symbols SYM are variables; they are literal (not evaluated).
The values VAL are expressions; they are evaluated.
Thus, (setq x (1+ y)) sets ‘x’ to the value of ‘(1+ y)’.
The second VAL is not computed until after the first SYM is set, and so on;
each VAL can use the new value of variables set earlier in the ‘setq’.
The return value of the ‘setq’ form is the value of the last VAL.

(fn [SYM VAL]...)〉〉enditem49840〈〈eval-and-compile〉〉:〈〈Like ‘progn’, but evaluates the body at compile time and at
load time.  In interpreted code, this is entirely equivalent to
‘progn’, except that the value of the expression may be (but is
not necessarily) computed at load time if eager macro expansion
is enabled.

(fn &rest BODY)〉〉enditem49840〈〈eval-when-compile〉〉:〈〈Like ‘progn’, but evaluates the body at compile time if you’re compiling.
Thus, the result of the body appears to the compiler as a quoted
constant.  In interpreted code, this is entirely equivalent to
‘progn’, except that the value of the expression may be (but is
not necessarily) computed at load time if eager macro expansion
is enabled.

(fn &rest BODY)〉〉enditem49840〈〈defvar〉〉:〈〈Define SYMBOL as a variable, and return SYMBOL.
You are not required to define a variable in order to use it, but
defining it lets you supply an initial value and documentation, which
can be referred to by the Emacs help facilities and other programming
tools.  The ‘defvar’ form also declares the variable as "special",
so that it is always dynamically bound even if ‘lexical-binding’ is t.

If SYMBOL’s value is void and the optional argument INITVALUE is
provided, INITVALUE is evaluated and the result used to set SYMBOL’s
value.  If SYMBOL is buffer-local, its default value is what is set;
buffer-local values are not affected.  If INITVALUE is missing,
SYMBOL’s value is not set.

If SYMBOL has a local binding, then this form affects the local
binding.  This is usually not what you want.  Thus, if you need to
load a file defining variables, with this form or with ‘defconst’ or
‘defcustom’, you should always load that file _outside_ any bindings
for these variables.  (‘defconst’ and ‘defcustom’ behave similarly in
this respect.)

The optional argument DOCSTRING is a documentation string for the
variable.

To define a user option, use ‘defcustom’ instead of ‘defvar’.

(fn SYMBOL &optional INITVALUE DOCSTRING)〉〉enditem49840〈〈defconst〉〉:〈〈Define SYMBOL as a constant variable.
This declares that neither programs nor users should ever change the
value.  This constancy is not actually enforced by Emacs Lisp, but
SYMBOL is marked as a special variable so that it is never lexically
bound.

The ‘defconst’ form always sets the value of SYMBOL to the result of
evalling INITVALUE.  If SYMBOL is buffer-local, its default value is
what is set; buffer-local values are not affected.  If SYMBOL has a
local binding, then this form sets the local binding’s value.
However, you should normally not make local bindings for variables
defined with this form.

The optional DOCSTRING specifies the variable’s documentation string.

(fn SYMBOL INITVALUE [DOCSTRING])〉〉enditem49840〈〈if〉〉:〈〈If COND yields non-nil, do THEN, else do ELSE...
Returns the value of THEN or the value of the last of the ELSE’s.
THEN must be one expression, but ELSE... can be zero or more expressions.
If COND yields nil, and there are no ELSE’s, the value is nil.

(fn COND THEN ELSE...)〉〉enditem49840〈〈cond〉〉:〈〈Try each clause until one succeeds.
Each clause looks like (CONDITION BODY...).  CONDITION is evaluated
and, if the value is non-nil, this clause succeeds:
then the expressions in BODY are evaluated and the last one’s
value is the value of the cond-form.
If a clause has one element, as in (CONDITION), then the cond-form
returns CONDITION’s value, if that is non-nil.
If no clause succeeds, cond returns nil.

(fn CLAUSES...)〉〉enditem49840〈〈track-mouse〉〉:〈〈Evaluate BODY with mouse movement events enabled.
Within a ‘track-mouse’ form, mouse motion generates input events that
 you can read with ‘read-event’.
Normally, mouse motion is ignored.

(fn &rest BODY)〉〉enditem49840〈〈save-restriction〉〉:〈〈Execute BODY, saving and restoring current buffer’s restrictions.
The buffer’s restrictions make parts of the beginning and end invisible.
(They are set up with ‘narrow-to-region’ and eliminated with ‘widen’.)
This special form, ‘save-restriction’, saves the current buffer’s restrictions
when it is entered, and restores them when it is exited.
So any ‘narrow-to-region’ within BODY lasts only until the end of the form.
The old restrictions settings are restored
even in case of abnormal exit (throw or error).

The value returned is the value of the last form in BODY.

Note: if you are using both ‘save-excursion’ and ‘save-restriction’,
use ‘save-excursion’ outermost:
    (save-excursion (save-restriction ...))

(fn &rest BODY)〉〉enditem49840〈〈with-no-warnings〉〉:〈〈Like ‘progn’, but prevents compiler warnings in the body.

(fn &rest BODY)〉〉enditem49840〈〈interactive〉〉:〈〈Specify a way of parsing arguments for interactive use of a function.
For example, write
 (defun foo (arg buf) "Doc string" (interactive "P\nbbuffer: ") .... )
 to make ARG be the raw prefix argument, and set BUF to an existing buffer,
 when ‘foo’ is called as a command.

The "call" to ‘interactive’ is actually a declaration rather than a
 function; it tells ‘call-interactively’ how to read arguments to pass
 to the function.  When actually called, ‘interactive’ just returns
 nil.

Usually the argument of ‘interactive’ is a string containing a code
 letter followed optionally by a prompt.  (Some code letters do not
 use I/O to get the argument and do not use prompts.)  To pass several
 arguments to the command, concatenate the individual strings,
 separating them by newline characters.

Prompts are passed to ‘format’, and may use % escapes to print the
 arguments that have already been read.
If the argument is not a string, it is evaluated to get a list of
 arguments to pass to the command.
Just ‘(interactive)’ means pass no arguments to the command when
 calling interactively.

Code letters available are:
a -- Function name: symbol with a function definition.
b -- Name of existing buffer.
B -- Name of buffer, possibly nonexistent.
c -- Character (no input method is used).
C -- Command name: symbol with interactive function definition.
d -- Value of point as number.  Does not do I/O.
D -- Directory name.
e -- Parameterized event (i.e., one that’s a list) that invoked this command.
     If used more than once, the Nth ‘e’ returns the Nth parameterized event.
     This skips events that are integers or symbols.
f -- Existing file name.
F -- Possibly nonexistent file name.
G -- Possibly nonexistent file name, defaulting to just directory name.
i -- Ignored, i.e. always nil.  Does not do I/O.
k -- Key sequence (downcase the last event if needed to get a definition).
K -- Key sequence to be redefined (do not downcase the last event).
m -- Value of mark as number.  Does not do I/O.
M -- Any string.  Inherits the current input method.
n -- Number read using minibuffer.
N -- Numeric prefix arg, or if none, do like code ‘n’.
p -- Prefix arg converted to number.  Does not do I/O.
P -- Prefix arg in raw form.  Does not do I/O.
r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.
s -- Any string.  Does not inherit the current input method.
S -- Any symbol.
U -- Mouse up event discarded by a previous k or K argument.
v -- Variable name: symbol that is ‘custom-variable-p’.
x -- Lisp expression read but not evaluated.
X -- Lisp expression read and evaluated.
z -- Coding system.
Z -- Coding system, nil if no prefix arg.

In addition, if the string begins with ‘*’, an error is signaled if
  the buffer is read-only.
If ‘@’ appears at the beginning of the string, and if the key sequence
 used to invoke the command includes any mouse events, then the window
 associated with the first of those events is selected before the
 command is run.
If the string begins with ‘^’ and ‘shift-select-mode’ is non-nil,
 Emacs first calls the function ‘handle-shift-selection’.
You may use ‘@’, ‘*’, and ‘^’ together.  They are processed in the
 order that they appear, before reading any arguments.

(fn &optional ARG-DESCRIPTOR)〉〉enditem49840〈〈save-excursion〉〉:〈〈Save point, and current buffer; execute BODY; restore those things.
Executes BODY just like ‘progn’.
The values of point and the current buffer are restored
even in case of abnormal exit (throw or error).

If you only want to save the current buffer but not point,
then just use ‘save-current-buffer’, or even ‘with-current-buffer’.

Before Emacs 25.1, ‘save-excursion’ used to save the mark state.
To save the mark state as well as point and the current buffer, use
‘save-mark-and-excursion’.

(fn &rest BODY)〉〉enditem49840〈〈while〉〉:〈〈If TEST yields non-nil, eval BODY... and repeat.
The order of execution is thus TEST, BODY, TEST, BODY and so on
until TEST returns nil.

(fn TEST BODY...)〉〉enditem49840〈〈condition-case〉〉:〈〈Regain control when an error is signaled.
Executes BODYFORM and returns its value if no error happens.
Each element of HANDLERS looks like (CONDITION-NAME BODY...)
where the BODY is made of Lisp expressions.

A handler is applicable to an error
if CONDITION-NAME is one of the error’s condition names.
If an error happens, the first applicable handler is run.

The car of a handler may be a list of condition names instead of a
single condition name; then it handles all of them.  If the special
condition name ‘debug’ is present in this list, it allows another
condition in the list to run the debugger if ‘debug-on-error’ and the
other usual mechanisms says it should (otherwise, ‘condition-case’
suppresses the debugger).

When a handler handles an error, control returns to the ‘condition-case’
and it executes the handler’s BODY...
with VAR bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.
(If VAR is nil, the handler can’t access that information.)
Then the value of the last BODY form is returned from the ‘condition-case’
expression.

See also the function ‘signal’ for more info.

(fn VAR BODYFORM &rest HANDLERS)〉〉enditem49840〈〈quote〉〉:〈〈Return the argument, without evaluating it.  ‘(quote x)’ yields ‘x’.
Warning: ‘quote’ does not construct its return value, but just returns
the value that was pre-constructed by the Lisp reader (see info node
‘(elisp)Printed Representation’).
This means that '(a . b) is not identical to (cons 'a 'b): the former
does not cons.  Quoting should be reserved for constants that will
never be modified by side-effects, unless you like self-modifying code.
See the common pitfall in info node ‘(elisp)Rearrangement’ for an example
of unexpected results when a quoted object is modified.

(fn ARG)〉〉enditem49840〈〈save-current-buffer〉〉:〈〈Record which buffer is current; execute BODY; make that buffer current.
BODY is executed just like ‘progn’.

(fn &rest BODY)〉〉enditem49840〈〈let〉〉:〈〈Bind variables according to VARLIST then eval BODY.
The value of the last form in BODY is returned.
Each element of VARLIST is a symbol (which is bound to nil)
or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
All the VALUEFORMs are evalled before any symbols are bound.

(fn VARLIST BODY...)〉〉enditem49840〈〈let*〉〉:〈〈Bind variables according to VARLIST then eval BODY.
The value of the last form in BODY is returned.
Each element of VARLIST is a symbol (which is bound to nil)
or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).
Each VALUEFORM can refer to the symbols already bound by this VARLIST.

(fn VARLIST BODY...)〉〉enditem49840〈〈and〉〉:〈〈Eval args until one of them yields nil, then return nil.
The remaining args are not evalled at all.
If no arg yields nil, return the last arg’s value.

(fn CONDITIONS...)〉〉enditem49840〈〈or〉〉:〈〈Eval args until one of them yields non-nil, then return that value.
The remaining args are not evalled at all.
If all args return nil, return nil.

(fn CONDITIONS...)〉〉enditem49840〈〈setq-default〉〉:〈〈Set the default value of variable VAR to VALUE.
VAR, the variable name, is literal (not evaluated);
VALUE is an expression: it is evaluated and its value returned.
The default value of a variable is seen in buffers
that do not have their own values for the variable.

More generally, you can use multiple variables and values, as in
  (setq-default VAR VALUE VAR VALUE...)
This sets each VAR’s default value to the corresponding VALUE.
The VALUE for the Nth VAR can refer to the new default values
of previous VARs.

(fn [VAR VALUE]...)〉〉enditem49840〈〈unwind-protect〉〉:〈〈Do BODYFORM, protecting with UNWINDFORMS.
If BODYFORM completes normally, its value is returned
after executing the UNWINDFORMS.
If BODYFORM exits nonlocally, the UNWINDFORMS are executed anyway.

(fn BODYFORM UNWINDFORMS...)〉〉enditem49840〈〈progn〉〉:〈〈Eval BODY forms sequentially and return value of last one.

(fn BODY...)〉〉enditem49840〈〈prog1〉〉:〈〈Eval FIRST and BODY sequentially; return value from FIRST.
The value of FIRST is saved during the evaluation of the remaining args,
whose values are discarded.

(fn FIRST BODY...)〉〉enditem49840〈〈prog2〉〉:〈〈Eval FORM1, FORM2 and BODY sequentially; return value from FORM2.
The value of FORM2 is saved during the evaluation of the
remaining args, whose values are discarded.

(fn FORM1 FORM2 BODY...)〉〉enditem49840〈〈2C-associate-buffer〉〉:〈〈Associate another buffer with this one in two-column minor mode.
Can also be used to associate a just previously visited file, by
accepting the proposed default buffer.

(See  C-h m .)

(fn)〉〉enditem49840〈〈2C-split〉〉:〈〈Split a two-column text at point, into two buffers in two-column minor mode.
Point becomes the local value of ‘2C-window-width’.  Only lines that
have the ARG same preceding characters at that column get split.  The
ARG preceding characters without any leading whitespace become the local
value for ‘2C-separator’.  This way lines that continue across both
columns remain untouched in the first buffer.

This function can be used with a prototype line, to set up things.  You
write the first line of each column and then split that line.  E.g.:

First column’s text    sSs  Second column’s text
		       \___/\
			/    \
   5 character Separator      You type  M-5 M-x 2C-split  with the point here.

(See  C-h m .)

(fn ARG)〉〉enditem49840〈〈2C-two-columns〉〉:〈〈Split current window vertically for two-column editing.
When called the first time, associates a buffer with the current
buffer in two-column minor mode (use C-h m once in the mode,
for details.).  It runs ‘2C-other-buffer-hook’ in the new buffer.
When called again, restores the screen layout with the current buffer
first and the associated buffer to its right.

(fn &optional BUFFER)〉〉enditem49840〈〈5x5〉〉:〈〈Play 5x5.

The object of 5x5 is very simple, by moving around the grid and flipping
squares you must fill the grid.

5x5 keyboard bindings are:

Uses keymap ‘5x5-mode-map’, which is not currently defined.

Flip                        M-x 5x5-flip-current
Move up                     M-x 5x5-up
Move down                   M-x 5x5-down
Move left                   M-x 5x5-left
Move right                  M-x 5x5-right
Start new game              M-x 5x5-new-game
New game with random grid   M-x 5x5-randomize
Random cracker              M-x 5x5-crack-randomly
Mutate current cracker      M-x 5x5-crack-mutating-current
Mutate best cracker         M-x 5x5-crack-mutating-best
Mutate xor cracker          M-x 5x5-crack-xor-mutate
Solve with Calc             M-x 5x5-solve-suggest
Rotate left Calc Solutions  M-x 5x5-solve-rotate-left
Rotate right Calc Solutions M-x 5x5-solve-rotate-right
Quit current game           M-x 5x5-quit-game

(fn &optional SIZE)〉〉enditem49840〈〈Buffer-menu-1-window〉〉:〈〈Select this line’s buffer, alone, in full frame.〉〉enditem49840〈〈Buffer-menu-2-window〉〉:〈〈Select this line’s buffer, with previous buffer in second window.〉〉enditem49840〈〈Buffer-menu-backup-unmark〉〉:〈〈Move up and cancel all requested operations on buffer on line above.〉〉enditem49840〈〈Buffer-menu-bury〉〉:〈〈Bury the buffer listed on this line.〉〉enditem49840〈〈Buffer-menu-delete-backwards〉〉:〈〈Mark the buffer on this Buffer Menu line for deletion, and move up.
A subsequent ‘x’
command will delete the marked buffer.  Prefix ARG means move
that many lines.

(fn &optional ARG)〉〉enditem49840〈〈Buffer-menu-delete〉〉:〈〈Mark the buffer on this Buffer Menu buffer line for deletion.
A subsequent ‘x’ command
will delete it.

If prefix argument ARG is non-nil, it specifies the number of
buffers to delete; a negative ARG means to delete backwards.

(fn &optional ARG)〉〉enditem49840〈〈Buffer-menu-execute〉〉:〈〈Save and/or delete marked buffers in the Buffer Menu.
Buffers marked with ‘s’ are saved.
Buffers marked with ‘C-k’ are deleted.〉〉enditem49840〈〈Buffer-menu-mark〉〉:〈〈Mark the Buffer menu entry at point for later display.
It will be displayed by the v command.〉〉enditem49840〈〈Buffer-menu-not-modified〉〉:〈〈Mark the buffer on this line as unmodified (no changes to save).
If ARG is non-nil (interactively, with a prefix argument), mark
it as modified.

(fn &optional ARG)〉〉enditem49840〈〈Buffer-menu-other-window〉〉:〈〈Select this line’s buffer in other window, leaving buffer menu visible.〉〉enditem49840〈〈Buffer-menu-save〉〉:〈〈Mark the buffer on this Buffer Menu line for saving.
A subsequent ‘x’ command
will save it.〉〉enditem49840〈〈Buffer-menu-select〉〉:〈〈Select this line’s buffer; also, display buffers marked with ‘>’.
You can mark buffers with the ‘m’ command.
This command deletes and replaces all the previously existing windows
in the selected frame.〉〉enditem49840〈〈Buffer-menu-switch-other-window〉〉:〈〈Make the other window select this line’s buffer.
The current window remains selected.〉〉enditem49840〈〈Buffer-menu-this-window〉〉:〈〈Select this line’s buffer in this window.〉〉enditem49840〈〈Buffer-menu-toggle-files-only〉〉:〈〈Toggle whether the current buffer-menu displays only file buffers.
With a positive ARG, display only file buffers.  With zero or
negative ARG, display other buffers as well.

(fn ARG)〉〉enditem49840〈〈Buffer-menu-toggle-read-only〉〉:〈〈Toggle read-only status of buffer on this line.
This behaves like invoking DEL n p in that buffer.〉〉enditem49840〈〈Buffer-menu-unmark〉〉:〈〈Cancel all requested operations on buffer on this line and move down.
Optional prefix arg means move up.

(fn &optional BACKUP)〉〉enditem49840〈〈Buffer-menu-visit-tags-table〉〉:〈〈Visit the tags table in the buffer on this line.  See ‘visit-tags-table’.〉〉enditem49840〈〈Control-X-prefix〉〉:〈〈Prefix command (definition is a keymap associating keystrokes with commands).〉〉enditem49840〈〈Custom-save〉〉:〈〈Set all edited settings, then save all settings that have been set.
If a setting was edited and set before, this saves it.  If a
setting was merely edited before, this sets it then saves it.

(fn &rest IGNORE)〉〉enditem49840〈〈Custom-set〉〉:〈〈Set the current value of all edited settings in the buffer.

(fn &rest IGNORE)〉〉enditem49840〈〈Info-goto-emacs-command-node〉〉:〈〈Go to the Info node in the Emacs manual for command COMMAND.
The command is found by looking up in Emacs manual’s indices
or in another manual found via COMMAND’s ‘info-file’ property or
the variable ‘Info-file-list-for-emacs’.
COMMAND must be a symbol or string.

(fn COMMAND)〉〉enditem49840〈〈Info-goto-emacs-key-command-node〉〉:〈〈Go to the node in the Emacs manual which describes the command bound to KEY.
KEY is a string.
Interactively, if the binding is ‘execute-extended-command’, a command is read.
The command is found by looking up in Emacs manual’s indices
or in another manual found via COMMAND’s ‘info-file’ property or
the variable ‘Info-file-list-for-emacs’.

(fn KEY)〉〉enditem49840〈〈abbrev-mode〉〉:〈〈Toggle Abbrev mode in the current buffer.
With a prefix argument ARG, enable Abbrev mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Abbrev mode if ARG is omitted or nil.

In Abbrev mode, inserting an abbreviation causes it to expand and
be replaced by its expansion.

(fn &optional ARG)〉〉enditem49840〈〈add-change-log-entry-other-window〉〉:〈〈Find change log file in other window and add entry and item.
This is just like ‘add-change-log-entry’ except that it displays
the change log file in another window.

(fn &optional WHOAMI FILE-NAME)〉〉enditem49840〈〈add-dir-local-variable〉〉:〈〈Add directory-local VARIABLE with its VALUE and MODE to .dir-locals.el.

(fn MODE VARIABLE VALUE)〉〉enditem49840〈〈add-file-local-variable-prop-line〉〉:〈〈Add file-local VARIABLE with its VALUE to the -*- line.

This command deletes all existing settings of VARIABLE (except ‘mode’
and ‘eval’) and adds a new file-local VARIABLE with VALUE to
the -*- line.

If there is no -*- line at the beginning of the current file buffer
then this function adds it.

(fn VARIABLE VALUE &optional INTERACTIVE)〉〉enditem49840〈〈add-file-local-variable〉〉:〈〈Add file-local VARIABLE with its VALUE to the Local Variables list.

This command deletes all existing settings of VARIABLE (except ‘mode’
and ‘eval’) and adds a new file-local VARIABLE with VALUE to the
Local Variables list.

If there is no Local Variables list in the current file buffer
then this function adds the first line containing the string
‘Local Variables:’ and the last line containing the string ‘End:’.

(fn VARIABLE VALUE &optional INTERACTIVE)〉〉enditem49840〈〈add-global-abbrev〉〉:〈〈Define global (all modes) abbrev for last word(s) before point.
The prefix argument specifies the number of words before point that form the
expansion; or zero means the region is the expansion.
A negative argument means to undefine the specified abbrev.
This command uses the minibuffer to read the abbreviation.

Don’t use this function in a Lisp program; use ‘define-abbrev’ instead.

(fn ARG)〉〉enditem49840〈〈add-mode-abbrev〉〉:〈〈Define mode-specific abbrev for last word(s) before point.
Argument is how many words before point form the expansion;
or zero means the region is the expansion.
A negative argument means to undefine the specified abbrev.
Reads the abbreviation in the minibuffer.

Don’t use this function in a Lisp program; use ‘define-abbrev’ instead.

(fn ARG)〉〉enditem49840〈〈animate-birthday-present〉〉:〈〈Return a birthday present in the buffer *Birthday-Present*.
When optional arg NAME is non-nil or called-interactively, prompt for
NAME of birthday present receiver and return a birthday present in
the buffer *Birthday-Present-for-Name*.

(fn &optional NAME)〉〉enditem49840〈〈append-next-kill〉〉:〈〈Cause following command, if it kills, to add to previous kill.
If the next command kills forward from point, the kill is
appended to the previous killed text.  If the command kills
backward, the kill is prepended.  Kill commands that act on the
region, such as ‘kill-region’, are regarded as killing forward if
point is after mark, and killing backward if point is before
mark.

If the next command is not a kill command, ‘append-next-kill’ has
no effect.

The argument is used for internal purposes; do not supply one.

(fn &optional INTERACTIVE)〉〉enditem49840〈〈append-to-buffer〉〉:〈〈Append to specified buffer the text of the region.
It is inserted into that buffer before its point.

When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied.

(fn BUFFER START END)〉〉enditem49840〈〈append-to-register〉〉:〈〈Append region to text in register REGISTER.
With prefix arg, delete as well.
Called from program, takes four args: REGISTER, START, END and DELETE-FLAG.
START and END are buffer positions indicating what to append.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER START END &optional DELETE-FLAG)〉〉enditem49840〈〈apply-macro-to-region-lines〉〉:〈〈Apply last keyboard macro to all lines in the region.
For each line that begins in the region, move to the beginning of
the line, and run the last keyboard macro.

When called from lisp, this function takes two arguments TOP and
BOTTOM, describing the current region.  TOP must be before BOTTOM.
The optional third argument MACRO specifies a keyboard macro to
execute.

This is useful for quoting or unquoting included text, adding and
removing comments, or producing tables where the entries are regular.

For example, in Usenet articles, sections of text quoted from another
author are indented, or have each line start with ‘>’.  To quote a
section of text, define a keyboard macro which inserts ‘>’, put point
and mark at opposite ends of the quoted section, and use
‘DEL r ,’ to mark the entire section.

Suppose you wanted to build a keyword table in C where each entry
looked like this:

    { "foo", foo_data, foo_function },
    { "bar", bar_data, bar_function },
    { "baz", baz_data, baz_function },

You could enter the names in this format:

    foo
    bar
    baz

and write a macro to massage a word into a table entry:

    \C-x (
       \M-d { "\C-y", \C-y_data, \C-y_function },
    \C-x )

and then select the region of un-tablified names and use
‘DEL r ,’ to build the table from the names.

(fn TOP BOTTOM &optional MACRO)〉〉enditem49840〈〈appt-activate〉〉:〈〈Toggle checking of appointments.
With optional numeric argument ARG, turn appointment checking on if
ARG is positive, otherwise off.

(fn &optional ARG)〉〉enditem49840〈〈appt-add〉〉:〈〈Add an appointment for today at TIME with message MSG.
The time should be in either 24 hour format or am/pm format.
Optional argument WARNTIME is an integer (or string) giving the number
of minutes before the appointment at which to start warning.
The default is ‘appt-message-warning-time’.

(fn TIME MSG &optional WARNTIME)〉〉enditem49840〈〈apropos-command〉〉:〈〈Show commands (interactively callable functions) that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words.

With C-u prefix, or if ‘apropos-do-all’ is non-nil, also show
noninteractive functions.

If VAR-PREDICATE is non-nil, show only variables, and only those that
satisfy the predicate VAR-PREDICATE.

When called from a Lisp program, a string PATTERN is used as a regexp,
while a list of strings is used as a word list.

(fn PATTERN &optional DO-ALL VAR-PREDICATE)〉〉enditem49840〈〈apropos-documentation〉〉:〈〈Show symbols whose documentation contains matches for PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words.

Note that by default this command only searches in the file specified by
‘internal-doc-file-name’; i.e., the etc/DOC file.  With C-u prefix,
or if ‘apropos-do-all’ is non-nil, it searches all currently defined
documentation strings.

Returns list of symbols and documentation found.

(fn PATTERN &optional DO-ALL)〉〉enditem49840〈〈apropos-user-option〉〉:〈〈Show user options that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words.

With C-u prefix, or if ‘apropos-do-all’ is non-nil, also show
variables, not just user options.

(fn PATTERN &optional DO-ALL)〉〉enditem49840〈〈apropos-value〉〉:〈〈Show all symbols whose value’s printed representation matches PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words.

With C-u prefix, or if ‘apropos-do-all’ is non-nil, also looks
at function definitions (arguments, documentation and body) and at the
names and values of properties.

Returns list of symbols and values found.

(fn PATTERN &optional DO-ALL)〉〉enditem49840〈〈apropos-variable〉〉:〈〈Show variables that match PATTERN.
With the optional argument DO-NOT-ALL non-nil (or when called
interactively with the prefix C-u), show user
options only, i.e. behave like ‘apropos-user-option’.

(fn PATTERN &optional DO-NOT-ALL)〉〉enditem49840〈〈async-shell-command〉〉:〈〈Execute string COMMAND asynchronously in background.

Like ‘shell-command’, but adds ‘&’ at the end of COMMAND
to execute it asynchronously.

The output appears in the buffer ‘*Async Shell Command*’.
That buffer is in shell mode.

You can configure ‘async-shell-command-buffer’ to specify what to do
when the ‘*Async Shell Command*’ buffer is already taken by another
running shell command.  To run COMMAND without displaying the output
in a window you can configure ‘display-buffer-alist’ to use the action
‘display-buffer-no-window’ for the buffer ‘*Async Shell Command*’.

In Elisp, you will often be better served by calling ‘start-process’
directly, since it offers more control and does not impose the use of
a shell (with its need to quote arguments).

(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)〉〉enditem49840〈〈auto-compression-mode〉〉:〈〈Toggle Auto Compression mode.
With a prefix argument ARG, enable Auto Compression mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

Auto Compression mode is a global minor mode.  When enabled,
compressed files are automatically uncompressed for reading, and
compressed when writing.〉〉enditem49840〈〈auto-fill-mode〉〉:〈〈Toggle automatic line breaking (Auto Fill mode).
Interactively, with a prefix argument, enable
Auto Fill mode if the prefix argument is positive,
and disable it otherwise.  If called from Lisp, toggle
the mode if ARG is ‘toggle’, disable the mode if ARG is
a non-positive integer, and enable the mode otherwise
(including if ARG is omitted or nil or a positive integer).

When Auto Fill mode is enabled, inserting a space at a column
beyond ‘current-fill-column’ automatically breaks the line at a
previous space.

When ‘auto-fill-mode’ is on, the ‘auto-fill-function’ variable is
non-nil.

The value of ‘normal-auto-fill-function’ specifies the function to use
for ‘auto-fill-function’ when turning Auto Fill mode on.

(fn &optional ARG)〉〉enditem49840〈〈auto-revert-mode〉〉:〈〈Toggle reverting buffer when the file changes (Auto-Revert Mode).
With a prefix argument ARG, enable Auto-Revert Mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Auto-Revert Mode is a minor mode that affects only the current
buffer.  When enabled, it reverts the buffer when the file on
disk changes.

When a buffer is reverted, a message is generated.  This can be
suppressed by setting ‘auto-revert-verbose’ to nil.

Use ‘global-auto-revert-mode’ to automatically revert all buffers.
Use ‘auto-revert-tail-mode’ if you know that the file will only grow
without being changed in the part that is already in the buffer.

(fn &optional ARG)〉〉enditem49840〈〈auto-revert-tail-mode〉〉:〈〈Toggle reverting tail of buffer when the file grows.
With a prefix argument ARG, enable Auto-Revert Tail Mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When Auto-Revert Tail Mode is enabled, the tail of the file is
constantly followed, as with the shell command ‘tail -f’.  This
means that whenever the file grows on disk (presumably because
some background process is appending to it from time to time),
this is reflected in the current buffer.

You can edit the buffer and turn this mode off and on again as
you please.  But make sure the background process has stopped
writing before you save the file!

When a buffer is reverted, a message is generated.  This can be
suppressed by setting ‘auto-revert-verbose’ to nil.

Use ‘auto-revert-mode’ for changes other than appends!

(fn &optional ARG)〉〉enditem49840〈〈autoarg-kp-mode〉〉:〈〈Toggle Autoarg-KP mode, a global minor mode.
With a prefix argument ARG, enable Autoarg-KP mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.


Uses keymap ‘autoarg-kp-mode-map’, which is not currently defined.

This is similar to ‘autoarg-mode’ but rebinds the keypad keys
‘kp-1’ etc. to supply digit arguments.


Uses keymap ‘autoarg-kp-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈autoarg-mode〉〉:〈〈Toggle Autoarg mode, a global minor mode.
With a prefix argument ARG, enable Autoarg mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.


Uses keymap ‘autoarg-mode-map’, which is not currently defined.

In Autoarg mode, digits are bound to ‘digit-argument’, i.e. they
supply prefix arguments as C-DIGIT and M-DIGIT normally do.
Furthermore, C-DIGIT inserts DIGIT.
M-x autoarg-terminate terminates the prefix sequence and inserts
the digits of the autoarg sequence into the buffer.
Without a numeric prefix arg, the normal binding of M-x autoarg-terminate
is invoked, i.e. what it would be with Autoarg mode off.

For example:
‘6 9 M-x autoarg-terminate’ inserts ‘69’ into the buffer, as does ‘C-6 C-9’.
‘6 9 a’ inserts 69 ‘a’s into the buffer.
‘6 9 M-x autoarg-terminate M-x autoarg-terminate’ inserts ‘69’ into the buffer and
then invokes the normal binding of M-x autoarg-terminate.
‘C-u M-x autoarg-terminate’ invokes the normal binding of M-x autoarg-terminate four times.


Uses keymap ‘autoarg-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈autoconf-mode〉〉:〈〈Major mode for editing Autoconf configure.ac files.

(fn)〉〉enditem49840〈〈backward-delete-char〉〉:〈〈Delete the previous N characters (following if N is negative).
If Transient Mark mode is enabled, the mark is active, and N is 1,
delete the text in the region and deactivate the mark instead.
To disable this, set option ‘delete-active-region’ to nil.

Optional second arg KILLFLAG, if non-nil, means to kill (save in
kill ring) instead of delete.  Interactively, N is the prefix
arg, and KILLFLAG is set if N is explicitly specified.

When killing, the killed text is filtered by
‘filter-buffer-substring’ before it is saved in the kill ring, so
the actual saved text might be different from what was killed.

In Overwrite mode, single character backward deletion may replace
tabs with spaces so as to back over columns, unless point is at
the end of the line.

(fn N &optional KILLFLAG)〉〉enditem49840〈〈backward-kill-sentence〉〉:〈〈Kill back from point to start of sentence.
With arg, repeat, or kill forward to Nth end of sentence if negative arg -N.〉〉enditem49840〈〈backward-kill-word〉〉:〈〈Kill characters backward until encountering the beginning of a word.
With argument ARG, do this that many times.

(fn ARG)〉〉enditem49840〈〈backward-page〉〉:〈〈Move backward to page boundary.  With arg, repeat, or go fwd if negative.
A page boundary is any line whose beginning matches the regexp
‘page-delimiter’.〉〉enditem49840〈〈backward-paragraph〉〉:〈〈Move backward to start of paragraph.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move forward N paragraphs.

A paragraph start is the beginning of a line which is a
‘paragraph-start’ or which is ordinary text and follows a
‘paragraph-separate’ing line; except: if the first real line of a
paragraph is preceded by a blank line, the paragraph starts at that
blank line.

See ‘forward-paragraph’ for more information.〉〉enditem49840〈〈backward-sentence〉〉:〈〈Move backward to start of sentence.  With arg, do it arg times.
See ‘forward-sentence’ for more information.〉〉enditem49840〈〈beginning-of-visual-line〉〉:〈〈Move point to beginning of current visual line.
With argument N not nil or 1, move forward N - 1 visual lines first.
If point reaches the beginning or end of buffer, it stops there.
(But if the buffer doesn’t end in a newline, it stops at the
beginning of the last visual line.)
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.

(fn &optional N)〉〉enditem49840〈〈bibtex-mode〉〉:〈〈Major mode for editing BibTeX files.

General information on working with BibTeX mode:

Use commands such as C-c C-e b to get a template for a specific entry.
Then fill in all desired fields using C-j to jump from field
to field.  After having filled in all desired fields in the entry, clean the
new entry with the command C-c C-c.

Some features of BibTeX mode are available only by setting the variable
‘bibtex-maintain-sorted-entries’ to non-nil.  However, then BibTeX mode
works only with buffers containing valid (syntactically correct) and sorted
entries.  This is usually the case, if you have created a buffer completely
with BibTeX mode and finished every new entry with C-c C-c.

For third party BibTeX files, call the command M-x bibtex-convert-alien
to fully take advantage of all features of BibTeX mode.


Special information:

A command such as C-c C-e b outlines the fields for a BibTeX book entry.

The names of optional fields start with the string OPT, and are thus ignored
by BibTeX.  The names of alternative fields from which only one is required
start with the string ALT.  The OPT or ALT string may be removed from
the name of a field with C-c C-o.
C-c C-f inserts a new field after the current one.
C-c C-k kills the current field entirely.
C-c C-y yanks the last recently killed field after the current field.
C-c } removes the double-quotes or braces around the text of the current field.
C-c C-d replaces the text of the current field with the default "" or {}.
TAB moves point to the end of the current field.
C-M-i completes word fragment before point according to context.

The command C-c C-c cleans the current entry, i.e. it removes OPT/ALT
from the names of all non-empty optional or alternative fields, checks that
no required fields are empty, and does some formatting dependent on the value
of ‘bibtex-entry-format’.  Furthermore, it can automatically generate a key
for the BibTeX entry, see ‘bibtex-generate-autokey’.
Note: some functions in BibTeX mode depend on entries being in a special
format (all fields beginning on separate lines), so it is usually a bad
idea to remove ‘realign’ from ‘bibtex-entry-format’.

BibTeX mode supports Imenu and hideshow minor mode (‘hs-minor-mode’).

----------------------------------------------------------
Entry to BibTeX mode calls the value of ‘bibtex-mode-hook’
if that value is non-nil.

key             binding
---             -------

C-c             Prefix Command
TAB             bibtex-find-text
C-j             bibtex-next-field
ESC             Prefix Command

C-c C-a         bibtex-search-entries
C-c C-b         bibtex-entry
C-c C-c         bibtex-clean-entry
C-c C-d         bibtex-empty-field
C-c C-e         Prefix Command
C-c C-f         bibtex-make-field
C-c C-k         bibtex-kill-field
C-c C-l         bibtex-url
C-c C-n         bibtex-pop-next
C-c C-o         bibtex-remove-OPT-or-ALT
C-c C-p         bibtex-pop-previous
C-c C-q         bibtex-fill-entry
C-c C-r         Prefix Command
C-c C-s         bibtex-search-entry
C-c C-t         bibtex-copy-summary-as-kill
C-c C-u         bibtex-entry-update
C-c C-w         bibtex-kill-entry
C-c C-x         bibtex-search-crossref
C-c C-y         bibtex-yank
C-c ESC         Prefix Command
C-c "           bibtex-remove-delimiters
C-c $           bibtex-ispell-abstract
C-c ?           bibtex-print-help-message
C-c {           bibtex-remove-delimiters
C-c }           bibtex-remove-delimiters

C-M-a           bibtex-beginning-of-entry
C-M-e           bibtex-end-of-entry
C-M-h           bibtex-mark-entry
C-M-i           completion-at-point
C-M-l           bibtex-reposition-window

C-c C-e C-a     bibtex-Article
C-c C-e C-b     bibtex-InBook
C-c C-e C-c     bibtex-InCollection
C-c C-e TAB     bibtex-InProceedings
C-c C-e RET     bibtex-Manual
C-c C-e C-p     bibtex-InProceedings
C-c C-e C-s     bibtex-String
C-c C-e C-t     bibtex-TechReport
C-c C-e C-u     bibtex-Unpublished
C-c C-e ESC     Prefix Command
C-c C-e B       bibtex-Booklet
C-c C-e I       bibtex-InBook
C-c C-e M       bibtex-Misc
C-c C-e P       bibtex-PhdThesis
C-c C-e b       bibtex-Book
C-c C-e i       bibtex-InCollection
C-c C-e m       bibtex-MastersThesis
C-c C-e p       bibtex-Proceedings

C-c C-r n       bibtex-narrow-to-entry
C-c C-r w       widen

C-c M-k         bibtex-copy-field-as-kill
C-c M-w         bibtex-copy-entry-as-kill
C-c M-y         bibtex-yank-pop

C-c C-e M-p     bibtex-Preamble

〉〉enditem49840〈〈binary-overwrite-mode〉〉:〈〈Toggle Binary Overwrite mode.
With a prefix argument ARG, enable Binary Overwrite mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When Binary Overwrite mode is enabled, printing characters typed
in replace existing text.  Newlines are not treated specially, so
typing at the end of a line joins the line to the next, with the
typed character between them.  Typing before a tab character
simply replaces the tab with the character typed.
C-q replaces the text at the cursor, just as
ordinary typing characters do.

Note that Binary Overwrite mode is not its own minor mode; it is
a specialization of overwrite mode, entered by setting the
‘overwrite-mode’ variable to ‘overwrite-mode-binary’.

(fn &optional ARG)〉〉enditem49840〈〈blackbox〉〉:〈〈Play blackbox.
Optional prefix argument is the number of balls; the default is 4.

What is blackbox?

Blackbox is a game of hide and seek played on an 8 by 8 grid (the
Blackbox).  Your opponent (Emacs, in this case) has hidden several
balls (usually 4) within this box.  By shooting rays into the box and
observing where they emerge it is possible to deduce the positions of
the hidden balls.  The fewer rays you use to find the balls, the lower
your score.

Overview of play:


Uses keymap ‘blackbox-mode-map’, which is not currently defined.
To play blackbox, type M-x blackbox.  An optional prefix argument
specifies the number of balls to be hidden in the box; the default is
four.

The cursor can be moved around the box with the standard cursor
movement keys.

To shoot a ray, move the cursor to the edge of the box and press SPC.
The result will be determined and the playfield updated.

You may place or remove balls in the box by moving the cursor into the
box and pressing M-x bb-romp.

When you think the configuration of balls you have placed is correct,
press M-x bb-done.  You will be informed whether you are correct or
not, and be given your score.  Your score is the number of letters and
numbers around the outside of the box plus five for each incorrectly
placed ball.  If you placed any balls incorrectly, they will be
indicated with ‘x’, and their actual positions indicated with ‘o’.

Details:

There are three possible outcomes for each ray you send into the box:

	Detour: the ray is deflected and emerges somewhere other than
		where you sent it in.  On the playfield, detours are
		denoted by matching pairs of numbers -- one where the
		ray went in, and the other where it came out.

	Reflection: the ray is reflected and emerges in the same place
		it was sent in.  On the playfield, reflections are
		denoted by the letter ‘R’.

	Hit:	the ray strikes a ball directly and is absorbed.  It does
		not emerge from the box.  On the playfield, hits are
		denoted by the letter ‘H’.

The rules for how balls deflect rays are simple and are best shown by
example.

As a ray approaches a ball it is deflected ninety degrees.  Rays can
be deflected multiple times.  In the diagrams below, the dashes
represent empty box locations and the letter ‘O’ represents a ball.
The entrance and exit points of each ray are marked with numbers as
described under "Detour" above.  Note that the entrance and exit
points are always interchangeable.  ‘*’ denotes the path taken by the
ray.

Note carefully the relative positions of the ball and the ninety
degree deflection it causes.

    1
  - * - - - - - -         - - - - - - - -         - - - - - - - -
  - * - - - - - -         - - - - - - - -         - - - - - - - -
1 * * - - - - - -         - - - - - - - -         - O - - - - O -
  - - O - - - - -         - - O - - - - -         - - * * * * - -
  - - - - - - - -         - - - * * * * * 2     3 * * * - - * - -
  - - - - - - - -         - - - * - - - -         - - - O - * - -
  - - - - - - - -         - - - * - - - -         - - - - * * - -
  - - - - - - - -         - - - * - - - -         - - - - * - O -
                                2                         3

As mentioned above, a reflection occurs when a ray emerges from the same point
it was sent in.  This can happen in several ways:


  - - - - - - - -         - - - - - - - -          - - - - - - - -
  - - - - O - - -         - - O - O - - -          - - - - - - - -
R * * * * - - - -         - - - * - - - -          O - - - - - - -
  - - - - O - - -         - - - * - - - -        R - - - - - - - -
  - - - - - - - -         - - - * - - - -          - - - - - - - -
  - - - - - - - -         - - - * - - - -          - - - - - - - -
  - - - - - - - -       R * * * * - - - -          - - - - - - - -
  - - - - - - - -         - - - - O - - -          - - - - - - - -

In the first example, the ray is deflected downwards by the upper
ball, then left by the lower ball, and finally retraces its path to
its point of origin.  The second example is similar.  The third
example is a bit anomalous but can be rationalized by realizing the
ray never gets a chance to get into the box.  Alternatively, the ray
can be thought of as being deflected downwards and immediately
emerging from the box.

A hit occurs when a ray runs straight into a ball:

  - - - - - - - -         - - - - - - - -          - - - - - - - -
  - - - - - - - -         - - - - - - - -          - - - - O - - -
  - - - - - - - -         - - - - O - - -        H * * * * - - - -
  - - - - - - - -       H * * * * O - - -          - - - * - - - -
  - - - - - - - -         - - - - O - - -          - - - O - - - -
H * * * O - - - -         - - - - - - - -          - - - - - - - -
  - - - - - - - -         - - - - - - - -          - - - - - - - -
  - - - - - - - -         - - - - - - - -          - - - - - - - -

Be sure to compare the second example of a hit with the first example of
a reflection.

(fn NUM)〉〉enditem49840〈〈blink-cursor-mode〉〉:〈〈Toggle cursor blinking (Blink Cursor mode).
With a prefix argument ARG, enable Blink Cursor mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

If the value of ‘blink-cursor-blinks’ is positive (10 by default),
the cursor stops blinking after that number of blinks, if Emacs
gets no input during that time.

See also ‘blink-cursor-interval’ and ‘blink-cursor-delay’.

This command is effective only on graphical frames.  On text-only
terminals, cursor blinking is controlled by the terminal.

(fn &optional ARG)〉〉enditem49840〈〈bookmark-delete〉〉:〈〈Delete BOOKMARK-NAME from the bookmark list.

Removes only the first instance of a bookmark with that name.  If
there are one or more other bookmarks with the same name, they will
not be deleted.  Defaults to the "current" bookmark (that is, the
one most recently used in this file, if any).
Optional second arg BATCH means don’t update the bookmark list buffer,
probably because we were called from there.〉〉enditem49840〈〈bookmark-insert-location〉〉:〈〈Insert the name of the file associated with BOOKMARK-NAME.

Optional second arg NO-HISTORY means don’t record this in the
minibuffer history list ‘bookmark-history’.〉〉enditem49840〈〈bookmark-insert〉〉:〈〈Insert the text of the file pointed to by bookmark BOOKMARK-NAME.
BOOKMARK-NAME is a bookmark name (a string), not a bookmark record.

You may have a problem using this function if the value of variable
‘bookmark-alist’ is nil.  If that happens, you need to load in some
bookmarks.  See help on function ‘bookmark-load’ for more about
this.〉〉enditem49840〈〈bookmark-jump〉〉:〈〈Jump to bookmark BOOKMARK (a point in some file).
You may have a problem using this function if the value of variable
‘bookmark-alist’ is nil.  If that happens, you need to load in some
bookmarks.  See help on function ‘bookmark-load’ for more about
this.

If the file pointed to by BOOKMARK no longer exists, you will be asked
if you wish to give the bookmark a new location, and ‘bookmark-jump’
will then jump to the new location, as well as recording it in place
of the old one in the permanent bookmark record.

BOOKMARK is usually a bookmark name (a string).  It can also be a
bookmark record, but this is usually only done by programmatic callers.

If DISPLAY-FUNC is non-nil, it is a function to invoke to display the
bookmark.  It defaults to ‘switch-to-buffer’.  A typical value for
DISPLAY-FUNC would be ‘switch-to-buffer-other-window’.〉〉enditem49840〈〈bookmark-load〉〉:〈〈Load bookmarks from FILE (which must be in bookmark format).
Appends loaded bookmarks to the front of the list of bookmarks.  If
optional second argument OVERWRITE is non-nil, existing bookmarks are
destroyed.  Optional third arg NO-MSG means don’t display any messages
while loading.

If you load a file that doesn’t contain a proper bookmark alist, you
will corrupt Emacs’s bookmark list.  Generally, you should only load
in files that were created with the bookmark functions in the first
place.  Your own personal bookmark file, specified by the variable
‘bookmark-default-file’, is maintained automatically by Emacs; you
shouldn’t need to load it explicitly.

If you load a file containing bookmarks with the same names as
bookmarks already present in your Emacs, the new bookmarks will get
unique numeric suffixes "<2>", "<3>", etc.〉〉enditem49840〈〈bookmark-save〉〉:〈〈Save currently defined bookmarks.
Saves by default in the file defined by the variable
‘bookmark-default-file’.  With a prefix arg, save it in file FILE
(second argument).

If you are calling this from Lisp, the two arguments are PARG and
FILE, and if you just want it to write to the default file, then
pass no arguments.  Or pass in nil and FILE, and it will save in FILE
instead.  If you pass in one argument, and it is non-nil, then the
user will be interactively queried for a file to save in.

When you want to load in the bookmarks from a file, use
‘bookmark-load’, M-x bookmark-load.  That function will prompt you
for a file, defaulting to the file defined by variable
‘bookmark-default-file’.〉〉enditem49840〈〈bookmark-set-no-overwrite〉〉:〈〈Set a bookmark named NAME at the current location.
If NAME is nil, then prompt the user.

If a bookmark named NAME already exists and prefix argument
PUSH-BOOKMARK is non-nil, then push the new bookmark onto the
bookmark alist.  Pushing it means that among bookmarks named
NAME, this one becomes the one in effect, but the others are
still there, in order, and become effective again if the user
ever deletes the most recent one.

Otherwise, if a bookmark named NAME already exists but PUSH-BOOKMARK
is nil, raise an error.

To yank words from the text of the buffer and use them as part of the
bookmark name, type C-w while setting a bookmark.  Successive C-w’s
yank successive words.

Typing C-u inserts (at the bookmark name prompt) the name of the last
bookmark used in the document where the new bookmark is being set;
this helps you use a single bookmark name to track progress through a
large document.  If there is no prior bookmark for this document, then
C-u inserts an appropriate name based on the buffer or file.

Use M-x bookmark-delete to remove bookmarks (you give it a name and
it removes only the first instance of a bookmark with that name from
the list of bookmarks.)〉〉enditem49840〈〈bookmark-set〉〉:〈〈Set a bookmark named NAME at the current location.
If NAME is nil, then prompt the user.

With a prefix arg (non-nil NO-OVERWRITE), do not overwrite any
existing bookmark that has the same name as NAME, but instead push the
new bookmark onto the bookmark alist.  The most recently set bookmark
with name NAME is thus the one in effect at any given time, but the
others are still there, should the user decide to delete the most
recent one.

To yank words from the text of the buffer and use them as part of the
bookmark name, type C-w while setting a bookmark.  Successive C-w’s
yank successive words.

Typing C-u inserts (at the bookmark name prompt) the name of the last
bookmark used in the document where the new bookmark is being set;
this helps you use a single bookmark name to track progress through a
large document.  If there is no prior bookmark for this document, then
C-u inserts an appropriate name based on the buffer or file.

Use M-x bookmark-delete to remove bookmarks (you give it a name and
it removes only the first instance of a bookmark with that name from
the list of bookmarks.)〉〉enditem49840〈〈bookmark-write〉〉:〈〈Write bookmarks to a file (reading the file name with the minibuffer).〉〉enditem49840〈〈browse-url-at-mouse〉〉:〈〈Ask a WWW browser to load a URL clicked with the mouse.
The URL is the one around or before the position of the mouse click
but point is not changed.  Variable ‘browse-url-browser-function’
says which browser to use.〉〉enditem49840〈〈browse-url-at-point〉〉:〈〈Ask a WWW browser to load the URL at or before point.
Variable ‘browse-url-browser-function’ says which browser to use.
Optional prefix argument ARG non-nil inverts the value of the option
‘browse-url-new-window-flag’.〉〉enditem49840〈〈browse-url〉〉:〈〈Ask a WWW browser to load URL.
Prompt for a URL, defaulting to the URL at or before point.
Invokes a suitable browser function which does the actual job.
The variable ‘browse-url-browser-function’ says which browser function to
use.  If the URL is a mailto: URL, consult ‘browse-url-mailto-function’
first, if that exists.

The additional ARGS are passed to the browser function.  See the doc
strings of the actual functions, starting with ‘browse-url-browser-function’,
for information about the significance of ARGS (most of the functions
ignore it).
If ARGS are omitted, the default is to pass ‘browse-url-new-window-flag’
as ARGS.〉〉enditem49840〈〈bs-show〉〉:〈〈Make a menu of buffers so you can manipulate buffers or the buffer list.

Uses keymap ‘bs-mode-map’, which is not currently defined.

There are many key commands similar to ‘Buffer-menu-mode’ for
manipulating the buffer list and the buffers themselves.
User can move with [up] or [down], select a buffer
by M-x bs-select or [SPC]

Type M-x bs-kill to leave Buffer Selection Menu without a selection.
Type M-x bs-help after invocation to get help on commands available.
With prefix argument ARG show a different buffer list.  Function
‘bs--configuration-name-for-prefix-arg’ determine accordingly
name of buffer configuration.

(fn ARG)〉〉enditem49840〈〈bubbles〉〉:〈〈Play Bubbles game.

Uses keymap ‘bubbles-mode-map’, which is not currently defined.

The goal is to remove all bubbles with as few moves as possible.
M-x bubbles-plop on a bubble removes that bubble and all
connected bubbles of the same color.  Unsupported bubbles fall
down, and columns that do not contain any bubbles suck the
columns on its right towards the left.

M-x bubbles-set-game-easy sets the difficulty to easy.
M-x bubbles-set-game-medium sets the difficulty to medium.
M-x bubbles-set-game-difficult sets the difficulty to difficult.
M-x bubbles-set-game-hard sets the difficulty to hard.

(fn)〉〉enditem49840〈〈buffer-menu-other-window〉〉:〈〈Display the Buffer Menu in another window.
See ‘buffer-menu’ for a description of the Buffer Menu.

By default, all buffers are listed except those whose names start
with a space (which are for internal use).  With prefix argument
ARG, show only buffers that are visiting files.

(fn &optional ARG)〉〉enditem49840〈〈buffer-menu〉〉:〈〈Switch to the Buffer Menu.
By default, the Buffer Menu lists all buffers except those whose
names start with a space (which are for internal use).  With
prefix argument ARG, show only buffers that are visiting files.

In the Buffer Menu, the first column (denoted "C") shows "."
for the buffer from which you came, ">" for buffers you mark to
be displayed, and "D" for those you mark for deletion.

The "R" column has a "%" if the buffer is read-only.
The "M" column has a "*" if it is modified, or "S" if you
have marked it for saving.

The remaining columns show the buffer name, the buffer size in
characters, its major mode, and the visited file name (if any).

See ‘Buffer-menu-mode’ for the keybindings available the Buffer
Menu.

(fn &optional ARG)〉〉enditem49840〈〈c-backslash-region〉〉:〈〈Insert, align, or delete end-of-line backslashes on the lines in the region.
With no argument, inserts backslashes and aligns existing backslashes.
With an argument, deletes the backslashes.  The backslash alignment is
done according to the settings in ‘c-backslash-column’,
‘c-backslash-max-column’ and ‘c-auto-align-backslashes’.

This function does not modify blank lines at the start of the region.
If the region ends at the start of a line and the macro doesn’t
continue below it, the backslash (if any) at the end of the previous
line is deleted.

You can put the region around an entire macro definition and use this
command to conveniently insert and align the necessary backslashes.〉〉enditem49840〈〈c-backward-conditional〉〉:〈〈Move back across a preprocessor conditional, leaving mark behind.
A prefix argument acts as a repeat count.  With a negative argument,
move forward across a preprocessor conditional.

The optional arguments TARGET-DEPTH and WITH-ELSE are historical,
and have the same meanings as in ‘c-scan-conditionals’.  If you
are calling c-forward-conditional from a program, you might want
to call ‘c-scan-conditionals’ directly instead.〉〉enditem49840〈〈c-beginning-of-defun〉〉:〈〈Move backward to the beginning of a defun.
Every top level declaration that contains a brace paren block is
considered to be a defun.

With a positive argument, move backward that many defuns.  A negative
argument -N means move forward to the Nth following beginning.  Return
t unless search stops due to beginning or end of buffer.

Unlike the built-in ‘beginning-of-defun’ this tries to be smarter
about finding the char with open-parenthesis syntax that starts the
defun.〉〉enditem49840〈〈c-beginning-of-statement〉〉:〈〈Go to the beginning of the innermost C statement.
With prefix arg, go back N - 1 statements.  If already at the
beginning of a statement then go to the beginning of the closest
preceding one, moving into nested blocks if necessary (use
C-M-b to skip over a block).  If within or next to a
comment or multiline string, move by sentences instead of statements.

When called from a program, this function takes 3 optional args: the
repetition count, a buffer position limit which is the farthest back
to search for the syntactic context, and a flag saying whether to do
sentence motion in or near comments and multiline strings.

Note that for use in programs, ‘c-beginning-of-statement-1’ is
usually better.  It has much better defined semantics than this one,
which is intended for interactive use, and might therefore change to
be more "DWIM:ey".〉〉enditem49840〈〈c-context-line-break〉〉:〈〈Do a line break suitable to the context.

When point is outside a comment or macro, insert a newline and indent
according to the syntactic context, unless ‘c-syntactic-indentation’
is nil, in which case the new line is indented as the previous
non-empty line instead.

When point is inside the content of a preprocessor directive, a line
continuation backslash is inserted before the line break and aligned
appropriately.  The end of the cpp directive doesn’t count as inside
it.

When point is inside a comment, continue it with the appropriate
comment prefix (see the ‘c-comment-prefix-regexp’ and
‘c-block-comment-prefix’ variables for details).  The end of a
C++-style line comment doesn’t count as inside it.

When point is inside a string, only insert a backslash when it is also
inside a preprocessor directive.〉〉enditem49840〈〈c-end-of-defun〉〉:〈〈Move forward to the end of a top level declaration.
With argument, do it that many times.  Negative argument -N means move
back to Nth preceding end.  Returns t unless search stops due to
beginning or end of buffer.

An end of a defun occurs right after the close-parenthesis that matches
the open-parenthesis that starts a defun; see ‘beginning-of-defun’.〉〉enditem49840〈〈c-end-of-statement〉〉:〈〈Go to the end of the innermost C statement.
With prefix arg, go forward N - 1 statements.  Move forward to the end
of the next statement if already at end, and move into nested blocks
(use C-M-f to skip over a block).  If within or next to a
comment or multiline string, move by sentences instead of statements.

When called from a program, this function takes 3 optional args: the
repetition count, a buffer position limit which is the farthest back
to search for the syntactic context, and a flag saying whether to do
sentence motion in or near comments and multiline strings.〉〉enditem49840〈〈c-fill-paragraph〉〉:〈〈Like M-q but handles C and C++ style comments.
If any of the current line is a comment or within a comment, fill the
comment or the paragraph of it that point is in, preserving the
comment indentation or line-starting decorations (see the
‘c-comment-prefix-regexp’ and ‘c-block-comment-prefix’ variables for
details).

If point is inside multiline string literal, fill it.  This currently
does not respect escaped newlines, except for the special case when it
is the very first thing in the string.  The intended use for this rule
is in situations like the following:

char description[] = "\
A very long description of something that you want to fill to make
nicely formatted output.";

If point is in any other situation, i.e. in normal code, do nothing.

Optional prefix ARG means justify paragraph as well.〉〉enditem49840〈〈c-forward-conditional〉〉:〈〈Move forward across a preprocessor conditional, leaving mark behind.
A prefix argument acts as a repeat count.  With a negative argument,
move backward across a preprocessor conditional.

If there aren’t enough conditionals after (or before) point, an
error is signaled.

"#elif" is treated like "#else" followed by "#if", except that
the nesting level isn’t changed when tracking subconditionals.

The optional arguments TARGET-DEPTH and WITH-ELSE are historical,
and have the same meanings as in ‘c-scan-conditionals’.  If you
are calling c-forward-conditional from a program, you might want
to call ‘c-scan-conditionals’ directly instead.〉〉enditem49840〈〈c-guess-install〉〉:〈〈Install the latest guessed style into the current buffer.
(This guessed style is a combination of ‘c-guess-guessed-basic-offset’,
‘c-guess-guessed-offsets-alist’ and ‘c-offsets-alist’.)

The style is entered into CC Mode’s style system by
‘c-add-style’.  Its name is either STYLE-NAME, or a name based on
the absolute file name of the file if STYLE-NAME is nil.〉〉enditem49840〈〈c-guess〉〉:〈〈Guess the style in the region up to ‘c-guess-region-max’, and install it.

The style is given a name based on the file’s absolute file name.

If given a prefix argument (or if the optional argument ACCUMULATE is
non-nil) then the previous guess is extended, otherwise a new guess is
made from scratch.〉〉enditem49840〈〈c-hungry-delete-backwards〉〉:〈〈Delete the preceding character or all preceding whitespace
back to the previous non-whitespace character.
See also M-x c-hungry-delete-forward.〉〉enditem49840〈〈c-hungry-delete-forward〉〉:〈〈Delete the following character or all following whitespace
up to the next non-whitespace character.
See also M-x c-hungry-delete-backwards.〉〉enditem49840〈〈c-indent-command〉〉:〈〈Indent current line as C code, and/or insert some whitespace.

If ‘c-tab-always-indent’ is t, always just indent the current line.
If nil, indent the current line only if point is at the left margin or
in the line’s indentation; otherwise insert some whitespace[*].  If
other than nil or t, then some whitespace[*] is inserted only within
literals (comments and strings), but the line is always reindented.

If ‘c-syntactic-indentation’ is t, indentation is done according to
the syntactic context.  A numeric argument, regardless of its value,
means indent rigidly all the lines of the expression starting after
point so that this line becomes properly indented.  The relative
indentation among the lines of the expression is preserved.

If ‘c-syntactic-indentation’ is nil, the line is just indented one
step according to ‘c-basic-offset’.  In this mode, a numeric argument
indents a number of such steps, positive or negative, and an empty
prefix argument is equivalent to -1.

  [*] The amount and kind of whitespace inserted is controlled by the
  variable ‘c-insert-tab-function’, which is called to do the actual
  insertion of whitespace.  Normally the function in this variable
  just inserts a tab character, or the equivalent number of spaces,
  depending on the variable ‘indent-tabs-mode’.〉〉enditem49840〈〈c-indent-defun〉〉:〈〈Indent the current top-level declaration or macro syntactically.
In the macro case this also has the effect of realigning any line
continuation backslashes, unless ‘c-auto-align-backslashes’ is nil.〉〉enditem49840〈〈c-indent-exp〉〉:〈〈Indent each line in the balanced expression following point syntactically.
If optional SHUTUP-P is non-nil, no errors are signaled if no
balanced expression is found.〉〉enditem49840〈〈c-indent-line-or-region〉〉:〈〈Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line.〉〉enditem49840〈〈c-indent-new-comment-line〉〉:〈〈Break line at point and indent, continuing comment or macro if within one.
If inside a comment and ‘comment-multi-line’ is non-nil, the
indentation and line prefix are preserved (see the
‘c-comment-prefix-regexp’ and ‘c-block-comment-prefix’ variables for
details).  If inside a single line comment and ‘comment-multi-line’ is
nil, a new comment of the same type is started on the next line and
indented as appropriate for comments.  If inside a macro, a line
continuation backslash is inserted and aligned as appropriate, and the
new line is indented according to ‘c-syntactic-indentation’.

If a fill prefix is specified, it overrides all the above.〉〉enditem49840〈〈c-macro-expand〉〉:〈〈Expand C macros in the region, using the C preprocessor.
Normally display output in temp buffer, but
prefix arg means replace the region with it.

‘c-macro-preprocessor’ specifies the preprocessor to use.
Tf the user option ‘c-macro-prompt-flag’ is non-nil
prompt for arguments to the preprocessor (e.g. ‘-DDEBUG -I ./include’),
otherwise use ‘c-macro-cppflags’.

Noninteractive args are START, END, SUBST.
For use inside Lisp programs, see also ‘c-macro-expansion’.

(fn START END SUBST)〉〉enditem49840〈〈c-mark-function〉〉:〈〈Put mark at end of the current top-level declaration or macro, point at beginning.
If point is not inside any then the closest following one is
chosen.  Each successive call of this command extends the marked
region by one function.

A mark is left where the command started, unless the region is already active
(in Transient Mark mode).

As opposed to M-x c-beginning-of-defun and M-x c-end-of-defun, this
function does not require the declaration to contain a brace block.〉〉enditem49840〈〈c-mode〉〉:〈〈Major mode for editing C code.

To submit a problem report, enter ‘M-x c-submit-bug-report’ from a
c-mode buffer.  This automatically sets up a mail buffer with version
information already added.  You just need to add a description of the
problem, including a reproducible test case, and send the message.

To see what version of CC Mode you are running, enter ‘M-x c-version’.

The hook ‘c-mode-common-hook’ is run with no args at mode
initialization, then ‘c-mode-hook’.

Key bindings:
key             binding
---             -------

C-c             Prefix Command
C-d             c-electric-delete-forward
TAB             c-indent-line-or-region
ESC             Prefix Command
#               c-electric-pound
( .. )          c-electric-paren
*               c-electric-star
,               c-electric-semi&comma
/               c-electric-slash
:               c-electric-colon
;               c-electric-semi&comma
{               c-electric-brace
}               c-electric-brace
DEL             c-electric-backspace

C-c C-e         c-macro-expand

C-c C-a         c-toggle-auto-newline
C-c C-b         c-submit-bug-report
C-c C-c         comment-region
C-c C-d         c-hungry-delete-forward
C-c C-k         c-toggle-comment-style
C-c C-l         c-toggle-electric-state
C-c C-n         c-forward-conditional
C-c C-o         c-set-offset
C-c C-p         c-backward-conditional
C-c C-q         c-indent-defun
C-c C-s         c-show-syntactic-information
C-c C-u         c-up-conditional
C-c C-w         c-subword-mode
C-c C-z         c-display-defun-name
C-c C-\         c-backslash-region
C-c .           c-set-style
C-c DEL         c-hungry-delete-backwards
C-c C-DEL       c-hungry-delete-backwards
C-c <C-backspace>               c-hungry-delete-backwards
C-c <C-delete>                  c-hungry-delete-forward
C-c <C-deletechar>              c-hungry-delete-forward
C-c <deletechar>                c-hungry-delete-forward

C-M-a           c-beginning-of-defun
C-M-e           c-end-of-defun
C-M-h           c-mark-function
C-M-j           c-indent-new-comment-line
C-M-q           c-indent-exp
M-a             c-beginning-of-statement
M-e             c-end-of-statement
M-j             c-indent-new-comment-line
M-q             c-fill-paragraph

C-M-q           prog-indent-sexp
  (that binding is currently shadowed by another mode)

〉〉enditem49840〈〈c-set-style〉〉:〈〈Set the current buffer to use the style STYLENAME.
STYLENAME, a string, must be an existing CC Mode style - These are contained
in the variable ‘c-style-alist’.

The variable ‘c-indentation-style’ will get set to STYLENAME.

"Setting the style" is done by setting CC Mode’s "style variables" to the
values indicated by the pertinent entry in ‘c-style-alist’.  Other variables
might get set too.

If DONT-OVERRIDE is neither nil nor t, style variables whose default values
have been set (more precisely, whose default values are not the symbol
‘set-from-style’) will not be changed.  This avoids overriding global settings
done in your init file.  It is useful to call c-set-style from a mode hook
in this way.

If DONT-OVERRIDE is t, style variables that already have values (i.e., whose
values are not the symbol ‘set-from-style’) will not be overridden.  CC Mode
calls c-set-style internally in this way whilst initializing a buffer; if
cc-set-style is called like this from anywhere else, it will usually behave as
a null operation.〉〉enditem49840〈〈c-show-syntactic-information〉〉:〈〈Show syntactic information for current line.
With universal argument, inserts the analysis as a comment on that line.〉〉enditem49840〈〈c-toggle-auto-newline〉〉:〈〈Toggle auto-newline feature.
Optional numeric ARG, if supplied, turns on auto-newline when
positive, turns it off when negative, and just toggles it when zero or
left out.

Turning on auto-newline automatically enables electric indentation.

When the auto-newline feature is enabled (indicated by "/la" on the
mode line after the mode name) newlines are automatically inserted
after special characters such as brace, comma, semi-colon, and colon.〉〉enditem49840〈〈c-toggle-electric-state〉〉:〈〈Toggle the electric indentation feature.
Optional numeric ARG, if supplied, turns on electric indentation when
positive, turns it off when negative, and just toggles it when zero or
left out.〉〉enditem49840〈〈c-toggle-hungry-state〉〉:〈〈Toggle hungry-delete-key feature.
Optional numeric ARG, if supplied, turns on hungry-delete when
positive, turns it off when negative, and just toggles it when zero or
left out.

When the hungry-delete-key feature is enabled (indicated by "/h" on
the mode line after the mode name) the delete key gobbles all preceding
whitespace in one fell swoop.〉〉enditem49840〈〈c-up-conditional〉〉:〈〈Move back to the containing preprocessor conditional, leaving mark behind.
A prefix argument acts as a repeat count.  With a negative argument,
move forward to the end of the containing preprocessor conditional.

"#elif" is treated like "#else" followed by "#if", so the
function stops at them when going backward, but not when going
forward.〉〉enditem49840〈〈cal-html-cursor-month〉〉:〈〈Write an HTML calendar file for numeric MONTH of four-digit YEAR.
The output directory DIR is created if necessary.  Interactively,
MONTH and YEAR are taken from the calendar cursor position, or from
the position specified by EVENT.  Note that any existing output files
are overwritten.

(fn MONTH YEAR DIR &optional EVENT)〉〉enditem49840〈〈cal-html-cursor-year〉〉:〈〈Write HTML calendar files (index and monthly pages) for four-digit YEAR.
The output directory DIR is created if necessary.  Interactively,
YEAR is taken from the calendar cursor position, or from the position
specified by EVENT.  Note that any existing output files are overwritten.

(fn YEAR DIR &optional EVENT)〉〉enditem49840〈〈cal-tex-cursor-day〉〉:〈〈Make a buffer with LaTeX commands for the day cursor is on.
Optional prefix argument N specifies number of days.  The calendar shows
the hours between ‘cal-tex-daily-start’ and ‘cal-tex-daily-end’, using
the 24-hour clock if ‘cal-tex-24’ is non-nil.  Optional EVENT indicates
a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-filofax-2week〉〉:〈〈Two-weeks-at-a-glance Filofax style calendar for week cursor is in.
Optional prefix argument N specifies number of weeks (default 1).
The calendar shows holiday and diary entries if
‘cal-tex-holidays’ and ‘cal-tex-diary’, respectively, are non-nil.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-filofax-week〉〉:〈〈One-week-at-a-glance Filofax style calendar for week indicated by cursor.
Optional prefix argument N specifies number of weeks (default 1),
starting on Mondays.  The calendar shows holiday and diary entries
if ‘cal-tex-holidays’ and ‘cal-tex-diary’, respectively, are non-nil.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-filofax-year〉〉:〈〈Make a Filofax one page yearly calendar of year indicated by cursor.
Optional prefix argument N specifies number of years.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-month-landscape〉〉:〈〈Make a LaTeX calendar buffer for the month the cursor is on.
Optional prefix argument N specifies number of months to be
produced (default 1).  The output is in landscape format, one
month to a page.  It shows holiday and diary entries if
‘cal-tex-holidays’ and ‘cal-tex-diary’, respectively, are non-nil.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-month〉〉:〈〈Make a LaTeX calendar buffer for the month the cursor is on.
Optional prefix argument N specifies number of months to be
produced (default 1).  The calendar is condensed onto one page.
It shows holiday and diary entries if ‘cal-tex-holidays’ and
‘cal-tex-diary’, respectively, are non-nil.  Optional EVENT
indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-week-iso〉〉:〈〈Make a one page LaTeX calendar for one week, in the ISO-style.
It does not show hours of the day.
It shows holidays if ‘cal-tex-holidays’ is non-nil.
It shows diary entries if ‘cal-tex-diary’ is non-nil.

The optional prefix argument N specifies a number of weeks (default 1).

By default, the calendar is for the week at point; the optional
argument EVENT specifies a different buffer position.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-week-monday〉〉:〈〈Make a one page LaTeX calendar for one week, showing hours of the day.
There are two columns; with M-W in the first and T-S in the second.
It shows the hours 8-12am and 1-5pm.
It shows holidays if ‘cal-tex-holidays’ is non-nil.
It does not show diary entries.

The optional prefix argument N specifies a number of weeks (default 1).

By default, the calendar is for the week at point; the optional
argument EVENT specifies a different buffer position.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-week2-summary〉〉:〈〈Make a two page LaTeX calendar for one week, with optional diary entries.
It does not show hours of the day.
It shows holidays if ‘cal-tex-holidays’ is non-nil.
It shows diary entries if ‘cal-tex-diary’ is non-nil.

The optional prefix argument N specifies a number of weeks (default 1).

By default, the calendar is for the week at point; the optional
argument EVENT specifies a different buffer position.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-week2〉〉:〈〈Make a two page LaTeX calendar for one week, showing hours of the day.
There are two columns; with 8-12am in the first and 1-5pm in the second.
It shows holidays if ‘cal-tex-holidays’ is non-nil.
It does not show diary entries.

The optional prefix argument N specifies a number of weeks (default 1).

By default, the calendar is for the week at point; the optional
argument EVENT specifies a different buffer position.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-week〉〉:〈〈Make a one page LaTeX calendar for one week, showing hours of the day.
There are two columns; with 8-12am in the first and 1-5pm in the second.
It shows holidays if ‘cal-tex-holidays’ is non-nil.
It does not show diary entries.

The optional prefix argument N specifies a number of weeks (default 1).

By default, the calendar is for the week at point; the optional
argument EVENT specifies a different buffer position.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-year-landscape〉〉:〈〈Make a buffer with LaTeX commands for the year cursor is on.
Optional prefix argument N specifies number of years.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈cal-tex-cursor-year〉〉:〈〈Make a buffer with LaTeX commands for the year cursor is on.
Optional prefix argument N specifies number of years.
Optional EVENT indicates a buffer position to use instead of point.

(fn &optional N EVENT)〉〉enditem49840〈〈calendar-astro-goto-day-number〉〉:〈〈Move cursor to astronomical (Julian) DAYNUMBER.
Echo astronomical (Julian) day number unless NOECHO is non-nil.

(fn DAYNUMBER &optional NOECHO)〉〉enditem49840〈〈calendar-astro-print-day-number〉〉:〈〈Show astronomical (Julian) day number after noon UTC on cursor date.

(fn)〉〉enditem49840〈〈calendar-backward-day〉〉:〈〈Move the cursor back ARG days.
Moves forward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-backward-month〉〉:〈〈Move the cursor backward by ARG months.
Movement is forward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-backward-week〉〉:〈〈Move the cursor back ARG weeks.
Moves forward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-backward-year〉〉:〈〈Move the cursor backward ARG years.
Movement is forward is ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-bahai-goto-date〉〉:〈〈Move cursor to Bahá’í date DATE; echo Bahá’í date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-bahai-print-date〉〉:〈〈Show the Bahá’í calendar equivalent of the selected date.

(fn)〉〉enditem49840〈〈calendar-beginning-of-month〉〉:〈〈Move the cursor backward ARG month beginnings.

(fn ARG)〉〉enditem49840〈〈calendar-beginning-of-week〉〉:〈〈Move the cursor back ARG calendar-week-start-day’s.

(fn ARG)〉〉enditem49840〈〈calendar-beginning-of-year〉〉:〈〈Move the cursor backward ARG year beginnings.

(fn ARG)〉〉enditem49840〈〈calendar-chinese-goto-date〉〉:〈〈Move cursor to Chinese date DATE.
Echo Chinese date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-chinese-print-date〉〉:〈〈Show the Chinese date equivalents of date.

(fn)〉〉enditem49840〈〈calendar-coptic-goto-date〉〉:〈〈Move cursor to Coptic date DATE.
Echo Coptic date unless NOECHO is t.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-coptic-print-date〉〉:〈〈Show the Coptic calendar equivalent of the selected date.

(fn)〉〉enditem49840〈〈calendar-count-days-region〉〉:〈〈Count the number of days (inclusive) between point and the mark.〉〉enditem49840〈〈calendar-cursor-holidays〉〉:〈〈Find holidays for the date specified by the cursor in the calendar window.
Optional DATE is a list (month day year) to use instead of the
cursor position.  EVENT specifies a buffer position to use for a date.

(fn &optional DATE EVENT)〉〉enditem49840〈〈calendar-end-of-month〉〉:〈〈Move the cursor forward ARG month ends.

(fn ARG)〉〉enditem49840〈〈calendar-end-of-week〉〉:〈〈Move the cursor forward ARG calendar-week-start-day+6’s.

(fn ARG)〉〉enditem49840〈〈calendar-end-of-year〉〉:〈〈Move the cursor forward ARG year beginnings.

(fn ARG)〉〉enditem49840〈〈calendar-ethiopic-goto-date〉〉:〈〈Move cursor to Ethiopic date DATE.
Echo Ethiopic date unless NOECHO is t.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-ethiopic-print-date〉〉:〈〈Show the Ethiopic calendar equivalent of the selected date.

(fn)〉〉enditem49840〈〈calendar-exit〉〉:〈〈Get out of the calendar window and hide it and related buffers.〉〉enditem49840〈〈calendar-forward-day〉〉:〈〈Move the cursor forward ARG days.
Moves backward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-forward-month〉〉:〈〈Move the cursor forward ARG months.
Movement is backward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-forward-week〉〉:〈〈Move the cursor forward ARG weeks.
Moves backward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-forward-year〉〉:〈〈Move the cursor forward by ARG years.
Movement is backward if ARG is negative.

(fn ARG)〉〉enditem49840〈〈calendar-french-goto-date〉〉:〈〈Move cursor to French Revolutionary date DATE.
Echo French Revolutionary date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-french-print-date〉〉:〈〈Show the French Revolutionary calendar equivalent of the selected date.

(fn)〉〉enditem49840〈〈calendar-goto-date〉〉:〈〈Move cursor to DATE.

(fn DATE)〉〉enditem49840〈〈calendar-goto-day-of-year〉〉:〈〈Move cursor to YEAR, DAY number; echo DAY/YEAR unless NOECHO is non-nil.
Negative DAY counts backward from end of year.

(fn YEAR DAY &optional NOECHO)〉〉enditem49840〈〈calendar-goto-today〉〉:〈〈Reposition the calendar window so the current date is visible.

(fn)〉〉enditem49840〈〈calendar-hebrew-goto-date〉〉:〈〈Move cursor to Hebrew DATE; echo Hebrew date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-hebrew-list-yahrzeits〉〉:〈〈List Yahrzeit dates for *Gregorian* DEATH-DATE from START-YEAR to END-YEAR.
When called interactively from the calendar window, the date of death is taken
from the cursor position.

(fn DEATH-DATE START-YEAR END-YEAR)〉〉enditem49840〈〈calendar-hebrew-print-date〉〉:〈〈Show the Hebrew calendar equivalent of the date under the cursor.

(fn)〉〉enditem49840〈〈calendar-islamic-goto-date〉〉:〈〈Move cursor to Islamic DATE; echo Islamic date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-islamic-print-date〉〉:〈〈Show the Islamic calendar equivalent of the date under the cursor.

(fn)〉〉enditem49840〈〈calendar-iso-goto-date〉〉:〈〈Move cursor to ISO DATE; echo ISO date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-iso-goto-week〉〉:〈〈Move cursor to ISO DATE; echo ISO date unless NOECHO is non-nil.
Interactively, goes to the first day of the specified week.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-iso-print-date〉〉:〈〈Show equivalent ISO date for the date under the cursor.

(fn)〉〉enditem49840〈〈calendar-julian-goto-date〉〉:〈〈Move cursor to Julian DATE; echo Julian date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-julian-print-date〉〉:〈〈Show the Julian calendar equivalent of the date under the cursor.

(fn)〉〉enditem49840〈〈calendar-list-holidays〉〉:〈〈Create a buffer containing the holidays for the current calendar window.
The holidays are those in the list ‘calendar-notable-days’.
Returns non-nil if any holidays are found.
If EVENT is non-nil, it’s an event indicating the buffer position to
use instead of point.

(fn &optional EVENT)〉〉enditem49840〈〈calendar-lunar-phases〉〉:〈〈Create a buffer with the lunar phases for the current calendar window.
If EVENT is non-nil, it’s an event indicating the buffer position to
use instead of point.

(fn &optional EVENT)〉〉enditem49840〈〈calendar-mark-holidays〉〉:〈〈Mark notable days in the calendar window.
If EVENT is non-nil, it’s an event indicating the buffer position to
use instead of point.

(fn &optional EVENT)〉〉enditem49840〈〈calendar-mark-today〉〉:〈〈Mark the date under the cursor in the calendar window.
The date is marked with ‘calendar-today-marker’.  You might want to add
this function to ‘calendar-today-visible-hook’.〉〉enditem49840〈〈calendar-mayan-goto-long-count-date〉〉:〈〈Move cursor to Mayan long count DATE.
Echo Mayan date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-mayan-next-haab-date〉〉:〈〈Move cursor to next instance of Mayan HAAB-DATE.
Echo Mayan date unless NOECHO is non-nil.

(fn HAAB-DATE &optional NOECHO)〉〉enditem49840〈〈calendar-mayan-next-tzolkin-date〉〉:〈〈Move cursor to next instance of Mayan TZOLKIN-DATE.
Echo Mayan date unless NOECHO is non-nil.

(fn TZOLKIN-DATE &optional NOECHO)〉〉enditem49840〈〈calendar-mayan-previous-haab-date〉〉:〈〈Move cursor to previous instance of Mayan HAAB-DATE.
Echo Mayan date unless NOECHO is non-nil.

(fn HAAB-DATE &optional NOECHO)〉〉enditem49840〈〈calendar-mayan-previous-tzolkin-date〉〉:〈〈Move cursor to previous instance of Mayan TZOLKIN-DATE.
Echo Mayan date unless NOECHO is non-nil.

(fn TZOLKIN-DATE &optional NOECHO)〉〉enditem49840〈〈calendar-mayan-print-date〉〉:〈〈Show the Mayan long count, tzolkin, and haab equivalents of date.

(fn)〉〉enditem49840〈〈calendar-other-month〉〉:〈〈Display a three-month calendar centered around MONTH and YEAR.
EVENT is an event like ‘last-nonmenu-event’.〉〉enditem49840〈〈calendar-persian-goto-date〉〉:〈〈Move cursor to Persian date DATE.
Echo Persian date unless NOECHO is non-nil.

(fn DATE &optional NOECHO)〉〉enditem49840〈〈calendar-persian-print-date〉〉:〈〈Show the Persian calendar equivalent of the selected date.

(fn)〉〉enditem49840〈〈calendar-print-day-of-year〉〉:〈〈Show day number in year/days remaining in year for date under the cursor.〉〉enditem49840〈〈calendar-print-other-dates〉〉:〈〈Show dates on other calendars for date under the cursor.
If called by a mouse-event, pops up a menu with the result.〉〉enditem49840〈〈calendar-redraw〉〉:〈〈Redraw the calendar display, if ‘calendar-buffer’ is live.〉〉enditem49840〈〈calendar-scroll-left-three-months〉〉:〈〈Scroll the displayed calendar window left by 3*ARG months.
If ARG is negative the calendar is scrolled right.  Maintains the relative
position of the cursor with respect to the calendar as well as possible.
EVENT is an event like ‘last-nonmenu-event’.

(fn ARG &optional EVENT)〉〉enditem49840〈〈calendar-scroll-left〉〉:〈〈Scroll the displayed calendar left by ARG months.
If ARG is negative the calendar is scrolled right.  Maintains the relative
position of the cursor with respect to the calendar as well as possible.
EVENT is an event like ‘last-nonmenu-event’.

(fn &optional ARG EVENT)〉〉enditem49840〈〈calendar-scroll-right-three-months〉〉:〈〈Scroll the displayed calendar window right by 3*ARG months.
If ARG is negative the calendar is scrolled left.  Maintains the relative
position of the cursor with respect to the calendar as well as possible.
EVENT is an event like ‘last-nonmenu-event’.

(fn ARG &optional EVENT)〉〉enditem49840〈〈calendar-scroll-right〉〉:〈〈Scroll the displayed calendar window right by ARG months.
If ARG is negative the calendar is scrolled left.  Maintains the relative
position of the cursor with respect to the calendar as well as possible.
EVENT is an event like ‘last-nonmenu-event’.

(fn &optional ARG EVENT)〉〉enditem49840〈〈calendar-set-date-style〉〉:〈〈Set the style of calendar and diary dates to STYLE (a symbol).
The valid styles are described in the documentation of ‘calendar-date-style’.〉〉enditem49840〈〈calendar-star-date〉〉:〈〈Replace the date under the cursor in the calendar window with asterisks.
You might want to add this function to ‘calendar-today-visible-hook’.〉〉enditem49840〈〈calendar-sunrise-sunset〉〉:〈〈Local time of sunrise and sunset for date under cursor.
Accurate to a few seconds.

(fn &optional EVENT)〉〉enditem49840〈〈calendar-unmark〉〉:〈〈Delete all diary/holiday marks/highlighting from the calendar.〉〉enditem49840〈〈calendar〉〉:〈〈Display a three-month Gregorian calendar.
The three months appear side by side, with the current month in
the middle surrounded by the previous and next months.  The
cursor is put on today’s date.  If optional prefix argument ARG
is non-nil, prompts for the central month and year.

Once in the calendar window, future or past months can be moved
into view.  Arbitrary months can be displayed, or the calendar
can be scrolled forward or backward.  The cursor can be moved
forward or backward by one day, one week, one month, or one year.
All of these commands take prefix arguments which, when negative,
cause movement in the opposite direction.  For convenience, the
digit keys and the minus sign are automatically prefixes.  Use
C-h m for details of the key bindings in the calendar
window.

Displays the calendar in a separate window, or optionally in a
separate frame, depending on the value of ‘calendar-setup’.

If ‘calendar-view-diary-initially-flag’ is non-nil, also displays the
diary entries for the current date (or however many days
‘diary-number-of-entries’ specifies).  This variable can be
overridden by ‘calendar-setup’.  As well as being displayed,
diary entries can also be marked on the calendar (see
‘calendar-mark-diary-entries-flag’).

Runs the following hooks:

‘calendar-today-visible-hook’, ‘calendar-today-invisible-hook’ - after
   generating a calendar, if today’s date is visible or not, respectively
‘calendar-initial-window-hook’ - after first creating a calendar

This function is suitable for execution in an init file.〉〉enditem49840〈〈cd〉〉:〈〈Make DIR become the current buffer’s default directory.
If your environment includes a ‘CDPATH’ variable, try each one of
that list of directories (separated by occurrences of
‘path-separator’) when resolving a relative directory name.
The path separator is colon in GNU and GNU-like systems.

(fn DIR)〉〉enditem49840〈〈center-line〉〉:〈〈Center the line point is on, within the width specified by ‘fill-column’.
This means adjusting the indentation so that it equals
the distance between the end of the text and ‘fill-column’.
The argument NLINES says how many lines to center.〉〉enditem49840〈〈change-log-merge〉〉:〈〈Merge the contents of change log file OTHER-LOG with this buffer.
Both must be found in Change Log mode (since the merging depends on
the appropriate motion commands).  OTHER-LOG can be either a file name
or a buffer.

Entries are inserted in chronological order.  Both the current and
old-style time formats for entries are supported.

(fn OTHER-LOG)〉〉enditem49840〈〈change-log-mode〉〉:〈〈Major mode for editing change logs; like Indented Text mode.
Prevents numeric backups and sets ‘left-margin’ to 8 and ‘fill-column’ to 74.
New log entries are usually made with M-x add-change-log-entry or C-x 4 a.
Each entry behaves as a paragraph, and the entries for one day as a page.
Runs ‘change-log-mode-hook’.


Uses keymap ‘change-log-mode-map’, which is not currently defined.


(fn)〉〉enditem49840〈〈char-fold-to-regexp〉〉:〈〈nil〉〉enditem49840〈〈check-parens〉〉:〈〈Check for unbalanced parentheses in the current buffer.
More accurately, check the narrowed part of the buffer for unbalanced
expressions ("sexps") in general.  This is done according to the
current syntax table and will find unbalanced brackets or quotes as
appropriate.  (See Info node ‘(emacs)Parentheses’.)  If imbalance is
found, an error is signaled and point is left at the first unbalanced
character.〉〉enditem49840〈〈chmod〉〉:〈〈Set mode bits of file named FILENAME to MODE (an integer).
Only the 12 low bits of MODE are used.

Interactively, mode bits are read by ‘read-file-modes’, which accepts
symbolic notation, like the ‘chmod’ command from GNU Coreutils.

(fn FILENAME MODE)〉〉enditem49840〈〈choose-completion〉〉:〈〈Choose the completion at point.
If EVENT, use EVENT’s position to determine the starting position.

(fn &optional EVENT)〉〉enditem49840〈〈clean-buffer-list〉〉:〈〈Kill old buffers that have not been displayed recently.
The relevant variables are ‘clean-buffer-list-delay-general’,
‘clean-buffer-list-delay-special’, ‘clean-buffer-list-kill-buffer-names’,
‘clean-buffer-list-kill-never-buffer-names’,
‘clean-buffer-list-kill-regexps’ and
‘clean-buffer-list-kill-never-regexps’.
While processing buffers, this procedure displays messages containing
the current date/time, buffer name, how many seconds ago it was
displayed (can be nil if the buffer was never displayed) and its
lifetime, i.e., its "age" when it will be purged.

(fn)〉〉enditem49840〈〈clear-rectangle〉〉:〈〈Blank out the region-rectangle.
The text previously in the region is overwritten with blanks.

When called from a program the rectangle’s corners are START and END.
With a prefix (or a FILL) argument, also fill with blanks the parts of the
rectangle which were empty.

(fn START END &optional FILL)〉〉enditem49840〈〈clipboard-kill-region〉〉:〈〈Kill the region, and save it in the GUI’s clipboard.
If the optional argument REGION is non-nil, the function ignores
BEG and END, and kills the current region instead.〉〉enditem49840〈〈clipboard-kill-ring-save〉〉:〈〈Copy region to kill ring, and save in the GUI’s clipboard.
If the optional argument REGION is non-nil, the function ignores
BEG and END, and saves the current region instead.〉〉enditem49840〈〈clipboard-yank〉〉:〈〈Insert the clipboard contents, or the last stretch of killed text.〉〉enditem49840〈〈clone-indirect-buffer-other-window〉〉:〈〈Like ‘clone-indirect-buffer’ but display in another window.

(fn NEWNAME DISPLAY-FLAG &optional NORECORD)〉〉enditem49840〈〈column-number-mode〉〉:〈〈Toggle column number display in the mode line (Column Number mode).
With a prefix argument ARG, enable Column Number mode if ARG is
positive, and disable it otherwise.

If called from Lisp, enable the mode if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈comint-bol-or-process-mark〉〉:〈〈Move point to beginning of line (after prompt) or to the process mark.
The first time you use this command, it moves to the beginning of the line
(but after the prompt, if any).  If you repeat it again immediately,
it moves point to the process mark.

The process mark separates the process output, along with input already sent,
from input that has not yet been sent.  Ordinarily, the process mark
is at the beginning of the current input line; but if you have
used M-x comint-accumulate to send multiple lines at once,
the process mark is at the beginning of the accumulated input.〉〉enditem49840〈〈comint-continue-subjob〉〉:〈〈Send CONT signal to process buffer’s process group.
Useful if you accidentally suspend the top-level process.〉〉enditem49840〈〈comint-copy-old-input〉〉:〈〈Insert after prompt old input at point as new input to be edited.
Calls ‘comint-get-old-input’ to get old input.〉〉enditem49840〈〈comint-delchar-or-maybe-eof〉〉:〈〈Delete ARG characters forward or send an EOF to subprocess.
Sends an EOF only if point is at the end of the buffer and there is no input.

(fn ARG)〉〉enditem49840〈〈comint-delete-output〉〉:〈〈Delete all output from interpreter since last input.
Does not delete the prompt.〉〉enditem49840〈〈comint-dynamic-list-filename-completions〉〉:〈〈Display a list of possible completions for the filename at point.〉〉enditem49840〈〈comint-dynamic-list-input-ring〉〉:〈〈Display a list of recent inputs entered into the current buffer.〉〉enditem49840〈〈comint-get-next-from-history〉〉:〈〈After fetching a line from input history, this fetches the following line.
In other words, this recalls the input line after the line you recalled last.
You can use this to repeat a sequence of input lines.〉〉enditem49840〈〈comint-history-isearch-backward-regexp〉〉:〈〈Search for a regular expression backward in input history using Isearch.〉〉enditem49840〈〈comint-insert-input〉〉:〈〈In a Comint buffer, set the current input to the previous input at point.
If there is no previous input at point, run the command specified
by the global keymap (usually ‘mouse-yank-at-click’).

(fn EVENT)〉〉enditem49840〈〈comint-interrupt-subjob〉〉:〈〈Interrupt the current subjob.〉〉enditem49840〈〈comint-kill-input〉〉:〈〈Kill all text from last stuff output by interpreter to point.〉〉enditem49840〈〈comint-magic-space〉〉:〈〈Expand input history references before point and insert ARG spaces.
A useful command to bind to SPC.  See ‘comint-replace-by-expanded-history’.

(fn ARG)〉〉enditem49840〈〈comint-next-input〉〉:〈〈Cycle forwards through input history.

(fn ARG)〉〉enditem49840〈〈comint-next-prompt〉〉:〈〈Move to end of Nth next prompt in the buffer.
If ‘comint-use-prompt-regexp’ is nil, then this means the beginning of
the Nth next ‘input’ field, otherwise, it means the Nth occurrence of
text matching ‘comint-prompt-regexp’.

(fn N)〉〉enditem49840〈〈comint-previous-input〉〉:〈〈Cycle backwards through input history, saving input.

(fn ARG)〉〉enditem49840〈〈comint-previous-prompt〉〉:〈〈Move to end of Nth previous prompt in the buffer.
If ‘comint-use-prompt-regexp’ is nil, then this means the beginning of
the Nth previous ‘input’ field, otherwise, it means the Nth occurrence of
text matching ‘comint-prompt-regexp’.

(fn N)〉〉enditem49840〈〈comint-quit-subjob〉〉:〈〈Send quit signal to the current subjob.〉〉enditem49840〈〈comint-run〉〉:〈〈Run PROGRAM in a Comint buffer and switch to it.
The buffer name is made by surrounding the file name of PROGRAM with ‘*’s.
The file name is used to make a symbol name, such as ‘comint-sh-hook’, and any
hooks on this symbol are run in the buffer.
See ‘make-comint’ and ‘comint-exec’.

(fn PROGRAM)〉〉enditem49840〈〈comint-send-input〉〉:〈〈Send input to process.
After the process output mark, sends all text from the process mark to
point as input to the process.  Before the process output mark, calls
value of variable ‘comint-get-old-input’ to retrieve old input, copies
it to the process mark, and sends it.

This command also sends and inserts a final newline, unless
NO-NEWLINE is non-nil.

Any history reference may be expanded depending on the value of the variable
‘comint-input-autoexpand’.  The list of function names contained in the value
of ‘comint-input-filter-functions’ is called on the input before sending it.
The input is entered into the input history ring, if the value of variable
‘comint-input-filter’ returns non-nil when called on the input.

If variable ‘comint-eol-on-send’ is non-nil, then point is moved to the
end of line before sending the input.

After the input has been sent, if ‘comint-process-echoes’ is non-nil,
then ‘comint-send-input’ waits to see if the process outputs a string
matching the input, and if so, deletes that part of the output.
If ARTIFICIAL is non-nil, it inhibits such deletion.
Callers sending input not from the user should use ARTIFICIAL = t.

The values of ‘comint-get-old-input’, ‘comint-input-filter-functions’, and
‘comint-input-filter’ are chosen according to the command interpreter running
in the buffer.  E.g.,

If the interpreter is the csh,
    ‘comint-get-old-input’ is the default:
	If ‘comint-use-prompt-regexp’ is nil, then
	either return the current input field, if point is on an input
	field, or the current line, if point is on an output field.
	If ‘comint-use-prompt-regexp’ is non-nil, then
	return the current line with any initial string matching the
	regexp ‘comint-prompt-regexp’ removed.
    ‘comint-input-filter-functions’ monitors input for "cd", "pushd", and
	"popd" commands.  When it sees one, it cd’s the buffer.
    ‘comint-input-filter’ is the default: returns t if the input isn’t all white
	space.

If the Comint is Lucid Common Lisp,
    ‘comint-get-old-input’ snarfs the sexp ending at point.
    ‘comint-input-filter-functions’ does nothing.
    ‘comint-input-filter’ returns nil if the input matches input-filter-regexp,
	which matches (1) all whitespace (2) :a, :c, etc.

Similarly for Soar, Scheme, etc.

(fn &optional NO-NEWLINE ARTIFICIAL)〉〉enditem49840〈〈comint-show-maximum-output〉〉:〈〈Put the end of the buffer at the bottom of the window.〉〉enditem49840〈〈comint-show-output〉〉:〈〈Display start of this batch of interpreter output at top of window.
Sets mark to the value of point when this command is run.〉〉enditem49840〈〈comint-stop-subjob〉〉:〈〈Stop the current subjob.

WARNING: if there is no current subjob, you can end up suspending
the top-level process running in the buffer.  If you accidentally do
this, use M-x comint-continue-subjob to resume the process.  (This
is not a problem with most shells, since they ignore this signal.)〉〉enditem49840〈〈comint-strip-ctrl-m〉〉:〈〈Strip trailing ‘^M’ characters from the current output group.
This function could be on ‘comint-output-filter-functions’ or bound to a key.

(fn &optional STRING)〉〉enditem49840〈〈comint-truncate-buffer〉〉:〈〈Truncate the buffer to ‘comint-buffer-maximum-size’.
This function could be on ‘comint-output-filter-functions’ or bound to a key.

(fn &optional STRING)〉〉enditem49840〈〈comint-write-output〉〉:〈〈Write output from interpreter since last input to FILENAME.
Any prompt at the end of the output is not written.

If the optional argument APPEND (the prefix argument when interactive)
is non-nil, the output is appended to the file instead.

If the optional argument MUSTBENEW is non-nil, check for an existing
file with the same name.  If MUSTBENEW is ‘excl’, that means to get an
error if the file already exists; never overwrite.  If MUSTBENEW is
neither nil nor ‘excl’, that means ask for confirmation before
overwriting, but do go ahead and overwrite the file if the user
confirms.  When interactive, MUSTBENEW is nil when appending, and t
otherwise.

(fn FILENAME &optional APPEND MUSTBENEW)〉〉enditem49840〈〈command-history〉〉:〈〈Examine commands from ‘command-history’ in a buffer.
The number of commands listed is controlled by ‘list-command-history-max’.
The command history is filtered by ‘list-command-history-filter’ if non-nil.
Use 
Uses keymap ‘command-history-map’, which is not currently defined.
M-x command-history-repeat to repeat the command on the current line.

Otherwise much like Emacs-Lisp Mode except that there is no self-insertion
and digits provide prefix arguments.  Tab does not indent.

Uses keymap ‘command-history-map’, which is not currently defined.


This command always recompiles the Command History listing
and runs the normal hook ‘command-history-hook’.

(fn)〉〉enditem49840〈〈comment-dwim〉〉:〈〈Call the comment command you want (Do What I Mean).
If the region is active and ‘transient-mark-mode’ is on, call
‘comment-region’ (unless it only consists of comments, in which
case it calls ‘uncomment-region’).
Else, if the current line is empty, call ‘comment-insert-comment-function’
if it is defined, otherwise insert a comment and indent it.
Else if a prefix ARG is specified, call ‘comment-kill’.
Else, call ‘comment-indent’.
You can configure ‘comment-style’ to change the way regions are commented.

(fn ARG)〉〉enditem49840〈〈comment-indent-new-line〉〉:〈〈Break line at point and indent, continuing comment if within one.
This indents the body of the continued comment
under the previous comment line.

This command is intended for styles where you write a comment per line,
starting a new comment (and terminating it if necessary) on each line.
If you want to continue one comment across several lines, use M-x newline-and-indent.

If a fill column is specified, it overrides the use of the comment column
or comment indentation.

The inserted newline is marked hard if variable ‘use-hard-newlines’ is true,
unless optional argument SOFT is non-nil.

(fn &optional SOFT)〉〉enditem49840〈〈comment-kill〉〉:〈〈Kill the first comment on this line, if any.
With prefix ARG, kill comments on that many lines starting with this one.

(fn ARG)〉〉enditem49840〈〈comment-line〉〉:〈〈Comment or uncomment current line and leave point after it.
With positive prefix, apply to N lines including current one.
With negative prefix, apply to -N lines above.  Also, further
consecutive invocations of this command will inherit the negative
argument.

If region is active, comment lines in active region instead.
Unlike ‘comment-dwim’, this always comments whole lines.

(fn N)〉〉enditem49840〈〈comment-region〉〉:〈〈Comment or uncomment each line in the region.
With just C-u prefix arg, uncomment each line in region BEG .. END.
Numeric prefix ARG means use ARG comment characters.
If ARG is negative, delete that many comment characters instead.

The strings used as comment starts are built from ‘comment-start’
and ‘comment-padding’; the strings used as comment ends are built
from ‘comment-end’ and ‘comment-padding’.

By default, the ‘comment-start’ markers are inserted at the
current indentation of the region, and comments are terminated on
each line (even for syntaxes in which newline does not end the
comment and blank lines do not get comments).  This can be
changed with ‘comment-style’.

(fn BEG END &optional ARG)〉〉enditem49840〈〈comment-set-column〉〉:〈〈Set the comment column based on point.
With no ARG, set the comment column to the current column.
With just minus as arg, kill any comment on this line.
With any other arg, set comment column to indentation of the previous comment
 and then align or create a comment on this line at that column.

(fn ARG)〉〉enditem49840〈〈compare-windows〉〉:〈〈Compare text in current window with text in another window.
The option ‘compare-windows-get-window-function’ defines how
to get another window.

Compares the text starting at point in each window,
moving over text in each one as far as they match.

This command pushes the mark in each window
at the prior location of point in that window.
If both windows display the same buffer,
the mark is pushed twice in that buffer:
first in the other window, then in the selected window.

A prefix arg means reverse the value of variable
‘compare-ignore-whitespace’.  If ‘compare-ignore-whitespace’ is
nil, then a prefix arg means ignore changes in whitespace.  If
‘compare-ignore-whitespace’ is non-nil, then a prefix arg means
don’t ignore changes in whitespace.  The variable
‘compare-windows-whitespace’ controls how whitespace is skipped.
If ‘compare-ignore-case’ is non-nil, changes in case are also
ignored.

If ‘compare-windows-sync’ is non-nil, then successive calls of
this command work in interlaced mode:
on first call it advances points to the next difference,
on second call it synchronizes points by skipping the difference,
on third call it again advances points to the next difference and so on.

(fn IGNORE-WHITESPACE)〉〉enditem49840〈〈compile〉〉:〈〈Compile the program including the current buffer.  Default: run ‘make’.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer ‘*compilation*’.

You can then use the command C-x ` to find the next error message
and move to the source code that caused it.

If optional second arg COMINT is t the buffer will be in Comint mode with
‘compilation-shell-minor-mode’.

Interactively, prompts for the command if the variable
‘compilation-read-command’ is non-nil; otherwise uses ‘compile-command’.
With prefix arg, always prompts.
Additionally, with universal prefix arg, compilation buffer will be in
comint mode, i.e. interactive.

To run more than one compilation at once, start one then rename
the ‘*compilation*’ buffer to some other name with
M-x rename-buffer.  Then _switch buffers_ and start the new compilation.
It will create a new ‘*compilation*’ buffer.

On most systems, termination of the main compilation process
kills its subprocesses.

The name used for the buffer is actually whatever is returned by
the function in ‘compilation-buffer-name-function’, so you can set that
to a function that generates a unique name.

(fn COMMAND &optional COMINT)〉〉enditem49840〈〈completion-at-point〉〉:〈〈Perform completion on the text around point.
The completion method is determined by ‘completion-at-point-functions’.〉〉enditem49840〈〈compose-mail-other-frame〉〉:〈〈Like C-x m, but edit the outgoing message in another frame.

(fn &optional TO SUBJECT OTHER-HEADERS CONTINUE YANK-ACTION SEND-ACTIONS RETURN-ACTION)〉〉enditem49840〈〈compose-mail-other-window〉〉:〈〈Like C-x m, but edit the outgoing message in another window.

(fn &optional TO SUBJECT OTHER-HEADERS CONTINUE YANK-ACTION SEND-ACTIONS RETURN-ACTION)〉〉enditem49840〈〈compose-mail〉〉:〈〈Start composing a mail message to send.
This uses the user’s chosen mail composition package
as selected with the variable ‘mail-user-agent’.
The optional arguments TO and SUBJECT specify recipients
and the initial Subject field, respectively.

OTHER-HEADERS is an alist specifying additional
header fields.  Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

CONTINUE, if non-nil, says to continue editing a message already
being composed.  Interactively, CONTINUE is the prefix argument.

SWITCH-FUNCTION, if non-nil, is a function to use to
switch to and display the buffer used for mail composition.

YANK-ACTION, if non-nil, is an action to perform, if and when necessary,
to insert the raw text of the message being replied to.
It has the form (FUNCTION . ARGS).  The user agent will apply
FUNCTION to ARGS, to insert the raw text of the original message.
(The user agent will also run ‘mail-citation-hook’, *after* the
original text has been inserted in this way.)

SEND-ACTIONS is a list of actions to call when the message is sent.
Each action has the form (FUNCTION . ARGS).

RETURN-ACTION, if non-nil, is an action for returning to the
caller.  It has the form (FUNCTION . ARGS).  The function is
called after the mail has been sent or put aside, and the mail
buffer buried.

(fn &optional TO SUBJECT OTHER-HEADERS CONTINUE SWITCH-FUNCTION YANK-ACTION SEND-ACTIONS RETURN-ACTION)〉〉enditem49840〈〈confirm-nonexistent-file-or-buffer〉〉:〈〈Whether to request confirmation before visiting a new file or buffer.
The variable ‘confirm-nonexistent-file-or-buffer’ determines the
return value, which may be passed as the REQUIRE-MATCH arg to
‘read-buffer’ or ‘find-file-read-args’.〉〉enditem49840〈〈copy-dir-locals-to-file-locals-prop-line〉〉:〈〈Copy directory-local variables to the -*- line.

(fn)〉〉enditem49840〈〈copy-dir-locals-to-file-locals〉〉:〈〈Copy directory-local variables to the Local Variables list.

(fn)〉〉enditem49840〈〈copy-file-locals-to-dir-locals〉〉:〈〈Copy file-local variables to .dir-locals.el.

(fn)〉〉enditem49840〈〈copy-rectangle-as-kill〉〉:〈〈Copy the region-rectangle and save it as the last killed one.

(fn START END)〉〉enditem49840〈〈copy-rectangle-to-register〉〉:〈〈Copy rectangular region into register REGISTER.
With prefix arg, delete as well.
To insert this register in the buffer, use DEL t k.

Called from a program, takes four args: REGISTER, START, END and DELETE-FLAG.
START and END are buffer positions giving two corners of rectangle.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER START END &optional DELETE-FLAG)〉〉enditem49840〈〈copy-to-buffer〉〉:〈〈Copy to specified buffer the text of the region.
It is inserted into that buffer, replacing existing text there.

When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied.

(fn BUFFER START END)〉〉enditem49840〈〈copy-to-register〉〉:〈〈Copy region into register REGISTER.
With prefix arg, delete as well.
Called from program, takes five args: REGISTER, START, END, DELETE-FLAG,
and REGION.  START and END are buffer positions indicating what to copy.
The optional argument REGION if non-nil, indicates that we’re not just
copying some text between START and END, but we’re copying the region.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER START END &optional DELETE-FLAG REGION)〉〉enditem49840〈〈count-lines-page〉〉:〈〈Report number of lines on current page, and how many are before or after point.〉〉enditem49840〈〈count-words-region〉〉:〈〈Count the number of words in the region.
If called interactively, print a message reporting the number of
lines, words, and characters in the region (whether or not the
region is active); with prefix ARG, report for the entire buffer
rather than the region.

If called from Lisp, return the number of words between positions
START and END.

(fn START END &optional ARG)〉〉enditem49840〈〈cpp-highlight-buffer〉〉:〈〈Highlight C code according to preprocessor conditionals.
This command pops up a buffer which you should edit to specify
what kind of highlighting to use, and the criteria for highlighting.
A prefix arg suppresses display of that buffer.

(fn ARG)〉〉enditem49840〈〈cua-mode〉〉:〈〈Toggle Common User Access style editing (CUA mode).
With a prefix argument ARG, enable CUA mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

CUA mode is a global minor mode.  When enabled, typed text
replaces the active selection, and you can use C-z, C-x, C-c, and
C-v to undo, cut, copy, and paste in addition to the normal Emacs
bindings.  The C-x and C-c keys only do cut and copy when the
region is active, so in most cases, they do not conflict with the
normal function of these prefix keys.

If you really need to perform a command which starts with one of
the prefix keys even when the region is active, you have three
options:
- press the prefix key twice very quickly (within 0.2 seconds),
- press the prefix key and the following key within 0.2 seconds, or
- use the SHIFT key with the prefix key, i.e. C-S-x or C-S-c.

You can customize ‘cua-enable-cua-keys’ to completely disable the
CUA bindings, or ‘cua-prefix-override-inhibit-delay’ to change
the prefix fallback behavior.

(fn &optional ARG)〉〉enditem49840〈〈cua-rectangle-mark-mode〉〉:〈〈Toggle the region as rectangular.
Activates the region if needed.  Only lasts until the region is deactivated.

(fn &optional ARG)〉〉enditem49840〈〈custom-file〉〉:〈〈Return the file name for saving customizations.

(fn &optional NO-ERROR)〉〉enditem49840〈〈custom-prompt-customize-unsaved-options〉〉:〈〈Prompt user to customize any unsaved customization options.
Return non-nil if user chooses to customize, for use in
‘kill-emacs-query-functions’.〉〉enditem49840〈〈customize-apropos〉〉:〈〈Customize loaded options, faces and groups matching PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of
words, search for matches for any two (or more) of those words.

If TYPE is ‘options’, include only options.
If TYPE is ‘faces’, include only faces.
If TYPE is ‘groups’, include only groups.

(fn PATTERN &optional TYPE)〉〉enditem49840〈〈customize-browse〉〉:〈〈Create a tree browser for the customize hierarchy.

(fn &optional GROUP)〉〉enditem49840〈〈customize-changed〉〉:〈〈Customize all settings whose meanings have changed in Emacs itself.
This includes new user options and faces, and new customization
groups, as well as older options and faces whose meanings or
default values have changed since the previous major Emacs
release.

With argument SINCE-VERSION (a string), customize all settings
that were added or redefined since that version.

(fn &optional SINCE-VERSION)〉〉enditem49840〈〈customize-create-theme〉〉:〈〈Create or edit a custom theme.
THEME, if non-nil, should be an existing theme to edit.  If THEME
is ‘user’, the resulting *Custom Theme* buffer also contains a
checkbox for removing the theme settings specified in the buffer
from the Custom save file.
BUFFER, if non-nil, should be a buffer to use; the default is
named *Custom Theme*.

(fn &optional THEME BUFFER)〉〉enditem49840〈〈customize-face〉〉:〈〈Customize FACE, which should be a face name or nil.
If FACE is nil, customize all faces.  If FACE is actually a
face-alias, customize the face it is aliased to.

If OTHER-WINDOW is non-nil, display in another window.

Interactively, when point is on text which has a face specified,
suggest to customize that face, if it’s customizable.

(fn &optional FACE OTHER-WINDOW)〉〉enditem49840〈〈customize-group〉〉:〈〈Customize GROUP, which must be a customization group.
If OTHER-WINDOW is non-nil, display in another window.

(fn &optional GROUP OTHER-WINDOW)〉〉enditem49840〈〈customize-option〉〉:〈〈Customize SYMBOL, which must be a user option.

(fn SYMBOL)〉〉enditem49840〈〈customize-saved〉〉:〈〈Customize all saved options and faces.〉〉enditem49840〈〈customize-themes〉〉:〈〈Display a selectable list of Custom themes.
When called from Lisp, BUFFER should be the buffer to use; if
omitted, a buffer named *Custom Themes* is used.

(fn &optional BUFFER)〉〉enditem49840〈〈customize-unsaved〉〉:〈〈Customize all options and faces set in this session but not saved.〉〉enditem49840〈〈customize〉〉:〈〈Select a customization buffer which you can use to set user options.
User options are structured into "groups".
Initially the top-level group ‘Emacs’ and its immediate subgroups
are shown; the contents of those subgroups are initially hidden.〉〉enditem49840〈〈cwarn-mode〉〉:〈〈Minor mode that highlights suspicious C and C++ constructions.

Suspicious constructs are highlighted using ‘font-lock-warning-face’.

Note, in addition to enabling this minor mode, the major mode must
be included in the variable ‘cwarn-configuration’.  By default C and
C++ modes are included.

With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈cycle-spacing〉〉:〈〈Manipulate whitespace around point in a smart way.
In interactive use, this function behaves differently in successive
consecutive calls.

The first call in a sequence acts like ‘just-one-space’.
It deletes all spaces and tabs around point, leaving one space
(or N spaces).  N is the prefix argument.  If N is negative,
it deletes newlines as well, leaving -N spaces.
(If PRESERVE-NL-BACK is non-nil, it does not delete newlines before point.)

The second call in a sequence deletes all spaces.

The third call in a sequence restores the original whitespace (and point).

If MODE is ‘single-shot’, it only performs the first step in the sequence.
If MODE is ‘fast’ and the first step would not result in any change
(i.e., there are exactly (abs N) spaces around point),
the function goes straight to the second step.

Repeatedly calling the function with different values of N starts a
new sequence each time.

(fn &optional N PRESERVE-NL-BACK MODE)〉〉enditem49840〈〈dabbrev-completion〉〉:〈〈Completion on current word.
Like M-/ but finds all expansions in the current buffer
and presents suggestions for completion.

With a prefix argument ARG, it searches all buffers accepted by the
function pointed out by ‘dabbrev-friend-buffer-function’ to find the
completions.

If the prefix argument is 16 (which comes from C-u C-u),
then it searches *all* buffers.

(fn &optional ARG)〉〉enditem49840〈〈dabbrev-expand〉〉:〈〈Expand previous word "dynamically".

Expands to the most recent, preceding word for which this is a prefix.
If no suitable preceding word is found, words following point are
considered.  If still no suitable word is found, then look in the
buffers accepted by the function pointed out by variable
‘dabbrev-friend-buffer-function’, if ‘dabbrev-check-other-buffers’
says so.  Then, if ‘dabbrev-check-all-buffers’ is non-nil, look in
all the other buffers, subject to constraints specified
by ‘dabbrev-ignored-buffer-names’ and ‘dabbrev-ignored-regexps’.

A positive prefix argument, N, says to take the Nth backward *distinct*
possibility.  A negative argument says search forward.

If the cursor has not moved from the end of the previous expansion and
no argument is given, replace the previously-made expansion
with the next possible expansion not yet tried.

The variable ‘dabbrev-backward-only’ may be used to limit the
direction of search to backward if set non-nil.

See also ‘dabbrev-abbrev-char-regexp’ and C-M-/.

(fn ARG)〉〉enditem49840〈〈dbx〉〉:〈〈Run dbx on program FILE in buffer *gud-FILE*.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.

(fn COMMAND-LINE)〉〉enditem49840〈〈decipher〉〉:〈〈Format a buffer of ciphertext for cryptanalysis and enter Decipher mode.

(fn)〉〉enditem49840〈〈defadvice〉〉:〈〈Define a piece of advice for FUNCTION (a symbol).
The syntax of ‘defadvice’ is as follows:

  (defadvice FUNCTION (CLASS NAME [POSITION] [ARGLIST] FLAG...)
    [DOCSTRING] [INTERACTIVE-FORM]
    BODY...)

FUNCTION ::= Name of the function to be advised.
CLASS ::= ‘before’ | ‘around’ | ‘after’ | ‘activation’ | ‘deactivation’.
NAME ::= Non-nil symbol that names this piece of advice.
POSITION ::= ‘first’ | ‘last’ | NUMBER. Optional, defaults to ‘first’,
    see also ‘ad-add-advice’.
ARGLIST ::= An optional argument list to be used for the advised function
    instead of the argument list of the original.  The first one found in
    before/around/after-advices will be used.
FLAG ::= ‘protect’|‘disable’|‘activate’|‘compile’|‘preactivate’.
    All flags can be specified with unambiguous initial substrings.
DOCSTRING ::= Optional documentation for this piece of advice.
INTERACTIVE-FORM ::= Optional interactive form to be used for the advised
    function.  The first one found in before/around/after-advices will be used.
BODY ::= Any s-expression.

Semantics of the various flags:
‘protect’: The piece of advice will be protected against non-local exits in
any code that precedes it.  If any around-advice of a function is protected
then automatically all around-advices will be protected (the complete onion).

‘activate’: All advice of FUNCTION will be activated immediately if
FUNCTION has been properly defined prior to this application of ‘defadvice’.

‘compile’: In conjunction with ‘activate’ specifies that the resulting
advised function should be compiled.

‘disable’: The defined advice will be disabled, hence, it will not be used
during activation until somebody enables it.

‘preactivate’: Preactivates the advised FUNCTION at macro-expansion/compile
time.  This generates a compiled advised definition according to the current
advice state that will be used during activation if appropriate.  Only use
this if the ‘defadvice’ gets actually compiled.

usage: (defadvice FUNCTION (CLASS NAME [POSITION] [ARGLIST] FLAG...)
          [DOCSTRING] [INTERACTIVE-FORM]
          BODY...)

(fn FUNCTION ARGS &rest BODY)〉〉enditem49840〈〈define-abbrevs〉〉:〈〈Define abbrevs according to current visible buffer contents.
See documentation of ‘edit-abbrevs’ for info on the format of the
text you must have in the buffer.
With argument, eliminate all abbrev definitions except
the ones defined from the buffer now.

(fn &optional ARG)〉〉enditem49840〈〈define-global-abbrev〉〉:〈〈Define ABBREV as a global abbreviation for EXPANSION.
The characters in ABBREV must all be word constituents in the standard
syntax table.

(fn ABBREV EXPANSION)〉〉enditem49840〈〈define-mode-abbrev〉〉:〈〈Define ABBREV as a mode-specific abbreviation for EXPANSION.
The characters in ABBREV must all be word-constituents in the current mode.

(fn ABBREV EXPANSION)〉〉enditem49840〈〈delete-active-region〉〉:〈〈Delete the active region.
If KILLP in not-nil, the active region is killed instead of deleted.

(fn &optional KILLP)〉〉enditem49840〈〈delete-dir-local-variable〉〉:〈〈Delete all MODE settings of file-local VARIABLE from .dir-locals.el.

(fn MODE VARIABLE)〉〉enditem49840〈〈delete-duplicate-lines〉〉:〈〈Delete all but one copy of any identical lines in the region.
Non-interactively, arguments BEG and END delimit the region.
Normally it searches forwards, keeping the first instance of
each identical line.  If REVERSE is non-nil (interactively, with
a C-u prefix), it searches backwards and keeps the last instance of
each repeated line.

Identical lines need not be adjacent, unless the argument
ADJACENT is non-nil (interactively, with a C-u C-u prefix).
This is a more efficient mode of operation, and may be useful
on large regions that have already been sorted.

If the argument KEEP-BLANKS is non-nil (interactively, with a
C-u C-u C-u prefix), it retains repeated blank lines.

Returns the number of deleted lines.  Interactively, or if INTERACTIVE
is non-nil, it also prints a message describing the number of deletions.

(fn BEG END &optional REVERSE ADJACENT KEEP-BLANKS INTERACTIVE)〉〉enditem49840〈〈delete-file-local-variable-prop-line〉〉:〈〈Delete all settings of file-local VARIABLE from the -*- line.

(fn VARIABLE &optional INTERACTIVE)〉〉enditem49840〈〈delete-file-local-variable〉〉:〈〈Delete all settings of file-local VARIABLE from the Local Variables list.

(fn VARIABLE &optional INTERACTIVE)〉〉enditem49840〈〈delete-forward-char〉〉:〈〈Delete the following N characters (previous if N is negative).
If Transient Mark mode is enabled, the mark is active, and N is 1,
delete the text in the region and deactivate the mark instead.
To disable this, set variable ‘delete-active-region’ to nil.

Optional second arg KILLFLAG non-nil means to kill (save in kill
ring) instead of delete.  Interactively, N is the prefix arg, and
KILLFLAG is set if N was explicitly specified.

When killing, the killed text is filtered by
‘filter-buffer-substring’ before it is saved in the kill ring, so
the actual saved text might be different from what was killed.

(fn N &optional KILLFLAG)〉〉enditem49840〈〈delete-other-frames〉〉:〈〈Delete all frames on FRAME’s terminal, except FRAME.
If FRAME uses another frame’s minibuffer, the minibuffer frame is
left untouched.  Do not delete any of FRAME’s child frames.  If
FRAME is a child frame, delete its siblings only.  FRAME must be
a live frame and defaults to the selected one.

(fn &optional FRAME)〉〉enditem49840〈〈delete-rectangle〉〉:〈〈Delete (don’t save) text in the region-rectangle.
The same range of columns is deleted in each line starting with the
line where the region begins and ending with the line where the region
ends.

When called from a program the rectangle’s corners are START and END.
With a prefix (or a FILL) argument, also fill lines where nothing has
to be deleted.

(fn START END &optional FILL)〉〉enditem49840〈〈delete-selection-mode〉〉:〈〈Toggle Delete Selection mode.
Interactively, with a prefix argument, enable
Delete Selection mode if the prefix argument is positive,
and disable it otherwise.  If called from Lisp, toggle
the mode if ARG is ‘toggle’, disable the mode if ARG is
a non-positive integer, and enable the mode otherwise
(including if ARG is omitted or nil or a positive integer).

When Delete Selection mode is enabled, typed text replaces the selection
if the selection is active.  Otherwise, typed text is just inserted at
point regardless of any selection.

See ‘delete-selection-helper’ and ‘delete-selection-pre-hook’ for
information on adapting behavior of commands in Delete Selection mode.

(fn &optional ARG)〉〉enditem49840〈〈delete-whitespace-rectangle〉〉:〈〈Delete all whitespace following a specified column in each line.
The left edge of the rectangle specifies the position in each line
at which whitespace deletion should begin.  On each line in the
rectangle, all contiguous whitespace starting at that column is deleted.

When called from a program the rectangle’s corners are START and END.
With a prefix (or a FILL) argument, also fill too short lines.

(fn START END &optional FILL)〉〉enditem49840〈〈describe-character-set〉〉:〈〈Display information about built-in character set CHARSET.

(fn CHARSET)〉〉enditem49840〈〈describe-coding-system〉〉:〈〈Display information about CODING-SYSTEM.

(fn CODING-SYSTEM)〉〉enditem49840〈〈describe-copying〉〉:〈〈Display info on how you may redistribute copies of GNU Emacs.〉〉enditem49840〈〈describe-distribution〉〉:〈〈Display info on how to obtain the latest version of GNU Emacs.〉〉enditem49840〈〈describe-function〉〉:〈〈Display the full documentation of FUNCTION (a symbol).
When called from lisp, FUNCTION may also be a function object.

(fn FUNCTION)〉〉enditem49840〈〈describe-gnu-project〉〉:〈〈Browse online information on the GNU project.〉〉enditem49840〈〈describe-input-method〉〉:〈〈Describe input method INPUT-METHOD.

(fn INPUT-METHOD)〉〉enditem49840〈〈describe-key-briefly〉〉:〈〈Print the name of the function KEY invokes.  KEY is a string.
If INSERT (the prefix arg) is non-nil, insert the message in the buffer.
If non-nil, UNTRANSLATED is a vector of the untranslated events.
It can also be a number in which case the untranslated events from
the last key hit are used.

If KEY is a menu item or a tool-bar button that is disabled, this command
temporarily enables it to allow getting help on disabled items and buttons.〉〉enditem49840〈〈describe-key〉〉:〈〈Display documentation of the function invoked by KEY.
KEY can be any kind of a key sequence; it can include keyboard events,
mouse events, and/or menu events.  When calling from a program,
pass KEY as a string or a vector.

If non-nil, UNTRANSLATED is a vector of the corresponding untranslated events.
It can also be a number, in which case the untranslated events from
the last key sequence entered are used.
UP-EVENT is the up-event that was discarded by reading KEY, or nil.

If KEY is a menu item or a tool-bar button that is disabled, this command
temporarily enables it to allow getting help on disabled items and buttons.〉〉enditem49840〈〈describe-language-environment〉〉:〈〈Describe how Emacs supports language environment LANGUAGE-NAME.

(fn LANGUAGE-NAME)〉〉enditem49840〈〈describe-no-warranty〉〉:〈〈Display info on all the kinds of warranty Emacs does NOT have.〉〉enditem49840〈〈describe-package〉〉:〈〈Display the full documentation of PACKAGE (a symbol).

(fn PACKAGE)〉〉enditem49840〈〈describe-symbol〉〉:〈〈Display the full documentation of SYMBOL.
Will show the info of SYMBOL as a function, variable, and/or face.
Optional arguments BUFFER and FRAME specify for which buffer and
frame to show the information about SYMBOL; they default to the
current buffer and the selected frame, respectively.

(fn SYMBOL &optional BUFFER FRAME)〉〉enditem49840〈〈describe-text-properties〉〉:〈〈Describe widgets, buttons, overlays, and text properties at POS.
POS is taken to be in BUFFER or in current buffer if nil.
Interactively, describe them for the character after point.
If optional second argument OUTPUT-BUFFER is non-nil,
insert the output into that buffer, and don’t initialize or clear it
otherwise.

(fn POS &optional OUTPUT-BUFFER BUFFER)〉〉enditem49840〈〈describe-theme〉〉:〈〈Display a description of the Custom theme THEME (a symbol).

(fn THEME)〉〉enditem49840〈〈describe-variable〉〉:〈〈Display the full documentation of VARIABLE (a symbol).
Returns the documentation as a string, also.
If VARIABLE has a buffer-local value in BUFFER or FRAME
(default to the current buffer and current frame),
it is displayed along with the global value.

(fn VARIABLE &optional BUFFER FRAME)〉〉enditem49840〈〈desktop-change-dir〉〉:〈〈Change to desktop saved in DIRNAME.
Kill the desktop as specified by variables ‘desktop-save-mode’ and
‘desktop-save’, then clear the desktop and load the desktop file in
directory DIRNAME.

(fn DIRNAME)〉〉enditem49840〈〈desktop-clear〉〉:〈〈Empty the Desktop.
This kills all buffers except for internal ones and those with names matched by
a regular expression in the list ‘desktop-clear-preserve-buffers’.
Furthermore, it clears the variables listed in ‘desktop-globals-to-clear’.
When called interactively and ‘desktop-restore-frames’ is non-nil, it also
deletes all frames except the selected one (and its minibuffer frame,
if different).〉〉enditem49840〈〈desktop-revert〉〉:〈〈Revert to the last loaded desktop.〉〉enditem49840〈〈desktop-save-mode〉〉:〈〈Toggle desktop saving (Desktop Save mode).
With a prefix argument ARG, enable Desktop Save mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode if ARG
is omitted or nil.

When Desktop Save mode is enabled, the state of Emacs is saved from
one session to another.  In particular, Emacs will save the desktop when
it exits (this may prompt you; see the option ‘desktop-save’).  The next
time Emacs starts, if this mode is active it will restore the desktop.

To manually save the desktop at any time, use the command ‘M-x desktop-save’.
To load it, use ‘M-x desktop-read’.

Once a desktop file exists, Emacs will auto-save it according to the
option ‘desktop-auto-save-timeout’.

To see all the options you can set, browse the ‘desktop’ customization group.

For further details, see info node ‘(emacs)Saving Emacs Sessions’.

(fn &optional ARG)〉〉enditem49840〈〈desktop-save〉〉:〈〈Save the desktop in a desktop file.
Parameter DIRNAME specifies where to save the desktop file.
Optional parameter RELEASE says whether we’re done with this
desktop.  If ONLY-IF-CHANGED is non-nil, compare the current
desktop information to that in the desktop file, and if the
desktop information has not changed since it was last saved then
do not rewrite the file.

This function can save the desktop in either format version
208 (which only Emacs 25.1 and later can read) or version
206 (which is readable by any Emacs from version 22.1 onwards).
By default, it will use the same format the desktop file had when
it was last saved, or version 208 when writing a fresh desktop
file.

To upgrade a version 206 file to version 208, call this command
explicitly with a bare prefix argument: C-u M-x desktop-save.
You are recommended to do this once you have firmly upgraded to
Emacs 25.1 (or later).  To downgrade a version 208 file to version
206, use a double command prefix: C-u C-u M-x desktop-save.
Confirmation will be requested in either case.  In a non-interactive
call, VERSION can be given as an integer, either 206 or 208, which
will be accepted as the format version in which to save the file
without further confirmation.

(fn DIRNAME &optional RELEASE ONLY-IF-CHANGED VERSION)〉〉enditem49840〈〈diary-bahai-insert-entry〉〉:〈〈Insert a diary entry.
For the Bahá’í date corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-bahai-insert-monthly-entry〉〉:〈〈Insert a monthly diary entry.
For the day of the Bahá’í month corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-bahai-insert-yearly-entry〉〉:〈〈Insert an annual diary entry.
For the day of the Bahá’í year corresponding to the date indicated by point.
Prefix argument ARG will make the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-chinese-insert-anniversary-entry〉〉:〈〈Insert an anniversary diary entry for the Chinese date at point.
Prefix argument ARG makes the entry nonmarking.

(fn &optional ARG)〉〉enditem49840〈〈diary-chinese-insert-entry〉〉:〈〈Insert a diary entry for the Chinese date at point.

(fn &optional ARG)〉〉enditem49840〈〈diary-chinese-insert-monthly-entry〉〉:〈〈Insert a monthly diary entry for the Chinese date at point.

(fn &optional ARG)〉〉enditem49840〈〈diary-chinese-insert-yearly-entry〉〉:〈〈Insert a yearly diary entry for the Chinese date at point.

(fn &optional ARG)〉〉enditem49840〈〈diary-chinese-list-entries〉〉:〈〈Add any Chinese date entries from the diary file to ‘diary-entries-list’.
Chinese date diary entries must be prefixed by ‘diary-chinese-entry-symbol’
(normally a ‘C’).  The same ‘diary-date-forms’ govern the style
of the Chinese calendar entries.  If a Chinese date diary entry begins with
‘diary-nonmarking-symbol’, the entry will appear in the diary listing,
but will not be marked in the calendar.

This function is provided for use with ‘diary-nongregorian-listing-hook’.

(fn)〉〉enditem49840〈〈diary-chinese-mark-entries〉〉:〈〈Mark days in the calendar window that have Chinese date diary entries.
Marks each entry in ‘diary-file’ (or included files) visible in the calendar
window.  See ‘diary-chinese-list-entries’ for more information.

This function is provided for use with ‘diary-nongregorian-marking-hook’.

(fn)〉〉enditem49840〈〈diary-hebrew-insert-entry〉〉:〈〈Insert a diary entry for the Hebrew date at point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-hebrew-insert-monthly-entry〉〉:〈〈Insert a monthly diary entry.
For the day of the Hebrew month corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-hebrew-insert-yearly-entry〉〉:〈〈Insert an annual diary entry.
For the day of the Hebrew year corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-anniversary-entry〉〉:〈〈Insert an anniversary diary entry for the date given by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-block-entry〉〉:〈〈Insert a block diary entry for the days between the point and marked date.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-cyclic-entry〉〉:〈〈Insert a cyclic diary entry starting at the date given by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-entry〉〉:〈〈Insert a diary entry for the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG &optional EVENT)〉〉enditem49840〈〈diary-insert-monthly-entry〉〉:〈〈Insert a monthly diary entry for the day of the month indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-weekly-entry〉〉:〈〈Insert a weekly diary entry for the day of the week indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-insert-yearly-entry〉〉:〈〈Insert an annual diary entry for the day of the year indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-islamic-insert-entry〉〉:〈〈Insert a diary entry.
For the Islamic date corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-islamic-insert-monthly-entry〉〉:〈〈Insert a monthly diary entry.
For the day of the Islamic month corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-islamic-insert-yearly-entry〉〉:〈〈Insert an annual diary entry.
For the day of the Islamic year corresponding to the date indicated by point.
Prefix argument ARG makes the entry nonmarking.

(fn ARG)〉〉enditem49840〈〈diary-mail-entries〉〉:〈〈Send a mail message showing diary entries for next NDAYS days.
If no prefix argument is given, NDAYS is set to ‘diary-mail-days’.
Mail is sent to the address specified by ‘diary-mail-addr’.

Here is an example of a script to call ‘diary-mail-entries’,
suitable for regular scheduling using cron (or at).  Note that
since ‘emacs -script’ does not load your init file, you should
ensure that all relevant variables are set.

#!/usr/bin/emacs -script
;; diary-rem.el - run the Emacs diary-reminder

(setq diary-mail-days 3
      diary-file "/path/to/diary.file"
      calendar-date-style 'european
      diary-mail-addr "user@host.name")

(diary-mail-entries)

# diary-rem.el ends here

(fn &optional NDAYS)〉〉enditem49840〈〈diary-mark-entries〉〉:〈〈Mark days in the calendar window that have diary entries.
Marks each entry in the diary that is visible in the calendar window.

After marking the entries, runs ‘diary-nongregorian-marking-hook’
for the main diary file, and each included file.  For example,
this is the appropriate hook to process Islamic entries in all
diary files.  Next ‘diary-mark-entries-hook’ runs, for the main diary
file only.  If not using include files, there is no difference between
these two hooks.

If the optional argument REDRAW is non-nil (which is the case
interactively, for example) then this first removes any existing diary
marks.  This is intended to deal with deleted diary entries.

(fn &optional REDRAW)〉〉enditem49840〈〈diary-show-all-entries〉〉:〈〈Show all of the diary entries in the diary file.
This function gets rid of the selective display of the diary file so that
all entries, not just some, are visible.  If there is no diary buffer, one
is created.

(fn)〉〉enditem49840〈〈diary-view-entries〉〉:〈〈Prepare and display a buffer with diary entries.
Searches the file named in ‘diary-file’ for entries that match
ARG days starting with the date indicated by the cursor position
in the displayed three-month calendar.

(fn &optional ARG)〉〉enditem49840〈〈diary〉〉:〈〈Generate the diary window for ARG days starting with the current date.
If no argument is provided, the number of days of diary entries is governed
by the variable ‘diary-number-of-entries’.  A value of ARG less than 1
does nothing.  This function is suitable for execution in an init file.

(fn &optional ARG)〉〉enditem49840〈〈diff-add-change-log-entries-other-window〉〉:〈〈Iterate through the current diff and create ChangeLog entries.
I.e. like ‘add-change-log-entry-other-window’ but applied to all hunks.〉〉enditem49840〈〈diff-apply-hunk〉〉:〈〈Apply the current hunk to the source file and go to the next.
By default, the new source file is patched, but if the variable
‘diff-jump-to-old-file’ is non-nil, then the old source file is
patched instead (some commands, such as ‘diff-goto-source’ can change
the value of this variable when given an appropriate prefix argument).

With a prefix argument, REVERSE the hunk.

(fn &optional REVERSE)〉〉enditem49840〈〈diff-auto-refine-mode〉〉:〈〈Toggle automatic diff hunk highlighting (Diff Auto Refine mode).
With a prefix argument ARG, enable Diff Auto Refine mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

Diff Auto Refine mode is a buffer-local minor mode used with
‘diff-mode’.  When enabled, Emacs automatically highlights
changes in detail as the user visits hunks.  When transitioning
from disabled to enabled, it tries to refine the current hunk, as
well.

(fn &optional ARG)〉〉enditem49840〈〈diff-backup〉〉:〈〈Diff this file with its backup file or vice versa.
Uses the latest backup, if there are several numerical backups.
If this file is a backup, diff it with its original.
The backup file is the first file given to ‘diff’.
With prefix arg, prompt for diff switches.

(fn FILE &optional SWITCHES)〉〉enditem49840〈〈diff-buffer-with-file〉〉:〈〈View the differences between BUFFER and its associated file.
This requires the external program ‘diff’ to be in your ‘exec-path’.

(fn &optional BUFFER)〉〉enditem49840〈〈diff-delete-trailing-whitespace〉〉:〈〈Remove trailing whitespace from lines modified in this diff.
This edits both the current Diff mode buffer and the patched
source file(s).  If ‘diff-jump-to-old-file’ is non-nil, edit the
original (unpatched) source file instead.  With a prefix argument
OTHER-FILE, flip the choice of which source file to edit.

If a file referenced in the diff has no buffer and needs to be
fixed, visit it in a buffer.

(fn &optional OTHER-FILE)〉〉enditem49840〈〈diff-ediff-patch〉〉:〈〈Call ‘ediff-patch-file’ on the current buffer.〉〉enditem49840〈〈diff-file-kill〉〉:〈〈Kill current file’s hunks.〉〉enditem49840〈〈diff-file-next〉〉:〈〈Go to the next COUNT’th file.

(fn &optional COUNT)〉〉enditem49840〈〈diff-file-prev〉〉:〈〈Go to the previous COUNT’th file

(fn &optional COUNT)〉〉enditem49840〈〈diff-goto-source〉〉:〈〈Jump to the corresponding source line.
‘diff-jump-to-old-file’ (or its opposite if the OTHER-FILE prefix arg
is given) determines whether to jump to the old or the new file.
If the prefix arg is bigger than 8 (for example with C-u C-u)
then ‘diff-jump-to-old-file’ is also set, for the next invocations.

(fn &optional OTHER-FILE EVENT)〉〉enditem49840〈〈diff-hunk-kill〉〉:〈〈Kill the hunk at point.〉〉enditem49840〈〈diff-hunk-next〉〉:〈〈Go to the next COUNT’th hunk.

(fn &optional COUNT)〉〉enditem49840〈〈diff-hunk-prev〉〉:〈〈Go to the previous COUNT’th hunk

(fn &optional COUNT)〉〉enditem49840〈〈diff-ignore-whitespace-hunk〉〉:〈〈Re-diff the current hunk, ignoring whitespace differences.〉〉enditem49840〈〈diff-mode〉〉:〈〈Major mode for viewing/editing context diffs.
Supports unified and context diffs as well as (to a lesser extent)
normal diffs.

When the buffer is read-only, the ESC prefix is not necessary.
If you edit the buffer manually, diff-mode will try to update the hunk
headers for you on-the-fly.

You can also switch between context diff and unified diff with M-x diff-context->unified,
or vice versa with M-x diff-unified->context and you can also reverse the direction of
a diff with M-x diff-reverse-direction.

   key             binding
---             -------

C-c             Prefix Command
C-x             Prefix Command
ESC             Prefix Command

C-x 4           Prefix Command

C-c C-a         diff-apply-hunk
C-c C-b         diff-refine-hunk
C-c C-c         diff-goto-source
C-c C-d         diff-unified->context
C-c C-e         diff-ediff-patch
C-c C-f         next-error-follow-minor-mode
C-c C-n         diff-restrict-view
C-c C-r         diff-reverse-direction
C-c C-s         diff-split-hunk
C-c C-t         diff-test-hunk
C-c C-u         diff-context->unified
C-c C-w         diff-ignore-whitespace-hunk

C-M-i           diff-hunk-next
M-RET           diff-goto-source
M-SPC           scroll-up-command
M--             negative-argument
M-0 .. M-9      digit-argument
M-<             beginning-of-buffer
M->             end-of-buffer
M-?             describe-mode
M-K             diff-file-kill
M-N             diff-file-next
M-P             diff-file-prev
M-h             describe-mode
M-k             diff-hunk-kill
M-n             diff-hunk-next
M-o             diff-goto-source
M-p             diff-hunk-prev
M-{             diff-file-prev
M-}             diff-file-next
M-DEL           scroll-down-command
M-S-SPC         scroll-down-command
ESC <backtab>   diff-hunk-prev
ESC <mouse-2>   diff-goto-source
ESC <remap>     Prefix Command

C-x 4 A         diff-add-change-log-entries-other-window

ESC <remap> <undo>              diff-undo



This mode runs the hook ‘diff-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈diff-refine-hunk〉〉:〈〈Highlight changes of hunk at point at a finer granularity.〉〉enditem49840〈〈diff-restrict-view〉〉:〈〈Restrict the view to the current hunk.
If the prefix ARG is given, restrict the view to the current file instead.

(fn &optional ARG)〉〉enditem49840〈〈diff-reverse-direction〉〉:〈〈Reverse the direction of the diffs.
START and END are either taken from the region (if a prefix arg is given) or
else cover the whole buffer.

(fn START END)〉〉enditem49840〈〈diff-split-hunk〉〉:〈〈Split the current (unified diff) hunk at point into two hunks.〉〉enditem49840〈〈diff〉〉:〈〈Find and display the differences between OLD and NEW files.
When called interactively, read NEW, then OLD, using the
minibuffer.  The default for NEW is the current buffer’s file
name, and the default for OLD is a backup file for NEW, if one
exists.  If NO-ASYNC is non-nil, call diff synchronously.

When called interactively with a prefix argument, prompt
interactively for diff switches.  Otherwise, the switches
specified in the variable ‘diff-switches’ are passed to the diff command.

(fn OLD NEW &optional SWITCHES NO-ASYNC)〉〉enditem49840〈〈dired-at-point〉〉:〈〈Start Dired, defaulting to file at point.  See ‘ffap’.
If ‘dired-at-point-require-prefix’ is set, the prefix meaning is reversed.〉〉enditem49840〈〈dired-change-marks〉〉:〈〈Change all OLD marks to NEW marks.
OLD and NEW are both characters used to mark files.

(fn &optional OLD NEW)〉〉enditem49840〈〈dired-clean-directory〉〉:〈〈Flag numerical backups for deletion.
Spares ‘dired-kept-versions’ latest versions, and ‘kept-old-versions’ oldest.
Positive prefix arg KEEP overrides ‘dired-kept-versions’;
Negative prefix arg KEEP overrides ‘kept-old-versions’ with KEEP made positive.

To clear the flags on these files, you can use M-x dired-flag-backup-files
with a prefix argument.

(fn KEEP)〉〉enditem49840〈〈dired-compare-directories〉〉:〈〈Mark files with different file attributes in two dired buffers.
Compare file attributes of files in the current directory
with file attributes in directory DIR2 using PREDICATE on pairs of files
with the same name.  Mark files for which PREDICATE returns non-nil.
Mark files with different names if PREDICATE is nil (or interactively
with empty input at the predicate prompt).

PREDICATE is a Lisp expression that can refer to the following variables:

    size1, size2   - file size in bytes
    mtime1, mtime2 - last modification time in seconds, as a float
    fa1, fa2       - list of file attributes
                     returned by function ‘file-attributes’

    where 1 refers to attribute of file in the current dired buffer
    and 2 to attribute of file in second dired buffer.

Examples of PREDICATE:

    (> mtime1 mtime2) - mark newer files
    (not (= size1 size2)) - mark files with different sizes
    (not (string= (nth 8 fa1) (nth 8 fa2))) - mark files with different modes
    (not (and (= (nth 2 fa1) (nth 2 fa2))   - mark files with different UID
              (= (nth 3 fa1) (nth 3 fa2))))   and GID.

(fn DIR2 PREDICATE)〉〉enditem49840〈〈dired-copy-filename-as-kill〉〉:〈〈Copy names of marked (or next ARG) files into the kill ring.
The names are separated by a space.
With a zero prefix arg, use the absolute file name of each marked file.
With C-u, use the file name relative to the Dired buffer’s
‘default-directory’.  (This still may contain slashes if in a subdirectory.)

If on a subdir headerline, use absolute subdirname instead;
prefix arg and marked files are ignored in this case.

You can then feed the file name(s) to other commands with C-v.

(fn &optional ARG)〉〉enditem49840〈〈dired-create-directory〉〉:〈〈Create a directory called DIRECTORY.
Parent directories of DIRECTORY are created as needed.
If DIRECTORY already exists, signal an error.

(fn DIRECTORY)〉〉enditem49840〈〈dired-diff〉〉:〈〈Compare file at point with FILE using ‘diff’.
If called interactively, prompt for FILE.
If the mark is active in Transient Mark mode, use the file at the mark
as the default for FILE.  (That’s the mark set by y,
not by Dired’s M-x dired-mark command.)
If the file at point has a backup file, use that as the default FILE.
If the file at point is a backup file, use its original, if that exists
and can be found.  Note that customizations of ‘backup-directory-alist’
and ‘make-backup-file-name-function’ change where this function searches
for the backup file, and affect its ability to find the original of a
backup file.

FILE is the first argument given to the ‘diff’ function.  The file at
point is the second argument given to ‘diff’.

With prefix arg, prompt for second argument SWITCHES, which is
the string of command switches used as the third argument of ‘diff’.

(fn FILE &optional SWITCHES)〉〉enditem49840〈〈dired-display-file〉〉:〈〈In Dired, display this file or directory in another window.〉〉enditem49840〈〈dired-do-async-shell-command〉〉:〈〈Run a shell command COMMAND on the marked files asynchronously.

Like ‘dired-do-shell-command’, but adds ‘&’ at the end of COMMAND
to execute it asynchronously.

When operating on multiple files, asynchronous commands
are executed in the background on each file in parallel.
In shell syntax this means separating the individual commands
with ‘&’.  However, when COMMAND ends in ‘;’ or ‘;&’ then commands
are executed in the background on each file sequentially waiting
for each command to terminate before running the next command.
In shell syntax this means separating the individual commands with ‘;’.

The output appears in the buffer ‘*Async Shell Command*’.

(fn COMMAND &optional ARG FILE-LIST)〉〉enditem49840〈〈dired-do-byte-compile〉〉:〈〈Byte compile marked (or next ARG) Emacs Lisp files.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-chgrp〉〉:〈〈Change the group of the marked (or next ARG) files.
Type M-n to pull the file attributes of the file at point
into the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-chmod〉〉:〈〈Change the mode of the marked (or next ARG) files.
Symbolic modes like ‘g+w’ are allowed.
Type M-n to pull the file attributes of the file at point
into the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-chown〉〉:〈〈Change the owner of the marked (or next ARG) files.
Type M-n to pull the file attributes of the file at point
into the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-compress-to〉〉:〈〈Compress selected files and directories to an archive.
Prompt for the archive file name.
Choose the archiving command based on the archive file-name extension
and ‘dired-compress-files-alist’.〉〉enditem49840〈〈dired-do-compress〉〉:〈〈Compress or uncompress marked (or next ARG) files.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-copy-regexp〉〉:〈〈Copy selected files whose names match REGEXP to NEWNAME.
See function ‘dired-do-rename-regexp’ for more info.

(fn REGEXP NEWNAME &optional ARG WHOLE-NAME)〉〉enditem49840〈〈dired-do-copy〉〉:〈〈Copy all marked (or next ARG) files, or copy the current file.
When operating on just the current file, prompt for the new name.

When operating on multiple or marked files, prompt for a target
directory, and make the new copies in that directory, with the
same names as the original files.  The initial suggestion for the
target directory is the Dired buffer’s current directory (or, if
‘dired-dwim-target’ is non-nil, the current directory of a
neighboring Dired window).

If ‘dired-copy-preserve-time’ is non-nil, this command preserves
the modification time of each old file in the copy, similar to
the "-p" option for the "cp" shell command.

This command copies symbolic links by creating new ones, similar
to the "-d" option for the "cp" shell command.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-delete〉〉:〈〈Delete all marked (or next ARG) files.
‘dired-recursive-deletes’ controls whether deletion of
non-empty directories is allowed.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-find-regexp-and-replace〉〉:〈〈Replace matches of FROM with TO, in all marked files.
For any marked directory, matches in all of its files are replaced,
recursively.  However, files matching ‘grep-find-ignored-files’
and subdirectories matching ‘grep-find-ignored-directories’ are skipped
in the marked directories.

REGEXP should use constructs supported by your local ‘grep’ command.

(fn FROM TO)〉〉enditem49840〈〈dired-do-find-regexp〉〉:〈〈Find all matches for REGEXP in all marked files.
For any marked directory, all of its files are searched recursively.
However, files matching ‘grep-find-ignored-files’ and subdirectories
matching ‘grep-find-ignored-directories’ are skipped in the marked
directories.

REGEXP should use constructs supported by your local ‘grep’ command.

(fn REGEXP)〉〉enditem49840〈〈dired-do-flagged-delete〉〉:〈〈In Dired, delete the files flagged for deletion.
If NOMESSAGE is non-nil, we don’t display any message
if there are no flagged files.
‘dired-recursive-deletes’ controls whether deletion of
non-empty directories is allowed.

(fn &optional NOMESSAGE)〉〉enditem49840〈〈dired-do-hardlink-regexp〉〉:〈〈Hardlink selected files whose names match REGEXP to NEWNAME.
See function ‘dired-do-rename-regexp’ for more info.

(fn REGEXP NEWNAME &optional ARG WHOLE-NAME)〉〉enditem49840〈〈dired-do-hardlink〉〉:〈〈Add names (hard links) current file or all marked (or next ARG) files.
When operating on just the current file, you specify the new name.
When operating on multiple or marked files, you specify a directory
and new hard links are made in that directory
with the same names that the files currently have.  The default
suggested for the target directory depends on the value of
‘dired-dwim-target’, which see.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-isearch-regexp〉〉:〈〈Search for a regexp through all marked files using Isearch.〉〉enditem49840〈〈dired-do-isearch〉〉:〈〈Search for a string through all marked files using Isearch.〉〉enditem49840〈〈dired-do-kill-lines〉〉:〈〈Kill all marked lines (not the files).
With a prefix argument, kill that many lines starting with the current line.
(A negative argument kills backward.)
If you use this command with a prefix argument to kill the line
for a file that is a directory, which you have inserted in the
Dired buffer as a subdirectory, then it deletes that subdirectory
from the buffer as well.
To kill an entire subdirectory (without killing its line in the
parent directory), go to its directory header line and use this
command with a prefix argument (the value does not matter).

(fn &optional ARG FMT)〉〉enditem49840〈〈dired-do-load〉〉:〈〈Load the marked (or next ARG) Emacs Lisp files.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-print〉〉:〈〈Print the marked (or next ARG) files.
Uses the shell command coming from variables ‘lpr-command’ and
‘lpr-switches’ as default.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-redisplay〉〉:〈〈Redisplay all marked (or next ARG) files.
If on a subdir line, redisplay that subdirectory.  In that case,
a prefix arg lets you edit the ‘ls’ switches used for the new listing.

Dired remembers switches specified with a prefix arg, so that reverting
the buffer will not reset them.  However, using ‘dired-undo’ to re-insert
or delete subdirectories can bypass this machinery.  Hence, you sometimes
may have to reset some subdirectory switches after a ‘dired-undo’.
You can reset all subdirectory switches to the default using
M-x dired-reset-subdir-switches.
See Info node ‘(emacs)Subdir switches’ for more details.

(fn &optional ARG TEST-FOR-SUBDIR)〉〉enditem49840〈〈dired-do-rename-regexp〉〉:〈〈Rename selected files whose names match REGEXP to NEWNAME.

With non-zero prefix argument ARG, the command operates on the next ARG
files.  Otherwise, it operates on all the marked files, or the current
file if none are marked.

As each match is found, the user must type a character saying
  what to do with it.  For directions, type C-h at that time.
NEWNAME may contain \<n> or \& as in ‘query-replace-regexp’.
REGEXP defaults to the last regexp used.

With a zero prefix arg, renaming by regexp affects the absolute file name.
Normally, only the non-directory part of the file name is used and changed.

(fn REGEXP NEWNAME &optional ARG WHOLE-NAME)〉〉enditem49840〈〈dired-do-rename〉〉:〈〈Rename current file or all marked (or next ARG) files.
When renaming just the current file, you specify the new name.
When renaming multiple or marked files, you specify a directory.
This command also renames any buffers that are visiting the files.
The default suggested for the target directory depends on the value
of ‘dired-dwim-target’, which see.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-shell-command〉〉:〈〈Run a shell command COMMAND on the marked files.
If no files are marked or a numeric prefix arg is given,
the next ARG files are used.  Just C-u means the current file.
The prompt mentions the file(s) or the marker, as appropriate.

If there is a ‘*’ in COMMAND, surrounded by whitespace, this runs
COMMAND just once with the entire file list substituted there.

If there is no ‘*’, but there is a ‘?’ in COMMAND, surrounded by
whitespace, or a ‘`?`’ this runs COMMAND on each file
individually with the file name substituted for ‘?’ or ‘`?`’.

Otherwise, this runs COMMAND on each file individually with the
file name added at the end of COMMAND (separated by a space).

‘*’ and ‘?’ when not surrounded by whitespace nor ‘`’ have no special
significance for ‘dired-do-shell-command’, and are passed through
normally to the shell, but you must confirm first.

If you want to use ‘*’ as a shell wildcard with whitespace around
it, write ‘*""’ in place of just ‘*’.  This is equivalent to just
‘*’ in the shell, but avoids Dired’s special handling.

If COMMAND ends in ‘&’, ‘;’, or ‘;&’, it is executed in the
background asynchronously, and the output appears in the buffer
‘*Async Shell Command*’.  When operating on multiple files and COMMAND
ends in ‘&’, the shell command is executed on each file in parallel.
However, when COMMAND ends in ‘;’ or ‘;&’ then commands are executed
in the background on each file sequentially waiting for each command
to terminate before running the next command.  You can also use
‘dired-do-async-shell-command’ that automatically adds ‘&’.

Otherwise, COMMAND is executed synchronously, and the output
appears in the buffer ‘*Shell Command Output*’.

This feature does not try to redisplay Dired buffers afterward, as
there’s no telling what files COMMAND may have changed.
Type M-x dired-do-redisplay to redisplay the marked files.

When COMMAND runs, its working directory is the top-level directory
of the Dired buffer, so output files usually are created there
instead of in a subdir.

In a noninteractive call (from Lisp code), you must specify
the list of file names explicitly with the FILE-LIST argument, which
can be produced by ‘dired-get-marked-files’, for example.

(fn COMMAND &optional ARG FILE-LIST)〉〉enditem49840〈〈dired-do-symlink-regexp〉〉:〈〈Symlink selected files whose names match REGEXP to NEWNAME.
See function ‘dired-do-rename-regexp’ for more info.

(fn REGEXP NEWNAME &optional ARG WHOLE-NAME)〉〉enditem49840〈〈dired-do-symlink〉〉:〈〈Make symbolic links to current file or all marked (or next ARG) files.
When operating on just the current file, you specify the new name.
When operating on multiple or marked files, you specify a directory
and new symbolic links are made in that directory
with the same names that the files currently have.  The default
suggested for the target directory depends on the value of
‘dired-dwim-target’, which see.

For relative symlinks, use M-x dired-do-relsymlink.

(fn &optional ARG)〉〉enditem49840〈〈dired-do-touch〉〉:〈〈Change the timestamp of the marked (or next ARG) files.
This calls touch.
Type M-n to pull the file attributes of the file at point
into the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈dired-downcase〉〉:〈〈Rename all marked (or next ARG) files to lower case.

(fn &optional ARG)〉〉enditem49840〈〈dired-find-file-other-window〉〉:〈〈In Dired, visit this file or directory in another window.〉〉enditem49840〈〈dired-find-file〉〉:〈〈In Dired, visit the file or directory named on this line.〉〉enditem49840〈〈dired-flag-auto-save-files〉〉:〈〈Flag for deletion files whose names suggest they are auto save files.
A prefix argument says to unmark or unflag those files instead.

(fn &optional UNFLAG-P)〉〉enditem49840〈〈dired-flag-backup-files〉〉:〈〈Flag all backup files (names ending with ‘~’) for deletion.
With prefix argument, unmark or unflag these files.

(fn &optional UNFLAG-P)〉〉enditem49840〈〈dired-flag-file-deletion〉〉:〈〈In Dired, flag the current line’s file for deletion.
If the region is active, flag all files in the region.
Otherwise, with a prefix arg, flag files on the next ARG lines.

If on a subdir headerline, flag all its files except ‘.’ and ‘..’.
If the region is active in Transient Mark mode, flag all files
in the active region.

(fn ARG &optional INTERACTIVE)〉〉enditem49840〈〈dired-flag-files-regexp〉〉:〈〈In Dired, flag all files containing the specified REGEXP for deletion.
The match is against the non-directory part of the filename.  Use ‘^’
  and ‘$’ to anchor matches.  Exclude subdirs by hiding them.
‘.’ and ‘..’ are never flagged.

(fn REGEXP)〉〉enditem49840〈〈dired-flag-garbage-files〉〉:〈〈Flag for deletion all files that match ‘dired-garbage-files-regexp’.〉〉enditem49840〈〈dired-goto-file〉〉:〈〈Go to line describing file FILE in this Dired buffer.

(fn FILE)〉〉enditem49840〈〈dired-hide-all〉〉:〈〈Hide all subdirectories, leaving only their header lines.
If there is already something hidden, make everything visible again.
Use M-x dired-hide-subdir to (un)hide a particular subdirectory.

(fn &optional IGNORED)〉〉enditem49840〈〈dired-hide-details-mode〉〉:〈〈Toggle visibility of detailed information in current Dired buffer.
When this minor mode is enabled, details such as file ownership and
permissions are hidden from view.

See options: ‘dired-hide-details-hide-symlink-targets’ and
‘dired-hide-details-hide-information-lines’.

(fn &optional ARG)〉〉enditem49840〈〈dired-hide-subdir〉〉:〈〈Hide or unhide the current subdirectory and move to next directory.
Optional prefix arg is a repeat factor.
Use M-x dired-hide-all to (un)hide all directories.

(fn ARG)〉〉enditem49840〈〈dired-isearch-filenames-regexp〉〉:〈〈Search for a regexp using Isearch only in file names in the Dired buffer.〉〉enditem49840〈〈dired-isearch-filenames〉〉:〈〈Search for a string using Isearch only in file names in the Dired buffer.〉〉enditem49840〈〈dired-mark-directories〉〉:〈〈Mark all directory file lines except ‘.’ and ‘..’.
With prefix argument, unmark or unflag all those files.

(fn UNFLAG-P)〉〉enditem49840〈〈dired-mark-executables〉〉:〈〈Mark all executable files.
With prefix argument, unmark or unflag all those files.

(fn UNFLAG-P)〉〉enditem49840〈〈dired-mark-files-containing-regexp〉〉:〈〈Mark all files with contents containing REGEXP for use in later commands.
A prefix argument means to unmark them instead.
‘.’ and ‘..’ are never marked.

Note that if a file is visited in an Emacs buffer, and
‘dired-always-read-filesystem’ is nil, this command will
look in the buffer without revisiting the file, so the results might
be inconsistent with the file on disk if its contents has changed
since it was last visited.

(fn REGEXP &optional MARKER-CHAR)〉〉enditem49840〈〈dired-mark-files-regexp〉〉:〈〈Mark all files matching REGEXP for use in later commands.
A prefix argument means to unmark them instead.
‘.’ and ‘..’ are never marked.

REGEXP is an Emacs regexp, not a shell wildcard.  Thus, use ‘\.o$’ for
object files--just ‘.o’ will mark more than you might think.

(fn REGEXP &optional MARKER-CHAR)〉〉enditem49840〈〈dired-mark-subdir-files〉〉:〈〈Mark all files except ‘.’ and ‘..’ in current subdirectory.
If the Dired buffer shows multiple directories, this command
marks the files listed in the subdirectory that point is in.〉〉enditem49840〈〈dired-mark-symlinks〉〉:〈〈Mark all symbolic links.
With prefix argument, unmark or unflag all those files.

(fn UNFLAG-P)〉〉enditem49840〈〈dired-mark〉〉:〈〈Mark the file at point in the Dired buffer.
If the region is active, mark all files in the region.
Otherwise, with a prefix arg, mark files on the next ARG lines.

If on a subdir headerline, mark all its files except ‘.’ and ‘..’.

Use M-x dired-unmark-all-files to remove all marks
and M-x dired-unmark on a subdir to remove the marks in
this subdir.

(fn ARG &optional INTERACTIVE)〉〉enditem49840〈〈dired-maybe-insert-subdir〉〉:〈〈Insert this subdirectory into the same dired buffer.
If it is already present, just move to it (type M-x dired-do-redisplay to refresh),
  else inserts it at its natural place (as ‘ls -lR’ would have done).
With a prefix arg, you may edit the ls switches used for this listing.
  You can add ‘R’ to the switches to expand the whole tree starting at
  this subdirectory.
This function takes some pains to conform to ‘ls -lR’ output.

Dired remembers switches specified with a prefix arg, so that reverting
the buffer will not reset them.  However, using ‘dired-undo’ to re-insert
or delete subdirectories can bypass this machinery.  Hence, you sometimes
may have to reset some subdirectory switches after a ‘dired-undo’.
You can reset all subdirectory switches to the default using
M-x dired-reset-subdir-switches.
See Info node ‘(emacs)Subdir switches’ for more details.

(fn DIRNAME &optional SWITCHES NO-ERROR-IF-NOT-DIR-P)〉〉enditem49840〈〈dired-mode〉〉:〈〈Mode for "editing" directory listings.
In Dired, you are "editing" a list of the files in a directory and
  (optionally) its subdirectories, in the format of ‘ls -lR’.
  Each directory is a page: use C-x [ and C-x ] to move pagewise.
"Editing" means that you can run shell commands on files, visit,
  compress, load or byte-compile them, change their file attributes
  and insert subdirectories into the same buffer.  You can "mark"
  files for later commands or "flag" them for deletion, either file
  by file or all files matching certain criteria.
You can move using the usual cursor motion commands.
The buffer is read-only.  Digits are prefix arguments.
Type d to flag a file ‘D’ for deletion.
Type m to Mark a file or subdirectory for later commands.
  Most commands operate on the marked files and use the current file
  if no files are marked.  Use a numeric prefix argument to operate on
  the next ARG (or previous -ARG if ARG<0) files, or just ‘1’
  to operate on the current file only.  Prefix arguments override marks.
  Mark-using commands display a list of failures afterwards.  Type ?
  to see why something went wrong.
Type u to Unmark a file or all files of an inserted subdirectory.
Type DEL to back up one line and unmark or unflag.
Type x to delete (eXpunge) the files flagged ‘D’.
Type RET to Find the current line’s file
  (or dired it in another buffer, if it is a directory).
Type o to find file or Dired directory in Other window.
Type i to Insert a subdirectory in this buffer.
Type R to Rename a file or move the marked files to another directory.
Type C to Copy files.
Type M-x dired-sort-toggle-or-edit to toggle Sorting by name/date or change the ‘ls’ switches.
Type g to read all currently expanded directories aGain.
  This retains all marks and hides subdirs again that were hidden before.
Use ‘SPC’ and ‘DEL’ to move down and up by lines.

If Dired ever gets confused, you can either type g to read the
directories again, type l to relist the file at point or the marked files or a
subdirectory, or type M-x dired-build-subdir-alist to parse the buffer
again for the directory tree.

Customization variables (rename this buffer and type C-h v on each line
for more info):

  ‘dired-listing-switches’
  ‘dired-trivial-filenames’
  ‘dired-marker-char’
  ‘dired-del-marker’
  ‘dired-keep-marker-rename’
  ‘dired-keep-marker-copy’
  ‘dired-keep-marker-hardlink’
  ‘dired-keep-marker-symlink’

Hooks (use C-h v to see their documentation):

  ‘dired-before-readin-hook’
  ‘dired-after-readin-hook’
  ‘dired-mode-hook’
  ‘dired-load-hook’

Keybindings:
key             binding
---             -------

e .. f          dired-find-file

RET             dired-find-file
C-o             dired-display-file
C-t             Prefix Command
C-x             Prefix Command
ESC             Prefix Command
SPC             dired-next-line
!               dired-do-shell-command
#               dired-flag-auto-save-files
$               dired-hide-subdir
%               Prefix Command
&               dired-do-async-shell-command
(               dired-hide-details-mode
*               Prefix Command
+               dired-create-directory
-               xah-dired-rename-space-to-underscore
.               dired-clean-directory
0 .. 9          digit-argument
:               Prefix Command
<               dired-prev-dirline
=               dired-diff
>               dired-next-dirline
?               dired-summary
A               dired-do-find-regexp
B               dired-do-byte-compile
C               dired-do-copy
D               dired-do-delete
F               dired-do-find-marked-files
G               dired-do-chgrp
H               dired-do-hardlink
I               dired-info
L               dired-do-load
M               dired-do-chmod
N               dired-man
O               dired-do-chown
P               dired-do-print
Q               dired-do-find-regexp-and-replace
R               dired-do-rename
S               dired-do-symlink
T               dired-do-touch
U               dired-unmark-all-marks
V               dired-do-run-mail
W               browse-url-of-dired-file
X               dired-do-shell-command
Y               dired-do-relsymlink
Z               dired-do-compress
^               dired-up-directory
a               dired-find-alternate-file
c               dired-do-compress-to
d               dired-flag-file-deletion
g               revert-buffer
h               describe-mode
i               dired-maybe-insert-subdir
j               dired-goto-file
k               dired-do-kill-lines
l               dired-do-redisplay
m               dired-mark
n               dired-next-line
o               dired-find-file-other-window
p               dired-previous-line
q               quit-window
s               xah-dired-sort
t               dired-toggle-marks
u               dired-unmark
v               dired-view-file
w               dired-copy-filename-as-kill
x               dired-do-flagged-delete
y               dired-show-file-type
~               dired-flag-backup-files
DEL             dired-unmark-backward
S-SPC           dired-previous-line
<follow-link>   mouse-face
<mouse-2>       dired-mouse-find-file-other-window
<remap>         Prefix Command

C-t C-t         image-dired-dired-toggle-marked-thumbs
C-t .           image-dired-display-thumb
C-t a           image-dired-display-thumbs-append
C-t c           image-dired-dired-comment-files
C-t d           image-dired-display-thumbs
C-t e           image-dired-dired-edit-comment-and-tags
C-t f           image-dired-mark-tagged-files
C-t i           image-dired-dired-display-image
C-t j           image-dired-jump-thumbnail-buffer
C-t r           image-dired-delete-tag
C-t t           image-dired-tag-files
C-t x           image-dired-dired-display-external

C-x ESC         Prefix Command

C-M-d           dired-tree-down
C-M-n           dired-next-subdir
C-M-p           dired-prev-subdir
C-M-u           dired-tree-up
M-!             dired-smart-shell-command
M-$             dired-hide-all
M-(             dired-mark-sexp
M-G             dired-goto-subdir
M-s             Prefix Command
M-{             dired-prev-marked-file
M-}             dired-next-marked-file
M-DEL           dired-unmark-all-files

M-s a           Prefix Command
M-s f           Prefix Command

% &             dired-flag-garbage-files
% C             dired-do-copy-regexp
% H             dired-do-hardlink-regexp
% R             dired-do-rename-regexp
% S             dired-do-symlink-regexp
% Y             dired-do-relsymlink-regexp
% d             dired-flag-files-regexp
% g             dired-mark-files-containing-regexp
% l             dired-downcase
% m             dired-mark-files-regexp
% r             dired-do-rename-regexp
% u             dired-upcase

* C-n           dired-next-marked-file
* C-p           dired-prev-marked-file
* !             dired-unmark-all-marks
* %             dired-mark-files-regexp
* (             dired-mark-sexp
* *             dired-mark-executables
* .             dired-mark-extension
* /             dired-mark-directories
* ?             dired-unmark-all-files
* @             dired-mark-symlinks
* O             dired-mark-omitted
* c             dired-change-marks
* m             dired-mark
* s             dired-mark-subdir-files
* t             dired-toggle-marks
* u             dired-unmark
* DEL           dired-unmark-backward

: d             epa-dired-do-decrypt
: e             epa-dired-do-encrypt
: s             epa-dired-do-sign
: v             epa-dired-do-verify

<remap> <advertised-undo>       dired-undo
<remap> <next-line>             dired-next-line
<remap> <previous-line>         dired-previous-line
<remap> <read-only-mode>        dired-toggle-read-only
<remap> <toggle-read-only>      dired-toggle-read-only
<remap> <undo>                  dired-undo

C-x M-o         dired-omit-mode

M-s f C-s       dired-isearch-filenames
M-s f ESC       Prefix Command

M-s a C-s       dired-do-isearch
M-s a ESC       Prefix Command

M-s f C-M-s     dired-isearch-filenames-regexp

M-s a C-M-s     dired-do-isearch-regexp



(fn &optional DIRNAME SWITCHES)〉〉enditem49840〈〈dired-mouse-find-file-other-window〉〉:〈〈In Dired, visit the file or directory name you click on in another window.

(fn EVENT)〉〉enditem49840〈〈dired-next-dirline〉〉:〈〈Goto ARGth next directory file line.

(fn ARG &optional OPOINT)〉〉enditem49840〈〈dired-next-marked-file〉〉:〈〈Move to the ARGth next marked file.
ARG is the numeric prefix argument and defaults to 1.
If WRAP is non-nil, which happens interactively, wrap around
to the beginning of the buffer and search from there, if no
marked file is found after this line.
Optional argument OPOINT specifies the buffer position to
return to if no ARGth marked file is found; it defaults to
the position where this command was invoked.

(fn ARG &optional WRAP OPOINT)〉〉enditem49840〈〈dired-next-subdir〉〉:〈〈Go to next subdirectory, regardless of level.

(fn ARG &optional NO-ERROR-IF-NOT-FOUND NO-SKIP)〉〉enditem49840〈〈dired-other-frame〉〉:〈〈"Edit" directory DIRNAME.  Like ‘dired’ but makes a new frame.

(fn DIRNAME &optional SWITCHES)〉〉enditem49840〈〈dired-other-window〉〉:〈〈"Edit" directory DIRNAME.  Like ‘dired’ but selects in another window.

(fn DIRNAME &optional SWITCHES)〉〉enditem49840〈〈dired-prev-dirline〉〉:〈〈Goto ARGth previous directory file line.

(fn ARG)〉〉enditem49840〈〈dired-prev-marked-file〉〉:〈〈Move to the ARGth previous marked file.
ARG is the numeric prefix argument and defaults to 1.
If WRAP is non-nil, which happens interactively, wrap around
to the end of the buffer and search backwards from there, if
no ARGth marked file is found before this line.

(fn ARG &optional WRAP)〉〉enditem49840〈〈dired-prev-subdir〉〉:〈〈Go to previous subdirectory, regardless of level.
When called interactively and not on a subdir line, go to this subdir’s line.

(fn ARG &optional NO-ERROR-IF-NOT-FOUND NO-SKIP)〉〉enditem49840〈〈dired-sort-toggle-or-edit〉〉:〈〈Toggle sorting by date, and refresh the Dired buffer.
With a prefix argument, edit the current listing switches instead.

(fn &optional ARG)〉〉enditem49840〈〈dired-toggle-marks〉〉:〈〈Toggle marks: marked files become unmarked, and vice versa.
Files marked with other flags (such as ‘D’) are not affected.
‘.’ and ‘..’ are never toggled.
As always, hidden subdirs are not affected.〉〉enditem49840〈〈dired-toggle-read-only〉〉:〈〈Edit Dired buffer with Wdired, or make it read-only.
If the current buffer can be edited with Wdired, (i.e. the major
mode is ‘dired-mode’), call ‘wdired-change-to-wdired-mode’.
Otherwise, toggle ‘read-only-mode’.〉〉enditem49840〈〈dired-tree-down〉〉:〈〈Go down in the dired tree.〉〉enditem49840〈〈dired-tree-up〉〉:〈〈Go up ARG levels in the dired tree.

(fn ARG)〉〉enditem49840〈〈dired-undo〉〉:〈〈Undo in a Dired buffer.
This doesn’t recover lost files, it just undoes changes in the buffer itself.
You can use it to recover marks, killed lines or subdirs.〉〉enditem49840〈〈dired-unmark-all-files〉〉:〈〈Remove a specific mark (or any mark) from every file.
After this command, type the mark character to remove,
or type RET to remove all marks.
With prefix arg, query for each marked file.
Type C-h at that time for help.

(fn MARK &optional ARG)〉〉enditem49840〈〈dired-unmark-all-marks〉〉:〈〈Remove all marks from all files in the Dired buffer.〉〉enditem49840〈〈dired-unmark-backward〉〉:〈〈In Dired, move up lines and remove marks or deletion flags there.
Optional prefix ARG says how many lines to unmark/unflag; default
is one line.
If the region is active in Transient Mark mode, unmark all files
in the active region.

(fn ARG)〉〉enditem49840〈〈dired-unmark〉〉:〈〈Unmark the file at point in the Dired buffer.
If the region is active, unmark all files in the region.
Otherwise, with a prefix arg, unmark files on the next ARG lines.

If looking at a subdir, unmark all its files except ‘.’ and ‘..’.
If the region is active in Transient Mark mode, unmark all files
in the active region.

(fn ARG &optional INTERACTIVE)〉〉enditem49840〈〈dired-up-directory〉〉:〈〈Run Dired on parent directory of current directory.
Find the parent directory either in this buffer or another buffer.
Creates a buffer if necessary.
If OTHER-WINDOW (the optional prefix arg), display the parent
directory in another window.

(fn &optional OTHER-WINDOW)〉〉enditem49840〈〈dired-upcase〉〉:〈〈Rename all marked (or next ARG) files to upper case.

(fn &optional ARG)〉〉enditem49840〈〈dired-view-file〉〉:〈〈In Dired, examine a file in view mode, returning to Dired when done.
When file is a directory, show it in this buffer if it is inserted.
Otherwise, display it in another buffer.〉〉enditem49840〈〈dired〉〉:〈〈"Edit" directory DIRNAME--delete, rename, print, etc. some files in it.
Optional second argument SWITCHES specifies the ‘ls’ options used.
(Interactively, use a prefix argument to be able to specify SWITCHES.)

If DIRNAME is a string, Dired displays a list of files in DIRNAME (which
may also have shell wildcards appended to select certain files).

If DIRNAME is a cons, its first element is taken as the directory name
and the rest as an explicit list of files to make directory entries for.
In this case, SWITCHES are applied to each of the files separately, and
therefore switches that control the order of the files in the produced
listing have no effect.

You can flag files for deletion with d and then
delete them by typing x.
Type h after entering Dired for more info.

If DIRNAME is already in a Dired buffer, that buffer is used without refresh.

(fn DIRNAME &optional SWITCHES)〉〉enditem49840〈〈dirtrack-mode〉〉:〈〈Toggle directory tracking in shell buffers (Dirtrack mode).
With a prefix argument ARG, enable Dirtrack mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

This method requires that your shell prompt contain the current
working directory at all times, and that you set the variable
‘dirtrack-list’ to match the prompt.

This is an alternative to ‘shell-dirtrack-mode’, which works by
tracking ‘cd’ and similar commands which change the shell working
directory.

(fn &optional ARG)〉〉enditem49840〈〈display-battery-mode〉〉:〈〈Toggle battery status display in mode line (Display Battery mode).
With a prefix argument ARG, enable Display Battery mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

The text displayed in the mode line is controlled by
‘battery-mode-line-format’ and ‘battery-status-function’.
The mode line is be updated every ‘battery-update-interval’
seconds.

(fn &optional ARG)〉〉enditem49840〈〈display-local-help〉〉:〈〈Display local help in the echo area.
This displays a short help message, namely the string produced by
the ‘kbd-help’ property at point.  If ‘kbd-help’ does not produce
a string, but the ‘help-echo’ property does, then that string is
printed instead.

A numeric argument ARG prevents display of a message in case
there is no help.  While ARG can be used interactively, it is
mainly meant for use from Lisp.

(fn &optional ARG)〉〉enditem49840〈〈display-time-mode〉〉:〈〈Toggle display of time, load level, and mail flag in mode lines.
With a prefix argument ARG, enable Display Time mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
it if ARG is omitted or nil.

When Display Time mode is enabled, it updates every minute (you
can control the number of seconds between updates by customizing
‘display-time-interval’).  If ‘display-time-day-and-date’ is
non-nil, the current day and date are displayed as well.  This
runs the normal hook ‘display-time-hook’ after each update.

(fn &optional ARG)〉〉enditem49840〈〈display-time〉〉:〈〈Enable display of time, load level, and mail flag in mode lines.
This display updates automatically every minute.
If ‘display-time-day-and-date’ is non-nil, the current day and date
are displayed as well.
This runs the normal hook ‘display-time-hook’ after each update.

(fn)〉〉enditem49840〈〈dissociated-press〉〉:〈〈Dissociate the text of the current buffer.
Output goes in buffer named *Dissociation*,
which is redisplayed each time text is added to it.
Every so often the user must say whether to continue.
If ARG is positive, require ARG chars of continuity.
If ARG is negative, require -ARG words of continuity.
Default is 2.

(fn &optional ARG)〉〉enditem49840〈〈do〉〉:〈〈The Common Lisp ‘do’ loop.

(fn ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)〉〉enditem49840〈〈doc-view-clear-cache〉〉:〈〈Delete the whole cache (‘doc-view-cache-directory’).〉〉enditem49840〈〈doc-view-enlarge〉〉:〈〈Enlarge the document by FACTOR.

(fn FACTOR)〉〉enditem49840〈〈doc-view-first-page〉〉:〈〈View the first page.〉〉enditem49840〈〈doc-view-goto-page〉〉:〈〈View the page given by PAGE.

(fn PAGE)〉〉enditem49840〈〈doc-view-kill-proc-and-buffer〉〉:〈〈Kill the current buffer.〉〉enditem49840〈〈doc-view-kill-proc〉〉:〈〈Kill the current converter process(es).〉〉enditem49840〈〈doc-view-last-page〉〉:〈〈View the last page.〉〉enditem49840〈〈doc-view-mode〉〉:〈〈Major mode in DocView buffers.

DocView Mode is an Emacs document viewer.  It displays PDF, PS
and DVI files (as PNG images) in Emacs buffers.

You can use C-c C-c to
toggle between displaying the document or editing it as text.
key             binding
---             -------

C-c             Prefix Command
RET             image-next-line
C-n             doc-view-next-line-or-next-page
C-p             doc-view-previous-line-or-previous-page
C-r             doc-view-search-backward
C-s             doc-view-search
C-t             doc-view-show-tooltip
ESC             Prefix Command
SPC             doc-view-scroll-up-or-next-page
+               doc-view-enlarge
-               doc-view-shrink
0               doc-view-scale-reset
1 .. 9          digit-argument
<               beginning-of-buffer
=               doc-view-enlarge
>               end-of-buffer
?               describe-mode
F               image-goto-frame
H               doc-view-fit-height-to-window
K               doc-view-kill-proc
P               doc-view-fit-page-to-window
W               doc-view-fit-width-to-window
a               Prefix Command
b               image-previous-frame
f               image-next-frame
g               doc-view-revert-buffer
h               describe-mode
k               image-kill-buffer
n               doc-view-next-page
o               image-save
p               doc-view-previous-page
q               quit-window
r               doc-view-revert-buffer
s               Prefix Command
DEL             doc-view-scroll-down-or-previous-page
S-SPC           doc-view-scroll-down-or-previous-page
<down>          doc-view-next-line-or-next-page
<find>          doc-view-search
<next>          forward-page
<prior>         backward-page
<remap>         Prefix Command
<up>            doc-view-previous-line-or-previous-page

C-c C-c         doc-view-toggle-display
C-c C-t         doc-view-open-text

s b             doc-view-set-slice-from-bounding-box
s m             doc-view-set-slice-using-mouse
s r             doc-view-reset-slice
s s             doc-view-set-slice

M-<             doc-view-first-page
M->             doc-view-last-page

<remap> <backward-page>         doc-view-previous-page
<remap> <forward-page>          doc-view-next-page
<remap> <goto-line>             doc-view-goto-page
<remap> <text-scale-adjust>     doc-view-scale-adjust

<remap> <backward-char>         image-backward-hscroll
<remap> <beginning-of-buffer>   image-bob
<remap> <end-of-buffer>         image-eob
<remap> <forward-char>          image-forward-hscroll
<remap> <left-char>             image-backward-hscroll
<remap> <move-beginning-of-line>
                                image-bol
<remap> <move-end-of-line>      image-eol
<remap> <next-line>             image-next-line
<remap> <previous-line>         image-previous-line
<remap> <right-char>            image-forward-hscroll
<remap> <scroll-down>           image-scroll-down
<remap> <scroll-down-command>   image-scroll-down
<remap> <scroll-left>           image-scroll-left
<remap> <scroll-right>          image-scroll-right
<remap> <scroll-up>             image-scroll-up
<remap> <scroll-up-command>     image-scroll-up

a +             image-increase-speed
a -             image-decrease-speed
a 0             image-reset-speed
a r             image-reverse-speed

C-c C-c         image-toggle-display
  (that binding is currently shadowed by another mode)
C-c C-x         image-toggle-hex-display

〉〉enditem49840〈〈doc-view-next-page〉〉:〈〈Browse ARG pages forward.

(fn &optional ARG)〉〉enditem49840〈〈doc-view-open-text〉〉:〈〈Display the current doc’s contents as text.〉〉enditem49840〈〈doc-view-previous-page〉〉:〈〈Browse ARG pages backward.

(fn &optional ARG)〉〉enditem49840〈〈doc-view-reset-slice〉〉:〈〈Reset the current slice.
After calling this function whole pages will be visible again.〉〉enditem49840〈〈doc-view-scroll-down-or-previous-page〉〉:〈〈Scroll page down ARG lines if possible, else goto previous page.
When ‘doc-view-continuous’ is non-nil, scrolling downward
at the top edge of the page moves to the previous page.
Otherwise, goto previous page only on typing DEL (ARG is nil).

(fn &optional ARG)〉〉enditem49840〈〈doc-view-scroll-up-or-next-page〉〉:〈〈Scroll page up ARG lines if possible, else goto next page.
When ‘doc-view-continuous’ is non-nil, scrolling upward
at the bottom edge of the page moves to the next page.
Otherwise, goto next page only on typing SPC (ARG is nil).

(fn &optional ARG)〉〉enditem49840〈〈doc-view-search-backward〉〉:〈〈Call ‘doc-view-search’ for backward search.
If prefix NEW-QUERY is given, ask for a new regexp.

(fn NEW-QUERY)〉〉enditem49840〈〈doc-view-search〉〉:〈〈Jump to the next match or initiate a new search if NEW-QUERY is given.
If the current document hasn’t been transformed to plain text
till now do that first.
If BACKWARD is non-nil, jump to the previous match.

(fn NEW-QUERY &optional BACKWARD)〉〉enditem49840〈〈doc-view-set-slice-from-bounding-box〉〉:〈〈Set the slice from the document’s BoundingBox information.
The result is that the margins are almost completely cropped,
much more accurate than could be done manually using
‘doc-view-set-slice-using-mouse’.

(fn &optional FORCE-PAPER-SIZE)〉〉enditem49840〈〈doc-view-set-slice-using-mouse〉〉:〈〈Set the slice of the images that should be displayed.
You set the slice by pressing mouse-1 at its top-left corner and
dragging it to its bottom-right corner.  See also
‘doc-view-set-slice’ and ‘doc-view-reset-slice’.〉〉enditem49840〈〈doc-view-set-slice〉〉:〈〈Set the slice of the images that should be displayed.
You can use this function to tell doc-view not to display the
margins of the document.  It prompts for the top-left corner (X
and Y) of the slice to display and its WIDTH and HEIGHT.

See ‘doc-view-set-slice-using-mouse’ and
‘doc-view-set-slice-from-bounding-box’ for more convenient ways
to do that.  To reset the slice use ‘doc-view-reset-slice’.

(fn X Y WIDTH HEIGHT)〉〉enditem49840〈〈doc-view-show-tooltip〉〉:〈〈nil〉〉enditem49840〈〈doc-view-shrink〉〉:〈〈Shrink the document.

(fn FACTOR)〉〉enditem49840〈〈doc-view-toggle-display〉〉:〈〈Toggle between editing a document as text or viewing it.〉〉enditem49840〈〈doctex-mode〉〉:〈〈Major mode to edit DocTeX files.

(fn)〉〉enditem49840〈〈doctor〉〉:〈〈Switch to *doctor* buffer and start giving psychotherapy.

(fn)〉〉enditem49840〈〈dunnet〉〉:〈〈Switch to *dungeon* buffer and start game.

(fn)〉〉enditem49840〈〈ediff〉〉:〈〈Run Ediff on a pair of files, FILE-A and FILE-B.
STARTUP-HOOKS is a list of functions that Emacs calls without
arguments after setting up the Ediff buffers.

(fn FILE-A FILE-B &optional STARTUP-HOOKS)〉〉enditem49840〈〈edit-abbrevs〉〉:〈〈Alter abbrev definitions by editing a list of them.
Selects a buffer containing a list of abbrev definitions with
point located in the abbrev table of current buffer.
You can edit them and type C-c C-c to redefine abbrevs
according to your editing.
Buffer contains a header line for each abbrev table,
 which is the abbrev table name in parentheses.
This is followed by one line per abbrev in that table:
NAME   USECOUNT   EXPANSION   HOOK
where NAME and EXPANSION are strings with quotes,
USECOUNT is an integer, and HOOK is any valid function
or may be omitted (it is usually omitted).〉〉enditem49840〈〈edit-kbd-macro〉〉:〈〈Edit a keyboard macro.
At the prompt, type any key sequence which is bound to a keyboard macro.
Or, type ‘C-x e’ or RET to edit the last
keyboard macro, ‘DEL h l’ to edit the last 300
keystrokes as a keyboard macro, or ‘DEL RET’
to edit a macro by its command name.
With a prefix argument, format the macro in a more concise way.〉〉enditem49840〈〈edit-tab-stops〉〉:〈〈Edit the tab stops used by ‘tab-to-tab-stop’.
Creates a buffer *Tab Stops* containing text describing the tab stops.
A colon indicates a column where there is a tab stop.
You can add or remove colons and then do C-c C-c to make changes take effect.〉〉enditem49840〈〈eldoc-mode〉〉:〈〈Toggle echo area display of Lisp objects at point (ElDoc mode).
With a prefix argument ARG, enable ElDoc mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable ElDoc mode
if ARG is omitted or nil.

ElDoc mode is a buffer-local minor mode.  When enabled, the echo
area displays information about a function or variable in the
text where point is.  If point is on a documented variable, it
displays the first line of that variable’s doc string.  Otherwise
it displays the argument list of the function called in the
expression point is on.

(fn &optional ARG)〉〉enditem49840〈〈electric-indent-mode〉〉:〈〈Toggle on-the-fly reindentation (Electric Indent mode).
With a prefix argument ARG, enable Electric Indent mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When enabled, this reindents whenever the hook ‘electric-indent-functions’
returns non-nil, or if you insert a character from ‘electric-indent-chars’.

This is a global minor mode.  To toggle the mode in a single buffer,
use ‘electric-indent-local-mode’.〉〉enditem49840〈〈electric-layout-mode〉〉:〈〈Automatically insert newlines around some chars.
With a prefix argument ARG, enable Electric Layout mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.
The variable ‘electric-layout-rules’ says when and how to insert newlines.〉〉enditem49840〈〈electric-pair-mode〉〉:〈〈Toggle automatic parens pairing (Electric Pair mode).
With a prefix argument ARG, enable Electric Pair mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Electric Pair mode is a global minor mode.  When enabled, typing
an open parenthesis automatically inserts the corresponding
closing parenthesis, and vice versa.  (Likewise for brackets, etc.).
If the region is active, the parentheses (brackets, etc.) are
inserted around the region instead.

To toggle the mode in a single buffer, use ‘electric-pair-local-mode’.

(fn &optional ARG)〉〉enditem49840〈〈electric-quote-mode〉〉:〈〈Toggle on-the-fly requoting (Electric Quote mode).
With a prefix argument ARG, enable Electric Quote mode if
ARG is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When enabled, as you type this replaces ` with ‘, ' with ’,
`` with “, and '' with ”.  This occurs only in comments, strings,
and text paragraphs, and these are selectively controlled with
‘electric-quote-comment’, ‘electric-quote-string’, and
‘electric-quote-paragraph’.

Customize ‘electric-quote-chars’ to use characters other than the
ones listed here.

This is a global minor mode.  To toggle the mode in a single buffer,
use ‘electric-quote-local-mode’.〉〉enditem49840〈〈emacs-lisp-mode〉〉:〈〈Major mode for editing Lisp code to run in Emacs.
Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

key             binding
---             -------

ESC             Prefix Command
DEL             backward-delete-char-untabify

C-M-i           completion-at-point
C-M-q           indent-pp-sexp
C-M-x           eval-defun

C-M-q           indent-sexp
  (that binding is currently shadowed by another mode)

C-M-q           prog-indent-sexp
  (that binding is currently shadowed by another mode)



In addition to any hooks its parent mode ‘prog-mode’ might have run,
this mode runs the hook ‘emacs-lisp-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈emerge-buffers-with-ancestor〉〉:〈〈Run Emerge on two buffers, giving another buffer as the ancestor.

(fn BUFFER-A BUFFER-B BUFFER-ANCESTOR &optional STARTUP-HOOKS QUIT-HOOKS)〉〉enditem49840〈〈emerge-buffers〉〉:〈〈Run Emerge on two buffers.

(fn BUFFER-A BUFFER-B &optional STARTUP-HOOKS QUIT-HOOKS)〉〉enditem49840〈〈emerge-files-with-ancestor〉〉:〈〈Run Emerge on two files, giving another file as the ancestor.

(fn ARG FILE-A FILE-B FILE-ANCESTOR FILE-OUT &optional STARTUP-HOOKS QUIT-HOOKS)〉〉enditem49840〈〈emerge-files〉〉:〈〈Run Emerge on two files.

(fn ARG FILE-A FILE-B FILE-OUT &optional STARTUP-HOOKS QUIT-HOOKS)〉〉enditem49840〈〈end-of-visual-line〉〉:〈〈Move point to end of current visual line.
With argument N not nil or 1, move forward N - 1 visual lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.

(fn &optional N)〉〉enditem49840〈〈enlarge-window-horizontally〉〉:〈〈Make selected window DELTA columns wider.
Interactively, if no argument is given, make selected window one
column wider.

(fn DELTA)〉〉enditem49840〈〈enlarge-window〉〉:〈〈Make the selected window DELTA lines taller.
Interactively, if no argument is given, make the selected window
one line taller.  If optional argument HORIZONTAL is non-nil,
make selected window wider by DELTA columns.  If DELTA is
negative, shrink selected window by -DELTA lines or columns.

(fn DELTA &optional HORIZONTAL)〉〉enditem49840〈〈enriched-mode〉〉:〈〈Minor mode for editing text/enriched files.
These are files with embedded formatting information in the MIME standard
text/enriched format.

With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Turning the mode on or off runs ‘enriched-mode-hook’.

More information about Enriched mode is available in the file
"enriched.txt" in ‘data-directory’.

Commands:


Uses keymap ‘enriched-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈epa-dired-do-decrypt〉〉:〈〈Decrypt marked files.

(fn)〉〉enditem49840〈〈epa-dired-do-encrypt〉〉:〈〈Encrypt marked files.

(fn)〉〉enditem49840〈〈epa-dired-do-sign〉〉:〈〈Sign marked files.

(fn)〉〉enditem49840〈〈epa-dired-do-verify〉〉:〈〈Verify marked files.

(fn)〉〉enditem49840〈〈eshell〉〉:〈〈Create an interactive Eshell buffer.
The buffer used for Eshell sessions is determined by the value of
‘eshell-buffer-name’.  If there is already an Eshell session active in
that buffer, Emacs will simply switch to it.  Otherwise, a new session
will begin.  A numeric prefix arg (as in ‘C-u 42 M-x eshell RET’)
switches to the session with that number, creating it if necessary.  A
nonnumeric prefix arg means to create a new session.  Returns the
buffer selected (or created).

(fn &optional ARG)〉〉enditem49840〈〈eval-defun〉〉:〈〈Evaluate the top-level form containing point, or after point.

If the current defun is actually a call to ‘defvar’ or ‘defcustom’,
evaluating it this way resets the variable using its initial value
expression (using the defcustom’s :set function if there is one), even
if the variable already has some other value.  (Normally ‘defvar’ and
‘defcustom’ do not alter the value if there already is one.)  In an
analogous way, evaluating a ‘defface’ overrides any customizations of
the face, so that it becomes defined exactly as the ‘defface’ expression
says.

If ‘eval-expression-debug-on-error’ is non-nil, which is the default,
this command arranges for all errors to enter the debugger.

With a prefix argument, instrument the code for Edebug.

If acting on a ‘defun’ for FUNCTION, and the function was
instrumented, ‘Edebug: FUNCTION’ is printed in the echo area.  If not
instrumented, just FUNCTION is printed.

If not acting on a ‘defun’, the result of evaluation is displayed in
the echo area.  This display is controlled by the variables
‘eval-expression-print-length’ and ‘eval-expression-print-level’,
which see.

(fn EDEBUG-IT)〉〉enditem49840〈〈eval-expression〉〉:〈〈Evaluate EXP and print value in the echo area.
When called interactively, read an Emacs Lisp expression and
evaluate it.  Value is also consed on to front of the variable
‘values’.  Optional argument INSERT-VALUE non-nil (interactively,
with a non ‘-’ prefix argument) means insert the result into the
current buffer instead of printing it in the echo area.

Normally, this function truncates long output according to the
value of the variables ‘eval-expression-print-length’ and
‘eval-expression-print-level’.  When NO-TRUNCATE is
non-nil (interactively, with a prefix argument of zero), however,
there is no such truncation.

If the resulting value is an integer, and CHAR-PRINT-LIMIT is
non-nil (interactively, unless given a positive prefix argument)
it will be printed in several additional formats (octal,
hexadecimal, and character).  The character format is only used
if the value is below CHAR-PRINT-LIMIT (interactively, if the
prefix argument is -1 or the value is below
‘eval-expression-print-maximum-character’).

Runs the hook ‘eval-expression-minibuffer-setup-hook’ on entering the
minibuffer.

If ‘eval-expression-debug-on-error’ is non-nil, which is the default,
this command arranges for all errors to enter the debugger.

(fn EXP &optional INSERT-VALUE NO-TRUNCATE CHAR-PRINT-LIMIT)〉〉enditem49840〈〈eval-last-sexp〉〉:〈〈Evaluate sexp before point; print value in the echo area.
Interactively, with a non ‘-’ prefix argument, print output into
current buffer.

Normally, this function truncates long output according to the
value of the variables ‘eval-expression-print-length’ and
‘eval-expression-print-level’.  With a prefix argument of zero,
however, there is no such truncation.  Such a prefix argument
also causes integers to be printed in several additional formats
(octal, hexadecimal, and character when the prefix argument is
-1 or the integer is ‘eval-expression-print-maximum-character’ or
less).

If ‘eval-expression-debug-on-error’ is non-nil, which is the default,
this command arranges for all errors to enter the debugger.

(fn EVAL-LAST-SEXP-ARG-INTERNAL)〉〉enditem49840〈〈eval-print-last-sexp〉〉:〈〈Evaluate sexp before point; print value into current buffer.

Normally, this function truncates long output according to the value
of the variables ‘eval-expression-print-length’ and
‘eval-expression-print-level’.  With a prefix argument of zero,
however, there is no such truncation.  Such a prefix argument
also causes integers to be printed in several additional formats
(octal, hexadecimal, and character).

If ‘eval-expression-debug-on-error’ is non-nil, which is the default,
this command arranges for all errors to enter the debugger.

(fn &optional EVAL-LAST-SEXP-ARG-INTERNAL)〉〉enditem49840〈〈eww-open-file〉〉:〈〈Render FILE using EWW.

(fn FILE)〉〉enditem49840〈〈eww〉〉:〈〈Fetch URL and render the page.
If the input doesn’t look like an URL or a domain name, the
word(s) will be searched for via ‘eww-search-prefix’.

(fn URL)〉〉enditem49840〈〈exchange-point-and-mark〉〉:〈〈:around advice: ‘ad-Advice-exchange-point-and-mark’

Put the mark where point is now, and point where the mark is now.
This command works even when the mark is not active,
and it reactivates the mark.

If Transient Mark mode is on, a prefix ARG deactivates the mark
if it is active, and otherwise avoids reactivating it.  If
Transient Mark mode is off, a prefix ARG enables Transient Mark
mode temporarily.

(fn &optional ARG)〉〉enditem49840〈〈expand-region-abbrevs〉〉:〈〈For abbrev occurrence in the region, offer to expand it.
The user is asked to type ‘y’ or ‘n’ for each occurrence.
A prefix argument means don’t query; expand all abbrevs.

(fn START END &optional NOQUERY)〉〉enditem49840〈〈f90-mode〉〉:〈〈Major mode for editing Fortran 90,95 code in free format.
For fixed format code, use ‘fortran-mode’.

M-x f90-indent-line indents the current line.
M-x f90-indent-new-line indents current line and creates a new indented line.
M-x f90-indent-subprogram indents the current subprogram.

Type `? or `C-h to display a list of built-in abbrevs for F90 keywords.

Key definitions:

Uses keymap ‘f90-mode-map’, which is not currently defined.


Variables controlling indentation style and extra features:

‘f90-do-indent’
  Extra indentation within do blocks (default 3).
‘f90-if-indent’
  Extra indentation within if/select/where/forall blocks (default 3).
‘f90-type-indent’
  Extra indentation within type/enum/interface/block-data blocks (default 3).
‘f90-program-indent’
  Extra indentation within program/module/subroutine/function blocks
  (default 2).
‘f90-associate-indent’
  Extra indentation within associate blocks (default 2).
‘f90-critical-indent’
  Extra indentation within critical/block blocks (default 2).
‘f90-continuation-indent’
  Extra indentation applied to continuation lines (default 5).
‘f90-comment-region’
  String inserted by function M-x f90-comment-region at start of each
  line in region (default "!!!$").
‘f90-indented-comment-re’
  Regexp determining the type of comment to be intended like code
  (default "!").
‘f90-directive-comment-re’
  Regexp of comment-like directive like "!HPF\\$", not to be indented
  (default "!hpf\\$").
‘f90-break-delimiters’
  Regexp holding list of delimiters at which lines may be broken
  (default "[-+*/><=,% \t]").
‘f90-break-before-delimiters’
  Non-nil causes ‘f90-do-auto-fill’ to break lines before delimiters
  (default t).
‘f90-beginning-ampersand’
  Automatic insertion of ‘&’ at beginning of continuation lines (default t).
‘f90-smart-end’
  From an END statement, check and fill the end using matching block start.
  Allowed values are ‘blink’, ‘no-blink’, and nil, which determine
  whether to blink the matching beginning (default ‘blink’).
‘f90-auto-keyword-case’
  Automatic change of case of keywords (default nil).
  The possibilities are ‘downcase-word’, ‘upcase-word’, ‘capitalize-word’.
‘f90-leave-line-no’
  Do not left-justify line numbers (default nil).

Turning on F90 mode calls the value of the variable ‘f90-mode-hook’
with no args, if that value is non-nil.

(fn)〉〉enditem49840〈〈facemenu-remove-all〉〉:〈〈Remove all text properties from the region.〉〉enditem49840〈〈facemenu-remove-face-props〉〉:〈〈Remove ‘face’ and ‘mouse-face’ text properties.〉〉enditem49840〈〈facemenu-set-background〉〉:〈〈Set the background COLOR of the region or next character typed.
This command reads the color in the minibuffer.

If the region is active (normally true except in Transient Mark mode)
and there is no prefix argument, this command sets the region to the
requested face.

Otherwise, this command specifies the face for the next character
inserted.  Moving point or switching buffers before
typing a character to insert cancels the specification.〉〉enditem49840〈〈facemenu-set-bold-italic〉〉:〈〈Select face ‘bold-italic’ for subsequent insertion.
If the mark is active and there is no prefix argument,
apply face ‘bold-italic’ to the region instead.
This command was defined by ‘facemenu-add-new-face’.〉〉enditem49840〈〈facemenu-set-bold〉〉:〈〈Select face ‘bold’ for subsequent insertion.
If the mark is active and there is no prefix argument,
apply face ‘bold’ to the region instead.
This command was defined by ‘facemenu-add-new-face’.〉〉enditem49840〈〈facemenu-set-default〉〉:〈〈Select face ‘default’ for subsequent insertion.
If the mark is active and there is no prefix argument,
apply face ‘default’ to the region instead.
This command was defined by ‘facemenu-add-new-face’.〉〉enditem49840〈〈facemenu-set-face〉〉:〈〈Apply FACE to the region or next character typed.

If the region is active (normally true except in Transient
Mark mode) and nonempty, and there is no prefix argument,
this command applies FACE to the region.  Otherwise, it applies FACE
to the faces to use for the next character
inserted.  (Moving point or switching buffers before typing
a character to insert cancels the specification.)

If FACE is ‘default’, to "apply" it means clearing
the list of faces to be used.  For any other value of FACE,
to "apply" it means putting FACE at the front of the list
of faces to be used, and removing any faces further
along in the list that would be completely overridden by
preceding faces (including FACE).

This command can also add FACE to the menu of faces,
if ‘facemenu-listed-faces’ says to do that.〉〉enditem49840〈〈facemenu-set-foreground〉〉:〈〈Set the foreground COLOR of the region or next character typed.
This command reads the color in the minibuffer.

If the region is active (normally true except in Transient Mark mode)
and there is no prefix argument, this command sets the region to the
requested face.

Otherwise, this command specifies the face for the next character
inserted.  Moving point or switching buffers before
typing a character to insert cancels the specification.〉〉enditem49840〈〈facemenu-set-italic〉〉:〈〈Select face ‘italic’ for subsequent insertion.
If the mark is active and there is no prefix argument,
apply face ‘italic’ to the region instead.
This command was defined by ‘facemenu-add-new-face’.〉〉enditem49840〈〈facemenu-set-underline〉〉:〈〈Select face ‘underline’ for subsequent insertion.
If the mark is active and there is no prefix argument,
apply face ‘underline’ to the region instead.
This command was defined by ‘facemenu-add-new-face’.〉〉enditem49840〈〈feedmail-send-it〉〉:〈〈Send the current mail buffer using the Feedmail package.
This is a suitable value for ‘send-mail-function’.  It can be used
with various lower-level mechanisms to provide features such as queueing.

(fn)〉〉enditem49840〈〈ff-find-related-file〉〉:〈〈Find the header or source file corresponding to this file.
Being on a ‘#include’ line pulls in that file.

If optional IN-OTHER-WINDOW is non-nil, find the file in the other window.
If optional IGNORE-INCLUDE is non-nil, ignore being on ‘#include’ lines.

Variables of interest include:

 - ‘ff-case-fold-search’
   Non-nil means ignore cases in matches (see ‘case-fold-search’).
   If you have extensions in different cases, you will want this to be nil.

 - ‘ff-always-in-other-window’
   If non-nil, always open the other file in another window, unless an
   argument is given to ‘ff-find-other-file’.

 - ‘ff-ignore-include’
   If non-nil, ignores #include lines.

 - ‘ff-always-try-to-create’
   If non-nil, always attempt to create the other file if it was not found.

 - ‘ff-quiet-mode’
   If non-nil, traces which directories are being searched.

 - ‘ff-special-constructs’
   A list of regular expressions specifying how to recognize special
   constructs such as include files etc, and an associated method for
   extracting the filename from that construct.

 - ‘ff-other-file-alist’
   Alist of extensions to find given the current file’s extension.

 - ‘ff-search-directories’
   List of directories searched through with each extension specified in
   ‘ff-other-file-alist’ that matches this file’s extension.

 - ‘ff-pre-find-hook’
   List of functions to be called before the search for the file starts.

 - ‘ff-pre-load-hook’
   List of functions to be called before the other file is loaded.

 - ‘ff-post-load-hook’
   List of functions to be called after the other file is loaded.

 - ‘ff-not-found-hook’
   List of functions to be called if the other file could not be found.

 - ‘ff-file-created-hook’
   List of functions to be called if the other file has been created.〉〉enditem49840〈〈ffap-at-mouse〉〉:〈〈Find file or URL guessed from text around mouse click.
Interactively, calls ‘ffap-at-mouse-fallback’ if no guess is found.
Return value:
  * if a guess string is found, return it (after finding it)
  * if the fallback is called, return whatever it returns
  * otherwise, nil〉〉enditem49840〈〈ffap-menu〉〉:〈〈Put up a menu of files and URLs mentioned in this buffer.
Then set mark, jump to choice, and try to fetch it.  The menu is
cached in ‘ffap-menu-alist’, and rebuilt by ‘ffap-menu-rescan’.
The optional RESCAN argument (a prefix, interactively) forces
a rebuild.  Searches with ‘ffap-menu-regexp’.〉〉enditem49840〈〈ffap-next〉〉:〈〈Search buffer for next file or URL, and run ffap.
Optional argument BACK says to search backwards.
Optional argument WRAP says to try wrapping around if necessary.
Interactively: use a single prefix C-u to search backwards,
double prefix to wrap forward, triple to wrap backwards.
Actual search is done by the function ‘ffap-next-guess’.〉〉enditem49840〈〈ffap〉〉:〈〈Find FILENAME, guessing a default from text around point.
If ‘ffap-url-regexp’ is not nil, the FILENAME may also be an URL.
With a prefix, this command behaves exactly like ‘ffap-file-finder’.
If ‘ffap-require-prefix’ is set, the prefix meaning is reversed.
See also the variables ‘ffap-dired-wildcards’, ‘ffap-newfile-prompt’,
‘ffap-url-unwrap-local’, ‘ffap-url-unwrap-remote’, and the functions
‘ffap-file-at-point’ and ‘ffap-url-at-point’.〉〉enditem49840〈〈file-cache-add-directory〉〉:〈〈Add all files in DIRECTORY to the file cache.
If called from Lisp with a non-nil REGEXP argument is non-nil,
only add files whose names match REGEXP.

(fn DIRECTORY &optional REGEXP)〉〉enditem49840〈〈file-cache-minibuffer-complete〉〉:〈〈Complete a filename in the minibuffer using a preloaded cache.
Filecache does two kinds of substitution: it completes on names in
the cache, and, once it has found a unique name, it cycles through
the directories that the name is available in.  With a prefix argument,
the name is considered already unique; only the second substitution
(directories) is done.

(fn ARG)〉〉enditem49840〈〈file-name-shadow-mode〉〉:〈〈Toggle file-name shadowing in minibuffers (File-Name Shadow mode).
With a prefix argument ARG, enable File-Name Shadow mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

File-Name Shadow mode is a global minor mode.  When enabled, any
part of a filename being read in the minibuffer that would be
ignored (because the result is passed through
‘substitute-in-file-name’) is given the properties in
‘file-name-shadow-properties’, which can be used to make that
portion dim, invisible, or otherwise less visually noticeable.〉〉enditem49840〈〈filesets-init〉〉:〈〈Filesets initialization.
Set up hooks, load the cache file -- if existing -- and build the menu.

(fn)〉〉enditem49840〈〈fill-french-nobreak-p〉〉:〈〈Return nil if French style allows breaking the line at point.
This is used in ‘fill-nobreak-predicate’ to prevent breaking lines just
after an opening paren or just before a closing paren or a punctuation
mark such as ‘?’ or ‘:’.  It is common in French writing to put a space
at such places, which would normally allow breaking the line at those
places.〉〉enditem49840〈〈fill-nonuniform-paragraphs〉〉:〈〈Fill paragraphs within the region, allowing varying indentation within each.
This command divides the region into "paragraphs",
only at paragraph-separator lines, then fills each paragraph
using as the fill prefix the smallest indentation of any line
in the paragraph.

When calling from a program, pass range to fill as first two arguments.

Optional third and fourth arguments JUSTIFYP and CITATION-REGEXP:
JUSTIFYP to justify paragraphs (prefix arg).
When filling a mail message, pass a regexp for CITATION-REGEXP
which will match the prefix of a line which is a citation marker
plus whitespace, but no other kind of prefix.
Also, if CITATION-REGEXP is non-nil, don’t fill header lines.〉〉enditem49840〈〈fill-single-char-nobreak-p〉〉:〈〈Return non-nil if a one-letter word is before point.
This function is suitable for adding to the hook ‘fill-nobreak-predicate’,
to prevent the breaking of a line just after a one-letter word,
which is an error according to some typographical conventions.〉〉enditem49840〈〈fill-single-word-nobreak-p〉〉:〈〈Don’t break a line after the first or before the last word of a sentence.〉〉enditem49840〈〈find-alternate-file〉〉:〈〈Find file FILENAME, select its buffer, kill previous buffer.
If the current buffer now contains an empty file that you just visited
(presumably by mistake), use this command to visit the file you really want.

See C-o for the possible forms of the FILENAME argument.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and replace the file with multiple files.

If the current buffer is an indirect buffer, or the base buffer
for one or more indirect buffers, the other buffer(s) are not
killed.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-dired〉〉:〈〈Run ‘find’ and go into Dired mode on a buffer of the output.
The command run (after changing into DIR) is essentially

    find . \( ARGS \) -ls

except that the car of the variable ‘find-ls-option’ specifies what to
use in place of "-ls" as the final argument.

(fn DIR ARGS)〉〉enditem49840〈〈find-file-at-point〉〉:〈〈Find FILENAME, guessing a default from text around point.
If ‘ffap-url-regexp’ is not nil, the FILENAME may also be an URL.
With a prefix, this command behaves exactly like ‘ffap-file-finder’.
If ‘ffap-require-prefix’ is set, the prefix meaning is reversed.
See also the variables ‘ffap-dired-wildcards’, ‘ffap-newfile-prompt’,
‘ffap-url-unwrap-local’, ‘ffap-url-unwrap-remote’, and the functions
‘ffap-file-at-point’ and ‘ffap-url-at-point’.〉〉enditem49840〈〈find-file-other-frame〉〉:〈〈Edit file FILENAME, in another frame.

Like C-o (which see), but creates a new frame or reuses
an existing one.  See the function ‘display-buffer’.

Interactively, the default if you just type RET is the current directory,
but the visited file name is available through the minibuffer history:
type M-x next-history-element to pull it into the minibuffer.

The first time M-x next-history-element is used after Emacs prompts for
the file name, the result is affected by ‘file-name-at-point-functions’,
which by default try to guess the file name by looking at point in the
current buffer.  Customize the value of ‘file-name-at-point-functions’
or set it to nil, if you want only the visited file name and the
current directory to be available on first M-x next-history-element
request.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-file-read-only-other-frame〉〉:〈〈Edit file FILENAME in another frame but don’t allow changes.
Like C-x 5 C-f, but marks buffer as read-only.
Use DEL n p to permit editing.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-file-read-only-other-window〉〉:〈〈Edit file FILENAME in another window but don’t allow changes.
Like C-x 4 C-f, but marks buffer as read-only.
Use DEL n p to permit editing.

(fn FILENAME &optional WILDCARDS)〉〉enditem49840〈〈find-grep-dired〉〉:〈〈Find files in DIR that contain matches for REGEXP and start Dired on output.
The command run (after changing into DIR) is

  find . \( -type f -exec ‘grep-program’ ‘find-grep-options’ \
    -e REGEXP {} \; \) -ls

where the first string in the value of the variable ‘find-ls-option’
specifies what to use in place of "-ls" as the final argument.

(fn DIR REGEXP)〉〉enditem49840〈〈find-grep〉〉:〈〈Run grep via find, with user-specified args COMMAND-ARGS.
Collect output in a buffer.
While find runs asynchronously, you can use the C-x ` command
to find the text that grep hits refer to.

This command uses a special history list for its arguments, so you can
easily repeat a find command.

(fn COMMAND-ARGS)〉〉enditem49840〈〈find-name-dired〉〉:〈〈Search DIR recursively for files matching the globbing pattern PATTERN,
and run Dired on those files.
PATTERN is a shell wildcard (not an Emacs regexp) and need not be quoted.
The default command run (after changing into DIR) is

    find . -name 'PATTERN' -ls

See ‘find-name-arg’ to customize the arguments.

(fn DIR PATTERN)〉〉enditem49840〈〈find-tag-other-window〉〉:〈〈Find tag (in current tags table) whose name contains TAGNAME.
Select the buffer containing the tag’s definition in another window, and
move point there.  The default for TAGNAME is the expression in the buffer
around or before point.

If second arg NEXT-P is t (interactively, with prefix arg), search for
another tag that matches the last tagname or regexp used.  When there are
multiple matches for a tag, more exact matches are found first.  If NEXT-P
is negative (interactively, with prefix arg that is a negative number or
just M--), pop back to the previous tag gone to.

If third arg REGEXP-P is non-nil, treat TAGNAME as a regexp.

A marker representing the point when this command is invoked is pushed
onto a ring and may be popped back to with M-x pop-tag-mark.
Contrast this with the ring of marks gone to by the command.

See documentation of variable ‘tags-file-name’.

(fn TAGNAME &optional NEXT-P REGEXP-P)〉〉enditem49840〈〈find-tag〉〉:〈〈Find tag (in current tags table) whose name contains TAGNAME.
Select the buffer containing the tag’s definition, and move point there.
The default for TAGNAME is the expression in the buffer around or before point.

If second arg NEXT-P is t (interactively, with prefix arg), search for
another tag that matches the last tagname or regexp used.  When there are
multiple matches for a tag, more exact matches are found first.  If NEXT-P
is the atom ‘-’ (interactively, with prefix arg that is a negative number
or just M--), pop back to the previous tag gone to.

If third arg REGEXP-P is non-nil, treat TAGNAME as a regexp.

A marker representing the point when this command is invoked is pushed
onto a ring and may be popped back to with M-x pop-tag-mark.
Contrast this with the ring of marks gone to by the command.

See documentation of variable ‘tags-file-name’.

(fn TAGNAME &optional NEXT-P REGEXP-P)〉〉enditem49840〈〈find〉〉:〈〈Find the first occurrence of ITEM in SEQ.
Return the matching ITEM, or nil if not found.

Keywords supported:  :test :test-not :key :start :end :from-end

(fn ITEM SEQ [KEYWORD VALUE]...)〉〉enditem49840〈〈finder-by-keyword〉〉:〈〈Find packages matching a given keyword.

(fn)〉〉enditem49840〈〈first-error〉〉:〈〈Restart at the first error.
Visit corresponding source code.
With prefix arg N, visit the source code of the Nth error.
This operates on the output from the M-x compile command, for instance.

(fn &optional N)〉〉enditem49840〈〈flush-lines〉〉:〈〈Delete lines containing matches for REGEXP.
When called from Lisp (and usually when called interactively as
well, see below), applies to the part of the buffer after point.
The line point is in is deleted if and only if it contains a
match for regexp starting after point.

If REGEXP contains upper case characters (excluding those preceded by ‘\’)
and ‘search-upper-case’ is non-nil, the matching is case-sensitive.

Second and third arg RSTART and REND specify the region to operate on.
Lines partially contained in this region are deleted if and only if
they contain a match entirely contained in it.

Interactively, in Transient Mark mode when the mark is active, operate
on the contents of the region.  Otherwise, operate from point to the
end of (the accessible portion of) the buffer.  When calling this function
from Lisp, you can pretend that it was called interactively by passing
a non-nil INTERACTIVE argument.

If a match is split across lines, all the lines it lies in are deleted.
They are deleted _before_ looking for the next match.  Hence, a match
starting on the same line at which another match ended is ignored.

(fn REGEXP &optional RSTART REND INTERACTIVE)〉〉enditem49840〈〈flyspell-mode〉〉:〈〈Toggle on-the-fly spell checking (Flyspell mode).
With a prefix argument ARG, enable Flyspell mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Flyspell mode is a buffer-local minor mode.  When enabled, it
spawns a single Ispell process and checks each word.  The default
flyspell behavior is to highlight incorrect words.

Bindings:
DEL 9: correct words (using Ispell).
M-x flyspell-auto-correct-word: automatically correct word.
M-x flyspell-auto-correct-previous-word: automatically correct the last misspelled word.
M-x flyspell-correct-word (or down-mouse-2): popup correct words.

Hooks:
This runs ‘flyspell-mode-hook’ after flyspell mode is entered or exit.

Remark:
‘flyspell-mode’ uses ‘ispell-mode’.  Thus all Ispell options are
valid.  For instance, a different dictionary can be used by
invoking ‘ispell-change-dictionary’.

Consider using the ‘ispell-parser’ to check your text.  For instance
consider adding:
(add-hook 'tex-mode-hook (function (lambda () (setq ispell-parser 'tex))))
in your init file.

M-x flyspell-region checks all words inside a region.
DEL n j checks the whole buffer.

(fn &optional ARG)〉〉enditem49840〈〈flyspell-prog-mode〉〉:〈〈Turn on ‘flyspell-mode’ for comments and strings.

(fn)〉〉enditem49840〈〈follow-mode〉〉:〈〈Toggle Follow mode.
With a prefix argument ARG, enable Follow mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Follow mode is a minor mode that combines windows into one tall
virtual window.  This is accomplished by two main techniques:

* The windows always displays adjacent sections of the buffer.
  This means that whenever one window is moved, all the
  others will follow.  (Hence the name Follow mode.)

* Should point (cursor) end up outside a window, another
  window displaying that point is selected, if possible.  This
  makes it possible to walk between windows using normal cursor
  movement commands.

Follow mode comes to its prime when used on a large screen and two or
more side-by-side windows are used.  The user can, with the help of
Follow mode, use these full-height windows as though they were one.
Imagine yourself editing a large function, or section of text, and
being able to use 144 or 216 lines instead of the normal 72... (your
mileage may vary).

To split one large window into two side-by-side windows, the commands
‘DEL 4’ or ‘M-x follow-delete-other-windows-and-split’ can be used.

Only windows displayed in the same frame follow each other.

This command runs the normal hook ‘follow-mode-hook’.

Keys specific to Follow mode:

Uses keymap ‘follow-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈font-lock-mode〉〉:〈〈Toggle syntax highlighting in this buffer (Font Lock mode).
With a prefix argument ARG, enable Font Lock mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Font Lock mode is enabled, text is fontified as you type it:

 - Comments are displayed in ‘font-lock-comment-face’;
 - Strings are displayed in ‘font-lock-string-face’;
 - Certain other expressions are displayed in other faces
   according to the value of the variable ‘font-lock-keywords’.

To customize the faces (colors, fonts, etc.) used by Font Lock for
fontifying different parts of buffer text, use M-x customize-face.

You can enable Font Lock mode in any major mode automatically by
turning on in the major mode’s hook.  For example, put in your
~/.emacs:

 (add-hook 'c-mode-hook 'turn-on-font-lock)

Alternatively, you can use Global Font Lock mode to automagically
turn on Font Lock mode in buffers whose major mode supports it
and whose major mode is one of ‘font-lock-global-modes’.  For
example, put in your ~/.emacs:

 (global-font-lock-mode t)

Where major modes support different levels of fontification, you
can use the variable ‘font-lock-maximum-decoration’ to specify
which level you generally prefer.  When you turn Font Lock mode
on/off the buffer is fontified/defontified, though fontification
occurs only if the buffer is less than ‘font-lock-maximum-size’.

To add your own highlighting for some major mode, and modify the
highlighting selected automatically via the variable
‘font-lock-maximum-decoration’, you can use
‘font-lock-add-keywords’.

To fontify a buffer, without turning on Font Lock mode and
regardless of buffer size, you can use M-x font-lock-fontify-buffer.

To fontify a block (the function or paragraph containing point,
or a number of lines around point), perhaps because modification
on the current line caused syntactic change on other lines, you
can use M-o M-o.

You can set your own default settings for some mode, by setting a
buffer local value for ‘font-lock-defaults’, via its mode hook.

The above is the default behavior of ‘font-lock-mode’; you may
specify your own function which is called when ‘font-lock-mode’
is toggled via ‘font-lock-function’. 〉〉enditem49840〈〈format-decode-buffer〉〉:〈〈Translate the buffer from some FORMAT.
If the format is not specified, attempt a regexp-based guess.
Set ‘buffer-file-format’ to the format used, and call any
format-specific mode functions.〉〉enditem49840〈〈fortran-mode〉〉:〈〈Major mode for editing Fortran code in fixed format.
For free format code, use ‘f90-mode’.

M-x fortran-indent-line indents the current Fortran line correctly.
Note that DO statements must not share a common CONTINUE.

Type ;? or ;C-h to display a list of built-in abbrevs for Fortran keywords.

Key definitions:

Uses keymap ‘fortran-mode-map’, which is not currently defined.


Variables controlling indentation style and extra features:

‘fortran-comment-line-start’
  To use comments starting with ‘!’, set this to the string "!".
‘fortran-do-indent’
  Extra indentation within DO blocks (default 3).
‘fortran-if-indent’
  Extra indentation within IF blocks (default 3).
‘fortran-structure-indent’
  Extra indentation within STRUCTURE, UNION, MAP and INTERFACE blocks.
  (default 3)
‘fortran-continuation-indent’
  Extra indentation applied to continuation statements (default 5).
‘fortran-comment-line-extra-indent’
  Amount of extra indentation for text in full-line comments (default 0).
‘fortran-comment-indent-style’
  How to indent the text in full-line comments. Allowed values are:
  nil         don’t change the indentation
  ‘fixed’     indent to ‘fortran-comment-line-extra-indent’ beyond the
              value of either
                ‘fortran-minimum-statement-indent-fixed’ (fixed format) or
                ‘fortran-minimum-statement-indent-tab’ (TAB format),
              depending on the continuation format in use.
  ‘relative’  indent to ‘fortran-comment-line-extra-indent’ beyond the
              indentation for a line of code.
  (default ‘fixed’)
‘fortran-comment-indent-char’
  Single-character string to be inserted instead of space for
  full-line comment indentation (default " ").
‘fortran-minimum-statement-indent-fixed’
  Minimum indentation for statements in fixed format mode (default 6).
‘fortran-minimum-statement-indent-tab’
  Minimum indentation for statements in TAB format mode (default 9).
‘fortran-line-number-indent’
  Maximum indentation for line numbers (default 1).  A line number will
  get less than this much indentation if necessary to avoid reaching
  column 5.
‘fortran-check-all-num-for-matching-do’
  Non-nil causes all numbered lines to be treated as possible "continue"
  statements (default nil).
‘fortran-blink-matching-if’
  Non-nil causes M-x fortran-indent-line on an ENDIF (or ENDDO) statement
  to blink on the matching IF (or DO [WHILE]).  (default nil)
‘fortran-continuation-string’
  Single-character string to be inserted in column 5 of a continuation
  line (default "$").
‘fortran-comment-region’
  String inserted by M-x fortran-comment-region at start of each line in
  the region (default "c$$$").
‘fortran-electric-line-number’
  Non-nil causes line number digits to be moved to the correct column
  as typed (default t).
‘fortran-break-before-delimiters’
  Non-nil causes lines to be broken before delimiters (default t).

Turning on Fortran mode calls the value of the variable ‘fortran-mode-hook’
with no args, if that value is non-nil.

(fn)〉〉enditem49840〈〈fortune-to-signature〉〉:〈〈Create signature from output of the fortune program.

If called with a prefix asks for the FILE to choose the fortune from,
otherwise uses the value of ‘fortune-file’.  If you want to have fortune
choose from a set of files in a directory, call interactively with prefix
and choose the directory as the fortune-file.

(fn &optional FILE)〉〉enditem49840〈〈fortune〉〉:〈〈Display a fortune cookie.
If called with a prefix asks for the FILE to choose the fortune from,
otherwise uses the value of ‘fortune-file’.  If you want to have fortune
choose from a set of files in a directory, call interactively with prefix
and choose the directory as the fortune-file.

(fn &optional FILE)〉〉enditem49840〈〈forward-page〉〉:〈〈Move forward to page boundary.  With arg, repeat, or go back if negative.
A page boundary is any line whose beginning matches the regexp
‘page-delimiter’.〉〉enditem49840〈〈forward-paragraph〉〉:〈〈Move forward to end of paragraph.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move backward N paragraphs.

A line which ‘paragraph-start’ matches either separates paragraphs
(if ‘paragraph-separate’ matches it also) or is the first line of a paragraph.
A paragraph end is the beginning of a line which is not part of the paragraph
to which the end of the previous line belongs, or the end of the buffer.
Returns the count of paragraphs left to move.〉〉enditem49840〈〈forward-sentence〉〉:〈〈Move forward to next end of sentence.  With argument, repeat.
With negative argument, move backward repeatedly to start of sentence.

The variable ‘sentence-end’ is a regular expression that matches ends of
sentences.  Also, every paragraph boundary terminates sentences as well.〉〉enditem49840〈〈frameset-to-register〉〉:〈〈Store the current frameset in register REGISTER.
Use C-x r j to restore the frameset.
Argument is a character, naming the register.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER)〉〉enditem49840〈〈fringe-mode〉〉:〈〈Set the default appearance of fringes on all frames.
When called interactively, query the user for MODE; valid values
are ‘no-fringes’, ‘default’, ‘left-only’, ‘right-only’, ‘minimal’
and ‘half-width’.  See ‘fringe-styles’.

When used in a Lisp program, MODE should be one of these:
- nil, which means the default width (8 pixels).
- a cons cell (LEFT . RIGHT), where LEFT and RIGHT are
  respectively the left and right fringe widths in pixels, or
  nil (meaning the default width).
- a single integer, which specifies the pixel widths of both
  fringes.
This command may round up the left and right width specifications
to ensure that their sum is a multiple of the character width of
a frame.  It never rounds up a fringe width of 0.

Fringe widths set by ‘set-window-fringes’ override the default
fringe widths set by this command.  This command applies to all
frames that exist and frames to be created in the future.  If you
want to set the default appearance of fringes on the selected
frame only, see the command ‘set-fringe-style’.〉〉enditem49840〈〈ftp〉〉:〈〈Run ‘ftp-program’ to connect to HOST.

(fn HOST)〉〉enditem49840〈〈gdb〉〉:〈〈Run gdb passing it COMMAND-LINE as arguments.

If COMMAND-LINE names a program FILE to debug, gdb will run in
a buffer named *gud-FILE*, and the directory containing FILE
becomes the initial working directory and source-file directory
for your debugger.
If COMMAND-LINE requests that gdb attaches to a process PID, gdb
will run in *gud-PID*, otherwise it will run in *gud*; in these
cases the initial working directory is the default-directory of
the buffer in which this command was invoked.

COMMAND-LINE should include "-i=mi" to use gdb’s MI text interface.
Note that the old "--annotate" option is no longer supported.

If option ‘gdb-many-windows’ is nil (the default value) then gdb just
pops up the GUD buffer unless ‘gdb-show-main’ is t.  In this case
it starts with two windows: one displaying the GUD buffer and the
other with the source file with the main routine of the inferior.

If option ‘gdb-many-windows’ is t, regardless of the value of
‘gdb-show-main’, the layout below will appear.  Keybindings are
shown in some of the buffers.

Watch expressions appear in the speedbar/slowbar.

The following commands help control operation :

‘gdb-many-windows’    - Toggle the number of windows gdb uses.
‘gdb-restore-windows’ - To restore the window layout.

See Info node ‘(emacs)GDB Graphical Interface’ for a more
detailed description of this mode.


+----------------------------------------------------------------------+
|                               GDB Toolbar                            |
+-----------------------------------+----------------------------------+
| GUD buffer (I/O of GDB)           | Locals buffer                    |
|                                   |                                  |
|                                   |                                  |
|                                   |                                  |
+-----------------------------------+----------------------------------+
| Source buffer                     | I/O buffer (of debugged program) |
|                                   | (comint-mode)                    |
|                                   |                                  |
|                                   |                                  |
|                                   |                                  |
|                                   |                                  |
|                                   |                                  |
|                                   |                                  |
+-----------------------------------+----------------------------------+
| Stack buffer                      | Breakpoints buffer               |
| RET      gdb-select-frame         | SPC    gdb-toggle-breakpoint     |
|                                   | RET    gdb-goto-breakpoint       |
|                                   | D      gdb-delete-breakpoint     |
+-----------------------------------+----------------------------------+

(fn COMMAND-LINE)〉〉enditem49840〈〈global-auto-revert-mode〉〉:〈〈Toggle Global Auto-Revert Mode.
With a prefix argument ARG, enable Global Auto-Revert Mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

Global Auto-Revert Mode is a global minor mode that reverts any
buffer associated with a file when the file changes on disk.  Use
‘auto-revert-mode’ to revert a particular buffer.

If ‘global-auto-revert-non-file-buffers’ is non-nil, this mode
may also revert some non-file buffers, as described in the
documentation of that variable.  It ignores buffers with modes
matching ‘global-auto-revert-ignore-modes’, and buffers with a
non-nil vale of ‘global-auto-revert-ignore-buffer’.

When a buffer is reverted, a message is generated.  This can be
suppressed by setting ‘auto-revert-verbose’ to nil.

This function calls the hook ‘global-auto-revert-mode-hook’.
It displays the text that ‘global-auto-revert-mode-text’
specifies in the mode line.

(fn &optional ARG)〉〉enditem49840〈〈global-cwarn-mode〉〉:〈〈Toggle Cwarn mode in all buffers.
With prefix ARG, enable Global Cwarn mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Cwarn mode is enabled in all buffers where
‘turn-on-cwarn-mode-if-enabled’ would do it.
See ‘cwarn-mode’ for more information on Cwarn mode.

(fn &optional ARG)〉〉enditem49840〈〈global-eldoc-mode〉〉:〈〈Toggle Eldoc mode in all buffers.
With prefix ARG, enable Global Eldoc mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Eldoc mode is enabled in all buffers where
‘turn-on-eldoc-mode’ would do it.
See ‘eldoc-mode’ for more information on Eldoc mode.

(fn &optional ARG)〉〉enditem49840〈〈global-font-lock-mode〉〉:〈〈Toggle Font-Lock mode in all buffers.
With prefix ARG, enable Global Font-Lock mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Font-Lock mode is enabled in all buffers where
‘turn-on-font-lock-if-desired’ would do it.
See ‘font-lock-mode’ for more information on Font-Lock mode.〉〉enditem49840〈〈global-hl-line-mode〉〉:〈〈Toggle line highlighting in all buffers (Global Hl-Line mode).
With a prefix argument ARG, enable Global Hl-Line mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

If ‘global-hl-line-sticky-flag’ is non-nil, Global Hl-Line mode
highlights the line about the current buffer’s point in all live
windows.

Global-Hl-Line mode uses the functions ‘global-hl-line-highlight’
and ‘global-hl-line-maybe-unhighlight’ on ‘post-command-hook’.

(fn &optional ARG)〉〉enditem49840〈〈global-prettify-symbols-mode〉〉:〈〈Toggle Prettify-Symbols mode in all buffers.
With prefix ARG, enable Global Prettify-Symbols mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Prettify-Symbols mode is enabled in all buffers where
‘turn-on-prettify-symbols-mode’ would do it.
See ‘prettify-symbols-mode’ for more information on Prettify-Symbols mode.

(fn &optional ARG)〉〉enditem49840〈〈global-visual-line-mode〉〉:〈〈Toggle Visual-Line mode in all buffers.
With prefix ARG, enable Global Visual-Line mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Visual-Line mode is enabled in all buffers where
‘turn-on-visual-line-mode’ would do it.
See ‘visual-line-mode’ for more information on Visual-Line mode.

(fn &optional ARG)〉〉enditem49840〈〈global-whitespace-mode〉〉:〈〈Toggle whitespace visualization globally (Global Whitespace mode).
With a prefix argument ARG, enable Global Whitespace mode if ARG
is positive, and disable it otherwise.

If called from Lisp, also enables the mode if ARG is omitted or nil,
and toggles it if ARG is ‘toggle’.

See also ‘whitespace-style’, ‘whitespace-newline’ and
‘whitespace-display-mappings’.

(fn &optional ARG)〉〉enditem49840〈〈global-whitespace-toggle-options〉〉:〈〈Toggle global ‘whitespace-mode’ options.

If global whitespace-mode is off, toggle the option given by ARG
and turn on global whitespace-mode.

If global whitespace-mode is on, toggle the option given by ARG
and restart global whitespace-mode.

Interactively, it accepts one of the following chars:

  CHAR	MEANING
  (VIA FACES)
   f	toggle face visualization
   t	toggle TAB visualization
   s	toggle SPACE and HARD SPACE visualization
   r	toggle trailing blanks visualization
   l	toggle "long lines" visualization
   L	toggle "long lines" tail visualization
   n	toggle NEWLINE visualization
   e	toggle empty line at bob and/or eob visualization
   C-i	toggle indentation SPACEs visualization (via ‘indent-tabs-mode’)
   I	toggle indentation SPACEs visualization
   i	toggle indentation TABs visualization
   C-t	toggle big indentation visualization
   C-a	toggle SPACEs after TAB visualization (via ‘indent-tabs-mode’)
   A	toggle SPACEs after TAB: SPACEs visualization
   a	toggle SPACEs after TAB: TABs visualization
   C-b	toggle SPACEs before TAB visualization (via ‘indent-tabs-mode’)
   B	toggle SPACEs before TAB: SPACEs visualization
   b	toggle SPACEs before TAB: TABs visualization

  (VIA DISPLAY TABLE)
   T	toggle TAB visualization
   S	toggle SPACEs before TAB visualization
   N	toggle NEWLINE visualization

   x	restore ‘whitespace-style’ value
   ?	display brief help

Non-interactively, ARG should be a symbol or a list of symbols.
The valid symbols are:

   face			toggle face visualization
   tabs			toggle TAB visualization
   spaces		toggle SPACE and HARD SPACE visualization
   trailing		toggle trailing blanks visualization
   lines		toggle "long lines" visualization
   lines-tail		toggle "long lines" tail visualization
   newline		toggle NEWLINE visualization
   empty		toggle empty line at bob and/or eob visualization
   indentation		toggle indentation SPACEs visualization
   indentation::tab	toggle indentation SPACEs visualization
   indentation::space	toggle indentation TABs visualization
   big-indent		toggle big indentation visualization
   space-after-tab		toggle SPACEs after TAB visualization
   space-after-tab::tab		toggle SPACEs after TAB: SPACEs visualization
   space-after-tab::space	toggle SPACEs after TAB: TABs visualization
   space-before-tab		toggle SPACEs before TAB visualization
   space-before-tab::tab	toggle SPACEs before TAB: SPACEs visualization
   space-before-tab::space	toggle SPACEs before TAB: TABs visualization

   tab-mark		toggle TAB visualization
   space-mark		toggle SPACEs before TAB visualization
   newline-mark		toggle NEWLINE visualization

   whitespace-style	restore ‘whitespace-style’ value

See ‘whitespace-style’ and ‘indent-tabs-mode’ for documentation.

(fn ARG)〉〉enditem49840〈〈gnus-group-list-groups〉〉:〈〈List newsgroups with level LEVEL or lower that have unread articles.
Default is all subscribed groups.
If argument UNREAD is non-nil, groups with no unread articles are also
listed.

Also see the ‘gnus-group-use-permanent-levels’ variable.〉〉enditem49840〈〈gnus〉〉:〈〈Read network news.
If ARG is non-nil and a positive number, Gnus will use that as the
startup level.  If ARG is non-nil and not a positive number, Gnus will
prompt the user for the name of an NNTP server to use.〉〉enditem49840〈〈gomoku〉〉:〈〈Start a Gomoku game between you and Emacs.

If a game is in progress, this command allows you to resume it.
If optional arguments N and M are given, an N by M board is used.
If prefix arg is given for N, M is prompted for.

You and Emacs play in turn by marking a free square.  You mark it with X
and Emacs marks it with O.  The winner is the first to get five contiguous
marks horizontally, vertically or in diagonal.

You play by moving the cursor over the square you choose and hitting

Uses keymap ‘gomoku-mode-map’, which is not currently defined.
M-x gomoku-human-plays.

This program actually plays a simplified or archaic version of the
Gomoku game, and ought to be upgraded to use the full modern rules.

Use C-h m for more info.

(fn &optional N M)〉〉enditem49840〈〈goto-address-at-point〉〉:〈〈Send to the e-mail address or load the URL at point.
Send mail to address at point.  See documentation for
‘goto-address-find-address-at-point’.  If no address is found
there, then load the URL at or before point.

(fn &optional EVENT)〉〉enditem49840〈〈goto-address-mode〉〉:〈〈Minor mode to buttonize URLs and e-mail addresses in the current buffer.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈goto-line〉〉:〈〈Go to LINE, counting from line 1 at beginning of buffer.
If called interactively, a numeric prefix argument specifies
LINE; without a numeric prefix argument, read LINE from the
minibuffer.

If optional argument BUFFER is non-nil, switch to that buffer and
move to line LINE there.  If called interactively with C-u
as argument, BUFFER is the most recently selected other buffer.

Prior to moving point, this function sets the mark (without
activating it), unless Transient Mark mode is enabled and the
mark is already active.

This function is usually the wrong thing to use in a Lisp program.
What you probably want instead is something like:
  (goto-char (point-min))
  (forward-line (1- N))
If at all possible, an even better solution is to use char counts
rather than line counts.

(fn LINE &optional BUFFER)〉〉enditem49840〈〈gpm-mouse-mode〉〉:〈〈Toggle mouse support in GNU/Linux consoles (GPM Mouse mode).
With a prefix argument ARG, enable GPM Mouse mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

This allows the use of the mouse when operating on a GNU/Linux console,
in the same way as you can use the mouse under X11.
It relies on the ‘gpm’ daemon being activated.

Note that when ‘gpm-mouse-mode’ is enabled, you cannot use the
mouse to transfer text between Emacs and other programs which use
GPM.  This is due to limitations in GPM and the Linux kernel.

(fn &optional ARG)〉〉enditem49840〈〈grep-find〉〉:〈〈Run grep via find, with user-specified args COMMAND-ARGS.
Collect output in a buffer.
While find runs asynchronously, you can use the C-x ` command
to find the text that grep hits refer to.

This command uses a special history list for its arguments, so you can
easily repeat a find command.

(fn COMMAND-ARGS)〉〉enditem49840〈〈grep〉〉:〈〈Run Grep with user-specified COMMAND-ARGS, collect output in a buffer.
While Grep runs asynchronously, you can use C-x ` (M-x next-error),
or RET in the *grep* buffer, to go to the lines where Grep found
matches.  To kill the Grep job before it finishes, type C-c C-k.

Noninteractively, COMMAND-ARGS should specify the Grep command-line
arguments.

For doing a recursive ‘grep’, see the ‘rgrep’ command.  For running
Grep in a specific directory, see ‘lgrep’.

This command uses a special history list for its COMMAND-ARGS, so you
can easily repeat a grep command.

A prefix argument says to default the COMMAND-ARGS based on the current
tag the cursor is over, substituting it into the last Grep command
in the Grep command history (or into ‘grep-command’ if that history
list is empty).

(fn COMMAND-ARGS)〉〉enditem49840〈〈gud-gdb〉〉:〈〈Run gdb passing it COMMAND-LINE as arguments.
If COMMAND-LINE names a program FILE to debug, gdb will run in
a buffer named *gud-FILE*, and the directory containing FILE
becomes the initial working directory and source-file directory
for your debugger.
If COMMAND-LINE requests that gdb attaches to a process PID, gdb
will run in *gud-PID*, otherwise it will run in *gud*; in these
cases the initial working directory is the default-directory of
the buffer in which this command was invoked.

(fn COMMAND-LINE)〉〉enditem49840〈〈gud-tooltip-mode〉〉:〈〈Toggle the display of GUD tooltips.
With a prefix argument ARG, enable the feature if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
it if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈gui-get-primary-selection〉〉:〈〈Return the PRIMARY selection, or the best emulation thereof.〉〉enditem49840〈〈gui-select-text〉〉:〈〈Select TEXT, a string, according to the window system.
if ‘select-enable-clipboard’ is non-nil, copy TEXT to the system’s clipboard.
If ‘select-enable-primary’ is non-nil, put TEXT in the primary selection.

MS-Windows does not have a "primary" selection.

(fn TEXT)〉〉enditem49840〈〈handwrite〉〉:〈〈Turns the buffer into a "handwritten" document.
The functions ‘handwrite-10pt’, ‘handwrite-11pt’, ‘handwrite-12pt’
and ‘handwrite-13pt’ set up for various sizes of output.

Variables: ‘handwrite-linespace’     (default 12)
           ‘handwrite-fontsize’      (default 11)
           ‘handwrite-numlines’      (default 60)
           ‘handwrite-pagenumbering’ (default nil)

(fn)〉〉enditem49840〈〈hanoi〉〉:〈〈Towers of Hanoi diversion.  Use NRINGS rings.

(fn NRINGS)〉〉enditem49840〈〈help-command〉〉:〈〈Prefix command (definition is a keymap associating keystrokes with commands).〉〉enditem49840〈〈help-follow-symbol〉〉:〈〈In help buffer, show docs for symbol at POS, defaulting to point.
Show all docs for that symbol as either a variable, function or face.〉〉enditem49840〈〈help-follow〉〉:〈〈Follow cross-reference at point.

For the cross-reference format, see ‘help-make-xrefs’.〉〉enditem49840〈〈help-for-help〉〉:〈〈Help command.〉〉enditem49840〈〈help-go-back〉〉:〈〈Go back to previous topic in this help buffer.〉〉enditem49840〈〈help-go-forward〉〉:〈〈Go to the next topic in this help buffer.〉〉enditem49840〈〈help-with-tutorial〉〉:〈〈Select the Emacs learn-by-doing tutorial.
If there is a tutorial version written in the language
of the selected language environment, that version is used.
If there’s no tutorial in that language, ‘TUTORIAL’ is selected.
With ARG, you are asked to choose which language.
If DONT-ASK-FOR-REVERT is non-nil the buffer is reverted without
any question when restarting the tutorial.

If any of the standard Emacs key bindings that are used in the
tutorial have been changed then an explanatory note about this is
shown in the beginning of the tutorial buffer.

When the tutorial buffer is killed the content and the point
position in the buffer is saved so that the tutorial may be
resumed later.

(fn &optional ARG DONT-ASK-FOR-REVERT)〉〉enditem49840〈〈hexl-mode〉〉:〈〈
Uses keymap ‘hexl-mode-map’, which is not currently defined.
A mode for editing binary files in hex dump format.
This is not an ordinary major mode; it alters some aspects
of the current mode’s behavior, but not all; also, you can exit
Hexl mode and return to the previous mode using ‘hexl-mode-exit’.

This function automatically converts a buffer into the hexl format
using the function ‘hexlify-buffer’.

Each line in the buffer has an "address" (displayed in hexadecimal)
representing the offset into the file that the characters on this line
are at and 16 characters from the file (displayed as hexadecimal
values grouped every ‘hexl-bits’ bits, and as their ASCII values).

If any of the characters (displayed as ASCII characters) are
unprintable (control or meta characters) they will be replaced by
periods.

If ‘hexl-mode’ is invoked with an argument the buffer is assumed to be
in hexl format.

A sample format:

  HEX ADDR: 0011 2233 4455 6677 8899 aabb ccdd eeff     ASCII-TEXT
  --------  ---- ---- ---- ---- ---- ---- ---- ----  ----------------
  00000000: 5468 6973 2069 7320 6865 786c 2d6d 6f64  This is hexl-mod
  00000010: 652e 2020 4561 6368 206c 696e 6520 7265  e.  Each line re
  00000020: 7072 6573 656e 7473 2031 3620 6279 7465  presents 16 byte
  00000030: 7320 6173 2068 6578 6164 6563 696d 616c  s as hexadecimal
  00000040: 2041 5343 4949 0a61 6e64 2070 7269 6e74   ASCII.and print
  00000050: 6162 6c65 2041 5343 4949 2063 6861 7261  able ASCII chara
  00000060: 6374 6572 732e 2020 416e 7920 636f 6e74  cters.  Any cont
  00000070: 726f 6c20 6f72 206e 6f6e 2d41 5343 4949  rol or non-ASCII
  00000080: 2063 6861 7261 6374 6572 730a 6172 6520   characters.are
  00000090: 6469 7370 6c61 7965 6420 6173 2070 6572  displayed as per
  000000a0: 696f 6473 2069 6e20 7468 6520 7072 696e  iods in the prin
  000000b0: 7461 626c 6520 6368 6172 6163 7465 7220  table character
  000000c0: 7265 6769 6f6e 2e0a                      region..

Movement is as simple as movement in a normal Emacs text buffer.
Most cursor movement bindings are the same: use M-x hexl-backward-char, M-x hexl-forward-char, M-x hexl-next-line, and M-x hexl-previous-line
to move the cursor left, right, down, and up.

Advanced cursor movement commands (ala M-x hexl-beginning-of-line, M-x hexl-end-of-line, M-x hexl-beginning-of-buffer, and M-x hexl-end-of-buffer) are
also supported.

There are several ways to change text in hexl mode:

ASCII characters (character between space (0x20) and tilde (0x7E)) are
bound to self-insert so you can simply type the character and it will
insert itself (actually overstrike) into the buffer.

M-x hexl-quoted-insert followed by another keystroke allows you to insert the key even if
it isn’t bound to self-insert.  An octal number can be supplied in place
of another key to insert the octal number’s ASCII representation.

M-x hexl-insert-hex-char will insert a given hexadecimal value (if it is between 0 and 0xFF)
into the buffer at the current point.

M-x hexl-insert-octal-char will insert a given octal value (if it is between 0 and 0377)
into the buffer at the current point.

M-x hexl-insert-decimal-char will insert a given decimal value (if it is between 0 and 255)
into the buffer at the current point.

M-x hexl-mode-exit will exit ‘hexl-mode’.

Note: saving the file with any of the usual Emacs commands
will actually convert it back to binary format while saving.

You can use M-x hexl-find-file to visit a file in Hexl mode.

DEL h b for advanced commands.

(fn &optional ARG)〉〉enditem49840〈〈hi-lock-mode〉〉:〈〈Toggle selective highlighting of patterns (Hi Lock mode).
With a prefix argument ARG, enable Hi Lock mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Hi Lock mode is automatically enabled when you invoke any of the
highlighting commands listed below, such as DEL . h.
To enable Hi Lock mode in all buffers, use ‘global-hi-lock-mode’
or add (global-hi-lock-mode 1) to your init file.

In buffers where Font Lock mode is enabled, patterns are
highlighted using font lock.  In buffers where Font Lock mode is
disabled, patterns are applied using overlays; in this case, the
highlighting will not be updated as you type.

When Hi Lock mode is enabled, a "Regexp Highlighting" submenu
is added to the "Edit" menu.  The commands in the submenu,
which can be called interactively, are:

DEL . h REGEXP FACE
  Highlight matches of pattern REGEXP in current buffer with FACE.

DEL . t PHRASE FACE
  Highlight matches of phrase PHRASE in current buffer with FACE.
  (PHRASE can be any REGEXP, but spaces will be replaced by matches
  to whitespace and initial lower-case letters will become case insensitive.)

DEL . c REGEXP FACE
  Highlight lines containing matches of REGEXP in current buffer with FACE.

DEL . .
  Highlight the symbol found near point without prompting, using the next
  available face automatically.

DEL . g REGEXP
  Remove highlighting on matches of REGEXP in current buffer.

M-s h w
  Write active REGEXPs into buffer as comments (if possible).  They may
  be read the next time file is loaded or when the M-s h f command
  is issued.  The inserted regexps are in the form of font lock keywords.
  (See ‘font-lock-keywords’.)  They may be edited and re-loaded with M-s h f,
  any valid ‘font-lock-keywords’ form is acceptable.  When a file is
  loaded the patterns are read if ‘hi-lock-file-patterns-policy’ is
  ‘ask’ and the user responds y to the prompt, or if
  ‘hi-lock-file-patterns-policy’ is bound to a function and that
  function returns t.

M-s h f
  Re-read patterns stored in buffer (in the format produced by M-s h w).

When hi-lock is started and if the mode is not excluded or patterns
rejected, the beginning of the buffer is searched for lines of the
form:
  Hi-lock: FOO

where FOO is a list of patterns.  The patterns must start before
position (number of characters into buffer)
‘hi-lock-file-patterns-range’.  Patterns will be read until
Hi-lock: end is found.  A mode is excluded if it’s in the list
‘hi-lock-exclude-modes’.

(fn &optional ARG)〉〉enditem49840〈〈hi-lock-write-interactive-patterns〉〉:〈〈Write interactively added patterns, if any, into buffer at point.

Interactively added patterns are those normally specified using
‘highlight-regexp’ and ‘highlight-lines-matching-regexp’; they can
be found in variable ‘hi-lock-interactive-patterns’.

(fn)〉〉enditem49840〈〈hide-body〉〉:〈〈Hide all body lines in buffer, leaving all headings visible.
Note that this does not hide the lines preceding the first heading line.〉〉enditem49840〈〈hide-entry〉〉:〈〈Hide the body directly following this heading.〉〉enditem49840〈〈hide-ifdef-mode〉〉:〈〈Toggle features to hide/show #ifdef blocks (Hide-Ifdef mode).
With a prefix argument ARG, enable Hide-Ifdef mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Hide-Ifdef mode is a buffer-local minor mode for use with C and
C-like major modes.  When enabled, code within #ifdef constructs
that the C preprocessor would eliminate may be hidden from view.
Several variables affect how the hiding is done:

‘hide-ifdef-env’
        An association list of defined and undefined symbols for the
        current project.  Initially, the global value of ‘hide-ifdef-env’
        is used.  This variable was a buffer-local variable, which limits
        hideif to parse only one C/C++ file at a time.  We’ve extended
        hideif to support parsing a C/C++ project containing multiple C/C++
        source files opened simultaneously in different buffers.  Therefore
        ‘hide-ifdef-env’ can no longer be buffer local but must be global.

‘hide-ifdef-define-alist’
        An association list of defined symbol lists.
        Use ‘hide-ifdef-set-define-alist’ to save the current ‘hide-ifdef-env’
        and ‘hide-ifdef-use-define-alist’ to set the current ‘hide-ifdef-env’
        from one of the lists in ‘hide-ifdef-define-alist’.

‘hide-ifdef-lines’
        Set to non-nil to not show #if, #ifdef, #ifndef, #else, and
        #endif lines when hiding.

‘hide-ifdef-initially’
        Indicates whether ‘hide-ifdefs’ should be called when Hide-Ifdef mode
        is activated.

‘hide-ifdef-read-only’
        Set to non-nil if you want to make buffers read only while hiding.
        After ‘show-ifdefs’, read-only status is restored to previous value.


Uses keymap ‘hide-ifdef-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈hide-leaves〉〉:〈〈Hide the body after this heading and at deeper levels.〉〉enditem49840〈〈hide-other〉〉:〈〈Hide everything except current body and parent and top-level headings.
This also unhides the top heading-less body, if any.〉〉enditem49840〈〈hide-sublevels〉〉:〈〈Hide everything but the top LEVELS levels of headers, in whole buffer.
This also unhides the top heading-less body, if any.

Interactively, the prefix argument supplies the value of LEVELS.
When invoked without a prefix argument, LEVELS defaults to the level
of the current heading, or to 1 if the current line is not a heading.〉〉enditem49840〈〈hide-subtree〉〉:〈〈Hide everything after this heading at deeper levels.〉〉enditem49840〈〈highlight-changes-mode〉〉:〈〈Toggle highlighting changes in this buffer (Highlight Changes mode).
With a prefix argument ARG, enable Highlight Changes mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When Highlight Changes is enabled, changes are marked with a text
property.  Normally they are displayed in a distinctive face, but
command M-x highlight-changes-visible-mode can be used to toggle
this on and off.

Other functions for buffers in this mode include:
M-x highlight-changes-next-change - move point to beginning of next change
M-x highlight-changes-previous-change - move to beginning of previous change
M-x highlight-changes-remove-highlight - remove the change face from the region
M-x highlight-changes-rotate-faces - rotate different "ages" of changes
through	various faces.
M-x highlight-compare-with-file - mark text as changed by comparing this
buffer with the contents of a file
M-x highlight-compare-buffers highlights differences between two buffers.

(fn &optional ARG)〉〉enditem49840〈〈highlight-lines-matching-regexp〉〉:〈〈Set face of all lines containing a match of REGEXP to FACE.
Interactively, prompt for REGEXP using ‘read-regexp’, then FACE.
Use the global history list for FACE.

Use Font lock mode, if enabled, to highlight REGEXP.  Otherwise,
use overlays for highlighting.  If overlays are used, the
highlighting will not update as you type.

(fn REGEXP &optional FACE)〉〉enditem49840〈〈highlight-phrase〉〉:〈〈Set face of each match of phrase REGEXP to FACE.
Interactively, prompt for REGEXP using ‘read-regexp’, then FACE.
Use the global history list for FACE.

When called interactively, replace whitespace in user-provided
regexp with arbitrary whitespace, and make initial lower-case
letters case-insensitive, before highlighting with ‘hi-lock-set-pattern’.

Use Font lock mode, if enabled, to highlight REGEXP.  Otherwise,
use overlays for highlighting.  If overlays are used, the
highlighting will not update as you type.

(fn REGEXP &optional FACE)〉〉enditem49840〈〈highlight-regexp〉〉:〈〈Set face of each match of REGEXP to FACE.
Interactively, prompt for REGEXP using ‘read-regexp’, then FACE.
Use the global history list for FACE.

Use Font lock mode, if enabled, to highlight REGEXP.  Otherwise,
use overlays for highlighting.  If overlays are used, the
highlighting will not update as you type.

(fn REGEXP &optional FACE)〉〉enditem49840〈〈highlight-symbol-at-point〉〉:〈〈Highlight each instance of the symbol at point.
Uses the next face from ‘hi-lock-face-defaults’ without prompting,
unless you use a prefix argument.
Uses ‘find-tag-default-as-symbol-regexp’ to retrieve the symbol at point.

This uses Font lock mode if it is enabled; otherwise it uses overlays,
in which case the highlighting will not update as you type.

(fn)〉〉enditem49840〈〈hl-line-mode〉〉:〈〈Toggle highlighting of the current line (Hl-Line mode).
With a prefix argument ARG, enable Hl-Line mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Hl-Line mode is a buffer-local minor mode.  If
‘hl-line-sticky-flag’ is non-nil, Hl-Line mode highlights the
line about the buffer’s point in all windows.  Caveat: the
buffer’s point might be different from the point of a
non-selected window.  Hl-Line mode uses the function
‘hl-line-highlight’ on ‘post-command-hook’ in this case.

When ‘hl-line-sticky-flag’ is nil, Hl-Line mode highlights the
line about point in the selected window only.  In this case, it
uses the function ‘hl-line-maybe-unhighlight’ in
addition to ‘hl-line-highlight’ on ‘post-command-hook’.

(fn &optional ARG)〉〉enditem49840〈〈holidays〉〉:〈〈Display the holidays for last month, this month, and next month.
If called with an optional prefix argument ARG, prompts for month and year.
This function is suitable for execution in an init file.

(fn &optional ARG)〉〉enditem49840〈〈horizontal-scroll-bar-mode〉〉:〈〈Toggle horizontal scroll bars on all frames (Horizontal Scroll Bar mode).
With a prefix argument ARG, enable Horizontal Scroll Bar mode if
ARG is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

This command applies to all frames that exist and frames to be
created in the future.〉〉enditem49840〈〈how-many〉〉:〈〈Print and return number of matches for REGEXP following point.
When called from Lisp and INTERACTIVE is omitted or nil, just return
the number, do not print it; if INTERACTIVE is t, the function behaves
in all respects as if it had been called interactively.

If REGEXP contains upper case characters (excluding those preceded by ‘\’)
and ‘search-upper-case’ is non-nil, the matching is case-sensitive.

Second and third arg RSTART and REND specify the region to operate on.

Interactively, in Transient Mark mode when the mark is active, operate
on the contents of the region.  Otherwise, operate from point to the
end of (the accessible portion of) the buffer.

This function starts looking for the next match from the end of
the previous match.  Hence, it ignores matches that overlap
a previously found match.

(fn REGEXP &optional RSTART REND INTERACTIVE)〉〉enditem49840〈〈hs-minor-mode〉〉:〈〈Minor mode to selectively hide/show code and comment blocks.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

When hideshow minor mode is on, the menu bar is augmented with hideshow
commands and the hideshow commands are enabled.
The value (hs . t) is added to ‘buffer-invisibility-spec’.

The main commands are: ‘hs-hide-all’, ‘hs-show-all’, ‘hs-hide-block’,
‘hs-show-block’, ‘hs-hide-level’ and ‘hs-toggle-hiding’.  There is also
‘hs-hide-initial-comment-block’ and ‘hs-mouse-toggle-hiding’.

Turning hideshow minor mode off reverts the menu bar and the
variables to default values and disables the hideshow commands.

Lastly, the normal hook ‘hs-minor-mode-hook’ is run using ‘run-hooks’.

Key bindings:

Uses keymap ‘hs-minor-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈html-mode〉〉:〈〈Major mode based on SGML mode for editing HTML documents.
This allows inserting skeleton constructs used in hypertext documents with
completion.  See below for an introduction to HTML.  Use
M-x browse-url-of-buffer to see how this comes out.  See also ‘sgml-mode’ on
which this is based.

Do DEL h n html- SPC and DEL h n sgml- SPC to see available variables.

To write fairly well formatted pages you only need to know few things.  Most
browsers have a function to read the source code of the page being seen, so
you can imitate various tricks.  Here’s a very short HTML primer which you
can also view with a browser to see what happens:

<title>A Title Describing Contents</title> should be on every page.  Pages can
have <h1>Very Major Headlines</h1> through <h6>Very Minor Headlines</h6>
<hr> Parts can be separated with horizontal rules.

<p>Paragraphs only need an opening tag.  Line breaks and multiple spaces are
ignored unless the text is <pre>preformatted.</pre>  Text can be marked as
<b>bold</b>, <i>italic</i> or <u>underlined</u> using the normal M-o or
Edit/Text Properties/Face commands.

Pages can have <a name="SOMENAME">named points</a> and can link other points
to them with <a href="#SOMENAME">see also somename</a>.  In the same way <a
href="URL">see also URL</a> where URL is a filename relative to current
directory, or absolute as in ‘http://www.cs.indiana.edu/elisp/w3/docs.html’.

Images in many formats can be inlined with <img src="URL">.

If you mainly create your own documents, ‘sgml-specials’ might be
interesting.  But note that some HTML 2 browsers can’t handle ‘&apos;’.
To work around that, do:
   (eval-after-load "sgml-mode" '(aset sgml-char-names ?' nil))

key             binding
---             -------

 .. ÿ       sgml-maybe-name-self

C-c             Prefix Command
/               sgml-slash

C-c C-c         Prefix Command
C-c C-j         html-line
C-c RET         html-paragraph
C-c C-s         html-autoview-mode
C-c C-v         browse-url-of-buffer
C-c 1           html-headline-1
C-c 2           html-headline-2
C-c 3           html-headline-3
C-c 4           html-headline-4
C-c 5           html-headline-5
C-c 6           html-headline-6

C-c C-a         sgml-attributes
C-c C-b         sgml-skip-tag-backward
C-c C-d         sgml-delete-tag
C-c C-e         sgml-close-tag
C-c C-f         sgml-skip-tag-forward
C-c TAB         sgml-tags-invisible
C-c C-n         sgml-name-char
C-c C-o         sgml-tag
C-c C-t         sgml-tag
C-c C-v         sgml-validate
  (that binding is currently shadowed by another mode)
C-c /           sgml-close-tag
C-c 8           sgml-name-8bit-mode
C-c ?           sgml-tag-help
C-c ]           sgml-close-tag
C-c DEL         sgml-delete-tag
C-c <left>      sgml-skip-tag-backward
C-c <right>     sgml-skip-tag-forward

C-c C-c -       html-horizontal-rule
C-c C-c c       html-checkboxes
C-c C-c h       html-href-anchor
C-c C-c i       html-image
C-c C-c l       html-list-item
C-c C-c n       html-name-anchor
C-c C-c o       html-ordered-list
C-c C-c r       html-radio-buttons
C-c C-c u       html-unordered-list



In addition to any hooks its parent mode might have run,
this mode runs the hook ‘html-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈htmlfontify-buffer〉〉:〈〈Create a new buffer, named for the current buffer + a .html extension,
containing an inline CSS-stylesheet and formatted CSS-markup HTML
that reproduces the look of the current Emacs buffer as closely
as possible.

Dangerous characters in the existing buffer are turned into HTML
entities, so you should even be able to do HTML-within-HTML
fontified display.

You should, however, note that random control or non-ASCII
characters such as ^L (U+000C FORM FEED (FF)) or ¤ (U+00A4
CURRENCY SIGN) won’t get mapped yet.

If the SRCDIR and FILE arguments are set, lookup etags derived
entries in the ‘hfy-tags-cache’ and add HTML anchors and
hyperlinks as appropriate.

(fn &optional SRCDIR FILE)〉〉enditem49840〈〈icalendar-export-file〉〉:〈〈Export diary file to iCalendar format.
All diary entries in the file DIARY-FILENAME are converted to iCalendar
format.  The result is appended to the file ICAL-FILENAME.

(fn DIARY-FILENAME ICAL-FILENAME)〉〉enditem49840〈〈icalendar-export-region〉〉:〈〈Export region in diary file to iCalendar format.
All diary entries in the region from MIN to MAX in the current buffer are
converted to iCalendar format.  The result is appended to the file
ICAL-FILENAME.
This function attempts to return t if something goes wrong.  In this
case an error string which describes all the errors and problems is
written into the buffer ‘*icalendar-errors*’.

(fn MIN MAX ICAL-FILENAME)〉〉enditem49840〈〈icalendar-import-buffer〉〉:〈〈Extract iCalendar events from current buffer.

This function searches the current buffer for the first iCalendar
object, reads it and adds all VEVENT elements to the diary
DIARY-FILE.

It will ask for each appointment whether to add it to the diary
unless DO-NOT-ASK is non-nil.  When called interactively,
DO-NOT-ASK is nil, so that you are asked for each event.

NON-MARKING determines whether diary events are created as
non-marking.

Return code t means that importing worked well, return code nil
means that an error has occurred.  Error messages will be in the
buffer ‘*icalendar-errors*’.

(fn &optional DIARY-FILE DO-NOT-ASK NON-MARKING)〉〉enditem49840〈〈icalendar-import-file〉〉:〈〈Import an iCalendar file and append to a diary file.
Argument ICAL-FILENAME output iCalendar file.
Argument DIARY-FILENAME input ‘diary-file’.
Optional argument NON-MARKING determines whether events are created as
non-marking or not.

(fn ICAL-FILENAME DIARY-FILENAME &optional NON-MARKING)〉〉enditem49840〈〈icomplete-mode〉〉:〈〈Toggle incremental minibuffer completion (Icomplete mode).
With a prefix argument ARG, enable Icomplete mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When this global minor mode is enabled, typing in the minibuffer
continuously displays a list of possible completions that match
the string you have typed.  See ‘icomplete-completions’ for a
description of how prospective completions are displayed.

For more information, see Info node ‘(emacs)Icomplete’.
For options you can set, ‘M-x customize-group icomplete’.

You can use the following key bindings to navigate and select
completions:

key             binding
---             -------

C-j             icomplete-force-complete-and-exit
ESC             Prefix Command
C-,             icomplete-backward-completions
C-.             icomplete-forward-completions
<left>          icomplete-backward-completions
<right>         icomplete-forward-completions

C-M-i           minibuffer-force-complete

〉〉enditem49840〈〈ielm〉〉:〈〈Interactively evaluate Emacs Lisp expressions.
Switches to the buffer ‘*ielm*’, or creates it if it does not exist.
See ‘inferior-emacs-lisp-mode’ for details.

(fn)〉〉enditem49840〈〈image-decrease-speed〉〉:〈〈Decrease the speed of current animated image by a factor of 2.〉〉enditem49840〈〈image-dired-dired-comment-files〉〉:〈〈Add comment to current or marked files in dired.

(fn)〉〉enditem49840〈〈image-dired-display-thumbs〉〉:〈〈Display thumbnails of all marked files, in ‘image-dired-thumbnail-buffer’.
If a thumbnail image does not exist for a file, it is created on the
fly.  With prefix argument ARG, display only thumbnail for file at
point (this is useful if you have marked some files but want to show
another one).

Recommended usage is to split the current frame horizontally so that
you have the dired buffer in the left window and the
‘image-dired-thumbnail-buffer’ buffer in the right window.

With optional argument APPEND, append thumbnail to thumbnail buffer
instead of erasing it first.

Optional argument DO-NOT-POP controls if ‘pop-to-buffer’ should be
used or not.  If non-nil, use ‘display-buffer’ instead of
‘pop-to-buffer’.  This is used from functions like
‘image-dired-next-line-and-display’ and
‘image-dired-previous-line-and-display’ where we do not want the
thumbnail buffer to be selected.

(fn &optional ARG APPEND DO-NOT-POP)〉〉enditem49840〈〈image-dired-mark-tagged-files〉〉:〈〈Use regexp to mark files with matching tag.
A ‘tag’ is a keyword, a piece of meta data, associated with an
image file and stored in image-dired’s database file.  This command
lets you input a regexp and this will be matched against all tags
on all image files in the database file.  The files that have a
matching tag will be marked in the dired buffer.

(fn)〉〉enditem49840〈〈image-dired-tag-files〉〉:〈〈Tag marked file(s) in dired.  With prefix ARG, tag file at point.

(fn ARG)〉〉enditem49840〈〈image-goto-frame〉〉:〈〈Show frame N of a multi-frame image.
Optional argument OFFSET non-nil means interpret N as relative to the
current frame.  Frames are indexed from 1.

(fn N &optional RELATIVE)〉〉enditem49840〈〈image-increase-speed〉〉:〈〈Increase the speed of current animated image by a factor of 2.〉〉enditem49840〈〈image-mode〉〉:〈〈Major mode for image files.
You can use C-c C-c or C-c C-x
to toggle between display as an image and display as text or hex.

Key bindings:
key             binding
---             -------

C-c             Prefix Command
RET             image-toggle-animation
SPC             image-scroll-up
+               image-increase-size
-               image-decrease-size
0 .. 9          digit-argument
<               beginning-of-buffer
>               end-of-buffer
?               describe-mode
F               image-goto-frame
a               Prefix Command
b               image-previous-frame
f               image-next-frame
g               revert-buffer
h               describe-mode
k               image-kill-buffer
n               image-next-file
o               image-save
p               image-previous-file
q               quit-window
r               image-rotate
DEL             image-scroll-down
S-SPC           image-scroll-down
<remap>         Prefix Command

<remap> <backward-char>         image-backward-hscroll
<remap> <beginning-of-buffer>   image-bob
<remap> <end-of-buffer>         image-eob
<remap> <forward-char>          image-forward-hscroll
<remap> <left-char>             image-backward-hscroll
<remap> <move-beginning-of-line>
                                image-bol
<remap> <move-end-of-line>      image-eol
<remap> <next-line>             image-next-line
<remap> <previous-line>         image-previous-line
<remap> <right-char>            image-forward-hscroll
<remap> <scroll-down>           image-scroll-down
<remap> <scroll-down-command>   image-scroll-down
<remap> <scroll-left>           image-scroll-left
<remap> <scroll-right>          image-scroll-right
<remap> <scroll-up>             image-scroll-up
<remap> <scroll-up-command>     image-scroll-up

a +             image-increase-speed
a -             image-decrease-speed
a 0             image-reset-speed
a r             image-reverse-speed

C-c C-c         image-toggle-display
C-c C-x         image-toggle-hex-display

〉〉enditem49840〈〈image-next-file〉〉:〈〈Visit the next image in the same directory as the current image file.
With optional argument N, visit the Nth image file after the
current one, in cyclic alphabetical order.

This command visits the specified file via ‘find-alternate-file’,
replacing the current Image mode buffer.

(fn &optional N)〉〉enditem49840〈〈image-next-frame〉〉:〈〈Switch to the next frame of a multi-frame image.
With optional argument N, switch to the Nth frame after the current one.
If N is negative, switch to the Nth frame before the current one.

(fn &optional N)〉〉enditem49840〈〈image-previous-file〉〉:〈〈Visit the preceding image in the same directory as the current file.
With optional argument N, visit the Nth image file preceding the
current one, in cyclic alphabetical order.

This command visits the specified file via ‘find-alternate-file’,
replacing the current Image mode buffer.

(fn &optional N)〉〉enditem49840〈〈image-previous-frame〉〉:〈〈Switch to the previous frame of a multi-frame image.
With optional argument N, switch to the Nth frame before the current one.
If N is negative, switch to the Nth frame after the current one.

(fn &optional N)〉〉enditem49840〈〈image-reset-speed〉〉:〈〈Reset the animation speed of the current image.〉〉enditem49840〈〈image-reverse-speed〉〉:〈〈Reverse the animation of the current image.〉〉enditem49840〈〈image-toggle-animation〉〉:〈〈Start or stop animating the current image.
If ‘image-animate-loop’ is non-nil, animation loops forever.
Otherwise it plays once, then stops.〉〉enditem49840〈〈image-toggle-display〉〉:〈〈Toggle between image and text display.

If the current buffer is displaying an image file as an image,
call ‘image-mode-as-text’ to switch to text or hex display.
Otherwise, display the image by calling ‘image-mode’〉〉enditem49840〈〈imenu--sort-by-name〉〉:〈〈Comparison function to sort items depending on their index name.
An item looks like (NAME . POSITION).

(fn ITEM1 ITEM2)〉〉enditem49840〈〈imenu-add-menubar-index〉〉:〈〈Add an Imenu "Index" entry on the menu bar for the current buffer.

A trivial interface to ‘imenu-add-to-menubar’ suitable for use in a hook.〉〉enditem49840〈〈imenu〉〉:〈〈Jump to a place in the buffer chosen using a buffer menu or mouse menu.
INDEX-ITEM specifies the position.  See ‘imenu-choose-buffer-index’
for more information.

(fn INDEX-ITEM)〉〉enditem49840〈〈increase-left-margin〉〉:〈〈Increase or decrease the left-margin of the region.
With no prefix argument, this adds ‘standard-indent’ of indentation.
A prefix arg (optional third arg INC noninteractively) specifies the amount
to change the margin by, in characters.
If ‘auto-fill-mode’ is active, re-fill the region to fit the new margin.

(fn FROM TO INC)〉〉enditem49840〈〈increment-register〉〉:〈〈Augment contents of REGISTER.
Interactively, PREFIX is in raw form.

If REGISTER contains a number, add ‘prefix-numeric-value’ of
PREFIX to it.

If REGISTER is empty or if it contains text, call
‘append-to-register’ with ‘delete-flag’ set to PREFIX.

Interactively, reads the register using ‘register-read-with-preview’.

(fn PREFIX REGISTER)〉〉enditem49840〈〈indent-pp-sexp〉〉:〈〈Indent each line of the list starting just after point, or prettyprint it.
A prefix argument specifies pretty-printing.

(fn &optional ARG)〉〉enditem49840〈〈info-emacs-manual〉〉:〈〈Display the Emacs manual in Info mode.〉〉enditem49840〈〈info-finder〉〉:〈〈Display descriptions of the keywords in the Finder virtual manual.
In interactive use, a prefix argument directs this command to read
a list of keywords separated by comma.  After that, it displays a node
with a list of packages that contain all specified keywords.

(fn &optional KEYWORDS)〉〉enditem49840〈〈info-lookup-file〉〉:〈〈Display the documentation of a file.
When this command is called interactively, it reads FILE from the minibuffer.
In the minibuffer, use M-n to yank the default file name
into the minibuffer so you can edit it.
The default file name is the one found at point.

With prefix arg MODE a query for the file help mode is offered.

(fn FILE &optional MODE)〉〉enditem49840〈〈info-lookup-symbol〉〉:〈〈Display the definition of SYMBOL, as found in the relevant manual.
When this command is called interactively, it reads SYMBOL from the
minibuffer.  In the minibuffer, use M-n to yank the default argument
value into the minibuffer so you can edit it.  The default symbol is the
one found at point.

With prefix arg MODE a query for the symbol help mode is offered.

(fn SYMBOL &optional MODE)〉〉enditem49840〈〈info〉〉:〈〈Enter Info, the documentation browser.
Optional argument FILE-OR-NODE specifies the file to examine;
the default is the top-level directory of Info.
Called from a program, FILE-OR-NODE may specify an Info node of the form
"(FILENAME)NODENAME".
Optional argument BUFFER specifies the Info buffer name;
the default buffer name is *info*.  If BUFFER exists,
just switch to BUFFER.  Otherwise, create a new buffer
with the top-level Info directory.

In interactive use, a non-numeric prefix argument directs
this command to read a file name from the minibuffer.

A numeric prefix argument of N selects an Info buffer named "*info*<N>".

The search path for Info files is in the variable ‘Info-directory-list’.
The top-level Info directory is made by combining all the files named ‘dir’
in all the directories in that path.

See a list of available Info commands in ‘Info-mode’.

(fn &optional FILE-OR-NODE BUFFER)〉〉enditem49840〈〈insert-abbrevs〉〉:〈〈Insert after point a description of all defined abbrevs.
Mark is set after the inserted text.〉〉enditem49840〈〈insert-file-literally〉〉:〈〈Insert contents of file FILENAME into buffer after point with no conversion.

This function is meant for the user to run interactively.
Don’t call it from programs!  Use ‘insert-file-contents-literally’ instead.
(Its calling sequence is different; see its documentation).

(fn FILENAME)〉〉enditem49840〈〈insert-file〉〉:〈〈Insert contents of file FILENAME into buffer after point.
Set mark after the inserted text.

This function is meant for the user to run interactively.
Don’t call it from programs!  Use ‘insert-file-contents’ instead.
(Its calling sequence is different; see its documentation).

(fn FILENAME)〉〉enditem49840〈〈insert-kbd-macro〉〉:〈〈Insert in buffer the definition of kbd macro MACRONAME, as Lisp code.
MACRONAME should be a symbol.
Optional second arg KEYS means also record the keys it is on
(this is the prefix argument, when calling interactively).

This Lisp code will, when executed, define the kbd macro with the same
definition it has now.  If you say to record the keys, the Lisp code
will also rebind those keys to the macro.  Only global key bindings
are recorded since executing this Lisp code always makes global
bindings.

To save a kbd macro, visit a file of Lisp code such as your ‘~/.emacs’,
use this command, and then save the file.

(fn MACRONAME &optional KEYS)〉〉enditem49840〈〈inverse-add-global-abbrev〉〉:〈〈Define last word before point as a global (mode-independent) abbrev.
With prefix argument N, defines the Nth word before point.
This command uses the minibuffer to read the expansion.
Expands the abbreviation after defining it.

(fn N)〉〉enditem49840〈〈inverse-add-mode-abbrev〉〉:〈〈Define last word before point as a mode-specific abbrev.
With prefix argument N, defines the Nth word before point.
This command uses the minibuffer to read the expansion.
Expands the abbreviation after defining it.

(fn N)〉〉enditem49840〈〈isearch-abort〉〉:〈〈Abort incremental search mode if searching is successful, signaling quit.
Otherwise, revert to previous successful search and continue searching.
Use ‘isearch-exit’ to quit without signaling.〉〉enditem49840〈〈isearch-backward-regexp〉〉:〈〈Do incremental search backward for regular expression.
With a prefix argument, do a regular string search instead.
Like ordinary incremental search except that your input is treated
as a regexp.  See the command ‘isearch-forward-regexp’ for more information.

(fn &optional NOT-REGEXP NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-backward〉〉:〈〈Do incremental search backward.
With a prefix argument, do a regular expression search instead.
See the command ‘isearch-forward’ for more information.

(fn &optional REGEXP-P NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-cancel〉〉:〈〈Terminate the search and go back to the starting point.〉〉enditem49840〈〈isearch-complete〉〉:〈〈Complete the search string from the strings on the search ring.
The completed string is then editable in the minibuffer.
If there is no completion possible, say so and continue searching.〉〉enditem49840〈〈isearch-del-char〉〉:〈〈Delete character from end of search string and search again.
Unlike ‘isearch-delete-char’, it only deletes the last character,
but doesn’t cancel the effect of other isearch command.
If search string is empty, just beep.

(fn &optional ARG)〉〉enditem49840〈〈isearch-forward-regexp〉〉:〈〈Do incremental search forward for regular expression.
With a prefix argument, do a regular string search instead.
Like ordinary incremental search except that your input is treated
as a regexp.  See the command ‘isearch-forward’ for more information.

In incremental searches, a space or spaces normally matches any
whitespace defined by the variable ‘search-whitespace-regexp’.
To search for a literal space and nothing else, enter C-q SPC.
To toggle whitespace matching, use ‘isearch-toggle-lax-whitespace’.
This command does not support character folding.

(fn &optional NOT-REGEXP NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-forward-symbol-at-point〉〉:〈〈Do incremental search forward for a symbol found near point.
Like ordinary incremental search except that the symbol found at point
is added to the search string initially as a regexp surrounded
by symbol boundary constructs \_< and \_>.
See the command ‘isearch-forward-symbol’ for more information.〉〉enditem49840〈〈isearch-forward-symbol〉〉:〈〈Do incremental search forward for a symbol.
The prefix argument is currently unused.
Like ordinary incremental search except that your input is treated
as a symbol surrounded by symbol boundary constructs \_< and \_>.
See the command ‘isearch-forward’ for more information.
This command does not support character folding, and lax space matching
has no effect on it.

(fn &optional NOT-SYMBOL NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-forward-word〉〉:〈〈Do incremental search forward for a sequence of words.
With a prefix argument, do a regular string search instead.
Like ordinary incremental search except that your input is treated
as a sequence of words without regard to how the words are separated.
See the command ‘isearch-forward’ for more information.
This command does not support character folding, and lax space matching
has no effect on it.

(fn &optional NOT-WORD NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-forward〉〉:〈〈Do incremental search forward.
With a prefix argument, do an incremental regular expression search instead.

As you type characters, they add to the search string and are found.
The following non-printing keys are bound in ‘isearch-mode-map’.

Type DEL to cancel last input item from end of search string.
Type RET to exit, leaving point at location found.
Type LFD (C-j) to match end of line.
Type C-s to search again forward, C-r to search again backward.
Type C-w to yank next word or character in buffer
  onto the end of the search string, and search for it.
Type C-M-w to delete character from end of search string.
Type C-M-y to yank char from buffer onto end of search string and search for it.
Type M-s C-e to yank rest of line onto end of search string and search for it.
Type C-y to yank the last string of killed text.
Type M-y to replace string just yanked into search prompt
 with string killed before it.
Type C-q to quote control character to search for it.
Type C-x 8 RET to add a character to search by Unicode name, with completion.
C-g while searching or when search has failed cancels input back to what has
 been found successfully.
C-g when search is successful aborts and moves point to starting point.

If you try to exit with the search string still empty, it invokes
 nonincremental search.

Type M-c to toggle search case-sensitivity.
Type M-s i to toggle search in invisible text.
Type M-r to toggle regular-expression mode.
Type M-s w to toggle word mode.
Type M-s _ to toggle symbol mode.
Type M-s ' to toggle character folding.

Type M-s SPC to toggle whitespace matching.
In incremental searches, a space or spaces normally matches any whitespace
defined by the variable ‘search-whitespace-regexp’; see also the variables
‘isearch-lax-whitespace’ and ‘isearch-regexp-lax-whitespace’.

Type M-s e to edit the search string in the minibuffer.

Also supported is a search ring of the previous 16 search strings.
Type M-n to search for the next item in the search ring.
Type M-p to search for the previous item in the search ring.
Type C-M-i to complete the search string using the search ring.

Type M-% to run ‘query-replace’ with string to replace from last search string.
Type C-M-% to run ‘query-replace-regexp’ with the last search string.
Type M-s o to run ‘occur’ that shows the last search string.
Type M-s h r to run ‘highlight-regexp’ that highlights the last search string.

Type C-h b to display all Isearch key bindings.
Type C-h k to display documentation of Isearch key.
Type C-h m to display documentation of Isearch mode.

If an input method is turned on in the current buffer, that input
method is also active while you are typing characters to search.
To toggle the input method, type C-\.  It also toggles the input
method in the current buffer.

To use a different input method for searching, type C-^,
and specify an input method you want to use.

The above keys, bound in ‘isearch-mode-map’, are often controlled by
 options; do M-x apropos on search-.* to find them.
Other control and meta characters terminate the search
 and are then executed normally (depending on ‘search-exit-option’).
Likewise for function keys and mouse button events.

If this function is called non-interactively with a nil NO-RECURSIVE-EDIT,
it does not return to the calling function until the search is done.
See the function ‘isearch-mode’ for more information.

(fn &optional REGEXP-P NO-RECURSIVE-EDIT)〉〉enditem49840〈〈isearch-highlight-regexp〉〉:〈〈Run ‘highlight-regexp’ with regexp from the current search string.
It exits Isearch mode and calls ‘hi-lock-face-buffer’ with its regexp
argument from the last search regexp or a quoted search string,
and reads its face argument using ‘hi-lock-read-face-name’.〉〉enditem49840〈〈isearch-occur〉〉:〈〈Run ‘occur’ using the last search string as the regexp.
Interactively, REGEXP is constructed using the search string from the
last search command.  NLINES has the same meaning as in ‘occur’.

If the last search command was a word search, REGEXP is computed from
the search words, ignoring punctuation.  If the last search
command was a regular expression search, REGEXP is the regular
expression used in that search.  If the last search command searched
for a literal string, REGEXP is constructed by quoting all the special
characters in that string.

(fn REGEXP &optional NLINES)〉〉enditem49840〈〈isearch-toggle-case-fold〉〉:〈〈Toggle case-fold searching on or off.
Toggles the value of the variable ‘isearch-case-fold-search’.〉〉enditem49840〈〈isearch-toggle-char-fold〉〉:〈〈Toggle char-fold searching on or off.
Turning on character-folding turns off regexp mode.〉〉enditem49840〈〈isearch-toggle-input-method〉〉:〈〈Toggle input method in interactive search.

(fn)〉〉enditem49840〈〈isearch-toggle-invisible〉〉:〈〈Toggle invisible searching on or off.
This determines whether to search inside invisible text or not.
Toggles the variable ‘isearch-invisible’ between values
nil and a non-nil value of the option ‘search-invisible’
(or ‘open’ if ‘search-invisible’ is nil).〉〉enditem49840〈〈isearch-toggle-lax-whitespace〉〉:〈〈Toggle lax-whitespace searching on or off.
In ordinary search, toggles the value of the variable
‘isearch-lax-whitespace’.  In regexp search, toggles the
value of the variable ‘isearch-regexp-lax-whitespace’.〉〉enditem49840〈〈isearch-toggle-regexp〉〉:〈〈Toggle regexp searching on or off.〉〉enditem49840〈〈isearch-toggle-specified-input-method〉〉:〈〈Select an input method and turn it on in interactive search.

(fn)〉〉enditem49840〈〈isearch-toggle-symbol〉〉:〈〈Toggle symbol searching on or off.
Turning on symbol search turns off regexp mode.〉〉enditem49840〈〈isearch-toggle-word〉〉:〈〈Toggle word searching on or off.
Turning on word search turns off regexp mode.〉〉enditem49840〈〈isearch-yank-char〉〉:〈〈Pull next character from buffer into search string.
If optional ARG is non-nil, pull in the next ARG characters.

(fn &optional ARG)〉〉enditem49840〈〈isearch-yank-kill〉〉:〈〈Pull string from kill ring into search string.〉〉enditem49840〈〈isearch-yank-line〉〉:〈〈Pull rest of line from buffer into search string.
If optional ARG is non-nil, yank the next ARG lines.

(fn &optional ARG)〉〉enditem49840〈〈isearch-yank-pop〉〉:〈〈Replace just-yanked search string with previously killed string.〉〉enditem49840〈〈isearch-yank-word-or-char〉〉:〈〈Pull next character, subword or word from buffer into search string.
Subword is used when ‘subword-mode’ is activated. 〉〉enditem49840〈〈isearch-yank-x-selection〉〉:〈〈Pull current X selection into search string.〉〉enditem49840〈〈iso-gtex2iso〉〉:〈〈Translate German TeX sequences to ISO 8859-1 characters.
Translate the region between FROM and TO using the table
‘iso-gtex2iso-trans-tab’.
Optional arg BUFFER is ignored (for use in ‘format-alist’).

(fn FROM TO &optional BUFFER)〉〉enditem49840〈〈iso-iso2gtex〉〉:〈〈Translate ISO 8859-1 characters to German TeX sequences.
Translate the region between FROM and TO using the table
‘iso-iso2gtex-trans-tab’.
Optional arg BUFFER is ignored (for use in ‘format-alist’).

(fn FROM TO &optional BUFFER)〉〉enditem49840〈〈iso-iso2tex〉〉:〈〈Translate ISO 8859-1 characters to TeX sequences.
Translate the region between FROM and TO using the table
‘iso-iso2tex-trans-tab’.
Optional arg BUFFER is ignored (for use in ‘format-alist’).

(fn FROM TO &optional BUFFER)〉〉enditem49840〈〈iso-tex2iso〉〉:〈〈Translate TeX sequences to ISO 8859-1 characters.
Translate the region between FROM and TO using the table
‘iso-tex2iso-trans-tab’.
Optional arg BUFFER is ignored (for use in ‘format-alist’).

(fn FROM TO &optional BUFFER)〉〉enditem49840〈〈ispell-buffer〉〉:〈〈Check the current buffer for spelling errors interactively.

(fn)〉〉enditem49840〈〈ispell-change-dictionary〉〉:〈〈Change to dictionary DICT for Ispell.
With a prefix arg, set it "globally", for all buffers.
Without a prefix arg, set it "locally", just for this buffer.

By just answering RET you can find out what the current dictionary is.

(fn DICT &optional ARG)〉〉enditem49840〈〈ispell-complete-word〉〉:〈〈Try to complete the word before or at point.
If optional INTERIOR-FRAG is non-nil, then the word may be a character
sequence inside of a word.

Standard ispell choices are then available.

(fn &optional INTERIOR-FRAG)〉〉enditem49840〈〈ispell-kill-ispell〉〉:〈〈Kill current Ispell process (so that you may start a fresh one).
With NO-ERROR, just return non-nil if there was no Ispell running.
With CLEAR, buffer session localwords are cleaned.

(fn &optional NO-ERROR CLEAR)〉〉enditem49840〈〈ispell-message〉〉:〈〈Check the spelling of a mail message or news post.
Don’t check spelling of message headers except the Subject field.
Don’t check included messages.

To abort spell checking of a message region and send the message anyway,
use the ‘x’ command.  (Any subsequent regions will be checked.)
The ‘X’ command aborts sending the message so that you can edit the buffer.

To spell-check whenever a message is sent, include the appropriate lines
in your init file:
   (add-hook 'message-send-hook #'ispell-message)  ;; GNUS 5
   (add-hook 'news-inews-hook #'ispell-message)    ;; GNUS 4
   (add-hook 'mail-send-hook  #'ispell-message)
   (add-hook 'mh-before-send-letter-hook #'ispell-message)

You can bind this to the key C-c i in GNUS or mail by adding to
‘news-reply-mode-hook’ or ‘mail-mode-hook’ the following lambda expression:
   (function (lambda () (local-set-key "\C-ci" 'ispell-message)))

(fn)〉〉enditem49840〈〈ispell-region〉〉:〈〈Interactively check a region for spelling errors.
Return nil if spell session was terminated, otherwise returns shift offset
amount for last line processed.

(fn REG-START REG-END &optional RECHECKP SHIFT)〉〉enditem49840〈〈ispell-word〉〉:〈〈Check spelling of word under or before the cursor.
If the word is not found in dictionary, display possible corrections
in a window allowing you to choose one.

If optional argument FOLLOWING is non-nil or if ‘ispell-following-word’
is non-nil when called interactively, then the following word
(rather than preceding) is checked when the cursor is not over a word.
When the optional argument QUIETLY is non-nil or ‘ispell-quietly’ is non-nil
when called interactively, non-corrective messages are suppressed.

With a prefix argument (or if CONTINUE is non-nil),
resume interrupted spell-checking of a buffer or region.

Interactively, in Transient Mark mode when the mark is active, call
‘ispell-region’ to check the active region for spelling errors.

Word syntax is controlled by the definition of the chosen dictionary,
which is in ‘ispell-local-dictionary-alist’ or ‘ispell-dictionary-alist’.

This will check or reload the dictionary.  Use M-x ispell-change-dictionary
or M-x ispell-region to update the Ispell process.

Return values:
nil           word is correct or spelling is accepted.
0             word is inserted into buffer-local definitions.
"word"        word corrected from word list.
("word" arg)  word is hand entered.
quit          spell session exited.

(fn &optional FOLLOWING QUIETLY CONTINUE REGION)〉〉enditem49840〈〈ispell〉〉:〈〈Interactively check a region or buffer for spelling errors.
If ‘transient-mark-mode’ is on, and a region is active, spell-check
that region.  Otherwise spell-check the buffer.

Ispell dictionaries are not distributed with Emacs.  If you are
looking for a dictionary, please see the distribution of the GNU ispell
program, or do an Internet search; there are various dictionaries
available on the net.

(fn)〉〉enditem49840〈〈jdb〉〉:〈〈Run jdb with command line COMMAND-LINE in a buffer.
The buffer is named "*gud*" if no initial class is given or
"*gud-<initial-class-basename>*" if there is.  If the "-classpath"
switch is given, omit all whitespace between it and its value.

See ‘gud-jdb-use-classpath’ and ‘gud-jdb-classpath’ documentation for
information on how jdb accesses source files.  Alternatively (if
‘gud-jdb-use-classpath’ is nil), see ‘gud-jdb-directories’ for the
original source file access method.

For general information about commands available to control jdb from
gud, see ‘gud-mode’.

(fn COMMAND-LINE)〉〉enditem49840〈〈jump-to-register〉〉:〈〈Move point to location stored in a register.
If the register contains a file name, find that file.
(To put a file name in a register, you must use ‘set-register’.)
If the register contains a window configuration (one frame) or a frameset
(all frames), restore that frame or all frames accordingly.
First argument is a character, naming the register.
Optional second arg non-nil (interactively, prefix argument) says to
delete any existing frames that the frameset doesn’t mention.
(Otherwise, these frames are iconified.)

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER &optional DELETE)〉〉enditem49840〈〈kbd-macro-query〉〉:〈〈Query user during kbd macro execution.
  With prefix argument, enters recursive edit, reading keyboard
commands even within a kbd macro.  You can give different commands
each time the macro executes.
  Without prefix argument, asks whether to continue running the macro.
Your options are: 
Y	Finish this iteration normally and continue with the next.
N	Skip the rest of this iteration, and start the next.
RET	Stop the macro entirely right now.
C-l	Redisplay the screen, then ask again.
C-r	Enter recursive edit; ask again when you exit from that.

(fn FLAG)〉〉enditem49840〈〈keep-lines〉〉:〈〈Delete all lines except those containing matches for REGEXP.
A match split across lines preserves all the lines it lies in.
When called from Lisp (and usually interactively as well, see below)
applies to all lines starting after point.

If REGEXP contains upper case characters (excluding those preceded by ‘\’)
and ‘search-upper-case’ is non-nil, the matching is case-sensitive.

Second and third arg RSTART and REND specify the region to operate on.
This command operates on (the accessible part of) all lines whose
accessible part is entirely contained in the region determined by RSTART
and REND.  (A newline ending a line counts as part of that line.)

Interactively, in Transient Mark mode when the mark is active, operate
on all lines whose accessible part is entirely contained in the region.
Otherwise, the command applies to all lines starting after point.
When calling this function from Lisp, you can pretend that it was
called interactively by passing a non-nil INTERACTIVE argument.

This function starts looking for the next match from the end of
the previous match.  Hence, it ignores matches that overlap
a previously found match.

(fn REGEXP &optional RSTART REND INTERACTIVE)〉〉enditem49840〈〈keyboard-escape-quit〉〉:〈〈Exit the current "mode" (in a generalized sense of the word).
This command can exit an interactive command such as ‘query-replace’,
can clear out a prefix argument or a region,
can get out of the minibuffer or other recursive edit,
cancel the use of the current buffer (for special-purpose buffers),
or go back to just one window (by deleting all but the selected window).〉〉enditem49840〈〈keypad-setup〉〉:〈〈Set keypad bindings in ‘function-key-map’ according to SETUP.
If optional second argument NUMLOCK is non-nil, the NumLock On bindings
are changed.  Otherwise, the NumLock Off bindings are changed.
If optional third argument SHIFT is non-nil, the shifted keypad
keys are bound.

 Setup      Binding
 -------------------------------------------------------------
 ‘prefix’   Command prefix argument, i.e.  M-0 .. M-9 and M--
 ‘S-cursor’ Bind shifted keypad keys to the shifted cursor movement keys.
 ‘cursor’   Bind keypad keys to the cursor movement keys.
 ‘numeric’  Plain numeric keypad, i.e. 0 .. 9 and .  (or DECIMAL arg)
 ‘none’     Removes all bindings for keypad keys in function-key-map;
            this enables any user-defined bindings for the keypad keys
            in the global and local keymaps.

If SETUP is ‘numeric’ and the optional fourth argument DECIMAL is non-nil,
the decimal key on the keypad is mapped to DECIMAL instead of ‘.’

(fn SETUP &optional NUMLOCK SHIFT DECIMAL)〉〉enditem49840〈〈kill-all-abbrevs〉〉:〈〈Undefine all defined abbrevs.〉〉enditem49840〈〈kill-buffer-and-window〉〉:〈〈Kill the current buffer and delete the selected window.〉〉enditem49840〈〈kill-line〉〉:〈〈Kill the rest of the current line; if no nonblanks there, kill thru newline.
With prefix argument ARG, kill that many lines from point.
Negative arguments kill lines backward.
With zero argument, kills the text before point on the current line.

When calling from a program, nil means "no arg",
a number counts as a prefix arg.

To kill a whole line, when point is not at the beginning, type M-x move-beginning-of-line DEL i DEL i.

If ‘show-trailing-whitespace’ is non-nil, this command will just
kill the rest of the current line, even if there are no nonblanks
there.

If option ‘kill-whole-line’ is non-nil, then this command kills the whole line
including its terminating newline, when used at the beginning of a line
with no argument.  As a consequence, you can always kill a whole line
by typing M-x move-beginning-of-line DEL i.

If you want to append the killed line to the last killed text,
use C-M-w before DEL i.

If the buffer is read-only, Emacs will beep and refrain from deleting
the line, but put the line in the kill ring anyway.  This means that
you can use this command to copy text from a read-only buffer.
(If the variable ‘kill-read-only-ok’ is non-nil, then this won’t
even beep.)

(fn &optional ARG)〉〉enditem49840〈〈kill-matching-buffers〉〉:〈〈Kill buffers whose name matches the specified REGEXP.
Ignores buffers whose name starts with a space, unless optional
prefix argument INTERNAL-TOO is non-nil.  Asks before killing
each buffer, unless NO-ASK is non-nil.

(fn REGEXP &optional INTERNAL-TOO NO-ASK)〉〉enditem49840〈〈kill-rectangle〉〉:〈〈Delete the region-rectangle and save it as the last killed one.

When called from a program the rectangle’s corners are START and END.
You might prefer to use ‘delete-extract-rectangle’ from a program.

With a prefix (or a FILL) argument, also fill lines where nothing has to be
deleted.

If the buffer is read-only, Emacs will beep and refrain from deleting
the rectangle, but put it in ‘killed-rectangle’ anyway.  This means that
you can use this command to copy text from a read-only buffer.
(If the variable ‘kill-read-only-ok’ is non-nil, then this won’t
even beep.)

(fn START END &optional FILL)〉〉enditem49840〈〈kill-ring-save〉〉:〈〈Save the region as if killed, but don’t kill it.
In Transient Mark mode, deactivate the mark.
If ‘interprogram-cut-function’ is non-nil, also save the text for a window
system cut and paste.

If you want to append the killed line to the last killed text,
use C-M-w before M-w.

The copied text is filtered by ‘filter-buffer-substring’ before it is
saved in the kill ring, so the actual saved text might be different
from what was in the buffer.

When called from Lisp, save in the kill ring the stretch of text
between BEG and END, unless the optional argument REGION is
non-nil, in which case ignore BEG and END, and save the current
region instead.

This command is similar to ‘copy-region-as-kill’, except that it gives
visual feedback indicating the extent of the region being copied.

(fn BEG END &optional REGION)〉〉enditem49840〈〈kill-sentence〉〉:〈〈Kill from point to end of sentence.
With arg, repeat; negative arg -N means kill back to Nth start of sentence.〉〉enditem49840〈〈kill-sexp〉〉:〈〈Kill the sexp (balanced expression) following point.
With ARG, kill that many sexps after point.
Negative arg -N means kill N sexps before point.
This command assumes point is not in a string or comment.

(fn &optional ARG)〉〉enditem49840〈〈kill-some-buffers〉〉:〈〈Kill some buffers.  Asks the user whether to kill each one of them.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one.

(fn &optional LIST)〉〉enditem49840〈〈kill-visual-line〉〉:〈〈Kill the rest of the visual line.
With prefix argument ARG, kill that many visual lines from point.
If ARG is negative, kill visual lines backward.
If ARG is zero, kill the text before point on the current visual
line.

If you want to append the killed line to the last killed text,
use C-M-w before DEL i.

If the buffer is read-only, Emacs will beep and refrain from deleting
the line, but put the line in the kill ring anyway.  This means that
you can use this command to copy text from a read-only buffer.
(If the variable ‘kill-read-only-ok’ is non-nil, then this won’t
even beep.)

(fn &optional ARG)〉〉enditem49840〈〈kill-whole-line〉〉:〈〈Kill current line.
With prefix ARG, kill that many lines starting from the current line.
If ARG is negative, kill backward.  Also kill the preceding newline.
(This is meant to make DEL t t work well with negative arguments.)
If ARG is zero, kill current line but exclude the trailing newline.

(fn &optional ARG)〉〉enditem49840〈〈kill-word〉〉:〈〈Kill characters forward until encountering the end of a word.
With argument ARG, do this that many times.

(fn ARG)〉〉enditem49840〈〈kmacro-add-counter〉〉:〈〈Add the value of numeric prefix arg (prompt if missing) to ‘kmacro-counter’.
With C-u, restore previous counter value.

(fn ARG)〉〉enditem49840〈〈kmacro-bind-to-key〉〉:〈〈When not defining or executing a macro, offer to bind last macro to a key.
The key sequences [C-x C-k 0] through [C-x C-k 9] and [C-x C-k A]
through [C-x C-k Z] are reserved for user bindings, and to bind to
one of these sequences, just enter the digit or letter, rather than
the whole sequence.

You can bind to any valid key sequence, but if you try to bind to
a key with an existing command binding, you will be asked for
confirmation whether to replace that binding.  Note that the
binding is made in the ‘global-map’ keymap, so the macro binding
may be shaded by a local key binding.
The ARG parameter is unused.

(fn ARG)〉〉enditem49840〈〈kmacro-cycle-ring-next〉〉:〈〈Move to next keyboard macro in keyboard macro ring.
Displays the selected macro in the echo area.
The ARG parameter is unused.

(fn &optional ARG)〉〉enditem49840〈〈kmacro-cycle-ring-previous〉〉:〈〈Move to previous keyboard macro in keyboard macro ring.
Displays the selected macro in the echo area.
The ARG parameter is unused.

(fn &optional ARG)〉〉enditem49840〈〈kmacro-edit-lossage〉〉:〈〈Edit most recent 300 keystrokes as a keyboard macro.〉〉enditem49840〈〈kmacro-edit-macro〉〉:〈〈As edit last keyboard macro, but without kmacro-repeat property.

(fn &optional ARG)〉〉enditem49840〈〈kmacro-end-and-call-macro〉〉:〈〈Call last keyboard macro, ending it first if currently being defined.
With numeric prefix ARG, repeat macro that many times.
Zero argument means repeat until there is an error.

To give a macro a name, so you can call it even after defining other
macros, use C-x C-k n.

(fn ARG &optional NO-REPEAT)〉〉enditem49840〈〈kmacro-end-macro〉〉:〈〈Finish defining a keyboard macro.
The definition was started by DEL r ..
The macro is now available for use via M-x kmacro-call-macro,
or it can be given a name with C-x C-k n and then invoked
under that name.

With numeric arg, repeat macro now that many times,
counting the definition just completed as the first repetition.
An argument of zero means repeat until error.

(fn ARG)〉〉enditem49840〈〈kmacro-end-or-call-macro-repeat〉〉:〈〈As ‘kmacro-end-or-call-macro’ but allows repeat without repeating prefix.

(fn ARG)〉〉enditem49840〈〈kmacro-end-or-call-macro〉〉:〈〈End kbd macro if currently being defined; else call last kbd macro.
With numeric prefix ARG, repeat macro that many times.
With C-u, call second macro in macro ring.

(fn ARG &optional NO-REPEAT)〉〉enditem49840〈〈kmacro-insert-counter〉〉:〈〈Insert current value of ‘kmacro-counter’, then increment it by ARG.
Interactively, ARG defaults to 1.  With C-u, insert
current value of ‘kmacro-counter’, but do not increment it.

(fn ARG)〉〉enditem49840〈〈kmacro-name-last-macro〉〉:〈〈Assign a name to the last keyboard macro defined.
Argument SYMBOL is the name to define.
The symbol’s function definition becomes the keyboard macro string.
Such a "function" cannot be called from Lisp, but it is a valid editor command.

(fn SYMBOL)〉〉enditem49840〈〈kmacro-set-counter〉〉:〈〈Set the value of ‘kmacro-counter’ to ARG, or prompt for value if no argument.
With C-u prefix, reset counter to its value prior to this iteration of the macro.

(fn ARG)〉〉enditem49840〈〈kmacro-set-format〉〉:〈〈Set the format of ‘kmacro-counter’ to FORMAT.

(fn FORMAT)〉〉enditem49840〈〈kmacro-start-macro-or-insert-counter〉〉:〈〈Record subsequent keyboard input, defining a keyboard macro.
The commands are recorded even as they are executed.

Initializes the macro’s ‘kmacro-counter’ to ARG (or 0 if no prefix arg)
before defining the macro.

With C-u, appends to current keyboard macro (keeping
the current value of ‘kmacro-counter’).

When used during defining/executing a macro, inserts the current value
of ‘kmacro-counter’ and increments the counter value by ARG (or by 1 if no
prefix argument).  With just C-u, inserts the current value
of ‘kmacro-counter’, but does not modify the counter; this is the
same as incrementing the counter by zero.

The macro counter can be set directly via C-x C-k C-c and C-x C-k C-a.
The format of the inserted value of the counter can be controlled
via C-x C-k C-f.

(fn ARG)〉〉enditem49840〈〈kmacro-start-macro〉〉:〈〈Record subsequent keyboard input, defining a keyboard macro.
The commands are recorded even as they are executed.
Use DEL r p to finish recording and make the macro available.
Use C-x e to execute the macro.

Non-nil arg (prefix arg) means append to last macro defined.

With C-u prefix, append to last keyboard macro
defined.  Depending on ‘kmacro-execute-before-append’, this may begin
by re-executing the last macro as if you typed it again.

Otherwise, it sets ‘kmacro-counter’ to ARG or 0 if missing before
defining the macro.

Use C-x C-k TAB to insert (and increment) the macro counter.
The counter value can be set or modified via C-x C-k C-c and C-x C-k C-a.
The format of the counter can be modified via C-x C-k C-f.

Use C-x C-k n to give it a name that will remain valid even
after another macro is defined.
Use C-x C-k b to bind it to a key sequence.

(fn ARG)〉〉enditem49840〈〈kmacro-step-edit-macro〉〉:〈〈Step edit and execute last keyboard macro.

To customize possible responses, change the "bindings" in ‘kmacro-step-edit-map’.〉〉enditem49840〈〈kmacro-to-register〉〉:〈〈Store the last keyboard macro in register R.

Interactively, reads the register using ‘register-read-with-preview’.

(fn R)〉〉enditem49840〈〈latex-mode〉〉:〈〈Major mode for editing files of input for LaTeX.
Makes $ and } display the characters they match.
Makes " insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts " only after a \.

Use M-x tex-region to run LaTeX on the current region, plus the preamble
copied from the top of the file (containing \documentstyle, etc.),
running LaTeX under a special subshell.  M-x tex-buffer does the whole buffer.
M-x tex-file saves the buffer and then processes the file.
M-x tex-print prints the .dvi file made by any of these.
M-x tex-view previews the .dvi file made by any of these.
M-x tex-bibtex-file runs bibtex on the file of the current buffer.

Use M-x tex-validate-buffer to check buffer for paragraphs containing
mismatched $’s or braces.

Special commands:

Uses keymap ‘latex-mode-map’, which is not currently defined.


Mode variables:
latex-run-command
	Command string used by M-x tex-region or M-x tex-buffer.
tex-directory
	Directory in which to create temporary files for LaTeX jobs
	run by M-x tex-region or M-x tex-buffer.
tex-dvi-print-command
	Command string used by M-x tex-print to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by M-x tex-print (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by M-x tex-view to preview a .dvi file.
tex-show-queue-command
	Command string used by M-x tex-show-print-queue to show the print
	queue that M-x tex-print put your job on.

Entering Latex mode runs the hook ‘text-mode-hook’, then
‘tex-mode-hook’, and finally ‘latex-mode-hook’.  When the special
subshell is initiated, ‘tex-shell-hook’ is run.

(fn)〉〉enditem49840〈〈latin1-display〉〉:〈〈Set up Latin-1/ASCII display for the arguments character SETS.
See option ‘latin1-display’ for the method.  The members of the list
must be in ‘latin1-display-sets’.  With no arguments, reset the
display for all of ‘latin1-display-sets’. See also
‘latin1-display-setup’.

(fn &rest SETS)〉〉enditem49840〈〈left-char〉〉:〈〈Move point N characters to the left (to the right if N is negative).
On reaching beginning or end of buffer, stop and signal error.

If ‘visual-order-cursor-movement’ is non-nil, this always moves
to the left on display, wherever that is in the buffer.
Otherwise, depending on the bidirectional context, this may move
one position either backward or forward in the buffer.  This is
in contrast with n and h, which
see.〉〉enditem49840〈〈left-word〉〉:〈〈Move point N words to the left (to the right if N is negative).

Depending on the bidirectional context, this may move either backward
or forward in the buffer.  This is in contrast with g
and r, which see.

Value is normally t.
If an edge of the buffer or a field boundary is reached, point is left there
and the function returns nil.  Field boundaries are not noticed
if ‘inhibit-field-text-motion’ is non-nil.〉〉enditem49840〈〈lgrep〉〉:〈〈Run grep, searching for REGEXP in FILES in directory DIR.
The search is limited to file names matching shell pattern FILES.
FILES may use abbreviations defined in ‘grep-files-aliases’, e.g.
entering ‘ch’ is equivalent to ‘*.[ch]’.  As whitespace triggers
completion when entering a pattern, including it requires
quoting, e.g. ‘C-q<space>’.

With C-u prefix, you can edit the constructed shell command line
before it is executed.
With two C-u prefixes, directly edit and run ‘grep-command’.

Collect output in a buffer.  While grep runs asynchronously, you
can use C-x ` (M-x next-error), or RET in the grep output buffer,
to go to the lines where grep found matches.

This command shares argument histories with M-x rgrep and M-x grep.

(fn REGEXP &optional FILES DIR CONFIRM)〉〉enditem49840〈〈life〉〉:〈〈Run Conway’s Life simulation.
The starting pattern is randomly selected.  Prefix arg (optional first
arg non-nil from a program) is the number of seconds to sleep between
generations (this defaults to 1).

(fn &optional SLEEPTIME)〉〉enditem49840〈〈line-move-visual〉〉:〈〈Move ARG lines forward.
If NOERROR, don’t signal an error if we can’t move that many lines.

(fn ARG &optional NOERROR)〉〉enditem49840〈〈line-number-mode〉〉:〈〈Toggle line number display in the mode line (Line Number mode).
With a prefix argument ARG, enable Line Number mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Line numbers do not appear for very large buffers and buffers
with very long lines; see variables ‘line-number-display-limit’
and ‘line-number-display-limit-width’.

(fn &optional ARG)〉〉enditem49840〈〈linum-mode〉〉:〈〈Toggle display of line numbers in the left margin (Linum mode).
With a prefix argument ARG, enable Linum mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Linum mode is a buffer-local minor mode.

(fn &optional ARG)〉〉enditem49840〈〈lisp-eval-defun〉〉:〈〈nil〉〉enditem49840〈〈lisp-indent-function〉〉:〈〈This function is the normal value of the variable ‘lisp-indent-function’.
The function ‘calculate-lisp-indent’ calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the ‘parse-partial-sexp’ state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property ‘lisp-indent-function’ (or the deprecated ‘lisp-indent-hook’),
it specifies how to indent.  The property value can be:

* ‘defun’, meaning indent ‘defun’-style
  (this is also the case if there is no property and the function
  has a name that begins with "def", and three or more arguments);

* an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

* a function to call that returns the indentation (or nil).
  ‘lisp-indent-function’ calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation.

(fn INDENT-POINT STATE)〉〉enditem49840〈〈lisp-interaction-mode〉〉:〈〈Major mode for typing and evaluating Lisp forms.
Like Lisp mode except that M-x eval-print-last-sexp evals the Lisp expression
before point, and prints its value into the buffer, advancing point.
Note that printing is controlled by ‘eval-expression-print-length’
and ‘eval-expression-print-level’.

Commands:
Delete converts tabs to spaces as it moves back.
Paragraphs are separated only by blank lines.
Semicolons start comments.

key             binding
---             -------

C-j             eval-print-last-sexp
ESC             Prefix Command
DEL             backward-delete-char-untabify

C-M-i           completion-at-point
C-M-q           indent-pp-sexp
C-M-x           eval-defun

C-M-q           indent-sexp
  (that binding is currently shadowed by another mode)

C-M-q           prog-indent-sexp
  (that binding is currently shadowed by another mode)



In addition to any hooks its parent mode ‘emacs-lisp-mode’ might have run,
this mode runs the hook ‘lisp-interaction-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈lisp-mode〉〉:〈〈Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

key             binding
---             -------

C-c             Prefix Command
ESC             Prefix Command
DEL             backward-delete-char-untabify

C-c C-z         run-lisp

C-M-x           lisp-eval-defun

C-M-q           indent-sexp

C-M-q           prog-indent-sexp
  (that binding is currently shadowed by another mode)


Note that ‘run-lisp’ may be used either to start an inferior Lisp job
or to switch back to an existing one.

In addition to any hooks its parent mode ‘prog-mode’ might have run,
this mode runs the hook ‘lisp-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈list-abbrevs〉〉:〈〈Display a list of defined abbrevs.
If LOCAL is non-nil, interactively when invoked with a
prefix arg, display only local, i.e. mode-specific, abbrevs.
Otherwise display all abbrevs.

(fn &optional LOCAL)〉〉enditem49840〈〈list-bookmarks〉〉:〈〈Display a list of existing bookmarks.
The list is displayed in a buffer named ‘*Bookmark List*’.
The leftmost column displays a D if the bookmark is flagged for
deletion, or > if it is flagged for displaying.〉〉enditem49840〈〈list-buffers〉〉:〈〈Display a list of existing buffers.
The list is displayed in a buffer named "*Buffer List*".
See ‘buffer-menu’ for a description of the Buffer Menu.

By default, all buffers are listed except those whose names start
with a space (which are for internal use).  With prefix argument
ARG, show only buffers that are visiting files.

(fn &optional ARG)〉〉enditem49840〈〈list-character-sets〉〉:〈〈Display a list of all character sets.

The D column contains the dimension of this character set.  The CH
column contains the number of characters in a block of this character
set.  The FINAL-BYTE column contains an ISO-2022 <final-byte> to use
in the designation escape sequence for this character set in
ISO-2022-based coding systems.

With prefix ARG, the output format gets more cryptic,
but still shows the full information.

(fn ARG)〉〉enditem49840〈〈list-coding-systems〉〉:〈〈Display a list of all coding systems.
This shows the mnemonic letter, name, and description of each coding system.

With prefix ARG, the output format gets more cryptic,
but still contains full information about each coding system.

(fn &optional ARG)〉〉enditem49840〈〈list-colors-display〉〉:〈〈Display names of defined colors, and show what they look like.
If the optional argument LIST is non-nil, it should be a list of
colors to display.  Otherwise, this command computes a list of
colors that the current display can handle.  Customize
‘list-colors-sort’ to change the order in which colors are shown.
Type ‘g’ or s-u after customizing ‘list-colors-sort’
to redisplay colors in the new order.

If the optional argument BUFFER-NAME is nil, it defaults to *Colors*.

If the optional argument CALLBACK is non-nil, it should be a
function to call each time the user types RET or clicks on a
color.  The function should accept a single argument, the color name.〉〉enditem49840〈〈list-command-history〉〉:〈〈List history of commands that used the minibuffer.
The number of commands listed is controlled by ‘list-command-history-max’.
Calls value of ‘list-command-history-filter’ (if non-nil) on each history
element to judge if that element should be excluded from the list.

The buffer is left in Command History mode.

(fn)〉〉enditem49840〈〈list-directory〉〉:〈〈Display a list of files in or matching DIRNAME, a la ‘ls’.
DIRNAME is globbed by the shell if necessary.
Prefix arg (second arg if noninteractive) means supply -l switch to ‘ls’.
Actions controlled by variables ‘list-directory-brief-switches’
and ‘list-directory-verbose-switches’.

(fn DIRNAME &optional VERBOSE)〉〉enditem49840〈〈list-faces-display〉〉:〈〈List all faces, using the same sample text in each.
The sample text is a string that comes from the variable
‘list-faces-sample-text’.

If REGEXP is non-nil, list only those faces with names matching
this regular expression.  When called interactively with a prefix
argument, prompt for a regular expression using ‘read-regexp’.

(fn &optional REGEXP)〉〉enditem49840〈〈list-holidays〉〉:〈〈Display holidays for years Y1 to Y2 (inclusive).
Y2 defaults to Y1.  The optional list of holidays L defaults to
‘calendar-holidays’.  If you want to control what holidays are
displayed, use a different list.  For example,

  (list-holidays 2006 2006
    (append holiday-general-holidays holiday-local-holidays))

will display holidays for the year 2006 defined in the two
mentioned lists, and nothing else.

When called interactively, this command offers a choice of
holidays, based on the variables ‘holiday-solar-holidays’ etc.  See the
documentation of ‘calendar-holidays’ for a list of the variables
that control the choices, as well as a description of the format
of a holiday list.

The optional LABEL is used to label the buffer created.

(fn Y1 &optional Y2 L LABEL)〉〉enditem49840〈〈list-input-methods〉〉:〈〈Display information about all input methods.

(fn)〉〉enditem49840〈〈list-matching-lines〉〉:〈〈Show all lines in the current buffer containing a match for REGEXP.
If a match spreads across multiple lines, all those lines are shown.

Each match is extended to include complete lines.  Only non-overlapping
matches are considered.  (Note that extending matches to complete
lines could cause some of the matches to overlap; if so, they will not
be shown as separate matches.)

Each line is displayed with NLINES lines before and after, or -NLINES
before if NLINES is negative.
NLINES defaults to ‘list-matching-lines-default-context-lines’.
Interactively it is the prefix arg.

Optional arg REGION, if non-nil, mean restrict search to the
specified region.  Otherwise search the entire buffer.
REGION must be a list of (START . END) positions as returned by
‘region-bounds’.

The lines are shown in a buffer named ‘*Occur*’.
It serves as a menu to find any of the occurrences in this buffer.
C-h m in that buffer will explain how.
If ‘list-matching-lines-jump-to-current-line’ is non-nil, then show
the current line highlighted with ‘list-matching-lines-current-line-face’
and set point at the first match after such line.

If REGEXP contains upper case characters (excluding those preceded by ‘\’)
and ‘search-upper-case’ is non-nil, the matching is case-sensitive.

When NLINES is a string or when the function is called
interactively with prefix argument without a number (‘C-u’ alone
as prefix) the matching strings are collected into the ‘*Occur*’
buffer by using NLINES as a replacement regexp.  NLINES may
contain \& and \N which convention follows ‘replace-match’.
For example, providing "defun\s +\(\S +\)" for REGEXP and
"\1" for NLINES collects all the function names in a lisp
program.  When there is no parenthesized subexpressions in REGEXP
the entire match is collected.  In any case the searched buffer
is not modified.

(fn REGEXP &optional NLINES REGION)〉〉enditem49840〈〈list-packages〉〉:〈〈Display a list of packages.
This first fetches the updated list of packages before
displaying, unless a prefix argument NO-FETCH is specified.
The list is displayed in a buffer named ‘*Packages*’, and
includes the package’s version, availability status, and a
short description.

(fn &optional NO-FETCH)〉〉enditem49840〈〈list-tags〉〉:〈〈Display list of tags in file FILE.
This searches only the first table in the list, and no included tables.
FILE should be as it appeared in the ‘etags’ command, usually without a
directory specification.

(fn FILE &optional NEXT-MATCH)〉〉enditem49840〈〈locate-with-filter〉〉:〈〈Run the executable program ‘locate’ with a filter.
This function is similar to the function ‘locate’, which see.
The difference is that, when invoked interactively, the present function
prompts for both SEARCH-STRING and FILTER.  It passes SEARCH-STRING
to the locate executable program.  It produces a ‘*Locate*’ buffer
that lists only those lines in the output of the locate program that
contain a match for the regular expression FILTER; this is often useful
to constrain a big search.

ARG is the interactive prefix arg, which has the same effect as in ‘locate’.

When called from Lisp, this function is identical with ‘locate’,
except that FILTER is not optional.

(fn SEARCH-STRING FILTER &optional ARG)〉〉enditem49840〈〈locate〉〉:〈〈Run the program ‘locate’, putting results in ‘*Locate*’ buffer.
Pass it SEARCH-STRING as argument.  Interactively, prompt for SEARCH-STRING.
With prefix arg ARG, prompt for the exact shell command to run instead.

This program searches for those file names in a database that match
SEARCH-STRING and normally outputs all matching absolute file names,
one per line.  The database normally consists of all files on your
system, or of all files that you have access to.  Consult the
documentation of the program for the details about how it determines
which file names match SEARCH-STRING.  (Those details vary highly with
the version.)

You can specify another program for this command to run by customizing
the variables ‘locate-command’ or ‘locate-make-command-line’.

The main use of FILTER is to implement ‘locate-with-filter’.  See
the docstring of that function for its meaning.

After preparing the results buffer, this runs ‘dired-mode-hook’ and
then ‘locate-post-command-hook’.

(fn SEARCH-STRING &optional FILTER ARG)〉〉enditem49840〈〈lpr-buffer〉〉:〈〈Print buffer contents without pagination or page headers.
See the variables ‘lpr-switches’ and ‘lpr-command’
for customization of the printer command.

(fn)〉〉enditem49840〈〈lpr-region〉〉:〈〈Print region contents without pagination or page headers.
See the variables ‘lpr-switches’ and ‘lpr-command’
for customization of the printer command.

(fn START END)〉〉enditem49840〈〈lunar-phases〉〉:〈〈Display the quarters of the moon for last month, this month, and next month.
If called with an optional prefix argument ARG, prompts for month and year.
This function is suitable for execution in an init file.

(fn &optional ARG)〉〉enditem49840〈〈mail〉〉:〈〈Edit a message to be sent.  Prefix arg means resume editing (don’t erase).
When this function returns, the buffer ‘*mail*’ is selected.
The value is t if the message was newly initialized; otherwise, nil.

Optionally, the signature file ‘mail-signature-file’ can be inserted at the
end; see the variable ‘mail-signature’.


Uses keymap ‘mail-mode-map’, which is not currently defined.

While editing message, type M-x mail-send-and-exit to send the message and exit.

Various special commands starting with C-c are available in sendmail mode
to move to message header fields:

Uses keymap ‘mail-mode-map’, which is not currently defined.


If ‘mail-self-blind’ is non-nil, a BCC to yourself is inserted
when the message is initialized.

If ‘mail-default-reply-to’ is non-nil, it should be an address (a string);
a Reply-to: field with that address is inserted.

If ‘mail-archive-file-name’ is non-nil, an FCC field with that file name
is inserted.

The normal hook ‘mail-setup-hook’ is run after the message is
initialized.  It can add more default fields to the message.

The first argument, NOERASE, determines what to do when there is
an existing modified ‘*mail*’ buffer.  If NOERASE is nil, the
existing mail buffer is used, and the user is prompted whether to
keep the old contents or to erase them.  If NOERASE has the value
‘new’, a new mail buffer will be created instead of using the old
one.  Any other non-nil value means to always select the old
buffer without erasing the contents.

The second through fifth arguments,
 TO, SUBJECT, IN-REPLY-TO and CC, specify if non-nil
 the initial contents of those header fields.
 These arguments should not have final newlines.
The sixth argument REPLYBUFFER is a buffer which contains an
 original message being replied to, or else an action
 of the form (FUNCTION . ARGS) which says how to insert the original.
 Or it can be nil, if not replying to anything.
The seventh argument ACTIONS is a list of actions to take
 if/when the message is sent.  Each action looks like (FUNCTION . ARGS);
 when the message is sent, we apply FUNCTION to ARGS.
 This is how Rmail arranges to mark messages ‘answered’.

(fn &optional NOERASE TO SUBJECT IN-REPLY-TO CC REPLYBUFFER ACTIONS RETURN-ACTION)〉〉enditem49840〈〈mailclient-send-it〉〉:〈〈nil〉〉enditem49840〈〈make-frame-command〉〉:〈〈Make a new frame, on the same terminal as the selected frame.
If the terminal is a text-only terminal, this also selects the
new frame.〉〉enditem49840〈〈man〉〉:〈〈Get a Un*x manual page and put it in a buffer.
This command is the top-level command in the man package.
It runs a Un*x command to retrieve and clean a manpage in the
background and places the results in a ‘Man-mode’ browsing
buffer.  The variable ‘Man-width’ defines the number of columns in
formatted manual pages.  The buffer is displayed immediately.
The variable ‘Man-notify-method’ defines how the buffer is displayed.
If a buffer already exists for this man page, it will be displayed
without running the man command.

For a manpage from a particular section, use either of the
following.  "cat(1)" is how cross-references appear and is
passed to man as "1 cat".

    cat(1)
    1 cat

To see manpages from all sections related to a subject, use an
"all pages" option (which might be "-a" if it’s not the
default), then step through with ‘Man-next-manpage’ (
Uses keymap ‘Man-mode-map’, which is not currently defined.
M-x Man-next-manpage) etc.
Add to ‘Man-switches’ to make this option permanent.

    -a chmod

An explicit filename can be given too.  Use -l if it might
otherwise look like a page name.

    /my/file/name.1.gz
    -l somefile.1

An "apropos" query with -k gives a buffer of matching page
names or descriptions.  The pattern argument is usually an
"grep -E" style regexp.

    -k pattern

(fn MAN-ARGS)〉〉enditem49840〈〈manual-entry〉〉:〈〈Get a Un*x manual page and put it in a buffer.
This command is the top-level command in the man package.
It runs a Un*x command to retrieve and clean a manpage in the
background and places the results in a ‘Man-mode’ browsing
buffer.  The variable ‘Man-width’ defines the number of columns in
formatted manual pages.  The buffer is displayed immediately.
The variable ‘Man-notify-method’ defines how the buffer is displayed.
If a buffer already exists for this man page, it will be displayed
without running the man command.

For a manpage from a particular section, use either of the
following.  "cat(1)" is how cross-references appear and is
passed to man as "1 cat".

    cat(1)
    1 cat

To see manpages from all sections related to a subject, use an
"all pages" option (which might be "-a" if it’s not the
default), then step through with ‘Man-next-manpage’ (
Uses keymap ‘Man-mode-map’, which is not currently defined.
M-x Man-next-manpage) etc.
Add to ‘Man-switches’ to make this option permanent.

    -a chmod

An explicit filename can be given too.  Use -l if it might
otherwise look like a page name.

    /my/file/name.1.gz
    -l somefile.1

An "apropos" query with -k gives a buffer of matching page
names or descriptions.  The pattern argument is usually an
"grep -E" style regexp.

    -k pattern

(fn MAN-ARGS)〉〉enditem49840〈〈mark-defun〉〉:〈〈Put mark at end of this defun, point at beginning.
The defun marked is the one that contains point or follows point.
With positive ARG, mark this and that many next defuns; with negative
ARG, change the direction of marking.

If the mark is active, it marks the next or previous defun(s) after
the one(s) already marked.

(fn &optional ARG)〉〉enditem49840〈〈mark-page〉〉:〈〈Put mark at end of page, point at beginning.
A numeric arg specifies to move forward or backward by that many pages,
thus marking a page other than the one point was originally in.〉〉enditem49840〈〈mark-paragraph〉〉:〈〈Put point at beginning of this paragraph, mark at end.
The paragraph marked is the one that contains point or follows point.

With argument ARG, puts mark at end of a following paragraph, so that
the number of paragraphs marked equals ARG.

If ARG is negative, point is put at end of this paragraph, mark is put
at beginning of this or a previous paragraph.

Interactively (or if ALLOW-EXTEND is non-nil), if this command is
repeated or (in Transient Mark mode) if the mark is active,
it marks the next ARG paragraphs after the ones already marked.〉〉enditem49840〈〈mark-sexp〉〉:〈〈Set mark ARG sexps from point.
The place mark goes is the same place C-M-f would
move to with the same argument.
Interactively, if this command is repeated
or (in Transient Mark mode) if the mark is active,
it marks the next ARG sexps after the ones already marked.
This command assumes point is not in a string or comment.

(fn &optional ARG ALLOW-EXTEND)〉〉enditem49840〈〈mark-whole-buffer〉〉:〈〈Put point at beginning and mark at end of buffer.
If narrowing is in effect, only uses the accessible part of the buffer.
You probably should not use this function in Lisp programs;
it is usually a mistake for a Lisp function to use any subroutine
that uses or sets the mark.〉〉enditem49840〈〈mark-word〉〉:〈〈Set mark ARG words away from point.
The place mark goes is the same place r would
move to with the same argument.
Interactively, if this command is repeated
or (in Transient Mark mode) if the mark is active,
it marks the next ARG words after the ones already marked.

(fn &optional ARG ALLOW-EXTEND)〉〉enditem49840〈〈menu-bar-mode〉〉:〈〈Toggle display of a menu bar on each frame (Menu Bar mode).
With a prefix argument ARG, enable Menu Bar mode if ARG is
positive, and disable it otherwise.  If called from Lisp, also
enable Menu Bar mode if ARG is omitted or nil.

This command applies to all frames that exist and frames to be
created in the future.〉〉enditem49840〈〈menu-bar-open〉〉:〈〈Start key navigation of the menu bar in FRAME.

This function decides which method to use to access the menu
depending on FRAME’s terminal device.  On X displays, it calls
‘x-menu-bar-open’; on Windows, ‘w32-menu-bar-open’; otherwise it
calls either ‘popup-menu’ or ‘tmm-menubar’ depending on whether
‘tty-menu-open-use-tmm’ is nil or not.

If FRAME is nil or not given, use the selected frame.〉〉enditem49840〈〈merge〉〉:〈〈Destructively merge the two sequences to produce a new sequence.
TYPE is the sequence type to return, SEQ1 and SEQ2 are the two argument
sequences, and PREDICATE is a ‘less-than’ predicate on the elements.

Keywords supported:  :key

(fn TYPE SEQ1 SEQ2 PREDICATE [KEYWORD VALUE]...)〉〉enditem49840〈〈message-send-and-exit〉〉:〈〈Send message like ‘message-send’, then, if no errors, exit from mail buffer.
The usage of ARG is defined by the instance that called Message.
It should typically alter the sending method in some way or other.

(fn &optional ARG)〉〉enditem49840〈〈message-yank-original〉〉:〈〈Insert the message being replied to, if any.
Puts point before the text and mark after.
Normally indents each nonblank line ARG spaces (default 3).  However,
if ‘message-yank-prefix’ is non-nil, insert that prefix on each line.

This function uses ‘message-cite-function’ to do the actual citing.

Just C-u as argument means don’t indent, insert no
prefix, and don’t delete any headers.

(fn &optional ARG)〉〉enditem49840〈〈midnight-mode〉〉:〈〈Non-nil means run ‘midnight-hook’ at midnight.

(fn &optional ARG)〉〉enditem49840〈〈minibuffer-electric-default-mode〉〉:〈〈Toggle Minibuffer Electric Default mode.
With a prefix argument ARG, enable Minibuffer Electric Default
mode if ARG is positive, and disable it otherwise.  If called
from Lisp, enable the mode if ARG is omitted or nil.

Minibuffer Electric Default mode is a global minor mode.  When
enabled, minibuffer prompts that show a default value only show
the default when it’s applicable -- that is, when hitting RET
would yield the default value.  If the user modifies the input
such that hitting RET would enter a non-default value, the prompt
is modified to remove the default indication.

(fn &optional ARG)〉〉enditem49840〈〈mml-attach-file〉〉:〈〈Attach a file to the outgoing MIME message.
The file is not inserted or encoded until you send the message with
‘M-x message-send-and-exit’ or ‘M-x message-send’ in Message mode,
or ‘M-x mail-send-and-exit’ or ‘M-x mail-send’ in Mail mode.

FILE is the name of the file to attach.  TYPE is its
content-type, a string of the form "type/subtype".  DESCRIPTION
is a one-line description of the attachment.  The DISPOSITION
specifies how the attachment is intended to be displayed.  It can
be either "inline" (displayed automatically within the message
body) or "attachment" (separate from the body).

If given a prefix interactively, no prompting will be done for
the TYPE, DESCRIPTION or DISPOSITION values.  Instead defaults
will be computed and used.〉〉enditem49840〈〈modify-coding-system-alist〉〉:〈〈Modify one of look up tables for finding a coding system on I/O operation.
There are three of such tables, ‘file-coding-system-alist’,
‘process-coding-system-alist’, and ‘network-coding-system-alist’.

TARGET-TYPE specifies which of them to modify.
If it is ‘file’, it affects ‘file-coding-system-alist’ (which see).
If it is ‘process’, it affects ‘process-coding-system-alist’ (which see).
If it is ‘network’, it affects ‘network-coding-system-alist’ (which see).

REGEXP is a regular expression matching a target of I/O operation.
The target is a file name if TARGET-TYPE is ‘file’, a program name if
TARGET-TYPE is ‘process’, or a network service name or a port number
to connect to if TARGET-TYPE is ‘network’.

CODING-SYSTEM is a coding system to perform code conversion on the I/O
operation, or a cons cell (DECODING . ENCODING) specifying the coding
systems for decoding and encoding respectively, or a function symbol
which, when called, returns such a cons cell.〉〉enditem49840〈〈morse-region〉〉:〈〈Convert all text in a given region to morse code.

(fn BEG END)〉〉enditem49840〈〈mouse-avoidance-mode〉〉:〈〈Set Mouse Avoidance mode to MODE.
MODE should be one of the symbols ‘banish’, ‘exile’, ‘jump’, ‘animate’,
‘cat-and-mouse’, ‘proteus’, or ‘none’.

If MODE is nil, toggle mouse avoidance between ‘none’ and ‘banish’
modes.  Positive numbers and symbols other than the above are treated
as equivalent to ‘banish’; negative numbers and ‘-’ are equivalent to ‘none’.

Effects of the different modes:
 * banish: Move the mouse to the upper-right corner on any keypress.
 * exile: Move the mouse to the corner only if the cursor gets too close,
     and allow it to return once the cursor is out of the way.
 * jump: If the cursor gets too close to the mouse, displace the mouse
     a random distance & direction.
 * animate: As ‘jump’, but shows steps along the way for illusion of motion.
 * cat-and-mouse: Same as ‘animate’.
 * proteus: As ‘animate’, but changes the shape of the mouse pointer too.

(See ‘mouse-avoidance-threshold’ for definition of "too close",
and ‘mouse-avoidance-nudge-dist’ and ‘mouse-avoidance-nudge-var’ for
definition of "random distance".)

(fn &optional MODE)〉〉enditem49840〈〈mouse-buffer-menu〉〉:〈〈Pop up a menu of buffers for selection with the mouse.
This switches buffers in the window that you clicked on,
and selects that window.

(fn EVENT)〉〉enditem49840〈〈mouse-choose-completion〉〉:〈〈Choose the completion at point.
If EVENT, use EVENT’s position to determine the starting position.

(fn &optional EVENT)〉〉enditem49840〈〈mouse-save-then-kill〉〉:〈〈Set the region according to CLICK; the second time, kill it.
CLICK should be a mouse click event.

If the region is inactive, activate it temporarily.  Set mark at
the original point, and move point to the position of CLICK.

If the region is already active, adjust it.  Normally, do this by
moving point or mark, whichever is closer, to CLICK.  But if you
have selected whole words or lines, move point or mark to the
word or line boundary closest to CLICK instead.

If ‘mouse-drag-copy-region’ is non-nil, this command also saves the
new region to the kill ring (replacing the previous kill if the
previous region was just saved to the kill ring).

If this command is called a second consecutive time with the same
CLICK position, kill the region (or delete it
if ‘mouse-drag-copy-region’ is non-nil)

(fn CLICK)〉〉enditem49840〈〈mouse-secondary-save-then-kill〉〉:〈〈Set the secondary selection and save it to the kill ring.
The second time, kill it.  CLICK should be a mouse click event.

If you have not called ‘mouse-start-secondary’ in the clicked
buffer, activate the secondary selection and set it between point
and the click position CLICK.

Otherwise, adjust the bounds of the secondary selection.
Normally, do this by moving its beginning or end, whichever is
closer, to CLICK.  But if you have selected whole words or lines,
adjust to the word or line boundary closest to CLICK instead.

If this command is called a second consecutive time with the same
CLICK position, kill the secondary selection.

(fn CLICK)〉〉enditem49840〈〈mouse-set-point〉〉:〈〈Move point to the position clicked on with the mouse.
This should be bound to a mouse click event type.
If PROMOTE-TO-REGION is non-nil and event is a multiple-click, select
the corresponding element around point, with the resulting position of
point determined by ‘mouse-select-region-move-to-beginning’.

(fn EVENT &optional PROMOTE-TO-REGION)〉〉enditem49840〈〈mouse-set-region〉〉:〈〈Set the region to the text dragged over, and copy to kill ring.
This should be bound to a mouse drag event.
See the ‘mouse-drag-copy-region’ variable to control whether this
command alters the kill ring or not.

(fn CLICK)〉〉enditem49840〈〈mouse-set-secondary〉〉:〈〈Set the secondary selection to the text that the mouse is dragged over.
This must be bound to a mouse drag event.

(fn CLICK)〉〉enditem49840〈〈mouse-start-secondary〉〉:〈〈Set one end of the secondary selection to the position clicked on.
Use <M-mouse-3> to set the other end
and complete the secondary selection.

(fn CLICK)〉〉enditem49840〈〈mouse-wheel-mode〉〉:〈〈Toggle mouse wheel support (Mouse Wheel mode).
With a prefix argument ARG, enable Mouse Wheel mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.〉〉enditem49840〈〈mouse-yank-at-click〉〉:〈〈Insert the last stretch of killed text at the position clicked on.
Also move point to one end of the text thus inserted (normally the end),
and set mark at the beginning.
Prefix arguments are interpreted as with C-v.
If ‘mouse-yank-at-point’ is non-nil, insert at point
regardless of where you click.

(fn CLICK ARG)〉〉enditem49840〈〈mouse-yank-primary〉〉:〈〈Insert the primary selection at the position clicked on.
Move point to the end of the inserted text, and set mark at
beginning.  If ‘mouse-yank-at-point’ is non-nil, insert at point
regardless of where you click.

(fn CLICK)〉〉enditem49840〈〈mouse-yank-secondary〉〉:〈〈Insert the secondary selection at the position clicked on.
Move point to the end of the inserted text.
If ‘mouse-yank-at-point’ is non-nil, insert at point
regardless of where you click.

(fn CLICK)〉〉enditem49840〈〈move-beginning-of-line〉〉:〈〈Move point to beginning of current line as displayed.
(If there’s an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
(But if the buffer doesn’t end in a newline, it stops at the
beginning of the last line.)
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.

(fn ARG)〉〉enditem49840〈〈move-end-of-line〉〉:〈〈Move point to end of current line as displayed.
With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.

To ignore the effects of the ‘intangible’ text or overlay
property, bind ‘inhibit-point-motion-hooks’ to t.
If there is an image in the current line, this function
disregards newlines that are part of the text on which the image
rests.

(fn ARG)〉〉enditem49840〈〈move-to-window-line-top-bottom〉〉:〈〈Position point relative to window.

With a prefix argument ARG, acts like ‘move-to-window-line’.

With no argument, positions point at center of window.
Successive calls position point at positions defined
by ‘recenter-positions’.

(fn &optional ARG)〉〉enditem49840〈〈mpuz〉〉:〈〈Multiplication puzzle with GNU Emacs.

(fn)〉〉enditem49840〈〈msb-mode〉〉:〈〈Toggle Msb mode.
With a prefix argument ARG, enable Msb mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

This mode overrides the binding(s) of ‘mouse-buffer-menu’ to provide a
different buffer menu using the function ‘msb’.

(fn &optional ARG)〉〉enditem49840〈〈multi-isearch-buffers〉〉:〈〈Start multi-buffer Isearch on a list of BUFFERS.
This list can contain live buffers or their names.
Interactively read buffer names to search, one by one, ended with RET.
With a prefix argument, ask for a regexp, and search in buffers
whose names match the specified regexp.〉〉enditem49840〈〈multi-isearch-files〉〉:〈〈Start multi-buffer Isearch on a list of FILES.
Relative file names in this list are expanded to absolute
file names using the current buffer’s value of ‘default-directory’.
Interactively read file names to search, one by one, ended with RET.
With a prefix argument, ask for a wildcard, and search in file buffers
whose file names match the specified wildcard.〉〉enditem49840〈〈multi-occur-in-matching-buffers〉〉:〈〈Show all lines matching REGEXP in buffers specified by BUFREGEXP.
Normally BUFREGEXP matches against each buffer’s visited file name,
but if you specify a prefix argument, it matches against the buffer name.
See also ‘multi-occur’.

(fn BUFREGEXP REGEXP &optional ALLBUFS)〉〉enditem49840〈〈multi-occur〉〉:〈〈Show all lines in buffers BUFS containing a match for REGEXP.
This function acts on multiple buffers; otherwise, it is exactly like
‘occur’.  When you invoke this command interactively, you must specify
the buffer names that you want, one by one.
See also ‘multi-occur-in-matching-buffers’.

(fn BUFS REGEXP &optional NLINES)〉〉enditem49840〈〈narrow-to-defun〉〉:〈〈Make text outside current defun invisible.
The current defun is the one that contains point or follows point.
Preceding comments are included if INCLUDE-COMMENTS is non-nil.
Interactively, the behavior depends on ‘narrow-to-defun-include-comments’.

(fn &optional INCLUDE-COMMENTS)〉〉enditem49840〈〈nato-region〉〉:〈〈Convert all text in a given region to NATO phonetic alphabet.

(fn BEG END)〉〉enditem49840〈〈next-buffer〉〉:〈〈In selected window switch to next buffer.〉〉enditem49840〈〈next-completion〉〉:〈〈Move to the next item in the completion list.
With prefix argument N, move N items (negative N means move backward).

(fn N)〉〉enditem49840〈〈next-error-follow-minor-mode〉〉:〈〈Minor mode for compilation, occur and diff modes.
With a prefix argument ARG, enable mode if ARG is positive, and
disable it otherwise.  If called from Lisp, enable mode if ARG is
omitted or nil.
When turned on, cursor motion in the compilation, grep, occur or diff
buffer causes automatic display of the corresponding source code location.

(fn &optional ARG)〉〉enditem49840〈〈next-error〉〉:〈〈Visit next ‘next-error’ message and corresponding source code.

If all the error messages parsed so far have been processed already,
the message buffer is checked for new ones.

A prefix ARG specifies how many error messages to move;
negative means move back to previous error messages.
Just C-u as a prefix means reparse the error message buffer
and start at the first error.

The RESET argument specifies that we should restart from the beginning.

C-x ` normally uses the most recently started
compilation, grep, or occur buffer.  It can also operate on any
buffer with output from the M-x compile, M-x grep commands, or,
more generally, on any buffer in Compilation mode or with
Compilation Minor mode enabled, or any buffer in which
‘next-error-function’ is bound to an appropriate function.
To specify use of a particular buffer for error messages, type
C-x ` in that buffer when it is the only one displayed
in the current frame.

Once C-x ` has chosen the buffer for error messages, it
runs ‘next-error-hook’ with ‘run-hooks’, and stays with that buffer
until you use it in some other buffer which uses Compilation mode
or Compilation Minor mode.

To control which errors are matched, customize the variable
‘compilation-error-regexp-alist’.

(fn &optional ARG RESET)〉〉enditem49840〈〈next-file〉〉:〈〈Select next file among files in current tags table.

A first argument of t (prefix arg, if interactive) initializes to the
beginning of the list of files in the tags table.  If the argument is
neither nil nor t, it is evalled to initialize the list of files.

Non-nil second argument NOVISIT means use a temporary buffer
 to save time and avoid uninteresting warnings.

Value is nil if the file was already visited;
if the file was newly read in, the value is the filename.

(fn &optional INITIALIZE NOVISIT)〉〉enditem49840〈〈next-line-or-history-element〉〉:〈〈Move cursor vertically down ARG lines, or to the next history element.
When point moves over the bottom line of multi-line minibuffer, puts ARGth
next element of the minibuffer history in the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈next-line〉〉:〈〈Move cursor vertically down ARG lines.
Interactively, vscroll tall lines if ‘auto-window-vscroll’ is enabled.
Non-interactively, use TRY-VSCROLL to control whether to vscroll tall
lines: if either ‘auto-window-vscroll’ or TRY-VSCROLL is nil, this
function will not vscroll.

ARG defaults to 1.

If there is no character in the target line exactly under the current column,
the cursor is positioned after the character in that line which spans this
column, or at the end of the line if it is not long enough.
If there is no line in the buffer after this one, behavior depends on the
value of ‘next-line-add-newlines’.  If non-nil, it inserts a newline character
to create a line, and moves the cursor to that line.  Otherwise it moves the
cursor to the end of the buffer.

If the variable ‘line-move-visual’ is non-nil, this command moves
by display lines.  Otherwise, it moves by buffer lines, without
taking variable-width characters or continued lines into account.
See M-x next-logical-line for a command that always moves by buffer lines.

The command C-x C-n can be used to create
a semipermanent goal column for this command.
Then instead of trying to move exactly vertically (or as close as possible),
this command moves to the specified goal column (or as close as possible).
The goal column is stored in the variable ‘goal-column’, which is nil
when there is no goal column.  Note that setting ‘goal-column’
overrides ‘line-move-visual’ and causes this command to move by buffer
lines rather than by display lines.

(fn &optional ARG TRY-VSCROLL)〉〉enditem49840〈〈next-logical-line〉〉:〈〈Move cursor vertically down ARG lines.
This is identical to ‘next-line’, except that it always moves
by logical lines instead of visual lines, ignoring the value of
the variable ‘line-move-visual’.

(fn &optional ARG TRY-VSCROLL)〉〉enditem49840〈〈normal-erase-is-backspace-mode〉〉:〈〈Toggle the Erase and Delete mode of the Backspace and Delete keys.
With a prefix argument ARG, enable this feature if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

On window systems, when this mode is on, Delete is mapped to C-d
and Backspace is mapped to DEL; when this mode is off, both
Delete and Backspace are mapped to DEL.  (The remapping goes via
‘local-function-key-map’, so binding Delete or Backspace in the
global or local keymap will override that.)

In addition, on window systems, the bindings of C-Delete, M-Delete,
C-M-Delete, C-Backspace, M-Backspace, and C-M-Backspace are changed in
the global keymap in accordance with the functionality of Delete and
Backspace.  For example, if Delete is remapped to C-d, which deletes
forward, C-Delete is bound to ‘kill-word’, but if Delete is remapped
to DEL, which deletes backward, C-Delete is bound to
‘backward-kill-word’.

If not running on a window system, a similar effect is accomplished by
remapping C-h (normally produced by the Backspace key) and DEL via
‘keyboard-translate’: if this mode is on, C-h is mapped to DEL and DEL
to C-d; if it’s off, the keys are not remapped.

When not running on a window system, and this mode is turned on, the
former functionality of C-h is available on the F1 key.  You should
probably not turn on this mode on a text-only terminal if you don’t
have both Backspace, Delete and F1 keys.

See also ‘normal-erase-is-backspace’.

(fn &optional ARG)〉〉enditem49840〈〈nroff-mode〉〉:〈〈Major mode for editing text intended for nroff to format.

Uses keymap ‘nroff-mode-map’, which is not currently defined.

Turning on Nroff mode runs ‘text-mode-hook’, then ‘nroff-mode-hook’.
Also, try ‘nroff-electric-mode’, for automatically inserting
closing requests for requests that are used in matched pairs.

(fn)〉〉enditem49840〈〈number-to-register〉〉:〈〈Store a number in a register.
Two args, NUMBER and REGISTER (a character, naming the register).
If NUMBER is nil, a decimal number is read from the buffer starting
at point, and point moves to the end of that number.
Interactively, NUMBER is the prefix arg (none means nil).

Interactively, reads the register using ‘register-read-with-preview’.

(fn NUMBER REGISTER)〉〉enditem49840〈〈nxml-mode〉〉:〈〈Major mode for editing XML.

M-x nxml-finish-element finishes the current element by inserting an end-tag.
C-c C-i closes a start-tag with ‘>’ and then inserts a balancing end-tag
leaving point between the start-tag and end-tag.
M-x nxml-balanced-close-start-tag-block is similar but for block rather than inline elements:
the start-tag, point, and end-tag are all left on separate lines.
If ‘nxml-slash-auto-complete-flag’ is non-nil, then inserting a ‘</’
automatically inserts the rest of the end-tag.

M-x completion-at-point performs completion on the symbol preceding point.

M-x nxml-dynamic-markup-word uses the contents of the current buffer
to choose a tag to put around the word preceding point.

Sections of the document can be displayed in outline form.  The
variable ‘nxml-section-element-name-regexp’ controls when an element
is recognized as a section.  The same key sequences that change
visibility in outline mode are used except that they start with C-c C-o
instead of C-c.

Validation is provided by the related minor-mode ‘rng-validate-mode’.
This also makes completion schema- and context- sensitive.  Element
names, attribute names, attribute values and namespace URIs can all be
completed. By default, ‘rng-validate-mode’ is automatically enabled.
You can toggle it using M-x rng-validate-mode or change the default by
customizing ‘rng-nxml-auto-validate-flag’.

DEL TAB TAB indents the current line appropriately.
This can be customized using the variable ‘nxml-child-indent’
and the variable ‘nxml-attribute-indent’.

M-x nxml-insert-named-char inserts a character reference using
the character’s name (by default, the Unicode name).
C-u M-x nxml-insert-named-char inserts the character directly.

The Emacs commands that normally operate on balanced expressions will
operate on XML markup items.  Thus C-M-f will move forward
across one markup item; C-M-b will move backward across
one markup item; C-M-k will kill the following markup item;
C-M-@ will mark the following markup item.  By default, each
tag each treated as a single markup item; to make the complete element
be treated as a single markup item, set the variable
‘nxml-sexp-element-flag’ to t.  For more details, see the function
‘nxml-forward-balanced-item’.

M-x nxml-backward-up-element and M-x nxml-down-element move up and down the element structure.

Many aspects this mode can be customized using
M-x customize-group nxml RET.

(fn)〉〉enditem49840〈〈occur〉〉:〈〈Show all lines in the current buffer containing a match for REGEXP.
If a match spreads across multiple lines, all those lines are shown.

Each match is extended to include complete lines.  Only non-overlapping
matches are considered.  (Note that extending matches to complete
lines could cause some of the matches to overlap; if so, they will not
be shown as separate matches.)

Each line is displayed with NLINES lines before and after, or -NLINES
before if NLINES is negative.
NLINES defaults to ‘list-matching-lines-default-context-lines’.
Interactively it is the prefix arg.

Optional arg REGION, if non-nil, mean restrict search to the
specified region.  Otherwise search the entire buffer.
REGION must be a list of (START . END) positions as returned by
‘region-bounds’.

The lines are shown in a buffer named ‘*Occur*’.
It serves as a menu to find any of the occurrences in this buffer.
C-h m in that buffer will explain how.
If ‘list-matching-lines-jump-to-current-line’ is non-nil, then show
the current line highlighted with ‘list-matching-lines-current-line-face’
and set point at the first match after such line.

If REGEXP contains upper case characters (excluding those preceded by ‘\’)
and ‘search-upper-case’ is non-nil, the matching is case-sensitive.

When NLINES is a string or when the function is called
interactively with prefix argument without a number (‘C-u’ alone
as prefix) the matching strings are collected into the ‘*Occur*’
buffer by using NLINES as a replacement regexp.  NLINES may
contain \& and \N which convention follows ‘replace-match’.
For example, providing "defun\s +\(\S +\)" for REGEXP and
"\1" for NLINES collects all the function names in a lisp
program.  When there is no parenthesized subexpressions in REGEXP
the entire match is collected.  In any case the searched buffer
is not modified.

(fn REGEXP &optional NLINES REGION)〉〉enditem49840〈〈open-line〉〉:〈〈Insert a newline and leave point before it.
If there is a fill prefix and/or a ‘left-margin’, insert them on
the new line if the line would have been blank.
With arg N, insert N newlines.

(fn N)〉〉enditem49840〈〈open-rectangle〉〉:〈〈Blank out the region-rectangle, shifting text right.

The text previously in the region is not overwritten by the blanks,
but instead winds up to the right of the rectangle.

When called from a program the rectangle’s corners are START and END.
With a prefix (or a FILL) argument, fill with blanks even if there is
no text on the right side of the rectangle.

(fn START END &optional FILL)〉〉enditem49840〈〈org-agenda-file-to-front〉〉:〈〈Move/add the current file to the top of the agenda file list.
If the file is not present in the list, it is added to the front.  If it is
present, it is moved there.  With optional argument TO-END, add/move to the
end of the list.

(fn &optional TO-END)〉〉enditem49840〈〈org-agenda-files〉〉:〈〈Get the list of agenda files.
Optional UNRESTRICTED means return the full list even if a restriction
is currently in place.
When ARCHIVES is t, include all archive files that are really being
used by the agenda files.  If ARCHIVE is ‘ifmode’, do this only if
‘org-agenda-archives-mode’ is t.

(fn &optional UNRESTRICTED ARCHIVES)〉〉enditem49840〈〈org-agenda〉〉:〈〈Dispatch agenda commands to collect entries to the agenda buffer.
Prompts for a command to execute.  Any prefix arg will be passed
on to the selected command.  The default selections are:

a     Call ‘org-agenda-list’ to display the agenda for current day or week.
t     Call ‘org-todo-list’ to display the global todo list.
T     Call ‘org-todo-list’ to display the global todo list, select only
      entries with a specific TODO keyword (the user gets a prompt).
m     Call ‘org-tags-view’ to display headlines with tags matching
      a condition  (the user is prompted for the condition).
M     Like ‘m’, but select only TODO entries, no ordinary headlines.
e     Export views to associated files.
s     Search entries for keywords.
S     Search entries for keywords, only with TODO keywords.
/     Multi occur across all agenda files and also files listed
      in ‘org-agenda-text-search-extra-files’.
<     Restrict agenda commands to buffer, subtree, or region.
      Press several times to get the desired effect.
>     Remove a previous restriction.
#     List "stuck" projects.
!     Configure what "stuck" means.
C     Configure custom agenda commands.

More commands can be added by configuring the variable
‘org-agenda-custom-commands’.  In particular, specific tags and TODO keyword
searches can be pre-defined in this way.

If the current buffer is in Org mode and visiting a file, you can also
first press ‘<’ once to indicate that the agenda should be temporarily
(until the next use of ‘M-x org-agenda’) restricted to the current file.
Pressing ‘<’ twice means to restrict to the current subtree or region
(if active).

(fn &optional ARG ORG-KEYS RESTRICTION)〉〉enditem49840〈〈org-cycle〉〉:〈〈TAB-action and visibility cycling for Org mode.

This is the command invoked in Org mode by the ‘TAB’ key.  Its main
purpose is outline visibility cycling, but it also invokes other actions
in special contexts.

When this function is called with a ‘C-u’ prefix, rotate the entire
buffer through 3 states (global cycling)
  1. OVERVIEW: Show only top-level headlines.
  2. CONTENTS: Show all headlines of all levels, but no body text.
  3. SHOW ALL: Show everything.

With a ‘C-u C-u’ prefix argument, switch to the startup visibility,
determined by the variable ‘org-startup-folded’, and by any VISIBILITY
properties in the buffer.

With a ‘C-u C-u C-u’ prefix argument, show the entire buffer, including
any drawers.

When inside a table, re-align the table and move to the next field.

When point is at the beginning of a headline, rotate the subtree started
by this line through 3 different states (local cycling)
  1. FOLDED:   Only the main headline is shown.
  2. CHILDREN: The main headline and the direct children are shown.
               From this state, you can move to one of the children
               and zoom in further.
  3. SUBTREE:  Show the entire subtree, including body text.
If there is no subtree, switch directly from CHILDREN to FOLDED.

When point is at the beginning of an empty headline and the variable
‘org-cycle-level-after-item/entry-creation’ is set, cycle the level
of the headline by demoting and promoting it to likely levels.  This
speeds up creation document structure by pressing ‘TAB’ once or several
times right after creating a new headline.

When there is a numeric prefix, go up to a heading with level ARG, do
a ‘show-subtree’ and return to the previous cursor position.  If ARG
is negative, go up that many levels.

When point is not at the beginning of a headline, execute the global
binding for ‘TAB’, which is re-indenting the line.  See the option
‘org-cycle-emulate-tab’ for details.

As a special case, if point is at the beginning of the buffer and there is
no headline in line 1, this function will act as if called with prefix arg
(‘C-u TAB’, same as ‘S-TAB’) also when called without prefix arg, but only
if the variable ‘org-cycle-global-at-bob’ is t.

(fn &optional ARG)〉〉enditem49840〈〈org-deadline〉〉:〈〈Insert the "DEADLINE:" string with a timestamp to make a deadline.
With one universal prefix argument, remove any deadline from the item.
With two universal prefix arguments, prompt for a warning delay.
With argument TIME, set the deadline at the corresponding date.  TIME
can either be an Org date like "2011-07-24" or a delta like "+2d".

(fn ARG &optional TIME)〉〉enditem49840〈〈org-metadown〉〉:〈〈Move subtree down or move table row down.
Calls ‘org-move-subtree-down’ or ‘org-table-move-row’ or
‘org-move-item-down’, depending on context.  See the individual
commands for more information.

(fn &optional ARG)〉〉enditem49840〈〈org-metaleft〉〉:〈〈Promote heading, list item at point or move table column left.

Calls ‘org-do-promote’, ‘org-outdent-item’ or ‘org-table-move-column’,
depending on context.  With no specific context, calls the Emacs
default ‘backward-word’.  See the individual commands for more
information.

This function runs the hook ‘org-metaleft-hook’ as a first step,
and returns at first non-nil value.

(fn &optional ARG)〉〉enditem49840〈〈org-metaright〉〉:〈〈Demote heading, list item at point or move table column right.

In front of a drawer or a block keyword, indent it correctly.

Calls ‘org-do-demote’, ‘org-indent-item’, ‘org-table-move-column’,
‘org-indent-drawer’ or ‘org-indent-block’ depending on context.
With no specific context, calls the Emacs default ‘forward-word’.
See the individual commands for more information.

This function runs the hook ‘org-metaright-hook’ as a first step,
and returns at first non-nil value.

(fn &optional ARG)〉〉enditem49840〈〈org-metaup〉〉:〈〈Move subtree up or move table row up.
Calls ‘org-move-subtree-up’ or ‘org-table-move-row’ or
‘org-move-item-up’, depending on context.  See the individual commands
for more information.

(fn &optional ARG)〉〉enditem49840〈〈org-mode〉〉:〈〈Outline-based notes management and organizer, alias
"Carsten’s outline-mode for keeping track of everything."

Org mode develops organizational tasks around a NOTES file which
contains information about projects as plain text.  Org mode is
implemented on top of Outline mode, which is ideal to keep the content
of large files well structured.  It supports ToDo items, deadlines and
time stamps, which magically appear in the diary listing of the Emacs
calendar.  Tables are easily created with a built-in table editor.
Plain text URL-like links connect to websites, emails (VM), Usenet
messages (Gnus), BBDB entries, and any files related to the project.
For printing and sharing of notes, an Org file (or a part of it)
can be exported as a structured ASCII or HTML file.

The following commands are available:

key             binding
---             -------

C-a             org-beginning-of-line
C-c             Prefix Command
C-e             org-end-of-line
TAB             org-cycle
C-j             org-return-indent
C-k             org-kill-line
RET             org-return
C-y             org-yank
ESC             Prefix Command
|               org-force-self-insert
C-#             org-table-rotate-recalc-marks
C-'             org-cycle-agenda-files
C-,             org-cycle-agenda-files
<C-M-S-left>    org-decrease-number-at-point
<C-M-S-right>   org-increase-number-at-point
<C-S-down>      org-shiftcontroldown
<C-S-left>      org-shiftcontrolleft
<C-S-return>    org-insert-todo-heading-respect-content
<C-S-right>     org-shiftcontrolright
<C-S-up>        org-shiftcontrolup
<C-return>      org-insert-heading-respect-content
<C-tab>         org-force-cycle-archived
<M-S-down>      org-shiftmetadown
<M-S-left>      org-shiftmetaleft
<M-S-return>    org-insert-todo-heading
<M-S-right>     org-shiftmetaright
<M-S-up>        org-shiftmetaup
<M-down>        org-metadown
<M-left>        org-metaleft
<M-right>       org-metaright
<M-up>          org-metaup
<S-down>        org-shiftdown
<S-iso-lefttab>                 org-shifttab
<S-left>        org-shiftleft
<S-return>      org-table-copy-down
<S-right>       org-shiftright
<S-tab>         org-shifttab
<S-up>          org-shiftup
<backtab>       org-shifttab
<remap>         Prefix Command
<tab>           org-cycle

C-M-i           pcomplete
M-RET           org-meta-return
C-M-t           org-transpose-element
M-^             org-delete-indentation
M-a             org-backward-sentence
M-e             org-forward-sentence
M-h             org-mark-element
M-{             org-backward-element
M-}             org-forward-element

C-c C-a         org-attach
C-c C-b         org-backward-heading-same-level
C-c C-c         org-ctrl-c-ctrl-c
C-c C-d         org-deadline
C-c C-e         org-export-dispatch
C-c C-f         org-forward-heading-same-level
C-c C-j         org-goto
C-c C-k         org-kill-note-or-show-branches
C-c C-l         org-insert-link
C-c RET         org-ctrl-c-ret
C-c C-o         org-open-at-point
C-c C-q         org-set-tags-command
C-c C-r         org-reveal
C-c C-s         org-schedule
C-c C-t         org-todo
C-c C-v         Prefix Command
C-c C-w         org-refile
C-c C-x         Prefix Command
C-c C-y         org-evaluate-time-range
C-c C-z         org-add-note
C-c ESC         Prefix Command
C-c C-^         org-up-element
C-c C-_         org-down-element
C-c SPC         org-table-blank-field
C-c !           org-time-stamp-inactive
C-c "           Prefix Command
C-c #           org-update-statistics-cookies
C-c $           org-archive-subtree
C-c %           org-mark-ring-push
C-c &           org-mark-ring-goto
C-c '           org-edit-special
C-c *           org-ctrl-c-star
C-c +           org-table-sum
C-c ,           org-priority
C-c -           org-ctrl-c-minus
C-c .           org-time-stamp
C-c /           org-sparse-tree
C-c :           org-toggle-fixed-width
C-c ;           org-toggle-comment
C-c <           org-date-from-calendar
C-c =           org-table-eval-formula
C-c >           org-goto-calendar
C-c ?           org-table-field-info
C-c @           org-mark-subtree
C-c [           org-agenda-file-to-front
C-c \           org-match-sparse-tree
C-c ]           org-remove-file
C-c ^           org-sort
C-c `           org-table-edit-field
C-c {           org-table-toggle-formula-debugger
C-c |           org-table-create-or-convert-from-region
C-c }           org-table-toggle-coordinate-overlays
C-c ~           org-table-create-with-table.el
C-c C-*         org-list-make-subtree

<remap> <backward-paragraph>    org-backward-paragraph
<remap> <comment-dwim>          org-comment-dwim
<remap> <delete-backward-char>  org-delete-backward-char
<remap> <delete-char>           org-delete-char
<remap> <fill-paragraph>        org-fill-paragraph
<remap> <forward-paragraph>     org-forward-paragraph
<remap> <open-line>             org-open-line
<remap> <outline-backward-same-level>
                                org-backward-heading-same-level
<remap> <outline-demote>        org-demote-subtree
<remap> <outline-forward-same-level>
                                org-forward-heading-same-level
<remap> <outline-insert-heading>
                                org-ctrl-c-ret
<remap> <outline-mark-subtree>  org-mark-subtree
<remap> <outline-next-visible-heading>
                                org-next-visible-heading
<remap> <outline-previous-visible-heading>
                                org-previous-visible-heading
<remap> <outline-promote>       org-promote-subtree
<remap> <outline-show-branches>
                                org-kill-note-or-show-branches
<remap> <outline-show-subtree>  org-show-subtree
<remap> <self-insert-command>   org-self-insert-command
<remap> <show-children>         org-show-children
<remap> <transpose-words>       org-transpose-words

C-c C-a         outline-show-all
  (that binding is currently shadowed by another mode)
C-c C-b         outline-backward-same-level
  (that binding is currently shadowed by another mode)
C-c C-c         outline-hide-entry
  (that binding is currently shadowed by another mode)
C-c C-d         outline-hide-subtree
  (that binding is currently shadowed by another mode)
C-c C-e         outline-show-entry
  (that binding is currently shadowed by another mode)
C-c C-f         outline-forward-same-level
  (that binding is currently shadowed by another mode)
C-c TAB         outline-show-children
C-c C-k         outline-show-branches
  (that binding is currently shadowed by another mode)
C-c C-l         outline-hide-leaves
  (that binding is currently shadowed by another mode)
C-c RET         outline-insert-heading
  (that binding is currently shadowed by another mode)
C-c C-n         outline-next-visible-heading
C-c C-o         outline-hide-other
  (that binding is currently shadowed by another mode)
C-c C-p         outline-previous-visible-heading
C-c C-q         outline-hide-sublevels
  (that binding is currently shadowed by another mode)
C-c C-s         outline-show-subtree
  (that binding is currently shadowed by another mode)
C-c C-t         outline-hide-body
  (that binding is currently shadowed by another mode)
C-c C-u         outline-up-heading
C-c C-v         outline-move-subtree-down
  (that binding is currently shadowed by another mode)
C-c C-^         outline-move-subtree-up
  (that binding is currently shadowed by another mode)
C-c @           outline-mark-subtree
  (that binding is currently shadowed by another mode)
C-c C-<         outline-promote
C-c C->         outline-demote

C-M-i           ispell-complete-word
  (that binding is currently shadowed by another mode)

C-c " a         orgtbl-ascii-plot
C-c " g         org-plot/gnuplot

C-c C-M-l       org-insert-all-links
C-c M-b         org-previous-block
C-c M-f         org-next-block
C-c M-l         org-insert-last-stored-link
C-c M-w         org-copy

C-c C-v C-a     org-babel-sha1-hash
C-c C-v C-b     org-babel-execute-buffer
C-c C-v C-c     org-babel-check-src-block
C-c C-v C-d     org-babel-demarcate-block
C-c C-v C-e     org-babel-execute-maybe
C-c C-v C-f     org-babel-tangle-file
C-c C-v TAB     org-babel-view-src-block-info
C-c C-v C-j     org-babel-insert-header-arg
C-c C-v C-l     org-babel-load-in-session
C-c C-v C-n     org-babel-next-src-block
C-c C-v C-o     org-babel-open-src-block-result
C-c C-v C-p     org-babel-previous-src-block
C-c C-v C-r     org-babel-goto-named-result
C-c C-v C-s     org-babel-execute-subtree
C-c C-v C-t     org-babel-tangle
C-c C-v C-u     org-babel-goto-src-block-head
C-c C-v C-v     org-babel-expand-src-block
C-c C-v C-x     org-babel-do-key-sequence-in-edit-buffer
C-c C-v C-z     org-babel-switch-to-session
C-c C-v ESC     Prefix Command
C-c C-v I       org-babel-view-src-block-info
C-c C-v a       org-babel-sha1-hash
C-c C-v b       org-babel-execute-buffer
C-c C-v c       org-babel-check-src-block
C-c C-v d       org-babel-demarcate-block
C-c C-v e       org-babel-execute-maybe
C-c C-v f       org-babel-tangle-file
C-c C-v g       org-babel-goto-named-src-block
C-c C-v h       org-babel-describe-bindings
C-c C-v i       org-babel-lob-ingest
C-c C-v j       org-babel-insert-header-arg
C-c C-v k       org-babel-remove-result-one-or-many
C-c C-v l       org-babel-load-in-session
C-c C-v n       org-babel-next-src-block
C-c C-v o       org-babel-open-src-block-result
C-c C-v p       org-babel-previous-src-block
C-c C-v r       org-babel-goto-named-result
C-c C-v s       org-babel-execute-subtree
C-c C-v t       org-babel-tangle
C-c C-v u       org-babel-goto-src-block-head
C-c C-v v       org-babel-expand-src-block
C-c C-v x       org-babel-do-key-sequence-in-edit-buffer
C-c C-v z       org-babel-switch-to-session-with-code

C-c C-x C-a     org-archive-subtree-default
C-c C-x C-b     org-toggle-checkbox
C-c C-x C-c     org-columns
C-c C-x C-d     org-clock-display
C-c C-x C-f     org-emphasize
C-c C-x TAB     org-clock-in
C-c C-x C-j     org-clock-goto
C-c C-x C-l     org-toggle-latex-fragment
C-c C-x RET     Prefix Command
C-c C-x C-n     org-next-link
C-c C-x C-o     org-clock-out
C-c C-x C-p     org-previous-link
C-c C-x C-q     org-clock-cancel
C-c C-x C-r     org-clock-report
C-c C-x C-s     org-archive-subtree
C-c C-x C-t     org-toggle-time-stamp-overlays
C-c C-x C-u     org-dblock-update
C-c C-x C-v     org-toggle-inline-images
C-c C-x C-w     org-cut-special
C-c C-x C-x     org-clock-in-last
C-c C-x C-y     org-paste-special
C-c C-x C-z     org-resolve-clocks
C-c C-x ESC     Prefix Command
C-c C-x !       org-reload
C-c C-x ,       org-timer-pause-or-continue
C-c C-x -       org-timer-item
C-c C-x .       org-timer
C-c C-x 0       org-timer-start
C-c C-x ;       org-timer-set-timer
C-c C-x <       org-agenda-set-restriction-lock
C-c C-x >       org-agenda-remove-restriction-lock
C-c C-x A       org-archive-to-archive-sibling
C-c C-x E       org-inc-effort
C-c C-x G       org-feed-goto-inbox
C-c C-x P       org-set-property-and-value
C-c C-x [       org-reftex-citation
C-c C-x \       org-toggle-pretty-entities
C-c C-x _       org-timer-stop
C-c C-x a       org-toggle-archive-tag
C-c C-x b       org-tree-to-indirect-buffer
C-c C-x c       org-clone-subtree-with-time-shift
C-c C-x d       org-insert-drawer
C-c C-x e       org-set-effort
C-c C-x f       org-footnote-action
C-c C-x g       org-feed-update-all
C-c C-x i       org-columns-insert-dblock
C-c C-x o       org-toggle-ordered-property
C-c C-x p       org-set-property
C-c C-x q       org-toggle-tags-groups
C-c C-x v       org-copy-visible

C-c C-v C-M-h   org-babel-mark-block

C-c C-x C-M-v   org-redisplay-inline-images
C-c C-x M-w     org-copy-special

C-c C-x RET g   org-mobile-pull
C-c C-x RET p   org-mobile-push



In addition to any hooks its parent mode ‘outline-mode’ might have run,
this mode runs the hook ‘org-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈org-schedule〉〉:〈〈Insert the SCHEDULED: string with a timestamp to schedule a TODO item.
With one universal prefix argument, remove any scheduling date from the item.
With two universal prefix arguments, prompt for a delay cookie.
With argument TIME, scheduled at the corresponding date.  TIME can
either be an Org date like "2011-07-24" or a delta like "+2d".

(fn ARG &optional TIME)〉〉enditem49840〈〈org-shifttab〉〉:〈〈Global visibility cycling or move to previous table field.
Call ‘org-table-previous-field’ within a table.
When ARG is nil, cycle globally through visibility states.
When ARG is a numeric prefix, show contents of this level.

(fn &optional ARG)〉〉enditem49840〈〈org-todo〉〉:〈〈Change the TODO state of an item.

The state of an item is given by a keyword at the start of the heading,
like
     *** TODO Write paper
     *** DONE Call mom

The different keywords are specified in the variable ‘org-todo-keywords’.
By default the available states are "TODO" and "DONE".  So, for this
example: when the item starts with TODO, it is changed to DONE.
When it starts with DONE, the DONE is removed.  And when neither TODO nor
DONE are present, add TODO at the beginning of the heading.

With ‘C-u’ prefix ARG, use completion to determine the new state.
With numeric prefix ARG, switch to that state.
With a ‘C-u C-u’ prefix, switch to the next set of TODO keywords (nextset).
With a ‘C-u C-u C-u’ prefix, circumvent any state blocking.
With a numeric prefix arg of 0, inhibit note taking for the change.
With a numeric prefix arg of -1, cancel repeater to allow marking as DONE.

When called through ELisp, arg is also interpreted in the following way:
‘none’        -> empty state
""            -> switch to empty state
‘done’        -> switch to DONE
‘nextset’     -> switch to the next set of keywords
‘previousset’ -> switch to the previous set of keywords
"WAITING"     -> switch to the specified keyword, but only if it
                 really is a member of ‘org-todo-keywords’.

(fn &optional ARG)〉〉enditem49840〈〈other-frame〉〉:〈〈Select the ARGth different visible frame on current display, and raise it.
All frames are arranged in a cyclic order.
This command selects the frame ARG steps away in that order.
A negative ARG moves in the opposite order.

To make this command work properly, you must tell Emacs how the
system (or the window manager) generally handles focus-switching
between windows.  If moving the mouse onto a window selects
it (gives it focus), set ‘focus-follows-mouse’ to t.  Otherwise,
that variable should be nil.

(fn ARG)〉〉enditem49840〈〈outline-backward-same-level〉〉:〈〈Move backward to the ARG’th subheading at same level as this one.
Stop at the first and last subheadings of a superior heading.〉〉enditem49840〈〈outline-forward-same-level〉〉:〈〈Move forward to the ARG’th subheading at same level as this one.
Stop at the first and last subheadings of a superior heading.〉〉enditem49840〈〈outline-level〉〉:〈〈Return the depth to which a statement is nested in the outline.
Point must be at the beginning of a header line.
This is actually either the level specified in ‘outline-heading-alist’
or else the number of characters matched by ‘outline-regexp’.〉〉enditem49840〈〈outline-minor-mode〉〉:〈〈Toggle Outline minor mode.
With a prefix argument ARG, enable Outline minor mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

See the command ‘outline-mode’ for more information on this mode.〉〉enditem49840〈〈outline-mode〉〉:〈〈Set major mode for editing outlines with selective display.
Headings are lines which start with asterisks: one for major headings,
two for subheadings, etc.  Lines not starting with asterisks are body lines.

Body text or subheadings under a heading can be made temporarily
invisible, or visible again.  Invisible lines are attached to the end
of the heading, so they move with it, if the line is killed and yanked
back.  A heading with text hidden under it is marked with an ellipsis (...).

key             binding
---             -------

C-c             Prefix Command
ESC             Prefix Command

C-c C-a         outline-show-all
C-c C-b         outline-backward-same-level
C-c C-c         outline-hide-entry
C-c C-d         outline-hide-subtree
C-c C-e         outline-show-entry
C-c C-f         outline-forward-same-level
C-c TAB         outline-show-children
C-c C-k         outline-show-branches
C-c C-l         outline-hide-leaves
C-c RET         outline-insert-heading
C-c C-n         outline-next-visible-heading
C-c C-o         outline-hide-other
C-c C-p         outline-previous-visible-heading
C-c C-q         outline-hide-sublevels
C-c C-s         outline-show-subtree
C-c C-t         outline-hide-body
C-c C-u         outline-up-heading
C-c C-v         outline-move-subtree-down
C-c C-^         outline-move-subtree-up
C-c @           outline-mark-subtree
C-c C-<         outline-promote
C-c C->         outline-demote

C-M-i           ispell-complete-word


The commands ‘outline-hide-subtree’, ‘outline-show-subtree’,
‘outline-show-children’, ‘outline-hide-entry’,
‘outline-show-entry’, ‘outline-hide-leaves’, and ‘outline-show-branches’
are used when point is on a heading line.

The variable ‘outline-regexp’ can be changed to control what is a heading.
A line is a heading if ‘outline-regexp’ matches something at the
beginning of the line.  The longer the match, the deeper the level.

Turning on outline mode calls the value of ‘text-mode-hook’ and then of
‘outline-mode-hook’, if they are non-nil.〉〉enditem49840〈〈outline-next-visible-heading〉〉:〈〈Move to the next visible heading line.
With ARG, repeats or can move backward if negative.
A heading line is one that starts with a ‘*’ (or that
‘outline-regexp’ matches).〉〉enditem49840〈〈outline-previous-visible-heading〉〉:〈〈Move to the previous heading line.
With ARG, repeats or can move forward if negative.
A heading line is one that starts with a ‘*’ (or that
‘outline-regexp’ matches).〉〉enditem49840〈〈outline-up-heading〉〉:〈〈Move to the visible heading line of which the present line is a subheading.
With argument, move up ARG levels.
If INVISIBLE-OK is non-nil, also consider invisible lines.〉〉enditem49840〈〈overwrite-mode〉〉:〈〈Toggle Overwrite mode.
With a prefix argument ARG, enable Overwrite mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Overwrite mode is enabled, printing characters typed in
replace existing text on a one-for-one basis, rather than pushing
it to the right.  At the end of a line, such characters extend
the line.  Before a tab, such characters insert until the tab is
filled in.  C-q still inserts characters in
overwrite mode; this is supposed to make it easier to insert
characters when necessary.

(fn &optional ARG)〉〉enditem49840〈〈package-install-file〉〉:〈〈Install a package from a file.
The file can either be a tar file, an Emacs Lisp file, or a
directory.

(fn FILE)〉〉enditem49840〈〈package-install〉〉:〈〈Install the package PKG.
PKG can be a ‘package-desc’ or a symbol naming one of the available packages
in an archive in ‘package-archives’.  Interactively, prompt for its name.

If called interactively or if DONT-SELECT nil, add PKG to
‘package-selected-packages’.

If PKG is a ‘package-desc’ and it is already installed, don’t try
to install it but still mark it as selected.

(fn PKG &optional DONT-SELECT)〉〉enditem49840〈〈package-menu-describe-package〉〉:〈〈Describe the current package.
If optional arg BUTTON is non-nil, describe its associated package.

(fn &optional BUTTON)〉〉enditem49840〈〈package-menu-execute〉〉:〈〈Perform marked Package Menu actions.
Packages marked for installation are downloaded and installed;
packages marked for deletion are removed.
Optional argument NOQUERY non-nil means do not ask the user to confirm.

(fn &optional NOQUERY)〉〉enditem49840〈〈package-menu-filter〉〉:〈〈Filter the *Packages* buffer.
Show only those items that relate to the specified KEYWORD.
KEYWORD can be a string or a list of strings.  If it is a list, a
package will be displayed if it matches any of the keywords.
Interactively, it is a list of strings separated by commas.

To restore the full package list, type ‘q’.

(fn KEYWORD)〉〉enditem49840〈〈package-menu-hide-package〉〉:〈〈Hide a package under point.
If optional arg BUTTON is non-nil, describe its associated package.〉〉enditem49840〈〈package-menu-mark-delete〉〉:〈〈Mark a package for deletion and move to the next line.

(fn &optional NUM)〉〉enditem49840〈〈package-menu-mark-install〉〉:〈〈Mark a package for installation and move to the next line.

(fn &optional NUM)〉〉enditem49840〈〈package-menu-mark-obsolete-for-deletion〉〉:〈〈Mark all obsolete packages for deletion.〉〉enditem49840〈〈package-menu-mark-upgrades〉〉:〈〈Mark all upgradable packages in the Package Menu.
For each installed package with a newer version available, place
an (I)nstall flag on the available version and a (D)elete flag on
the installed version.  A subsequent M-x package-menu-execute
call will upgrade the package.

If there’s an async refresh operation in progress, the flags will
be placed as part of ‘package-menu--post-refresh’ instead of
immediately.〉〉enditem49840〈〈package-menu-quick-help〉〉:〈〈Show short key binding help for ‘package-menu-mode’.
The full list of keys can be viewed with C-h m.〉〉enditem49840〈〈package-menu-refresh〉〉:〈〈Download the Emacs Lisp package archive.
This fetches the contents of each archive specified in
‘package-archives’, and then refreshes the package menu.〉〉enditem49840〈〈package-menu-toggle-hiding〉〉:〈〈Toggle visibility of obsolete available packages.〉〉enditem49840〈〈paragraph-indent-minor-mode〉〉:〈〈Minor mode for editing text, with leading spaces starting a paragraph.
In this mode, you do not need blank lines between paragraphs when the
first line of the following paragraph starts with whitespace, as with
‘paragraph-indent-text-mode’.
Turning on Paragraph-Indent minor mode runs the normal hook
‘paragraph-indent-text-mode-hook’.〉〉enditem49840〈〈paragraph-indent-text-mode〉〉:〈〈Major mode for editing text, with leading spaces starting a paragraph.
In this mode, you do not need blank lines between paragraphs
when the first line of the following paragraph starts with whitespace.
‘paragraph-indent-minor-mode’ provides a similar facility as a minor mode.
Special commands:
key             binding
---             -------

ESC             Prefix Command

C-M-i           ispell-complete-word


Turning on Paragraph-Indent Text mode runs the normal hooks
‘text-mode-hook’ and ‘paragraph-indent-text-mode-hook’.〉〉enditem49840〈〈pdb〉〉:〈〈Run pdb on program FILE in buffer ‘*gud-FILE*’.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.

(fn COMMAND-LINE)〉〉enditem49840〈〈perldb〉〉:〈〈Run perldb on program FILE in buffer *gud-FILE*.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.

(fn COMMAND-LINE)〉〉enditem49840〈〈picture-mode〉〉:〈〈Switch to Picture mode, in which a quarter-plane screen model is used.

Uses keymap ‘picture-mode-map’, which is not currently defined.

Printing characters replace instead of inserting themselves with motion
afterwards settable by these commands:

 Move left after insertion:            M-x picture-movement-left
 Move right after insertion:           M-x picture-movement-right
 Move up after insertion:              M-x picture-movement-up
 Move down after insertion:            M-x picture-movement-down

 Move northwest (nw) after insertion:  M-x picture-movement-nw
 Move northeast (ne) after insertion:  M-x picture-movement-ne
 Move southwest (sw) after insertion:  M-x picture-movement-sw
 Move southeast (se) after insertion:  M-x picture-movement-se

 Move westnorthwest (wnw) after insertion:  C-u M-x picture-movement-nw
 Move eastnortheast (ene) after insertion:  C-u M-x picture-movement-ne
 Move westsouthwest (wsw) after insertion:  C-u M-x picture-movement-sw
 Move eastsoutheast (ese) after insertion:  C-u M-x picture-movement-se

The current direction is displayed in the mode line.  The initial
direction is right.  Whitespace is inserted and tabs are changed to
spaces when required by movement.  You can move around in the buffer
with these commands:

 Move vertically to SAME column in previous line: M-x picture-move-down
 Move vertically to SAME column in next line:     M-x picture-move-up
 Move to column following last
  non-whitespace character:                       M-x picture-end-of-line
 Move right, inserting spaces if required:        M-x picture-forward-column
 Move left changing tabs to spaces if required:   M-x picture-backward-column
 Move in direction of current picture motion:     M-x picture-motion
 Move opposite to current picture motion:         M-x picture-motion-reverse
 Move to beginning of next line:                  t

You can edit tabular text with these commands:

 Move to column beneath (or at) next interesting
  character (see variable ‘picture-tab-chars’):   M-x picture-tab-search
 Move to next stop in tab stop list:              M-x picture-tab
 Set tab stops according to context of this line: M-x picture-set-tab-stops
   (With ARG, resets tab stops to default value.)
 Change the tab stop list:                        M-x edit-tab-stops

You can manipulate text with these commands:
 Clear ARG columns after point without moving:    M-x picture-clear-column
 Delete char at point:                            M-x picture-delete-char
 Clear ARG columns backward:                      M-x picture-backward-clear-column
 Clear ARG lines, advancing over them:            M-x picture-clear-line
  (the cleared text is saved in the kill ring)
 Open blank line(s) beneath current line:         M-x picture-open-line

You can manipulate rectangles with these commands:
  Clear a rectangle and save it:                  M-x picture-clear-rectangle
  Clear a rectangle, saving in a named register:  M-x picture-clear-rectangle-to-register
  Insert currently saved rectangle at point:      M-x picture-yank-rectangle
  Insert rectangle from named register:           M-x picture-yank-rectangle-from-register
  Draw a rectangular box around mark and point:   M-x picture-draw-rectangle
  Copies a rectangle to a register:               DEL t r
  Undo effects of rectangle overlay commands:     C-x u

You can return to the previous mode with M-x picture-mode-exit, which
also strips trailing whitespace from every line.  Stripping is suppressed
by supplying an argument.

Entry to this mode calls the value of ‘picture-mode-hook’ if non-nil.

Note that Picture mode commands will work outside of Picture mode, but
they are not by default assigned to keys.

(fn)〉〉enditem49840〈〈plain-tex-mode〉〉:〈〈Major mode for editing files of input for plain TeX.
Makes $ and } display the characters they match.
Makes " insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts " only after a \.

Use M-x tex-region to run TeX on the current region, plus a "header"
copied from the top of the file (containing macro definitions, etc.),
running TeX under a special subshell.  M-x tex-buffer does the whole buffer.
M-x tex-file saves the buffer and then processes the file.
M-x tex-print prints the .dvi file made by any of these.
M-x tex-view previews the .dvi file made by any of these.
M-x tex-bibtex-file runs bibtex on the file of the current buffer.

Use M-x tex-validate-buffer to check buffer for paragraphs containing
mismatched $’s or braces.

Special commands:

Uses keymap ‘plain-tex-mode-map’, which is not currently defined.


Mode variables:
tex-run-command
	Command string used by M-x tex-region or M-x tex-buffer.
tex-directory
	Directory in which to create temporary files for TeX jobs
	run by M-x tex-region or M-x tex-buffer.
tex-dvi-print-command
	Command string used by M-x tex-print to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by M-x tex-print (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by M-x tex-view to preview a .dvi file.
tex-show-queue-command
	Command string used by M-x tex-show-print-queue to show the print
	queue that M-x tex-print put your job on.

Entering Plain-tex mode runs the hook ‘text-mode-hook’, then the hook
‘tex-mode-hook’, and finally the hook ‘plain-tex-mode-hook’.  When the
special subshell is initiated, the hook ‘tex-shell-hook’ is run.

(fn)〉〉enditem49840〈〈point-to-register〉〉:〈〈Store current location of point in register REGISTER.
With prefix argument, store current frame configuration.
Use C-x r j to go to that location or restore that configuration.
Argument is a character, naming the register.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER &optional ARG)〉〉enditem49840〈〈pong〉〉:〈〈Play pong and waste time.
This is an implementation of the classical game pong.
Move left and right bats and try to bounce the ball to your opponent.

pong-mode keybindings:
Uses keymap ‘pong-mode-map’, which is not currently defined.



Uses keymap ‘pong-mode-map’, which is not currently defined.


(fn)〉〉enditem49840〈〈pop-global-mark〉〉:〈〈:around advice: ‘ad-Advice-pop-global-mark’

Pop off global mark ring and jump to the top location.

(fn)〉〉enditem49840〈〈pop-tag-mark〉〉:〈〈Pop back to where DEL , t was last invoked.〉〉enditem49840〈〈pr-interface〉〉:〈〈Activate the printing interface buffer.

If BUFFER is nil, the current buffer is used for printing.

For more information, type M-x pr-interface-help.

(fn &optional BUFFER)〉〉enditem49840〈〈prefer-coding-system〉〉:〈〈Add CODING-SYSTEM at the front of the priority list for automatic detection.
This also sets the following coding systems:
  o coding system of a newly created buffer
  o default coding system for subprocess I/O
This also sets the following values:
  o default value used as ‘file-name-coding-system’ for converting file names
  o default value for the command ‘set-terminal-coding-system’
  o default value for the command ‘set-keyboard-coding-system’

If CODING-SYSTEM specifies a certain type of EOL conversion, the coding
systems set by this function will use that type of EOL conversion.

A coding system that requires automatic detection of text+encoding
(e.g. undecided, unix) can’t be preferred.

To prefer, for instance, utf-8, say the following:

  (prefer-coding-system 'utf-8)

(fn CODING-SYSTEM)〉〉enditem49840〈〈prepend-to-buffer〉〉:〈〈Prepend to specified buffer the text of the region.
It is inserted into that buffer after its point.

When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied.

(fn BUFFER START END)〉〉enditem49840〈〈prepend-to-register〉〉:〈〈Prepend region to text in register REGISTER.
With prefix arg, delete as well.
Called from program, takes four args: REGISTER, START, END and DELETE-FLAG.
START and END are buffer positions indicating what to prepend.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER START END &optional DELETE-FLAG)〉〉enditem49840〈〈prettify-symbols-default-compose-p〉〉:〈〈Return true iff the symbol MATCH should be composed.
The symbol starts at position START and ends at position END.
This is the default for ‘prettify-symbols-compose-predicate’
which is suitable for most programming languages such as C or Lisp.

(fn START END MATCH)〉〉enditem49840〈〈prettify-symbols-mode〉〉:〈〈Toggle Prettify Symbols mode.
With a prefix argument ARG, enable Prettify Symbols mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Prettify Symbols mode and font-locking are enabled, symbols are
prettified (displayed as composed characters) according to the rules
in ‘prettify-symbols-alist’ (which see), which are locally defined
by major modes supporting prettifying.  To add further customizations
for a given major mode, you can modify ‘prettify-symbols-alist’ thus:

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("<=" . ?≤) prettify-symbols-alist)))

You can enable this mode locally in desired buffers, or use
‘global-prettify-symbols-mode’ to enable it for all modes that
support it.

(fn &optional ARG)〉〉enditem49840〈〈previous-buffer〉〉:〈〈In selected window switch to previous buffer.〉〉enditem49840〈〈previous-completion〉〉:〈〈Move to the previous item in the completion list.

(fn N)〉〉enditem49840〈〈previous-error〉〉:〈〈Visit previous ‘next-error’ message and corresponding source code.

Prefix arg N says how many error messages to move backwards (or
forwards, if negative).

This operates on the output from the M-x compile and M-x grep commands.

(fn &optional N)〉〉enditem49840〈〈previous-line-or-history-element〉〉:〈〈Move cursor vertically up ARG lines, or to the previous history element.
When point moves over the top line of multi-line minibuffer, puts ARGth
previous element of the minibuffer history in the minibuffer.

(fn &optional ARG)〉〉enditem49840〈〈previous-line〉〉:〈〈Move cursor vertically up ARG lines.
Interactively, vscroll tall lines if ‘auto-window-vscroll’ is enabled.
Non-interactively, use TRY-VSCROLL to control whether to vscroll tall
lines: if either ‘auto-window-vscroll’ or TRY-VSCROLL is nil, this
function will not vscroll.

ARG defaults to 1.

If there is no character in the target line exactly over the current column,
the cursor is positioned after the character in that line which spans this
column, or at the end of the line if it is not long enough.

If the variable ‘line-move-visual’ is non-nil, this command moves
by display lines.  Otherwise, it moves by buffer lines, without
taking variable-width characters or continued lines into account.
See M-x previous-logical-line for a command that always moves by buffer lines.

The command C-x C-n can be used to create
a semipermanent goal column for this command.
Then instead of trying to move exactly vertically (or as close as possible),
this command moves to the specified goal column (or as close as possible).
The goal column is stored in the variable ‘goal-column’, which is nil
when there is no goal column.  Note that setting ‘goal-column’
overrides ‘line-move-visual’ and causes this command to move by buffer
lines rather than by display lines.

(fn &optional ARG TRY-VSCROLL)〉〉enditem49840〈〈previous-logical-line〉〉:〈〈Move cursor vertically up ARG lines.
This is identical to ‘previous-line’, except that it always moves
by logical lines instead of visual lines, ignoring the value of
the variable ‘line-move-visual’.

(fn &optional ARG TRY-VSCROLL)〉〉enditem49840〈〈prin1〉〉:〈〈Output the printed representation of OBJECT, any Lisp object.
Quoting characters are printed when needed to make output that ‘read’
can handle, whenever this is possible.  For complex objects, the behavior
is controlled by ‘print-level’ and ‘print-length’, which see.

OBJECT is any of the Lisp data types: a number, a string, a symbol,
a list, a buffer, a window, a frame, etc.

A printed representation of an object is text which describes that object.

Optional argument PRINTCHARFUN is the output stream, which can be one
of these:

   - a buffer, in which case output is inserted into that buffer at point;
   - a marker, in which case output is inserted at marker’s position;
   - a function, in which case that function is called once for each
     character of OBJECT’s printed representation;
   - a symbol, in which case that symbol’s function definition is called; or
   - t, in which case the output is displayed in the echo area.

If PRINTCHARFUN is omitted, the value of ‘standard-output’ (which see)
is used instead.

(fn OBJECT &optional PRINTCHARFUN)〉〉enditem49840〈〈print-buffer〉〉:〈〈Paginate and print buffer contents.

The variable ‘lpr-headers-switches’ controls how to paginate.
If it is nil (the default), we run the ‘pr’ program (or whatever program
‘lpr-page-header-program’ specifies) to paginate.
‘lpr-page-header-switches’ specifies the switches for that program.

Otherwise, the switches in ‘lpr-headers-switches’ are used
in the print command itself; we expect them to request pagination.

See the variables ‘lpr-switches’ and ‘lpr-command’
for further customization of the printer command.

(fn)〉〉enditem49840〈〈print-region〉〉:〈〈Paginate and print the region contents.

The variable ‘lpr-headers-switches’ controls how to paginate.
If it is nil (the default), we run the ‘pr’ program (or whatever program
‘lpr-page-header-program’ specifies) to paginate.
‘lpr-page-header-switches’ specifies the switches for that program.

Otherwise, the switches in ‘lpr-headers-switches’ are used
in the print command itself; we expect them to request pagination.

See the variables ‘lpr-switches’ and ‘lpr-command’
for further customization of the printer command.

(fn START END)〉〉enditem49840〈〈ps-despool〉〉:〈〈Send the spooled PostScript to the printer.

Interactively, when you use a prefix argument (C-u), the command prompts the
user for a file name, and saves the spooled PostScript image in that file
instead of sending it to the printer.

Noninteractively, the argument FILENAME is treated as follows: if it is nil,
send the image to the printer.  If FILENAME is a string, save the PostScript
image in a file with that name.

(fn &optional FILENAME)〉〉enditem49840〈〈ps-print-buffer-with-faces〉〉:〈〈Generate and print a PostScript image of the buffer.
Like ‘ps-print-buffer’, but includes font, color, and underline information in
the generated image.  This command works only if you are using a window system,
so it has a way to determine color values.

(fn &optional FILENAME)〉〉enditem49840〈〈ps-print-buffer〉〉:〈〈Generate and print a PostScript image of the buffer.

Interactively, when you use a prefix argument (C-u), the command prompts the
user for a file name, and saves the PostScript image in that file instead of
sending it to the printer.

Noninteractively, the argument FILENAME is treated as follows: if it is nil,
send the image to the printer.  If FILENAME is a string, save the PostScript
image in a file with that name.

(fn &optional FILENAME)〉〉enditem49840〈〈ps-print-region-with-faces〉〉:〈〈Generate and print a PostScript image of the region.
Like ‘ps-print-region’, but includes font, color, and underline information in
the generated image.  This command works only if you are using a window system,
so it has a way to determine color values.

(fn FROM TO &optional FILENAME)〉〉enditem49840〈〈ps-print-region〉〉:〈〈Generate and print a PostScript image of the region.
Like ‘ps-print-buffer’, but prints just the current region.

(fn FROM TO &optional FILENAME)〉〉enditem49840〈〈ps-spool-buffer-with-faces〉〉:〈〈Generate and spool a PostScript image of the buffer.
Like the command ‘ps-spool-buffer’, but includes font, color, and underline
information in the generated image.  This command works only if you are using
a window system, so it has a way to determine color values.

Use the command ‘ps-despool’ to send the spooled images to the printer.

(fn)〉〉enditem49840〈〈ps-spool-buffer〉〉:〈〈Generate and spool a PostScript image of the buffer.
Like ‘ps-print-buffer’ except that the PostScript image is saved in a local
buffer to be sent to the printer later.

Use the command ‘ps-despool’ to send the spooled images to the printer.

(fn)〉〉enditem49840〈〈ps-spool-region-with-faces〉〉:〈〈Generate a PostScript image of the region and spool locally.
Like ‘ps-spool-region’, but includes font, color, and underline information in
the generated image.  This command works only if you are using a window system,
so it has a way to determine color values.

Use the command ‘ps-despool’ to send the spooled images to the printer.

(fn FROM TO)〉〉enditem49840〈〈ps-spool-region〉〉:〈〈Generate a PostScript image of the region and spool locally.
Like ‘ps-spool-buffer’, but spools just the current region.

Use the command ‘ps-despool’ to send the spooled images to the printer.

(fn FROM TO)〉〉enditem49840〈〈pwd〉〉:〈〈Show the current default directory.
With prefix argument INSERT, insert the current default directory
at point instead.

(fn &optional INSERT)〉〉enditem49840〈〈quail-set-keyboard-layout〉〉:〈〈Set the current keyboard layout to the same as keyboard KBD-TYPE.

Since some Quail packages depends on a physical layout of keys (not
characters generated by them), those are created by assuming the
standard layout defined in ‘quail-keyboard-layout-standard’.  This
function tells Quail system the layout of your keyboard so that what
you type is correctly handled.

(fn KBD-TYPE)〉〉enditem49840〈〈query-replace-regexp〉〉:〈〈Replace some things after point matching REGEXP with TO-STRING.
As each match is found, the user must type a character saying
what to do with it.  For directions, type C-h at that time.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer’s
accessible portion.

Use M-n to pull the last incremental search regexp to the minibuffer
that reads REGEXP, or invoke replacements from
incremental search with a key sequence like ‘C-M-s C-M-s C-M-%’
to use its current search regexp as the regexp to replace.

Matching is independent of case if ‘case-fold-search’ is non-nil and
REGEXP has no uppercase letters.  Replacement transfers the case
pattern of the old text to the new text, if ‘case-replace’ and
‘case-fold-search’ are non-nil and REGEXP has no uppercase letters.
(Transferring the case pattern means that if the old text matched is
all caps, or capitalized, then its replacement is upcased or
capitalized.)

Ignore read-only matches if ‘query-replace-skip-read-only’ is non-nil,
ignore hidden matches if ‘search-invisible’ is nil, and ignore more
matches using ‘isearch-filter-predicate’.

If ‘replace-regexp-lax-whitespace’ is non-nil, a space or spaces in the regexp
to be replaced will match a sequence of whitespace chars defined by the
regexp in ‘search-whitespace-regexp’.

This function is not affected by ‘replace-char-fold’.

Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace
only matches surrounded by word boundaries.  A negative prefix arg means
replace backward.

Fourth and fifth arg START and END specify the region to operate on.

In TO-STRING, ‘\&’ stands for whatever matched the whole of REGEXP,
and ‘\N’ (where N is a digit) stands for whatever matched
the Nth ‘\(...\)’ (1-based) in REGEXP.  The ‘\(...\)’ groups are
counted from 1.
‘\?’ lets you edit the replacement text in the minibuffer
at the given position for each replacement.

In interactive calls, the replacement text can contain ‘\,’
followed by a Lisp expression.  Each
replacement evaluates that expression to compute the replacement
string.  Inside of that expression, ‘\&’ is a string denoting the
whole match as a string, ‘\N’ for a partial match, ‘\#&’ and ‘\#N’
for the whole or a partial match converted to a number with
‘string-to-number’, and ‘\#’ itself for the number of replacements
done so far (starting with zero).

If the replacement expression is a symbol, write a space after it
to terminate it.  One space there, if any, will be discarded.

When using those Lisp features interactively in the replacement
text, TO-STRING is actually made a list instead of a string.
Use C-x M-: after this command for details.

(fn REGEXP TO-STRING &optional DELIMITED START END BACKWARD REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈query-replace〉〉:〈〈Replace some occurrences of FROM-STRING with TO-STRING.
As each match is found, the user must type a character saying
what to do with it.  For directions, type C-h at that time.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer’s
accessible portion.

In interactive use, the prefix arg (non-nil DELIMITED in
non-interactive use), means replace only matches surrounded by
word boundaries.  A negative prefix arg means replace backward.

Use M-n to pull the last incremental search string to the minibuffer
that reads FROM-STRING, or invoke replacements from
incremental search with a key sequence like ‘C-s C-s M-%’
to use its current search string as the string to replace.

Matching is independent of case if ‘case-fold-search’ is non-nil and
FROM-STRING has no uppercase letters.  Replacement transfers the case
pattern of the old text to the new text, if ‘case-replace’ and
‘case-fold-search’ are non-nil and FROM-STRING has no uppercase
letters.  (Transferring the case pattern means that if the old text
matched is all caps, or capitalized, then its replacement is upcased
or capitalized.)

Ignore read-only matches if ‘query-replace-skip-read-only’ is non-nil,
ignore hidden matches if ‘search-invisible’ is nil, and ignore more
matches using ‘isearch-filter-predicate’.

If ‘replace-lax-whitespace’ is non-nil, a space or spaces in the string
to be replaced will match a sequence of whitespace chars defined by the
regexp in ‘search-whitespace-regexp’.

If ‘replace-char-fold’ is non-nil, matching uses character folding,
i.e. it ignores diacritics and other differences between equivalent
character strings.

Fourth and fifth arg START and END specify the region to operate on.

To customize possible responses, change the bindings in ‘query-replace-map’.

(fn FROM-STRING TO-STRING &optional DELIMITED START END BACKWARD REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈quoted-insert〉〉:〈〈Read next input character and insert it.
This is useful for inserting control characters.
With argument, insert ARG copies of the character.

If the first character you type after this command is an octal digit,
you should type a sequence of octal digits which specify a character code.
Any nondigit terminates the sequence.  If the terminator is a RET,
it is discarded; any other terminator is used itself as input.
The variable ‘read-quoted-char-radix’ specifies the radix for this feature;
set it to 10 or 16 to use decimal or hex instead of octal.

In overwrite mode, this function inserts the character anyway, and
does not handle octal digits specially.  This means that if you use
overwrite as your normal editing mode, you can use this function to
insert characters when necessary.

In binary overwrite mode, this function does overwrite, and octal
digits are interpreted as a character code.  This is intended to be
useful for editing binary files.

(fn ARG)〉〉enditem49840〈〈read-abbrev-file〉〉:〈〈Read abbrev definitions from file written with ‘write-abbrev-file’.
Optional argument FILE is the name of the file to read;
it defaults to the value of ‘abbrev-file-name’.
Optional second argument QUIETLY non-nil means don’t display a message.

(fn &optional FILE QUIETLY)〉〉enditem49840〈〈recentf-edit-list〉〉:〈〈Show a dialog to delete selected files from the recent list.〉〉enditem49840〈〈recentf-mode〉〉:〈〈Toggle "Open Recent" menu (Recentf mode).
With a prefix argument ARG, enable Recentf mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Recentf mode if ARG is omitted or nil.

When Recentf mode is enabled, a "Open Recent" submenu is
displayed in the "File" menu, containing a list of files that
were operated on recently.〉〉enditem49840〈〈recentf-save-list〉〉:〈〈Save the recent list.
Write data into the file specified by ‘recentf-save-file’.〉〉enditem49840〈〈recode-file-name〉〉:〈〈Change the encoding of FILE’s name from CODING to NEW-CODING.
The value is a new name of FILE.
Signals a ‘file-already-exists’ error if a file of the new name
already exists unless optional fourth argument OK-IF-ALREADY-EXISTS
is non-nil.  A number as fourth arg means request confirmation if
the new name already exists.  This is what happens in interactive
use with M-x.

(fn FILE CODING NEW-CODING &optional OK-IF-ALREADY-EXISTS)〉〉enditem49840〈〈recode-region〉〉:〈〈Re-decode the region (previously decoded by CODING) by NEW-CODING.〉〉enditem49840〈〈recover-file〉〉:〈〈Visit file FILE, but get contents from its last auto-save file.

(fn FILE)〉〉enditem49840〈〈recover-session〉〉:〈〈Recover auto save files from a previous Emacs session.
This command first displays a Dired buffer showing you the
previous sessions that you could recover from.
To choose one, move point to the proper line and then type C-c C-c.
Then you’ll be asked about a number of files to recover.〉〉enditem49840〈〈rectangle-mark-mode〉〉:〈〈Toggle the region as rectangular.
Activates the region if needed.  Only lasts until the region is deactivated.

(fn &optional ARG)〉〉enditem49840〈〈rectangle-number-lines〉〉:〈〈Insert numbers in front of the region-rectangle.

START-AT, if non-nil, should be a number from which to begin
counting.  FORMAT, if non-nil, should be a format string to pass
to ‘format’ along with the line count.  When called interactively
with a prefix argument, prompt for START-AT and FORMAT.

(fn START END START-AT &optional FORMAT)〉〉enditem49840〈〈rename-uniquely〉〉:〈〈Rename current buffer to a similar name not already taken.
This function is useful for creating multiple shell process buffers
or multiple mail buffers, etc.

Note that some commands, in particular those based on ‘compilation-mode’
(‘compile’, ‘grep’, etc.) will reuse the current buffer if it has the
appropriate mode even if it has been renamed.  So as well as renaming
the buffer, you also need to switch buffers before running another
instance of such commands.〉〉enditem49840〈〈repeat-complex-command〉〉:〈〈Edit and re-evaluate last complex command, or ARGth from last.
A complex command is one which used the minibuffer.
The command is placed in the minibuffer as a Lisp form for editing.
The result is executed, repeating the command as changed.
If the command has been changed or is not the most recent previous
command it is added to the front of the command history.
You can use the minibuffer history commands M-n and M-p
to get different commands to edit and resubmit.

(fn ARG)〉〉enditem49840〈〈repeat〉〉:〈〈Repeat most recently executed command.
If REPEAT-ARG is non-nil (interactively, with a prefix argument),
supply a prefix argument to that command.  Otherwise, give the
command the same prefix argument it was given before, if any.

If this command is invoked by a multi-character key sequence, it
can then be repeated by repeating the final character of that
sequence.  This behavior can be modified by the global variable
‘repeat-on-final-keystroke’.

‘repeat’ ignores commands bound to input events.  Hence the term
"most recently executed command" shall be read as "most
recently executed command not bound to an input event".

(fn REPEAT-ARG)〉〉enditem49840〈〈replace-regexp〉〉:〈〈Replace things after point matching REGEXP with TO-STRING.
Preserve case in each match if ‘case-replace’ and ‘case-fold-search’
are non-nil and REGEXP has no uppercase letters.

Ignore read-only matches if ‘query-replace-skip-read-only’ is non-nil,
ignore hidden matches if ‘search-invisible’ is nil, and ignore more
matches using ‘isearch-filter-predicate’.

If ‘replace-regexp-lax-whitespace’ is non-nil, a space or spaces in the regexp
to be replaced will match a sequence of whitespace chars defined by the
regexp in ‘search-whitespace-regexp’.

This function is not affected by ‘replace-char-fold’

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer’s
accessible portion.

Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace
only matches surrounded by word boundaries.  A negative prefix arg means
replace backward.

Fourth and fifth arg START and END specify the region to operate on.

In TO-STRING, ‘\&’ stands for whatever matched the whole of REGEXP,
and ‘\N’ (where N is a digit) stands for whatever matched
the Nth ‘\(...\)’ (1-based) in REGEXP.
‘\?’ lets you edit the replacement text in the minibuffer
at the given position for each replacement.

In interactive calls, the replacement text may contain ‘\,’
followed by a Lisp expression used as part of the replacement
text.  Inside of that expression, ‘\&’ is a string denoting the
whole match, ‘\N’ a partial match, ‘\#&’ and ‘\#N’ the respective
numeric values from ‘string-to-number’, and ‘\#’ itself for
‘replace-count’, the number of replacements occurred so far, starting
from zero.

If your Lisp expression is an identifier and the next letter in
the replacement string would be interpreted as part of it, you
can wrap it with an expression like ‘\,(or \#)’.  Incidentally,
for this particular case you may also enter ‘\#’ in the
replacement text directly.

When using those Lisp features interactively in the replacement
text, TO-STRING is actually made a list instead of a string.
Use DEL t n after this command for details.

Use M-n to pull the last incremental search regexp to the minibuffer
that reads REGEXP.

This function is usually the wrong thing to use in a Lisp program.
What you probably want is a loop like this:
  (while (re-search-forward REGEXP nil t)
    (replace-match TO-STRING nil nil))
which will run faster and will not set the mark or print anything.

(fn REGEXP TO-STRING &optional DELIMITED START END BACKWARD)〉〉enditem49840〈〈replace-string〉〉:〈〈Replace occurrences of FROM-STRING with TO-STRING.
Preserve case in each match if ‘case-replace’ and ‘case-fold-search’
are non-nil and FROM-STRING has no uppercase letters.
(Preserving case means that if the string matched is all caps, or capitalized,
then its replacement is upcased or capitalized.)

Ignore read-only matches if ‘query-replace-skip-read-only’ is non-nil,
ignore hidden matches if ‘search-invisible’ is nil, and ignore more
matches using ‘isearch-filter-predicate’.

If ‘replace-lax-whitespace’ is non-nil, a space or spaces in the string
to be replaced will match a sequence of whitespace chars defined by the
regexp in ‘search-whitespace-regexp’.

If ‘replace-char-fold’ is non-nil, matching uses character folding,
i.e. it ignores diacritics and other differences between equivalent
character strings.

Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace
only matches surrounded by word boundaries.  A negative prefix arg means
replace backward.

Operates on the region between START and END (if both are nil, from point
to the end of the buffer).  Interactively, if Transient Mark mode is
enabled and the mark is active, operates on the contents of the region;
otherwise from point to the end of the buffer’s accessible portion.

Use M-n to pull the last incremental search string to the minibuffer
that reads FROM-STRING.

This function is usually the wrong thing to use in a Lisp program.
What you probably want is a loop like this:
  (while (search-forward FROM-STRING nil t)
    (replace-match TO-STRING nil t))
which will run faster and will not set the mark or print anything.
(You may need a more complex loop if FROM-STRING can match the null string
and TO-STRING is also null.)

(fn FROM-STRING TO-STRING &optional DELIMITED START END BACKWARD)〉〉enditem49840〈〈report-emacs-bug〉〉:〈〈Report a bug in GNU Emacs.
Prompts for bug subject.  Leaves you in a mail buffer.

(fn TOPIC &optional UNUSED)〉〉enditem49840〈〈reposition-window〉〉:〈〈Make the current definition and/or comment visible.
Further invocations move it to the top of the window or toggle the
visibility of comments that precede it.
  Point is left unchanged unless prefix ARG is supplied.
  If the definition is fully onscreen, it is moved to the top of the
window.  If it is partly offscreen, the window is scrolled to get the
definition (or as much as will fit) onscreen, unless point is in a comment
which is also partly offscreen, in which case the scrolling attempts to get
as much of the comment onscreen as possible.
  Initially ‘reposition-window’ attempts to make both the definition and
preceding comments visible.  Further invocations toggle the visibility of
the comment lines.
  If ARG is non-nil, point may move in order to make the whole defun
visible (if only part could otherwise be made so), to make the defun line
visible (if point is in code and it could not be made so, or if only
comments, including the first comment line, are visible), or to make the
first comment line visible (if point is in a comment).

(fn &optional ARG)〉〉enditem49840〈〈return〉〉:〈〈Return from the block named nil.
This is equivalent to ‘(cl-return-from nil RESULT)’.

(fn &optional RESULT)〉〉enditem49840〈〈reveal-mode〉〉:〈〈Toggle uncloaking of invisible text near point (Reveal mode).
With a prefix argument ARG, enable Reveal mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Reveal mode if ARG is omitted or nil.

Reveal mode is a buffer-local minor mode.  When enabled, it
reveals invisible text around point.

(fn &optional ARG)〉〉enditem49840〈〈reverse-region〉〉:〈〈Reverse the order of lines in a region.
From a program takes two point or marker arguments, BEG and END.

(fn BEG END)〉〉enditem49840〈〈revert-buffer-with-coding-system〉〉:〈〈Visit the current buffer’s file again using coding system CODING-SYSTEM.
For a list of possible values of CODING-SYSTEM, use M-x list-coding-systems.

If CODING-SYSTEM leaves the text conversion unspecified, or if it leaves
the end-of-line conversion unspecified, FORCE controls what to do.
If FORCE is nil, get the unspecified aspect (or aspects) from the buffer’s
previous ‘buffer-file-coding-system’ value (if it is specified there).
Otherwise, determine it from the file contents as usual for visiting a file.〉〉enditem49840〈〈rgrep〉〉:〈〈Recursively grep for REGEXP in FILES in directory tree rooted at DIR.
The search is limited to file names matching shell pattern FILES.
FILES may use abbreviations defined in ‘grep-files-aliases’, e.g.
entering ‘ch’ is equivalent to ‘*.[ch]’.  As whitespace triggers
completion when entering a pattern, including it requires
quoting, e.g. ‘C-q<space>’.

With C-u prefix, you can edit the constructed shell command line
before it is executed.
With two C-u prefixes, directly edit and run ‘grep-find-command’.

Collect output in a buffer.  While the recursive grep is running,
you can use C-x ` (M-x next-error), or RET in the grep output buffer,
to visit the lines where matches were found.  To kill the job
before it finishes, type C-c C-k.

This command shares argument histories with M-x lgrep and M-x grep-find.

When called programmatically and FILES is nil, REGEXP is expected
to specify a command to run.

(fn REGEXP &optional FILES DIR CONFIRM)〉〉enditem49840〈〈right-char〉〉:〈〈Move point N characters to the right (to the left if N is negative).
On reaching beginning or end of buffer, stop and signal error.

If ‘visual-order-cursor-movement’ is non-nil, this always moves
to the right on display, wherever that is in the buffer.
Otherwise, depending on the bidirectional context, this may move
one position either forward or backward in the buffer.  This is
in contrast with n and h, which
see.〉〉enditem49840〈〈right-word〉〉:〈〈Move point N words to the right (to the left if N is negative).

Depending on the bidirectional context, this may move either forward
or backward in the buffer.  This is in contrast with r
and g, which see.

Value is normally t.
If an edge of the buffer or a field boundary is reached, point is left there
and the function returns nil.  Field boundaries are not noticed
if ‘inhibit-field-text-motion’ is non-nil.〉〉enditem49840〈〈rlogin〉〉:〈〈Open a network login connection via ‘rlogin’ with args INPUT-ARGS.
INPUT-ARGS should start with a host name; it may also contain
other arguments for ‘rlogin’.

Input is sent line-at-a-time to the remote connection.

Communication with the remote host is recorded in a buffer ‘*rlogin-HOST*’
(or ‘*rlogin-USER@HOST*’ if the remote username differs).
If a prefix argument is given and the buffer ‘*rlogin-HOST*’ already exists,
a new buffer with a different connection will be made.

When called from a program, if the optional second argument BUFFER is
a string or buffer, it specifies the buffer to use.

The variable ‘rlogin-program’ contains the name of the actual program to
run.  It can be a relative or absolute path.

The variable ‘rlogin-explicit-args’ is a list of arguments to give to
the rlogin when starting.  They are added after any arguments given in
INPUT-ARGS.

If the default value of ‘rlogin-directory-tracking-mode’ is t, then the
default directory in that buffer is set to a remote (FTP) file name to
access your home directory on the remote machine.  Occasionally this causes
an error, if you cannot access the home directory on that machine.  This
error is harmless as long as you don’t try to use that default directory.

If ‘rlogin-directory-tracking-mode’ is neither t nor nil, then the default
directory is initially set up to your (local) home directory.
This is useful if the remote machine and your local machine
share the same files via NFS.  This is the default.

If you wish to change directory tracking styles during a session, use the
function ‘rlogin-directory-tracking-mode’ rather than simply setting the
variable.

(fn INPUT-ARGS &optional BUFFER)〉〉enditem49840〈〈rmail-input〉〉:〈〈Run Rmail on file FILENAME.

(fn FILENAME)〉〉enditem49840〈〈rmail-mode〉〉:〈〈Rmail Mode is used by M-x rmail for editing Rmail files.
All normal editing commands are turned off.
Instead, these commands are available:

.	Move point to front of this message.
/	Move point to bottom of this message.
<S-next>	Scroll to next screen of this message.
<S-prior>	Scroll to previous screen of this message.
n	Move to Next non-deleted message.
p	Move to Previous non-deleted message.
M-n	Move to Next message whether deleted or not.
M-p	Move to Previous message whether deleted or not.
<	Move to the first message in Rmail file.
>	Move to the last message in Rmail file.
j	Jump to message specified by numeric position in file.
M-s	Search for string and show message it is found in.
d	Delete this message, move to next nondeleted.
C-d	Delete this message, move to previous nondeleted.
u	Undelete message.  Tries current message, then earlier messages
	till a deleted message is found.
e	Edit the current message.  M-x rmail-cease-edit to return to Rmail.
x	Expunge deleted messages.
s	Expunge and save the file.
q       Quit Rmail: expunge, save, then switch to another buffer.
C-x C-s Save without expunging.
g	Move new mail from system spool directory into this file.
m	Mail a message (same as M-x mail-other-window).
c	Continue composing outgoing message started before.
r	Reply to this message.  Like m but initializes some fields.
M-m	Send this message again.  Used on a mailer failure message.
f	Forward this message to another user.
o	Output (append) this message to another mail file.
C-o	Output (append) this message to file as it’s displayed.
w	Save message body to a file.  Default filename comes from Subject line.
i	Input Rmail file.  Run Rmail on that file.
a	Add label to message.  It will be displayed in the mode line.
k	Kill label.  Remove a label from current message.
C-M-n   Move to Next message with specified label
          (label defaults to last one specified).
          Standard labels: filed, unseen, answered, forwarded, deleted.
          Any other label is present only if you add it with a.
C-M-p   Move to Previous message with specified label
h	Show headers buffer, with a one line summary of each message.
l	Summarize only messages with particular label(s).
C-M-r   Summarize only messages with particular recipient(s).
C-M-s   Summarize only messages with particular regexp(s).
C-M-t   Summarize only messages with subject line regexp(s).
t	Toggle display of complete header.〉〉enditem49840〈〈rmail-output-as-seen〉〉:〈〈Append this message to mbox file named FILE-NAME.
The details are as for ‘rmail-output’, except that:
  i) the header is output as currently seen
 ii) this function cannot write to Babyl files
iii) an Rmail buffer cannot be visiting FILE-NAME

Note that if NOT-RMAIL is non-nil, there is no difference between this
function and ‘rmail-output’.  This argument may be removed in future,
so you should call ‘rmail-output’ directly in that case.

(fn FILE-NAME &optional COUNT NOATTRIBUTE NOT-RMAIL)〉〉enditem49840〈〈rmail-output-body-to-file〉〉:〈〈Write this message body to the file FILE-NAME.
Interactively, the default file name comes from either the message
"Subject" header, or from ‘rmail-default-body-file’.  Updates the value
of ‘rmail-default-body-file’ accordingly.  In all uses, if FILE-NAME
is not absolute, it is expanded with the directory part of
‘rmail-default-body-file’.

Note that this overwrites FILE-NAME (after confirmation), rather
than appending to it.  Deletes the message after writing if
‘rmail-delete-after-output’ is non-nil.

(fn FILE-NAME)〉〉enditem49840〈〈rmail-output〉〉:〈〈nil〉〉enditem49840〈〈rmail-show-message〉〉:〈〈Show message number N (prefix argument), counting from start of file.
If summary buffer is currently displayed, update current message there also.
N defaults to the current message.

(fn &optional N NO-SUMMARY)〉〉enditem49840〈〈rmail〉〉:〈〈Read and edit incoming mail.
Moves messages into file named by ‘rmail-file-name’ and edits that
file in RMAIL Mode.
Type C-h m once editing that file, for a list of RMAIL commands.

May be called with file name as argument; then performs rmail editing on
that file, but does not copy any new mail into the file.
Interactively, if you supply a prefix argument, then you
have a chance to specify a file name with the minibuffer.

If ‘rmail-display-summary’ is non-nil, make a summary for this RMAIL file.

(fn &optional FILE-NAME-ARG)〉〉enditem49840〈〈rot13-other-window〉〉:〈〈Display current buffer in ROT13 in another window.
The text itself is not modified, only the way it is displayed is affected.

To terminate the ROT13 display, delete that window.  As long as that window
is not deleted, any buffer displayed in it will become instantly encoded
in ROT13.

See also ‘toggle-rot13-mode’.

(fn)〉〉enditem49840〈〈run-lisp〉〉:〈〈Run an inferior Lisp process, input and output via buffer ‘*inferior-lisp*’.
If there is a process already running in ‘*inferior-lisp*’, just switch
to that buffer.
With argument, allows you to edit the command line (default is value
of ‘inferior-lisp-program’).  Runs the hooks from
‘inferior-lisp-mode-hook’ (after the ‘comint-mode-hook’ is run).
(Type C-h m in the process buffer for a list of commands.)

(fn CMD)〉〉enditem49840〈〈run-scheme〉〉:〈〈Run an inferior Scheme process, input and output via buffer ‘*scheme*’.
If there is a process already running in ‘*scheme*’, switch to that buffer.
With argument, allows you to edit the command line (default is value
of ‘scheme-program-name’).
If the file ‘~/.emacs_SCHEMENAME’ or ‘~/.emacs.d/init_SCHEMENAME.scm’ exists,
it is given as initial input.
Note that this may lose due to a timing error if the Scheme processor
discards input when it starts up.
Runs the hook ‘inferior-scheme-mode-hook’ (after the ‘comint-mode-hook’
is run).
(Type C-h m in the process buffer for a list of commands.)

(fn CMD)〉〉enditem49840〈〈save-buffers-kill-terminal〉〉:〈〈Offer to save each buffer, then kill the current connection.
If the current frame has no client, kill Emacs itself using
‘save-buffers-kill-emacs’.

With prefix ARG, silently save all file-visiting buffers, then kill.

If emacsclient was started with a list of filenames to edit, then
only these files will be asked to be saved.

(fn &optional ARG)〉〉enditem49840〈〈scheme-mode〉〉:〈〈Major mode for editing Scheme code.
Editing commands are similar to those of ‘lisp-mode’.

In addition, if an inferior Scheme process is running, some additional
commands will be defined, for evaluating expressions and controlling
the interpreter, and the state of the process will be displayed in the
mode line of all Scheme buffers.  The names of commands that interact
with the Scheme process start with "xscheme-" if you use the MIT
Scheme-specific ‘xscheme’ package; for more information see the
documentation for ‘xscheme-interaction-mode’.  Use M-x run-scheme to
start an inferior Scheme using the more general ‘cmuscheme’ package.

Commands:
Delete converts tabs to spaces as it moves back.
Blank lines separate paragraphs.  Semicolons start comments.

Uses keymap ‘scheme-mode-map’, which is not currently defined.


(fn)〉〉enditem49840〈〈scroll-all-mode〉〉:〈〈Toggle shared scrolling in same-frame windows (Scroll-All mode).
With a prefix argument ARG, enable Scroll-All mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Scroll-All mode is enabled, scrolling commands invoked in
one window apply to all visible windows in the same frame.

(fn &optional ARG)〉〉enditem49840〈〈scroll-bar-mode〉〉:〈〈Toggle vertical scroll bars on all frames (Scroll Bar mode).
With a prefix argument ARG, enable Scroll Bar mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

This command applies to all frames that exist and frames to be
created in the future.〉〉enditem49840〈〈scroll-down-line〉〉:〈〈Scroll text of selected window down ARG lines; or one line if no ARG.
If ARG is omitted or nil, scroll down by one line.
This is different from ‘scroll-down-command’ that scrolls a full screen.

(fn &optional ARG)〉〉enditem49840〈〈scroll-other-window-down〉〉:〈〈Scroll the "other window" down.
For more details, see the documentation for ‘scroll-other-window’.

(fn &optional LINES)〉〉enditem49840〈〈scroll-up-line〉〉:〈〈Scroll text of selected window upward ARG lines; or one line if no ARG.
If ARG is omitted or nil, scroll upward by one line.
This is different from ‘scroll-up-command’ that scrolls a full screen.

(fn &optional ARG)〉〉enditem49840〈〈sdb〉〉:〈〈Run sdb on program FILE in buffer *gud-FILE*.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.

(fn COMMAND-LINE)〉〉enditem49840〈〈select-frame-by-name〉〉:〈〈Select the frame whose name is NAME and raise it.
Frames on the current terminal are checked first.
If there is no frame by that name, signal an error.

(fn NAME)〉〉enditem49840〈〈send-invisible〉〉:〈〈Read a string without echoing.
Then send it to the process running in the current buffer.
The string is sent using ‘comint-input-sender’.
Security bug: your string can still be temporarily recovered with
DEL h l; ‘clear-this-command-keys’ can fix that.

(fn &optional PROMPT)〉〉enditem49840〈〈sendmail-query-once〉〉:〈〈Query for ‘send-mail-function’ and send mail with it.
This also saves the value of ‘send-mail-function’ via Customize.

(fn)〉〉enditem49840〈〈server-start〉〉:〈〈Allow this Emacs process to be a server for client processes.
This starts a server communications subprocess through which client
"editors" can send your editing commands to this Emacs job.
To use the server, set up the program ‘emacsclient’ in the Emacs
distribution as your standard "editor".

Optional argument LEAVE-DEAD (interactively, a prefix arg) means just
kill any existing server communications subprocess.

If a server is already running, restart it.  If clients are
running, ask the user for confirmation first, unless optional
argument INHIBIT-PROMPT is non-nil.

To force-start a server, do M-x server-force-delete and then
M-x server-start.

(fn &optional LEAVE-DEAD INHIBIT-PROMPT)〉〉enditem49840〈〈set-buffer-file-coding-system〉〉:〈〈Set the file coding-system of the current buffer to CODING-SYSTEM.
This means that when you save the buffer, it will be converted
according to CODING-SYSTEM.  For a list of possible values of
CODING-SYSTEM, use M-x list-coding-systems.

If CODING-SYSTEM leaves the text conversion unspecified, or if it leaves
the end-of-line conversion unspecified, FORCE controls what to do.
If FORCE is nil, get the unspecified aspect (or aspects) from the buffer’s
previous ‘buffer-file-coding-system’ value (if it is specified there).
Otherwise, leave it unspecified.

This marks the buffer modified so that the succeeding C-s
surely saves the buffer with CODING-SYSTEM.  From a program, if you
don’t want to mark the buffer modified, specify t for NOMODIFY.
If you know exactly what coding system you want to use,
just set the variable ‘buffer-file-coding-system’ directly.〉〉enditem49840〈〈set-buffer-process-coding-system〉〉:〈〈Set coding systems for the process associated with the current buffer.
DECODING is the coding system to be used to decode input from the process,
ENCODING is the coding system to be used to encode output to the process.

For a list of possible coding systems, use M-x list-coding-systems.〉〉enditem49840〈〈set-file-name-coding-system〉〉:〈〈Set coding system for decoding and encoding file names to CODING-SYSTEM.
It actually just set the variable ‘file-name-coding-system’ (which see)
to CODING-SYSTEM.〉〉enditem49840〈〈set-fill-column〉〉:〈〈Set ‘fill-column’ to specified argument.
Use C-u followed by a number to specify a column.
Just C-u as argument means to use the current column.

(fn ARG)〉〉enditem49840〈〈set-fill-prefix〉〉:〈〈Set the fill prefix to the current line up to point.
Filling expects lines to start with the fill prefix and
reinserts the fill prefix in each resulting line.〉〉enditem49840〈〈set-frame-name〉〉:〈〈Set the name of the selected frame to NAME.
When called interactively, prompt for the name of the frame.
On text terminals, the frame name is displayed on the mode line.
On graphical displays, it is displayed on the frame’s title bar.

(fn NAME)〉〉enditem49840〈〈set-fringe-style〉〉:〈〈Set the default appearance of fringes on the selected frame.
When called interactively, query the user for MODE; valid values
are ‘no-fringes’, ‘default’, ‘left-only’, ‘right-only’, ‘minimal’
and ‘half-width’.  See ‘fringe-styles’.

When used in a Lisp program, MODE should be one of these:
- nil, which means the default width (8 pixels).
- a cons cell (LEFT . RIGHT), where LEFT and RIGHT are
  respectively the left and right fringe widths in pixels, or
  nil (meaning the default width).
- a single integer, which specifies the pixel widths of both
  fringes.
This command may round up the left and right width specifications
to ensure that their sum is a multiple of the character width of
a frame.  It never rounds up a fringe width of 0.

Fringe widths set by ‘set-window-fringes’ override the default
fringe widths set by this command.  If you want to set the
default appearance of fringes on all frames, see the command
‘fringe-mode’.〉〉enditem49840〈〈set-goal-column〉〉:〈〈Set the current horizontal position as a goal for t and c.
Those commands will move to this position in the line moved to
rather than trying to keep the same horizontal position.
With a non-nil argument ARG, clears out the goal column
so that t and c resume vertical motion.
The goal column is stored in the variable ‘goal-column’.
This is a buffer-local setting.

(fn ARG)〉〉enditem49840〈〈set-justification-center〉〉:〈〈Make paragraphs in the region centered.
If the mark is not active, this applies to the current paragraph.〉〉enditem49840〈〈set-justification-full〉〉:〈〈Make paragraphs in the region fully justified.
This makes lines flush on both margins by inserting spaces between words.
If the mark is not active, this applies to the current paragraph.〉〉enditem49840〈〈set-justification-left〉〉:〈〈Make paragraphs in the region left-justified.
This means they are flush at the left margin and ragged on the right.
This is usually the default, but see the variable ‘default-justification’.
If the mark is not active, this applies to the current paragraph.〉〉enditem49840〈〈set-justification-none〉〉:〈〈Disable automatic filling for paragraphs in the region.
If the mark is not active, this applies to the current paragraph.〉〉enditem49840〈〈set-justification-right〉〉:〈〈Make paragraphs in the region right-justified.
This means they are flush at the right margin and ragged on the left.
If the mark is not active, this applies to the current paragraph.〉〉enditem49840〈〈set-language-environment〉〉:〈〈Set up multilingual environment for using LANGUAGE-NAME.
This sets the coding system priority and the default input method
and sometimes other things.  LANGUAGE-NAME should be a string
which is the name of a language environment.  For example, "Latin-1"
specifies the character set for the major languages of Western Europe.

If there is a prior value for ‘current-language-environment’, this
runs the hook ‘exit-language-environment-hook’.  After setting up
the new language environment, it runs ‘set-language-environment-hook’.

(fn LANGUAGE-NAME)〉〉enditem49840〈〈set-locale-environment〉〉:〈〈Set up multilingual environment for using LOCALE-NAME.
This sets the language environment, the coding system priority,
the default input method and sometimes other things.

LOCALE-NAME should be a string which is the name of a locale supported
by the system.  Often it is of the form xx_XX.CODE, where xx is a
language, XX is a country, and CODE specifies a character set and
coding system.  For example, the locale name "ja_JP.EUC" might name
a locale for Japanese in Japan using the ‘japanese-iso-8bit’
coding-system.  The name may also have a modifier suffix, e.g. ‘@euro’
or ‘@cyrillic’.

If LOCALE-NAME is nil, its value is taken from the environment
variables LC_ALL, LC_CTYPE and LANG (the first one that is set).

The locale names supported by your system can typically be found in a
directory named ‘/usr/share/locale’ or ‘/usr/lib/locale’.  LOCALE-NAME
will be translated according to the table specified by
‘locale-translation-file-name’.

If FRAME is non-nil, only set the keyboard coding system and the
terminal coding system for the terminal of that frame, and don’t
touch session-global parameters like the language environment.

See also ‘locale-charset-language-names’, ‘locale-language-names’,
‘locale-preferred-coding-systems’ and ‘locale-coding-system’.

(fn &optional LOCALE-NAME FRAME)〉〉enditem49840〈〈set-mark-command〉〉:〈〈Set the mark where point is, and activate it; or jump to the mark.
Setting the mark also alters the region, which is the text
between point and mark; this is the closest equivalent in
Emacs to what some editors call the "selection".

With no prefix argument, set the mark at point, and push the
old mark position on local mark ring.  Also push the new mark on
global mark ring, if the previous mark was set in another buffer.

When Transient Mark Mode is off, immediately repeating this
command activates ‘transient-mark-mode’ temporarily.

With prefix argument (e.g., C-u y), jump to the mark, and set the mark from
position popped off the local mark ring (this does not affect the global
mark ring).  Use C-d to jump to a mark popped off the global
mark ring (see ‘pop-global-mark’).

If ‘set-mark-command-repeat-pop’ is non-nil, repeating
the y command with no prefix argument pops the next position
off the local (or global) mark ring and jumps there.

With C-u C-u as prefix
argument, unconditionally set mark where point is, even if
‘set-mark-command-repeat-pop’ is non-nil.

Novice Emacs Lisp programmers often try to use the mark for the wrong
purposes.  See the documentation of ‘set-mark’ for more information.

(fn ARG)〉〉enditem49840〈〈set-next-selection-coding-system〉〉:〈〈Use CODING-SYSTEM for next communication with other window system clients.
This setting is effective for the next communication only.〉〉enditem49840〈〈set-selection-coding-system〉〉:〈〈Make CODING-SYSTEM used for communicating with other X clients.
When sending or receiving text via cut_buffer, selection, and clipboard,
the text is encoded or decoded by CODING-SYSTEM.〉〉enditem49840〈〈set-selective-display〉〉:〈〈Set ‘selective-display’ to ARG; clear it if no arg.
When the value of ‘selective-display’ is a number > 0,
lines whose indentation is >= that value are not displayed.
The variable ‘selective-display’ has a separate value for each buffer.

(fn ARG)〉〉enditem49840〈〈set-variable〉〉:〈〈Set VARIABLE to VALUE.  VALUE is a Lisp object.
VARIABLE should be a user option variable name, a Lisp variable
meant to be customized by users.  You should enter VALUE in Lisp syntax,
so if you want VALUE to be a string, you must surround it with doublequotes.
VALUE is used literally, not evaluated.

If VARIABLE has a ‘variable-interactive’ property, that is used as if
it were the arg to ‘interactive’ (which see) to interactively read VALUE.

If VARIABLE has been defined with ‘defcustom’, then the type information
in the definition is used to check that VALUE is valid.

Note that this function is at heart equivalent to the basic ‘set’ function.
For a variable defined with ‘defcustom’, it does not pay attention to
any :set property that the variable might have (if you want that, use
M-x customize-set-variable instead).

With a prefix argument, set VARIABLE to VALUE buffer-locally.

(fn VARIABLE VALUE &optional MAKE-LOCAL)〉〉enditem49840〈〈sgml-attributes〉〉:〈〈When at top level of a tag, interactively insert attributes.

Completion and configuration of TAG are done according to ‘sgml-tag-alist’.
If QUIET, do not print a message when there are no attributes for TAG.

(fn TAG &optional QUIET)〉〉enditem49840〈〈sgml-close-tag〉〉:〈〈Close current element.
Depending on context, inserts a matching close-tag, or closes
the current start-tag or the current comment or the current cdata, ...〉〉enditem49840〈〈sgml-delete-tag〉〉:〈〈Delete tag on or after cursor, and matching closing or opening tag.
With prefix argument ARG, repeat this ARG times.

(fn ARG)〉〉enditem49840〈〈sgml-mode〉〉:〈〈Major mode for editing SGML documents.
Makes > match <.
Keys <, &, SPC within <>, ", / and ' can be electric depending on
‘sgml-quick-keys’.

An argument of N to a tag-inserting command means to wrap it around
the next N words.  In Transient Mark mode, when the mark is active,
N defaults to -1, which means to wrap it around the current region.

If you like upcased tags, put (setq sgml-transformation-function 'upcase)
in your init file.

Use M-x sgml-validate to validate your document with an SGML parser.

Do DEL h n sgml- SPC to see available variables.
Do DEL h k on the following bindings to discover what they do.
key             binding
---             -------

 .. ÿ       sgml-maybe-name-self

C-c             Prefix Command
/               sgml-slash

C-c C-a         sgml-attributes
C-c C-b         sgml-skip-tag-backward
C-c C-d         sgml-delete-tag
C-c C-e         sgml-close-tag
C-c C-f         sgml-skip-tag-forward
C-c TAB         sgml-tags-invisible
C-c C-n         sgml-name-char
C-c C-o         sgml-tag
C-c C-t         sgml-tag
C-c C-v         sgml-validate
C-c /           sgml-close-tag
C-c 8           sgml-name-8bit-mode
C-c ?           sgml-tag-help
C-c ]           sgml-close-tag
C-c DEL         sgml-delete-tag
C-c <left>      sgml-skip-tag-backward
C-c <right>     sgml-skip-tag-forward



In addition to any hooks its parent mode ‘text-mode’ might have run,
this mode runs the hook ‘sgml-mode-hook’, as the final or penultimate step
during initialization.〉〉enditem49840〈〈sgml-name-8bit-mode〉〉:〈〈Toggle whether to insert named entities instead of non-ASCII characters.
This only works for Latin-1 input.〉〉enditem49840〈〈sgml-name-char〉〉:〈〈Insert a symbolic character name according to ‘sgml-char-names’.
Non-ASCII chars may be inserted either with the meta key, as in M-SPC for
no-break space or M-- for a soft hyphen; or via an input method or
encoded keyboard operation.

(fn &optional CHAR)〉〉enditem49840〈〈sgml-skip-tag-backward〉〉:〈〈Skip to beginning of tag or matching opening tag if present.
With prefix argument ARG, repeat this ARG times.
Return non-nil if we skipped over matched tags.

(fn ARG)〉〉enditem49840〈〈sgml-skip-tag-forward〉〉:〈〈Skip to end of tag or matching closing tag if present.
With prefix argument ARG, repeat this ARG times.
Return t if after a closing tag.

(fn ARG)〉〉enditem49840〈〈sgml-tag-help〉〉:〈〈Display description of tag TAG.  If TAG is omitted, use the tag at point.

(fn &optional TAG)〉〉enditem49840〈〈sgml-tag〉〉:〈〈Prompt for a tag and insert it, optionally with attributes.
Completion and configuration are done according to ‘sgml-tag-alist’.
If you like tags and attributes in uppercase, customize
‘sgml-transformation-function’ to ‘upcase’.

This is a skeleton command (see ‘skeleton-insert’).
Normally the skeleton text is inserted at point, with nothing "inside".
If there is a highlighted region, the skeleton text is wrapped
around the region text.

A prefix argument ARG says to wrap the skeleton around the next ARG words.
A prefix argument of -1 says to wrap around region, even if not highlighted.
A prefix argument of zero says to wrap around zero words---that is, nothing.
This is a way of overriding the use of a highlighted region.

(fn &optional STR ARG)〉〉enditem49840〈〈sgml-tags-invisible〉〉:〈〈Toggle visibility of existing tags.

(fn ARG)〉〉enditem49840〈〈sgml-validate〉〉:〈〈Validate an SGML document.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer ‘*compilation*’.
You can then use the command C-x ` to find the next error message
and move to the line in the SGML document that caused it.

(fn COMMAND)〉〉enditem49840〈〈shadow-initialize〉〉:〈〈Set up file shadowing.

(fn)〉〉enditem49840〈〈shell-command-on-region〉〉:〈〈Execute string COMMAND in inferior shell with region as input.
Normally display output (if any) in temp buffer ‘*Shell Command Output*’;
Prefix arg means replace the region with it.  Return the exit code of
COMMAND.

To specify a coding system for converting non-ASCII characters
in the input and output to the shell command, use C-x RET c
before this command.  By default, the input (from the current buffer)
is encoded using coding-system specified by ‘process-coding-system-alist’,
falling back to ‘default-process-coding-system’ if no match for COMMAND
is found in ‘process-coding-system-alist’.

Noninteractive callers can specify coding systems by binding
‘coding-system-for-read’ and ‘coding-system-for-write’.

If the command generates output, the output may be displayed
in the echo area or in a buffer.
If the output is short enough to display in the echo area
(determined by the variable ‘max-mini-window-height’ if
‘resize-mini-windows’ is non-nil), it is shown there.
Otherwise it is displayed in the buffer ‘*Shell Command Output*’.
The output is available in that buffer in both cases.

If there is output and an error, a message about the error
appears at the end of the output.

Optional fourth arg OUTPUT-BUFFER specifies where to put the
command’s output.  If the value is a buffer or buffer name,
erase that buffer and insert the output there; a non-nil value of
‘shell-command-dont-erase-buffer’ prevent to erase the buffer.
If the value is nil, use the buffer ‘*Shell Command Output*’.
Any other non-nil value means to insert the output in the
current buffer after START.

Optional fifth arg REPLACE, if non-nil, means to insert the
output in place of text from START to END, putting point and mark
around it.

Optional sixth arg ERROR-BUFFER, if non-nil, specifies a buffer
or buffer name to which to direct the command’s standard error
output.  If nil, error output is mingled with regular output.
When called interactively, ‘shell-command-default-error-buffer’
is used for ERROR-BUFFER.

Optional seventh arg DISPLAY-ERROR-BUFFER, if non-nil, means to
display the error buffer if there were any errors.  When called
interactively, this is t.

(fn START END COMMAND &optional OUTPUT-BUFFER REPLACE ERROR-BUFFER DISPLAY-ERROR-BUFFER REGION-NONCONTIGUOUS-P)〉〉enditem49840〈〈shell-command〉〉:〈〈Execute string COMMAND in inferior shell; display output, if any.
With prefix argument, insert the COMMAND’s output at point.

Interactively, prompt for COMMAND in the minibuffer.

If COMMAND ends in ‘&’, execute it asynchronously.
The output appears in the buffer ‘*Async Shell Command*’.
That buffer is in shell mode.  You can also use
‘async-shell-command’ that automatically adds ‘&’.

Otherwise, COMMAND is executed synchronously.  The output appears in
the buffer ‘*Shell Command Output*’.  If the output is short enough to
display in the echo area (which is determined by the variables
‘resize-mini-windows’ and ‘max-mini-window-height’), it is shown
there, but it is nonetheless available in buffer ‘*Shell Command
Output*’ even though that buffer is not automatically displayed.

To specify a coding system for converting non-ASCII characters
in the shell command output, use C-x RET c before this command.

Noninteractive callers can specify coding systems by binding
‘coding-system-for-read’ and ‘coding-system-for-write’.

The optional second argument OUTPUT-BUFFER, if non-nil,
says to put the output in some other buffer.
If OUTPUT-BUFFER is a buffer or buffer name, erase that buffer
and insert the output there; a non-nil value of
‘shell-command-dont-erase-buffer’ prevents the buffer from being
erased.  If OUTPUT-BUFFER is not a buffer and not nil, insert the
output in current buffer after point leaving mark after it.  This
cannot be done asynchronously.

If the command terminates without error, but generates output,
and you did not specify "insert it in the current buffer",
the output can be displayed in the echo area or in its buffer.
If the output is short enough to display in the echo area
(determined by the variable ‘max-mini-window-height’ if
‘resize-mini-windows’ is non-nil), it is shown there.
Otherwise, the buffer containing the output is displayed.

If there is output and an error, and you did not specify "insert it
in the current buffer", a message about the error goes at the end
of the output.

If the optional third argument ERROR-BUFFER is non-nil, it is a buffer
or buffer name to which to direct the command’s standard error output.
If it is nil, error output is mingled with regular output.
In an interactive call, the variable ‘shell-command-default-error-buffer’
specifies the value of ERROR-BUFFER.

In Elisp, you will often be better served by calling ‘call-process’ or
‘start-process’ directly, since they offer more control and do not
impose the use of a shell (with its need to quote arguments).

(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)〉〉enditem49840〈〈shell〉〉:〈〈Run an inferior shell, with I/O through BUFFER (which defaults to ‘*shell*’).
Interactively, a prefix arg means to prompt for BUFFER.
If ‘default-directory’ is a remote file name, it is also prompted
to change if called with a prefix arg.

If BUFFER exists but shell process is not running, make new shell.
If BUFFER exists and shell process is running, just switch to BUFFER.
Program used comes from variable ‘explicit-shell-file-name’,
 or (if that is nil) from the ESHELL environment variable,
 or (if that is nil) from ‘shell-file-name’.
If a file ‘~/.emacs_SHELLNAME’ exists, or ‘~/.emacs.d/init_SHELLNAME.sh’,
it is given as initial input (but this may be lost, due to a timing
error, if the shell discards input when it starts up).
The buffer is put in Shell mode, giving commands for sending input
and controlling the subjobs of the shell.  See ‘shell-mode’.
See also the variable ‘shell-prompt-pattern’.

To specify a coding system for converting non-ASCII characters
in the input and output to the shell, use C-x RET c
before DEL n u.  You can also specify this with C-x RET p
in the shell buffer, after you start the shell.
The default comes from ‘process-coding-system-alist’ and
‘default-process-coding-system’.

The shell file name (sans directories) is used to make a symbol name
such as ‘explicit-csh-args’.  If that symbol is a variable,
its value is used as a list of arguments when invoking the shell.
Otherwise, one argument ‘-i’ is passed to the shell.

(Type C-h m in the shell buffer for a list of commands.)

(fn &optional BUFFER)〉〉enditem49840〈〈show-all〉〉:〈〈Show all of the text in the buffer.〉〉enditem49840〈〈show-branches〉〉:〈〈Show all subheadings of this heading, but not their bodies.〉〉enditem49840〈〈show-children〉〉:〈〈Show all direct subheadings of this heading.
Prefix arg LEVEL is how many levels below the current level should be shown.
Default is enough to cause the following heading to appear.〉〉enditem49840〈〈show-entry〉〉:〈〈Show the body directly following this heading.
Show the heading too, if it is currently invisible.〉〉enditem49840〈〈show-paren-mode〉〉:〈〈Toggle visualization of matching parens (Show Paren mode).
With a prefix argument ARG, enable Show Paren mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Show Paren mode is a global minor mode.  When enabled, any
matching parenthesis is highlighted in ‘show-paren-style’ after
‘show-paren-delay’ seconds of Emacs idle time.〉〉enditem49840〈〈show-subtree〉〉:〈〈Show everything after this heading at deeper levels.〉〉enditem49840〈〈shrink-window-horizontally〉〉:〈〈Make selected window DELTA columns narrower.
Interactively, if no argument is given, make selected window one
column narrower.

(fn DELTA)〉〉enditem49840〈〈size-indication-mode〉〉:〈〈Toggle buffer size display in the mode line (Size Indication mode).
With a prefix argument ARG, enable Size Indication mode if ARG is
positive, and disable it otherwise.

If called from Lisp, enable the mode if ARG is omitted or nil.

(fn &optional ARG)〉〉enditem49840〈〈slitex-mode〉〉:〈〈Major mode for editing files of input for SliTeX.
Makes $ and } display the characters they match.
Makes " insert `` when it seems to be the beginning of a quotation,
and '' when it appears to be the end; it inserts " only after a \.

Use M-x tex-region to run SliTeX on the current region, plus the preamble
copied from the top of the file (containing \documentstyle, etc.),
running SliTeX under a special subshell.  M-x tex-buffer does the whole buffer.
M-x tex-file saves the buffer and then processes the file.
M-x tex-print prints the .dvi file made by any of these.
M-x tex-view previews the .dvi file made by any of these.
M-x tex-bibtex-file runs bibtex on the file of the current buffer.

Use M-x tex-validate-buffer to check buffer for paragraphs containing
mismatched $’s or braces.

Special commands:

Uses keymap ‘slitex-mode-map’, which is not currently defined.


Mode variables:
slitex-run-command
	Command string used by M-x tex-region or M-x tex-buffer.
tex-directory
	Directory in which to create temporary files for SliTeX jobs
	run by M-x tex-region or M-x tex-buffer.
tex-dvi-print-command
	Command string used by M-x tex-print to print a .dvi file.
tex-alt-dvi-print-command
	Alternative command string used by M-x tex-print (when given a prefix
	argument) to print a .dvi file.
tex-dvi-view-command
	Command string used by M-x tex-view to preview a .dvi file.
tex-show-queue-command
	Command string used by M-x tex-show-print-queue to show the print
	queue that M-x tex-print put your job on.

Entering SliTeX mode runs the hook ‘text-mode-hook’, then the hook
‘tex-mode-hook’, then the hook ‘latex-mode-hook’, and finally the hook
‘slitex-mode-hook’.  When the special subshell is initiated, the hook
‘tex-shell-hook’ is run.

(fn)〉〉enditem49840〈〈smerge-mode〉〉:〈〈Minor mode to simplify editing output from the diff3 program.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Uses keymap ‘smerge-mode-map’, which is not currently defined.


(fn &optional ARG)〉〉enditem49840〈〈smtpmail-send-it〉〉:〈〈

(fn)〉〉enditem49840〈〈snake〉〉:〈〈Play the Snake game.
Move the snake around without colliding with its tail or with the border.

Eating dots causes the snake to get longer.

Snake mode keybindings:
   
Uses keymap ‘snake-mode-map’, which is not currently defined.

M-x snake-start-game	Starts a new game of Snake
M-x snake-end-game	Terminates the current game
M-x snake-pause-game	Pauses (or resumes) the current game
M-x snake-move-left	Makes the snake move left
M-x snake-move-right	Makes the snake move right
M-x snake-move-up	Makes the snake move up
M-x snake-move-down	Makes the snake move down

(fn)〉〉enditem49840〈〈solitaire〉〉:〈〈Play Solitaire.

To play Solitaire, type M-x solitaire.

Uses keymap ‘solitaire-mode-map’, which is not currently defined.

Move around the board using the cursor keys.
Move stones using M-x solitaire-move followed by a direction key.
Undo moves using M-x solitaire-undo.
Check for possible moves using M-x solitaire-do-check.
(The variable ‘solitaire-auto-eval’ controls whether to automatically
check after each move or undo.)

What is Solitaire?

I don’t know who invented this game, but it seems to be rather old and
its origin seems to be northern Africa.  Here’s how to play:
Initially, the board will look similar to this:

	Le Solitaire
	============

		o   o   o

		o   o   o

	o   o   o   o   o   o   o

	o   o   o   .   o   o   o

	o   o   o   o   o   o   o

		o   o   o

		o   o   o

Let’s call the o’s stones and the .’s holes.  One stone fits into one
hole.  As you can see, all holes but one are occupied by stones.  The
aim of the game is to get rid of all but one stone, leaving that last
one in the middle of the board if you’re cool.

A stone can be moved if there is another stone next to it, and a hole
after that one.  Thus there must be three fields in a row, either
horizontally or vertically, up, down, left or right, which look like
this:  o  o  .

Then the first stone is moved to the hole, jumping over the second,
which therefore is taken away.  The above thus ‘evaluates’ to:  .  .  o

That’s all.  Here’s the board after two moves:

		o   o   o

		.   o   o

	o   o   .   o   o   o   o

	o   .   o   o   o   o   o

	o   o   o   o   o   o   o

		o   o   o

		o   o   o

Pick your favorite shortcuts:


Uses keymap ‘solitaire-mode-map’, which is not currently defined.


(fn ARG)〉〉enditem49840〈〈split-line〉〉:〈〈Split current line, moving portion beyond point vertically down.
If the current line starts with ‘fill-prefix’, insert it on the new
line as well.  With prefix ARG, don’t insert ‘fill-prefix’ on new line.

When called from Lisp code, ARG may be a prefix string to copy.

(fn &optional ARG)〉〉enditem49840〈〈spook〉〉:〈〈Adds that special touch of class to your outgoing mail.

(fn)〉〉enditem49840〈〈standard-display-8bit〉〉:〈〈Display characters representing raw bytes in the range L to H literally.

On a terminal display, each character in the range is displayed
by sending the corresponding byte directly to the terminal.

On a graphic display, each character in the range is displayed
using the default font by a glyph whose code is the corresponding
byte.

Note that ASCII printable characters (SPC to TILDA) are displayed
in the default way after this call.〉〉enditem49840〈〈string-insert-rectangle〉〉:〈〈Insert STRING on each line of region-rectangle, shifting text right.

When called from a program, the rectangle’s corners are START and END.
The left edge of the rectangle specifies the column for insertion.
This command does not delete or overwrite any existing text.

(fn START END STRING)〉〉enditem49840〈〈string-rectangle〉〉:〈〈Replace rectangle contents with STRING on each line.
The length of STRING need not be the same as the rectangle width.

When called interactively and option ‘rectangle-preview’ is
non-nil, display the result as the user enters the string into
the minibuffer.

Called from a program, takes three args; START, END and STRING.

(fn START END STRING)〉〉enditem49840〈〈subword-mode〉〉:〈〈Toggle subword movement and editing (Subword mode).
With a prefix argument ARG, enable Subword mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Subword mode is a buffer-local minor mode.  Enabling it changes
the definition of a word so that word-based commands stop inside
symbols with mixed uppercase and lowercase letters,
e.g. "GtkWidget", "EmacsFrameClass", "NSGraphicsContext".

Here we call these mixed case symbols ‘nomenclatures’.  Each
capitalized (or completely uppercase) part of a nomenclature is
called a ‘subword’.  Here are some examples:

  Nomenclature           Subwords
  ===========================================================
  GtkWindow          =>  "Gtk" and "Window"
  EmacsFrameClass    =>  "Emacs", "Frame" and "Class"
  NSGraphicsContext  =>  "NS", "Graphics" and "Context"

This mode changes the definition of a word so that word commands
treat nomenclature boundaries as word boundaries.

key             binding
---             -------



(fn &optional ARG)〉〉enditem49840〈〈sunrise-sunset〉〉:〈〈Local time of sunrise and sunset for today.  Accurate to a few seconds.
If called with an optional prefix argument ARG, prompt for date.
If called with an optional double prefix argument, prompt for
longitude, latitude, time zone, and date, and always use standard time.

This function is suitable for execution in an init file.

(fn &optional ARG)〉〉enditem49840〈〈superword-mode〉〉:〈〈Toggle superword movement and editing (Superword mode).
With a prefix argument ARG, enable Superword mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Superword mode is a buffer-local minor mode.  Enabling it changes
the definition of words such that symbols characters are treated
as parts of words: e.g., in ‘superword-mode’,
"this_is_a_symbol" counts as one word.

key             binding
---             -------



(fn &optional ARG)〉〉enditem49840〈〈switch-to-completions〉〉:〈〈Select the completion list window.〉〉enditem49840〈〈tabify〉〉:〈〈Convert multiple spaces in region to tabs when possible.
A group of spaces is partially replaced by tabs
when this can be done without changing the column they end at.
If called interactively with prefix ARG, convert for the entire
buffer.

Called non-interactively, the region is specified by arguments
START and END, rather than by the position of point and mark.
The variable ‘tab-width’ controls the spacing of tab stops.

(fn START END &optional ARG)〉〉enditem49840〈〈table-backward-cell〉〉:〈〈Move backward to the beginning of the previous cell.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move forward N cells.

(fn &optional ARG)〉〉enditem49840〈〈table-capture〉〉:〈〈Convert plain text into a table by capturing the text in the region.
Create a table with the text in region as cell contents.  BEG and END
specify the region.  The text in the region is replaced with a table.
The removed text is inserted in the table.  When optional
COL-DELIM-REGEXP and ROW-DELIM-REGEXP are provided the region contents
is parsed and separated into individual cell contents by using the
delimiter regular expressions.  This parsing determines the number of
columns and rows of the table automatically.  If COL-DELIM-REGEXP and
ROW-DELIM-REGEXP are omitted the result table has only one cell and
the entire region contents is placed in that cell.  Optional JUSTIFY
is one of ‘left’, ‘center’ or ‘right’, which specifies the cell
justification.  Optional MIN-CELL-WIDTH specifies the minimum cell
width.  Optional COLUMNS specify the number of columns when
ROW-DELIM-REGEXP is not specified.


Example 1:

1, 2, 3, 4
5, 6, 7, 8
, 9, 10

Running ‘table-capture’ on above 3 line region with COL-DELIM-REGEXP
"," and ROW-DELIM-REGEXP "\n" creates the following table.  In
this example the cells are centered and minimum cell width is
specified as 5.

+-----+-----+-----+-----+
|  1  |  2  |  3  |  4  |
+-----+-----+-----+-----+
|  5  |  6  |  7  |  8  |
+-----+-----+-----+-----+
|     |  9  | 10  |     |
+-----+-----+-----+-----+

Note:

In case the function is called interactively user must use C-q ‘quoted-insert’
in order to enter "\n" successfully.  COL-DELIM-REGEXP at the end
of each row is optional.


Example 2:

This example shows how a table can be used for text layout editing.
Let ‘table-capture’ capture the following region starting from
-!- and ending at -*-, that contains three paragraphs and two item
name headers.  This time specify empty string for both
COL-DELIM-REGEXP and ROW-DELIM-REGEXP.

-!-‘table-capture’ is a powerful command however mastering its power
requires some practice.  Here is a list of items what it can do.

Parse Cell Items      By using column delimiter regular
		      expression and raw delimiter regular
		      expression, it parses the specified text
		      area and extracts cell items from
		      non-table text and then forms a table out
		      of them.

Capture Text Area     When no delimiters are specified it
		      creates a single cell table.  The text in
		      the specified region is placed in that
		      cell.-*-

Now the entire content is captured in a cell which is itself a table
like this.

+-----------------------------------------------------------------+
|‘table-capture’ is a powerful command however mastering its power|
|requires some practice.  Here is a list of items what it can do. |
|                                                                 |
|Parse Cell Items      By using column delimiter regular          |
|                      expression and raw delimiter regular       |
|                      expression, it parses the specified text   |
|                      area and extracts cell items from          |
|                      non-table text and then forms a table out  |
|                      of them.                                   |
|                                                                 |
|Capture Text Area     When no delimiters are specified it        |
|                      creates a single cell table.  The text in  |
|                      the specified region is placed in that     |
|                      cell.                                      |
+-----------------------------------------------------------------+

By splitting the cell appropriately we now have a table consisting of
paragraphs occupying its own cell.  Each cell can now be edited
independently.

+-----------------------------------------------------------------+
|‘table-capture’ is a powerful command however mastering its power|
|requires some practice.  Here is a list of items what it can do. |
+---------------------+-------------------------------------------+
|Parse Cell Items     |By using column delimiter regular          |
|                     |expression and raw delimiter regular       |
|                     |expression, it parses the specified text   |
|                     |area and extracts cell items from          |
|                     |non-table text and then forms a table out  |
|                     |of them.                                   |
+---------------------+-------------------------------------------+
|Capture Text Area    |When no delimiters are specified it        |
|                     |creates a single cell table.  The text in  |
|                     |the specified region is placed in that     |
|                     |cell.                                      |
+---------------------+-------------------------------------------+

By applying ‘table-release’, which does the opposite process, the
contents become once again plain text.  ‘table-release’ works as
companion command to ‘table-capture’ this way.

(fn BEG END &optional COL-DELIM-REGEXP ROW-DELIM-REGEXP JUSTIFY MIN-CELL-WIDTH COLUMNS)〉〉enditem49840〈〈table-fixed-width-mode〉〉:〈〈Cell width is fixed when this is non-nil.
Normally it should be nil for allowing automatic cell width expansion
that widens a cell when it is necessary.  When non-nil, typing in a
cell does not automatically expand the cell width.  A word that is too
long to fit in a cell is chopped into multiple lines.  The chopped
location is indicated by ‘table-word-continuation-char’.  This
variable’s value can be toggled by M-x table-fixed-width-mode at
run-time.

(fn &optional ARG)〉〉enditem49840〈〈table-forward-cell〉〉:〈〈Move point forward to the beginning of the next cell.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move backward N cells.
Do not specify NO-RECOGNIZE and UNRECOGNIZE. They are for internal use only.

Sample Cell Traveling Order (In Irregular Table Cases)

You can actually try how it works in this buffer.  Press
M-x table-recognize and go to cells in the following tables and press
M-x table-forward-cell or TAB key.

+-----+--+  +--+-----+  +--+--+--+  +--+--+--+  +---------+  +--+---+--+
|0    |1 |  |0 |1    |  |0 |1 |2 |  |0 |1 |2 |  |0        |  |0 |1  |2 |
+--+--+  |  |  +--+--+  +--+  |  |  |  |  +--+  +----+----+  +--+-+-+--+
|2 |3 |  |  |  |2 |3 |  |3 +--+  |  |  +--+3 |  |1   |2   |  |3   |4   |
|  +--+--+  +--+--+  |  +--+4 |  |  |  |4 +--+  +--+-+-+--+  +----+----+
|  |4    |  |4    |  |  |5 |  |  |  |  |  |5 |  |3 |4  |5 |  |5        |
+--+-----+  +-----+--+  +--+--+--+  +--+--+--+  +--+---+--+  +---------+

+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+
|0 |1 |2 |  |0 |1 |2 |  |0 |1 |2 |  |0 |1 |2 |
|  |  |  |  |  +--+  |  |  |  |  |  +--+  +--+
+--+  +--+  +--+3 +--+  |  +--+  |  |3 +--+4 |
|3 |  |4 |  |4 +--+5 |  |  |3 |  |  +--+5 +--+
|  |  |  |  |  |6 |  |  |  |  |  |  |6 |  |7 |
+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+

+--+--+--+  +--+--+--+  +--+--+--+--+  +--+-----+--+  +--+--+--+--+
|0 |1 |2 |  |0 |1 |2 |	|0 |1 |2 |3 |  |0 |1    |2 |  |0 |1 |2 |3 |
|  +--+  |  |  +--+  |	|  +--+--+  |  |  |     |  |  |  +--+--+  |
|  |3 +--+  +--+3 |  |	+--+4    +--+  +--+     +--+  +--+4    +--+
+--+  |4 |  |4 |  +--+	|5 +--+--+6 |  |3 +--+--+4 |  |5 |     |6 |
|5 +--+  |  |  +--+5 |	|  |7 |8 |  |  |  |5 |6 |  |  |  |     |  |
|  |6 |  |  |  |6 |  |	+--+--+--+--+  +--+--+--+--+  +--+-----+--+
+--+--+--+  +--+--+--+

(fn &optional ARG NO-RECOGNIZE UNRECOGNIZE)〉〉enditem49840〈〈table-generate-source〉〉:〈〈Generate source of the current table in the specified language.
LANGUAGE is a symbol that specifies the language to describe the
structure of the table.  It must be either ‘html’, ‘latex’ or ‘cals’.
The resulted source text is inserted into DEST-BUFFER and the buffer
object is returned.  When DEST-BUFFER is omitted or nil the default
buffer specified in ‘table-dest-buffer-name’ is used.  In this case
the content of the default buffer is erased prior to the generation.
When DEST-BUFFER is non-nil it is expected to be either a destination
buffer or a name of the destination buffer.  In this case the
generated result is inserted at the current point in the destination
buffer and the previously existing contents in the buffer are
untouched.

References used for this implementation:

HTML:
        URL ‘http://www.w3.org’

LaTeX:
        URL ‘http://www.maths.tcd.ie/~dwilkins/LaTeXPrimer/Tables.html’

CALS (DocBook DTD):
        URL ‘http://www.oasis-open.org/html/a502.htm’
        URL ‘http://www.oreilly.com/catalog/docbook/chapter/book/table.html#AEN114751’

(fn LANGUAGE &optional DEST-BUFFER CAPTION)〉〉enditem49840〈〈table-heighten-cell〉〉:〈〈Heighten the current cell by N lines by expanding the cell vertically.
Heightening is done by adding blank lines at the bottom of the current
cell.  Other cells aligned horizontally with the current one are also
heightened in order to keep the rectangular table structure.  The
optional argument NO-COPY is internal use only and must not be
specified.

(fn N &optional NO-COPY NO-UPDATE)〉〉enditem49840〈〈table-insert-column〉〉:〈〈Insert N table column(s).
When point is in a table the newly inserted column(s) are placed left
of the current column.  When point is outside of the table it must be
right side of the table within the table height range, then the newly
created column(s) are appended at the right of the table.

(fn N)〉〉enditem49840〈〈table-insert-row〉〉:〈〈Insert N table row(s).
When point is in a table the newly inserted row(s) are placed above
the current row.  When point is outside of the table it must be below
the table within the table width range, then the newly created row(s)
are appended at the bottom of the table.

(fn N)〉〉enditem49840〈〈table-insert-sequence〉〉:〈〈Travel cells forward while inserting a specified sequence string in each cell.
STR is the base string from which the sequence starts.  When STR is an
empty string then each cell content is erased.  When STR ends with
numerical characters (they may optionally be surrounded by a pair of
parentheses) they are incremented as a decimal number.  Otherwise the
last character in STR is incremented in ASCII code order.  N is the
number of sequence elements to insert.  When N is negative the cell
traveling direction is backward.  When N is zero it travels forward
entire table.  INCREMENT is the increment between adjacent sequence
elements and can be a negative number for effectively decrementing.
INTERVAL is the number of cells to travel between sequence element
insertion which is normally 1.  When zero or less is given for
INTERVAL it is interpreted as number of cells per row so that sequence
is placed straight down vertically as long as the table’s cell
structure is uniform.  JUSTIFY is a symbol ‘left’, ‘center’ or
‘right’ that specifies justification of the inserted string.

Example:

  (progn
    (table-insert 16 3 5 1)
    (table-forward-cell 15)
    (table-insert-sequence "D0" -16 1 1 'center)
    (table-forward-cell 16)
    (table-insert-sequence "A[0]" -16 1 1 'center)
    (table-forward-cell 1)
    (table-insert-sequence "-" 16 0 1 'center))

  (progn
    (table-insert 16 8 5 1)
    (table-insert-sequence "@" 0 1 2 'right)
    (table-forward-cell 1)
    (table-insert-sequence "64" 0 1 2 'left))

(fn STR N INCREMENT INTERVAL JUSTIFY)〉〉enditem49840〈〈table-insert〉〉:〈〈Insert an editable text table.
Insert a table of specified number of COLUMNS and ROWS.  Optional
parameter CELL-WIDTH and CELL-HEIGHT can specify the size of each
cell.  The cell size is uniform across the table if the specified size
is a number.  They can be a list of numbers to specify different size
for each cell.  When called interactively, the list of number is
entered by simply listing all the numbers with space characters
delimiting them.

Examples:

M-x table-insert inserts a table at the current point location.

Suppose we have the following situation where ‘-!-’ indicates the
location of point.

    -!-

Type M-x table-insert and hit ENTER key.  As it asks table
specification, provide 3 for number of columns, 1 for number of rows,
5 for cell width and 1 for cell height.  Now you shall see the next
table and the point is automatically moved to the beginning of the
first cell.

    +-----+-----+-----+
    |-!-  |     |     |
    +-----+-----+-----+

Inside a table cell, there are special key bindings. 
Uses keymap ‘table-cell-map’, which is not currently defined.


M-9 M-x table-widen-cell (or C-u 9 M-x table-widen-cell) widens the first cell by 9 character
width, which results as

    +--------------+-----+-----+
    |-!-           |     |     |
    +--------------+-----+-----+

Type TAB M-x table-widen-cell then type TAB M-2 M-7 M-x table-widen-cell (or C-u 2 7 M-x table-widen-cell).  Typing
TAB moves the point forward by a cell. The result now looks like this:

    +--------------+------+--------------------------------+
    |              |      |-!-                             |
    +--------------+------+--------------------------------+

If you knew each width of the columns prior to the table creation,
what you could have done better was to have had given the complete
width information to ‘table-insert’.

Cell width(s): 14 6 32

instead of

Cell width(s): 5

This would have eliminated the previously mentioned width adjustment
work all together.

If the point is in the last cell type S-TAB S-TAB to move it to the
first cell.  Now type M-x table-heighten-cell which heighten the row by a line.

    +--------------+------+--------------------------------+
    |-!-           |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+

Type M-x table-insert-row-column and tell it to insert a row.

    +--------------+------+--------------------------------+
    |-!-           |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+

Move the point under the table as shown below.

    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    -!-

Type M-x table-insert-row instead of M-x table-insert-row-column.  M-x table-insert-row-column does not work
when the point is outside of the table.  This insertion at
outside of the table effectively appends a row at the end.

    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    |-!-           |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+

Text editing inside the table cell produces reasonably expected
results.

    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+
    |              |      |Text editing inside the table   |
    |              |      |cell produces reasonably        |
    |              |      |expected results.-!-            |
    +--------------+------+--------------------------------+
    |              |      |                                |
    |              |      |                                |
    +--------------+------+--------------------------------+

Inside a table cell has a special keymap.


Uses keymap ‘table-cell-map’, which is not currently defined.


(fn COLUMNS ROWS &optional CELL-WIDTH CELL-HEIGHT)〉〉enditem49840〈〈table-justify〉〉:〈〈Justify contents of a cell, a row of cells or a column of cells.
WHAT is a symbol ‘cell’, ‘row’ or ‘column’.  JUSTIFY is a symbol
‘left’, ‘center’, ‘right’, ‘top’, ‘middle’, ‘bottom’ or ‘none’.

(fn WHAT JUSTIFY)〉〉enditem49840〈〈table-narrow-cell〉〉:〈〈Narrow the current cell by N columns and shrink the cell horizontally.
Some other cells in the same table are narrowed as well to keep the
table’s rectangle structure.

(fn N)〉〉enditem49840〈〈table-query-dimension〉〉:〈〈Return the dimension of the current cell and the current table.
The result is a list (cw ch tw th c r cells) where cw is the cell
width, ch is the cell height, tw is the table width, th is the table
height, c is the number of columns, r is the number of rows and cells
is the total number of cells.  The cell dimension excludes the cell
frame while the table dimension includes the table frame.  The columns
and the rows are counted by the number of cell boundaries.  Therefore
the number tends to be larger than it appears for the tables with
non-uniform cell structure (heavily spanned and split).  When optional
WHERE is provided the cell and table at that location is reported.

(fn &optional WHERE)〉〉enditem49840〈〈table-recognize-cell〉〉:〈〈Recognize a table cell that contains current point.
Probe the cell dimension and prepare the cell information.  The
optional two arguments FORCE and NO-COPY are for internal use only and
must not be specified.  When the optional numeric prefix argument ARG
is negative the cell becomes inactive, meaning that the cell becomes
plain text and loses all the table specific features.

(fn &optional FORCE NO-COPY ARG)〉〉enditem49840〈〈table-recognize-region〉〉:〈〈Recognize all tables within region.
BEG and END specify the region to work on.  If the optional numeric
prefix argument ARG is negative the tables in the region become
inactive, meaning the tables become plain text and lose all the table
specific features.

(fn BEG END &optional ARG)〉〉enditem49840〈〈table-recognize-table〉〉:〈〈Recognize a table at point.
If the optional numeric prefix argument ARG is negative the table
becomes inactive, meaning the table becomes plain text and loses all
the table specific features.

(fn &optional ARG)〉〉enditem49840〈〈table-recognize〉〉:〈〈Recognize all tables within the current buffer and activate them.
Scans the entire buffer and recognizes valid table cells.  If the
optional numeric prefix argument ARG is negative the tables in the
buffer become inactive, meaning the tables become plain text and loses
all the table specific features.

(fn &optional ARG)〉〉enditem49840〈〈table-release〉〉:〈〈Convert a table into plain text by removing the frame from a table.
Remove the frame from a table and deactivate the table.  This command
converts a table into plain text without frames.  It is a companion to
‘table-capture’ which does the opposite process.

(fn)〉〉enditem49840〈〈table-shorten-cell〉〉:〈〈Shorten the current cell by N lines by shrinking the cell vertically.
Shortening is done by removing blank lines from the bottom of the cell
and possibly from the top of the cell as well.  Therefore, the cell
must have some bottom/top blank lines to be shorten effectively.  This
is applicable to all the cells aligned horizontally with the current
one because they are also shortened in order to keep the rectangular
table structure.

(fn N)〉〉enditem49840〈〈table-span-cell〉〉:〈〈Span current cell into adjacent cell in DIRECTION.
DIRECTION is one of symbols; right, left, above or below.

(fn DIRECTION)〉〉enditem49840〈〈table-split-cell-horizontally〉〉:〈〈Split current cell horizontally.
Creates a cell on the left and a cell on the right of the current point location.

(fn)〉〉enditem49840〈〈table-split-cell-vertically〉〉:〈〈Split current cell vertically.
Creates a cell above and a cell below the current point location.

(fn)〉〉enditem49840〈〈table-split-cell〉〉:〈〈Split current cell in ORIENTATION.
ORIENTATION is a symbol either horizontally or vertically.

(fn ORIENTATION)〉〉enditem49840〈〈table-unrecognize-cell〉〉:〈〈

(fn)〉〉enditem49840〈〈table-unrecognize-region〉〉:〈〈

(fn BEG END)〉〉enditem49840〈〈table-unrecognize-table〉〉:〈〈

(fn)〉〉enditem49840〈〈table-unrecognize〉〉:〈〈

(fn)〉〉enditem49840〈〈table-widen-cell〉〉:〈〈Widen the current cell by N columns and expand the cell horizontally.
Some other cells in the same table are widen as well to keep the
table’s rectangle structure.

(fn N &optional NO-COPY NO-UPDATE)〉〉enditem49840〈〈tabulated-list-sort〉〉:〈〈Sort Tabulated List entries by the column at point.
With a numeric prefix argument N, sort the Nth column.

(fn &optional N)〉〉enditem49840〈〈tags-loop-continue〉〉:〈〈Continue last M-x tags-search or M-x tags-query-replace command.
Used noninteractively with non-nil argument to begin such a command (the
argument is passed to ‘next-file’, which see).

Two variables control the processing we do on each file: the value of
‘tags-loop-scan’ is a form to be executed on each file to see if it is
interesting (it returns non-nil if so) and ‘tags-loop-operate’ is a form to
evaluate to operate on an interesting file.  If the latter evaluates to
nil, we exit; otherwise we scan the next file.

(fn &optional FIRST-TIME)〉〉enditem49840〈〈tags-query-replace〉〉:〈〈Do ‘query-replace-regexp’ of FROM with TO on all files listed in tags table.
Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit (C-g, RET or q), you can resume the query replace
with the command M-x tags-loop-continue.
Fourth arg FILE-LIST-FORM non-nil means initialize the replacement loop.

If FILE-LIST-FORM is non-nil, it is a form to evaluate to
produce the list of files to search.

See also the documentation of the variable ‘tags-file-name’.

(fn FROM TO &optional DELIMITED FILE-LIST-FORM)〉〉enditem49840〈〈tags-search〉〉:〈〈Search through all files listed in tags table for match for REGEXP.
Stops when a match is found.
To continue searching for next match, use command M-x tags-loop-continue.

If FILE-LIST-FORM is non-nil, it should be a form that, when
evaluated, will return a list of file names.  The search will be
restricted to these files.

Also see the documentation of the ‘tags-file-name’ variable.

(fn REGEXP &optional FILE-LIST-FORM)〉〉enditem49840〈〈telnet〉〉:〈〈Open a network login connection to host named HOST (a string).
Optional arg PORT specifies alternative port to connect to.
Interactively, use C-u prefix to be prompted for port number.

Communication with HOST is recorded in a buffer ‘*PROGRAM-HOST*’
where PROGRAM is the telnet program being used.  This program
is controlled by the contents of the global variable ‘telnet-host-properties’,
falling back on the value of the global variable ‘telnet-program’.
Normally input is edited in Emacs and sent a line at a time.

(fn HOST &optional PORT)〉〉enditem49840〈〈temp-buffer-resize-mode〉〉:〈〈Toggle auto-resizing temporary buffer windows (Temp Buffer Resize Mode).
With a prefix argument ARG, enable Temp Buffer Resize mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

When Temp Buffer Resize mode is enabled, the windows in which we
show a temporary buffer are automatically resized in height to
fit the buffer’s contents, but never more than
‘temp-buffer-max-height’ nor less than ‘window-min-height’.

A window is resized only if it has been specially created for the
buffer.  Windows that have shown another buffer before are not
resized.  A frame is resized only if ‘fit-frame-to-buffer’ is
non-nil.

This mode is used by ‘help’, ‘apropos’ and ‘completion’ buffers,
and some others.〉〉enditem49840〈〈term-char-mode〉〉:〈〈Switch to char ("raw") sub-mode of term mode.
Each character you type is sent directly to the inferior without
intervention from Emacs, except for the escape character (usually C-c).〉〉enditem49840〈〈term-line-mode〉〉:〈〈Switch to line ("cooked") sub-mode of term mode.
This means that Emacs editing commands work as normally, until
you type M-x term-send-input which sends the current line to the inferior.〉〉enditem49840〈〈term-pager-toggle〉〉:〈〈nil〉〉enditem49840〈〈term〉〉:〈〈Start a terminal-emulator in a new buffer.
The buffer is in Term mode; see ‘term-mode’ for the
commands to use in that buffer.

Type C-c b to switch to another buffer.〉〉enditem49840〈〈tetris〉〉:〈〈Play the Tetris game.
Shapes drop from the top of the screen, and the user has to move and
rotate the shape to fit in with those at the bottom of the screen so
as to form complete rows.

tetris-mode keybindings:
   
Uses keymap ‘tetris-mode-map’, which is not currently defined.

M-x tetris-start-game	Starts a new game of Tetris
M-x tetris-end-game	Terminates the current game
M-x tetris-pause-game	Pauses (or resumes) the current game
M-x tetris-move-left	Moves the shape one square to the left
M-x tetris-move-right	Moves the shape one square to the right
M-x tetris-rotate-prev	Rotates the shape clockwise
M-x tetris-rotate-next	Rotates the shape anticlockwise
M-x tetris-move-bottom	Drops the shape to the bottom of the playing area

(fn)〉〉enditem49840〈〈tex-mode〉〉:〈〈Major mode for editing files of input for TeX, LaTeX, or SliTeX.
Tries to determine (by looking at the beginning of the file) whether
this file is for plain TeX, LaTeX, or SliTeX and calls ‘plain-tex-mode’,
‘latex-mode’, or ‘slitex-mode’, respectively.  If it cannot be determined,
such as if there are no commands in the file, the value of ‘tex-default-mode’
says which mode to use.

(fn)〉〉enditem49840〈〈text-scale-adjust〉〉:〈〈Adjust the height of the default face by INC.

INC may be passed as a numeric prefix argument.

The actual adjustment made depends on the final component of the
key-binding used to invoke the command, with all modifiers removed:

   +, =   Increase the default face height by one step
   -      Decrease the default face height by one step
   0      Reset the default face height to the global default

After adjusting, continue to read input events and further adjust
the face height as long as the input event read
(with all modifiers removed) is one of the above characters.

Each step scales the height of the default face by the variable
‘text-scale-mode-step’ (a negative number of steps decreases the
height by the same amount).  As a special case, an argument of 0
will remove any scaling currently active.

This command is a special-purpose wrapper around the
‘text-scale-increase’ command which makes repetition convenient
even when it is bound in a non-top-level keymap.  For binding in
a top-level keymap, ‘text-scale-increase’ or
‘text-scale-decrease’ may be more appropriate.

(fn INC)〉〉enditem49840〈〈text-scale-decrease〉〉:〈〈Decrease the height of the default face in the current buffer by DEC steps.
See ‘text-scale-increase’ for more details.

(fn DEC)〉〉enditem49840〈〈text-scale-increase〉〉:〈〈Increase the height of the default face in the current buffer by INC steps.
If the new height is other than the default, ‘text-scale-mode’ is enabled.

Each step scales the height of the default face by the variable
‘text-scale-mode-step’ (a negative number of steps decreases the
height by the same amount).  As a special case, an argument of 0
will remove any scaling currently active.

(fn INC)〉〉enditem49840〈〈text-scale-set〉〉:〈〈Set the scale factor of the default face in the current buffer to LEVEL.
If LEVEL is non-zero, ‘text-scale-mode’ is enabled, otherwise it is disabled.

LEVEL is a number of steps, with 0 representing the default size.
Each step scales the height of the default face by the variable
‘text-scale-mode-step’ (a negative number decreases the height by
the same amount).

(fn LEVEL)〉〉enditem49840〈〈time-stamp〉〉:〈〈Update the time stamp string(s) in the buffer.
A template in a file can be automatically updated with a new time stamp
every time you save the file.  Add this line to your init file:
    (add-hook 'before-save-hook 'time-stamp)
or customize ‘before-save-hook’ through Custom.
Normally the template must appear in the first 8 lines of a file and
look like one of the following:
      Time-stamp: <>
      Time-stamp: " "
The time stamp is written between the brackets or quotes:
      Time-stamp: <2001-02-18 10:20:51 gildea>
The time stamp is updated only if the variable ‘time-stamp-active’ is non-nil.
The format of the time stamp is set by the variable ‘time-stamp-pattern’ or
‘time-stamp-format’.  The variables ‘time-stamp-pattern’,
‘time-stamp-line-limit’, ‘time-stamp-start’, ‘time-stamp-end’,
‘time-stamp-count’, and ‘time-stamp-inserts-lines’ control finding
the template.

(fn)〉〉enditem49840〈〈timeclock-change〉〉:〈〈Change to working on a different project.
This clocks out of the current project, then clocks in on a new one.
With a prefix ARG, consider the previous project as finished at the
time of changeover.  PROJECT is the name of the last project you were
working on.

(fn &optional ARG PROJECT)〉〉enditem49840〈〈timeclock-in〉〉:〈〈Clock in, recording the current time moment in the timelog.
With a numeric prefix ARG, record the fact that today has only that
many hours in it to be worked.  If ARG is a non-numeric prefix argument
(non-nil, but not a number), 0 is assumed (working on a holiday or
weekend).  *If not called interactively, ARG should be the number of
_seconds_ worked today*.  This feature only has effect the first time
this function is called within a day.

PROJECT is the project being clocked into.  If PROJECT is nil, and
FIND-PROJECT is non-nil -- or the user calls ‘timeclock-in’
interactively -- call the function ‘timeclock-get-project-function’ to
discover the name of the project.

(fn &optional ARG PROJECT FIND-PROJECT)〉〉enditem49840〈〈timeclock-out〉〉:〈〈Clock out, recording the current time moment in the timelog.
If a prefix ARG is given, the user has completed the project that was
begun during the last time segment.

REASON is the user’s reason for clocking out.  If REASON is nil, and
FIND-REASON is non-nil -- or the user calls ‘timeclock-out’
interactively -- call the function ‘timeclock-get-reason-function’ to
discover the reason.

(fn &optional ARG REASON FIND-REASON)〉〉enditem49840〈〈timeclock-reread-log〉〉:〈〈Re-read the timeclock, to account for external changes.
Returns the new value of ‘timeclock-discrepancy’.

(fn)〉〉enditem49840〈〈tmm-menubar〉〉:〈〈Text-mode emulation of looking and choosing from a menubar.
See the documentation for ‘tmm-prompt’.
X-POSITION, if non-nil, specifies a horizontal position within the menu bar;
we make that menu bar item (the one at that position) the default choice.

Note that DEL n k by default drops down TTY menus; if you want it
to invoke ‘tmm-menubar’ instead, customize the variable
‘tty-menu-open-use-tmm’ to a non-nil value.

(fn &optional X-POSITION)〉〉enditem49840〈〈toggle-debug-on-error〉〉:〈〈Toggle whether to enter Lisp debugger when an error is signaled.
In an interactive call, record this option as a candidate for saving
by "Save Options" in Custom buffers.〉〉enditem49840〈〈toggle-frame-fullscreen〉〉:〈〈Toggle fullscreen state of selected frame.
Make selected frame fullscreen or restore its previous size if it
is already fullscreen.

Before making the frame fullscreen remember the current value of
the frame’s ‘fullscreen’ parameter in the ‘fullscreen-restore’
parameter of the frame.  That value is used to restore the
frame’s fullscreen state when toggling fullscreen the next time.

Note that with some window managers you may have to set
‘frame-resize-pixelwise’ to non-nil in order to make a frame
appear truly fullscreen.  In addition, you may have to set
‘x-frame-normalize-before-maximize’ in order to enable
transitions from one fullscreen state to another.

See also ‘toggle-frame-maximized’.〉〉enditem49840〈〈toggle-frame-maximized〉〉:〈〈Toggle maximization state of selected frame.
Maximize selected frame or un-maximize if it is already maximized.

If the frame is in fullscreen state, don’t change its state, but
set the frame’s ‘fullscreen-restore’ parameter to ‘maximized’, so
the frame will be maximized after disabling fullscreen state.

Note that with some window managers you may have to set
‘frame-resize-pixelwise’ to non-nil in order to make a frame
appear truly maximized.  In addition, you may have to set
‘x-frame-normalize-before-maximize’ in order to enable
transitions from one fullscreen state to another.

See also ‘toggle-frame-fullscreen’.〉〉enditem49840〈〈toggle-input-method〉〉:〈〈Enable or disable multilingual text input method for the current buffer.
Only one input method can be enabled at any time in a given buffer.

The normal action is to enable an input method if none was enabled,
and disable the current one otherwise.  Which input method to enable
can be determined in various ways--either the one most recently used,
or the one specified by ‘default-input-method’, or as a last resort
by reading the name of an input method in the minibuffer.

With a prefix argument ARG, read an input method name with the minibuffer
and enable that one.  The default is the most recent input method specified
(not including the currently active input method, if any).

When called interactively, the optional argument INTERACTIVE is non-nil,
which marks the variable ‘default-input-method’ as set for Custom buffers.

(fn &optional ARG INTERACTIVE)〉〉enditem49840〈〈toggle-scroll-bar〉〉:〈〈Toggle whether or not the selected frame has vertical scroll bars.
With ARG, turn vertical scroll bars on if and only if ARG is positive.
The variable ‘scroll-bar-mode’ controls which side the scroll bars are on
when they are turned on; if it is nil, they go on the left.〉〉enditem49840〈〈toggle-truncate-lines〉〉:〈〈Toggle truncating of long lines for the current buffer.
When truncating is off, long lines are folded.
With prefix argument ARG, truncate long lines if ARG is positive,
otherwise fold them.  Note that in side-by-side windows, this
command has no effect if ‘truncate-partial-width-windows’ is
non-nil.

(fn &optional ARG)〉〉enditem49840〈〈tool-bar-mode〉〉:〈〈Toggle the tool bar in all graphical frames (Tool Bar mode).
With a prefix argument ARG, enable Tool Bar mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Tool Bar mode if ARG is omitted or nil.

See ‘tool-bar-add-item’ and ‘tool-bar-add-item-from-menu’ for
conveniently adding tool bar items.〉〉enditem49840〈〈tooltip-delay〉〉:〈〈Return the delay in seconds for the next tooltip.〉〉enditem49840〈〈transient-mark-mode〉〉:〈〈Toggle Transient Mark mode.
With a prefix argument ARG, enable Transient Mark mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
Transient Mark mode if ARG is omitted or nil.

Transient Mark mode is a global minor mode.  When enabled, the
region is highlighted with the ‘region’ face whenever the mark
is active.  The mark is "deactivated" by changing the buffer,
and after certain other operations that set the mark but whose
main purpose is something else--for example, incremental search,
DEL d, and DEL b.

You can also deactivate the mark by typing C-g or
M-ESC ESC.

Many commands change their behavior when Transient Mark mode is
in effect and the mark is active, by acting on the region instead
of their usual default part of the buffer’s text.  Examples of
such commands include M-;, M-x flush-lines, M-x keep-lines,
DEL p, DEL t p, s-:, and C-x u.
To see the documentation of commands which are sensitive to the
Transient Mark mode, invoke DEL h d and type "transient"
or "mark.*active" at the prompt.

(fn &optional ARG)〉〉enditem49840〈〈transpose-chars〉〉:〈〈Interchange characters around point, moving forward one character.
With prefix arg ARG, effect is to take character before point
and drag it forward past ARG other characters (backward if ARG negative).
If no argument and at end of line, the previous two chars are exchanged.

(fn ARG)〉〉enditem49840〈〈transpose-lines〉〉:〈〈Exchange current line and previous line, leaving point after both.
With argument ARG, takes previous line and moves it past ARG lines.
With argument 0, interchanges line point is in with line mark is in.

(fn ARG)〉〉enditem49840〈〈transpose-sexps〉〉:〈〈Like M-x transpose-chars (‘transpose-chars’), but applies to sexps.
Unlike ‘transpose-words’, point must be between the two sexps and not
in the middle of a sexp to be transposed.
With non-zero prefix arg ARG, effect is to take the sexp before point
and drag it forward past ARG other sexps (backward if ARG is negative).
If ARG is zero, the sexps ending at or after point and at or after mark
are interchanged.

(fn ARG)〉〉enditem49840〈〈transpose-words〉〉:〈〈Interchange words around point, leaving point at end of them.
With prefix arg ARG, effect is to take word before or around point
and drag it forward past ARG other words (backward if ARG negative).
If ARG is zero, the words around or after point and around or after mark
are interchanged.

(fn ARG)〉〉enditem49840〈〈tty-suppress-bold-inverse-default-colors〉〉:〈〈Suppress/allow boldness of faces with inverse default colors.
SUPPRESS non-nil means suppress it.
This affects bold faces on TTYs whose foreground is the default background
color of the display and whose background is the default foreground color.
For such faces, the bold face attribute is ignored if this variable
is non-nil.

(fn SUPPRESS)〉〉enditem49840〈〈uncomment-region〉〉:〈〈Uncomment each line in the BEG .. END region.
The numeric prefix ARG can specify a number of chars to remove from the
comment markers.

(fn BEG END &optional ARG)〉〉enditem49840〈〈undo-only〉〉:〈〈Undo some previous changes.
Repeat this command to undo more changes.
A numeric ARG serves as a repeat count.
Contrary to ‘undo’, this will not redo a previous undo.

(fn &optional ARG)〉〉enditem49840〈〈undo〉〉:〈〈Undo some previous changes.
Repeat this command to undo more changes.
A numeric ARG serves as a repeat count.

In Transient Mark mode when the mark is active, only undo changes within
the current region.  Similarly, when not in Transient Mark mode, just C-u
as an argument limits undo to changes within the current region.

(fn &optional ARG)〉〉enditem49840〈〈unexpand-abbrev〉〉:〈〈Undo the expansion of the last abbrev that expanded.
This differs from ordinary undo in that other editing done since then
is not undone.〉〉enditem49840〈〈unhighlight-regexp〉〉:〈〈Remove highlighting of each match to REGEXP set by hi-lock.
Interactively, prompt for REGEXP, accepting only regexps
previously inserted by hi-lock interactive functions.
If REGEXP is t (or if C-u was specified interactively),
then remove all hi-lock highlighting.

(fn REGEXP)〉〉enditem49840〈〈union〉〉:〈〈Combine LIST1 and LIST2 using a set-union operation.
The resulting list contains all items that appear in either LIST1 or LIST2.
This is a non-destructive function; it makes a copy of the data if necessary
to avoid corrupting the original LIST1 and LIST2.

Keywords supported:  :test :test-not :key

(fn LIST1 LIST2 [KEYWORD VALUE]...)〉〉enditem49840〈〈universal-coding-system-argument〉〉:〈〈Execute an I/O command using the specified coding system.

(fn CODING-SYSTEM)〉〉enditem49840〈〈unmorse-region〉〉:〈〈Convert morse coded text in region to ordinary ASCII text.

(fn BEG END)〉〉enditem49840〈〈untabify〉〉:〈〈Convert all tabs in region to multiple spaces, preserving columns.
If called interactively with prefix ARG, convert for the entire
buffer.

Called non-interactively, the region is specified by arguments
START and END, rather than by the position of point and mark.
The variable ‘tab-width’ controls the spacing of tab stops.

(fn START END &optional ARG)〉〉enditem49840〈〈vc-annotate〉〉:〈〈Display the edit history of the current FILE using colors.

This command creates a buffer that shows, for each line of the current
file, when it was last edited and by whom.  Additionally, colors are
used to show the age of each line--blue means oldest, red means
youngest, and intermediate colors indicate intermediate ages.  By
default, the time scale stretches back one year into the past;
everything that is older than that is shown in blue.

With a prefix argument, this command asks two questions in the
minibuffer.  First, you may enter a revision number REV; then the buffer
displays and annotates that revision instead of the working revision
(type RET in the minibuffer to leave that default unchanged).  Then,
you are prompted for the time span in days which the color range
should cover.  For example, a time span of 20 days means that changes
over the past 20 days are shown in red to blue, according to their
age, and everything that is older than that is shown in blue.

If MOVE-POINT-TO is given, move the point to that line.

If VC-BK is given used that VC backend.

Customization variables:

‘vc-annotate-menu-elements’ customizes the menu elements of the
mode-specific menu.  ‘vc-annotate-color-map’ and
‘vc-annotate-very-old-color’ define the mapping of time to colors.
‘vc-annotate-background’ specifies the background color.
‘vc-annotate-background-mode’ specifies whether the color map
should be applied to the background or to the foreground.

(fn FILE REV &optional DISPLAY-MODE BUF MOVE-POINT-TO VC-BK)〉〉enditem49840〈〈vc-create-tag〉〉:〈〈Descending recursively from DIR, make a tag called NAME.
For each registered file, the working revision becomes part of
the named configuration.  If the prefix argument BRANCHP is
given, the tag is made as a new branch and the files are
checked out in that new branch.

(fn DIR NAME BRANCHP)〉〉enditem49840〈〈vc-delete-file〉〉:〈〈Delete file and mark it as such in the version control system.
If called interactively, read FILE, defaulting to the current
buffer’s file name if it’s under version control.

(fn FILE)〉〉enditem49840〈〈vc-diff〉〉:〈〈Display diffs between file revisions.
Normally this compares the currently selected fileset with their
working revisions.  With a prefix argument HISTORIC, it reads two revision
designators specifying which revisions to compare.

The optional argument NOT-URGENT non-nil means it is ok to say no to
saving the buffer.

(fn &optional HISTORIC NOT-URGENT)〉〉enditem49840〈〈vc-dir〉〉:〈〈Show the VC status for "interesting" files in and below DIR.
This allows you to mark files and perform VC operations on them.
The list omits files which are up to date, with no changes in your copy
or the repository, if there is nothing in particular to say about them.

Preparing the list of file status takes time; when the buffer
first appears, it has only the first few lines of summary information.
The file lines appear later.

Optional second argument BACKEND specifies the VC backend to use.
Interactively, a prefix argument means to ask for the backend.

These are the commands available for use in the file status buffer:


Uses keymap ‘vc-dir-mode-map’, which is not currently defined.


(fn DIR &optional BACKEND)〉〉enditem49840〈〈vc-ediff〉〉:〈〈Display diffs between file revisions using ediff.
Normally this compares the currently selected fileset with their
working revisions.  With a prefix argument HISTORIC, it reads two revision
designators specifying which revisions to compare.

The optional argument NOT-URGENT non-nil means it is ok to say no to
saving the buffer.

(fn HISTORIC &optional NOT-URGENT)〉〉enditem49840〈〈vc-insert-headers〉〉:〈〈Insert headers into a file for use with a version control system.
Headers desired are inserted at point, and are pulled from
the variable ‘vc-BACKEND-header’.

(fn)〉〉enditem49840〈〈vc-log-incoming〉〉:〈〈Show a log of changes that will be received with a pull operation from REMOTE-LOCATION.
When called interactively with a prefix argument, prompt for REMOTE-LOCATION.

(fn &optional REMOTE-LOCATION)〉〉enditem49840〈〈vc-log-outgoing〉〉:〈〈Show a log of changes that will be sent with a push operation to REMOTE-LOCATION.
When called interactively with a prefix argument, prompt for REMOTE-LOCATION.

(fn &optional REMOTE-LOCATION)〉〉enditem49840〈〈vc-merge〉〉:〈〈Perform a version control merge operation.
You must be visiting a version controlled file, or in a ‘vc-dir’ buffer.
On a distributed version control system, this runs a "merge"
operation to incorporate changes from another branch onto the
current branch, prompting for an argument list.

On a non-distributed version control system, this merges changes
between two revisions into the current fileset.  This asks for
two revisions to merge from in the minibuffer.  If the first
revision is a branch number, then merge all changes from that
branch.  If the first revision is empty, merge the most recent
changes from the current branch.

(fn)〉〉enditem49840〈〈vc-next-action〉〉:〈〈Do the next logical version control operation on the current fileset.
This requires that all files in the current VC fileset be in the
same state.  If not, signal an error.

For merging-based version control systems:
  If every file in the VC fileset is not registered for version
   control, register the fileset (but don’t commit).
  If every work file in the VC fileset is added or changed, pop
   up a *vc-log* buffer to commit the fileset.
  For a centralized version control system, if any work file in
   the VC fileset is out of date, offer to update the fileset.

For old-style locking-based version control systems, like RCS:
  If every file is not registered, register the file(s).
  If every file is registered and unlocked, check out (lock)
   the file(s) for editing.
  If every file is locked by you and has changes, pop up a
   *vc-log* buffer to check in the changes.  Leave a
   read-only copy of each changed file after checking in.
  If every file is locked by you and unchanged, unlock them.
  If every file is locked by someone else, offer to steal the lock.

(fn VERBOSE)〉〉enditem49840〈〈vc-print-log〉〉:〈〈List the change log of the current fileset in a window.
If WORKING-REVISION is non-nil, leave point at that revision.
If LIMIT is non-nil, it should be a number specifying the maximum
number of revisions to show; the default is ‘vc-log-show-limit’.

When called interactively with a prefix argument, prompt for
WORKING-REVISION and LIMIT.

(fn &optional WORKING-REVISION LIMIT)〉〉enditem49840〈〈vc-print-root-log〉〉:〈〈List the change log for the current VC controlled tree in a window.
If LIMIT is non-nil, it should be a number specifying the maximum
number of revisions to show; the default is ‘vc-log-show-limit’.
When called interactively with a prefix argument, prompt for LIMIT.

(fn &optional LIMIT)〉〉enditem49840〈〈vc-pull〉〉:〈〈Update the current fileset or branch.
You must be visiting a version controlled file, or in a ‘vc-dir’ buffer.
On a distributed version control system, this runs a "pull"
operation to update the current branch, prompting for an argument
list if required.  Optional prefix ARG forces a prompt for the VCS
command to run.

On a non-distributed version control system, update the current
fileset to the tip revisions.  For each unchanged and unlocked
file, this simply replaces the work file with the latest revision
on its branch.  If the file contains changes, any changes in the
tip revision are merged into the working file.

(fn &optional ARG)〉〉enditem49840〈〈vc-push〉〉:〈〈Push the current branch.
You must be visiting a version controlled file, or in a ‘vc-dir’ buffer.
On a distributed version control system, this runs a "push"
operation on the current branch, prompting for the precise command
if required.  Optional prefix ARG non-nil forces a prompt for the
VCS command to run.

On a non-distributed version control system, this signals an error.
It also signals an error in a Bazaar bound branch.

(fn &optional ARG)〉〉enditem49840〈〈vc-refresh-state〉〉:〈〈Refresh the VC state of the current buffer’s file.

This command is more thorough than ‘vc-state-refresh’, in that it
also supports switching a back-end or removing the file from VC.
In the latter case, VC mode is deactivated for this buffer.〉〉enditem49840〈〈vc-region-history〉〉:〈〈Show the history of the region between FROM and TO.

If called interactively, show the history between point and
mark.

(fn FROM TO)〉〉enditem49840〈〈vc-register〉〉:〈〈Register into a version control system.
If VC-FILESET is given, register the files in that fileset.
Otherwise register the current file.
If COMMENT is present, use that as an initial comment.

The version control system to use is found by cycling through the list
‘vc-handled-backends’.  The first backend in that list which declares
itself responsible for the file (usually because other files in that
directory are already registered under that backend) will be used to
register the file.  If no backend declares itself responsible, the
first backend that could register the file is used.

(fn &optional VC-FILESET COMMENT)〉〉enditem49840〈〈vc-rename-file〉〉:〈〈Rename file OLD to NEW in both work area and repository.
If called interactively, read OLD and NEW, defaulting OLD to the
current buffer’s file name if it’s under version control.

(fn OLD NEW)〉〉enditem49840〈〈vc-retrieve-tag〉〉:〈〈For each file in or below DIR, retrieve their tagged version NAME.
NAME can name a branch, in which case this command will switch to the
named branch in the directory DIR.
Interactively, prompt for DIR only for VCS that works at file level;
otherwise use the repository root of the current buffer.
If NAME is empty, it refers to the latest revisions of the current branch.
If locking is used for the files in DIR, then there must not be any
locked files at or below DIR (but if NAME is empty, locked files are
allowed and simply skipped).

(fn DIR NAME)〉〉enditem49840〈〈vc-revert-buffer〉〉:〈〈Revert working copies of the selected fileset to their repository contents.
This asks for confirmation if the buffer contents are not identical
to the working revision (except for keyword expansion).

(fn)〉〉enditem49840〈〈vc-revert〉〉:〈〈Revert working copies of the selected fileset to their repository contents.
This asks for confirmation if the buffer contents are not identical
to the working revision (except for keyword expansion).

(fn)〉〉enditem49840〈〈vc-revision-other-window〉〉:〈〈Visit revision REV of the current file in another window.
If the current file is named ‘F’, the revision is named ‘F.~REV~’.
If ‘F.~REV~’ already exists, use it instead of checking it out again.

(fn REV)〉〉enditem49840〈〈vc-root-diff〉〉:〈〈Display diffs between VC-controlled whole tree revisions.
Normally, this compares the tree corresponding to the current
fileset with the working revision.
With a prefix argument HISTORIC, prompt for two revision
designators specifying which revisions to compare.

The optional argument NOT-URGENT non-nil means it is ok to say no to
saving the buffer.

(fn HISTORIC &optional NOT-URGENT)〉〉enditem49840〈〈vc-state-refresh〉〉:〈〈Quickly recompute the ‘state’ of FILE.〉〉enditem49840〈〈vc-update-change-log〉〉:〈〈Find change log file and add entries from recent version control logs.
Normally, find log entries for all registered files in the default
directory.

With prefix arg of C-u, only find log entries for the current buffer’s file.

With any numeric prefix arg, find log entries for all currently visited
files that are under version control.  This puts all the entries in the
log for the default directory, which may not be appropriate.

From a program, any ARGS are assumed to be filenames for which
log entries should be gathered.

(fn &rest ARGS)〉〉enditem49840〈〈view-buffer〉〉:〈〈View BUFFER in View mode, returning to previous buffer when done.
Emacs commands editing the buffer contents are not available; instead, a
special set of commands (mostly letters and punctuation) are defined for
moving around in the buffer.
Space scrolls forward, Delete scrolls backward.
For a list of all View commands, type H or h while viewing.

This command runs the normal hook ‘view-mode-hook’.

Optional argument EXIT-ACTION is either nil or a function with buffer as
argument.  This function is called when finished viewing buffer.  Use
this argument instead of explicitly setting ‘view-exit-action’.

Do not set EXIT-ACTION to ‘kill-buffer’ when BUFFER visits a
file: Users may suspend viewing in order to modify the buffer.
Exiting View mode will then discard the user’s edits.  Setting
EXIT-ACTION to ‘kill-buffer-if-not-modified’ avoids this.

This function does not enable View mode if the buffer’s major-mode
has a ‘special’ mode-class, because such modes usually have their
own View-like bindings.

(fn BUFFER &optional EXIT-ACTION)〉〉enditem49840〈〈view-echo-area-messages〉〉:〈〈View the log of recent echo-area messages: the ‘*Messages*’ buffer.
The number of messages retained in that buffer
is specified by the variable ‘message-log-max’.〉〉enditem49840〈〈view-emacs-FAQ〉〉:〈〈Display the Emacs Frequently Asked Questions (FAQ) file.〉〉enditem49840〈〈view-emacs-debugging〉〉:〈〈Display info on how to debug Emacs problems.〉〉enditem49840〈〈view-emacs-news〉〉:〈〈Display info on recent changes to Emacs.
With argument, display info only for the selected version.〉〉enditem49840〈〈view-emacs-problems〉〉:〈〈Display info on known problems with Emacs and possible workarounds.〉〉enditem49840〈〈view-emacs-todo〉〉:〈〈Display the Emacs TODO list.〉〉enditem49840〈〈view-external-packages〉〉:〈〈Display info on where to get more Emacs packages.〉〉enditem49840〈〈view-file〉〉:〈〈View FILE in View mode, returning to previous buffer when done.
Emacs commands editing the buffer contents are not available; instead, a
special set of commands (mostly letters and punctuation) are defined for
moving around in the buffer.
Space scrolls forward, Delete scrolls backward.
For a list of all View commands, type H or h while viewing.

This command runs the normal hook ‘view-mode-hook’.

(fn FILE)〉〉enditem49840〈〈view-hello-file〉〉:〈〈Display the HELLO file, which lists many languages and characters.〉〉enditem49840〈〈view-lossage〉〉:〈〈Display last few input keystrokes and the commands run.

To record all your input, use ‘open-dribble-file’.〉〉enditem49840〈〈view-order-manuals〉〉:〈〈Display information on how to buy printed copies of Emacs manuals.〉〉enditem49840〈〈visit-tags-table〉〉:〈〈Tell tags commands to use tags table file FILE.
FILE should be the name of a file created with the ‘etags’ program.
A directory name is ok too; it means file TAGS in that directory.

Normally M-x visit-tags-table sets the global value of ‘tags-file-name’.
With a prefix arg, set the buffer-local value instead.  When called
from Lisp, if the optional arg LOCAL is non-nil, set the local value.
When you find a tag with M-x find-tag, the buffer it finds the tag
in is given a local value of this variable which is the name of the tags
file the tag was in.

(fn FILE &optional LOCAL)〉〉enditem49840〈〈visual-line-mode〉〉:〈〈Toggle visual line based editing (Visual Line mode) in the current buffer.
Interactively, with a prefix argument, enable
Visual Line mode if the prefix argument is positive,
and disable it otherwise.  If called from Lisp, toggle
the mode if ARG is ‘toggle’, disable the mode if ARG is
a non-positive integer, and enable the mode otherwise
(including if ARG is omitted or nil or a positive integer).

When Visual Line mode is enabled, ‘word-wrap’ is turned on in
this buffer, and simple editing commands are redefined to act on
visual lines, not logical lines.  See Info node ‘Visual Line
Mode’ for details.

(fn &optional ARG)〉〉enditem49840〈〈wdired-change-to-wdired-mode〉〉:〈〈Put a Dired buffer in Writable Dired (WDired) mode.

In WDired mode, you can edit the names of the files in the
buffer, the target of the links, and the permission bits of the
files.  After typing C-c C-c, Emacs modifies the files and
directories to reflect your edits.

See ‘wdired-mode’.〉〉enditem49840〈〈wdired-finish-edit〉〉:〈〈Actually rename files based on your editing in the Dired buffer.〉〉enditem49840〈〈what-cursor-position〉〉:〈〈Print info on cursor position (on screen and within buffer).
Also describe the character after point, and give its character code
in octal, decimal and hex.

For a non-ASCII multibyte character, also give its encoding in the
buffer’s selected coding system if the coding system encodes the
character safely.  If the character is encoded into one byte, that
code is shown in hex.  If the character is encoded into more than one
byte, just "..." is shown.

In addition, with prefix argument, show details about that character
in *Help* buffer.  See also the command ‘describe-char’.

(fn &optional DETAIL)〉〉enditem49840〈〈what-line〉〉:〈〈Print the current buffer line number and narrowed line number of point.〉〉enditem49840〈〈what-page〉〉:〈〈Print page and line number of point.〉〉enditem49840〈〈where-is〉〉:〈〈Print message listing key sequences that invoke the command DEFINITION.
Argument is a command definition, usually a symbol with a function definition.
If INSERT (the prefix arg) is non-nil, insert the message in the buffer.〉〉enditem49840〈〈which-function-mode〉〉:〈〈Toggle mode line display of current function (Which Function mode).
With a prefix argument ARG, enable Which Function mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Which Function mode is a global minor mode.  When enabled, the
current function name is continuously displayed in the mode line,
in certain major modes.

(fn &optional ARG)〉〉enditem49840〈〈whitespace-mode〉〉:〈〈Toggle whitespace visualization (Whitespace mode).
With a prefix argument ARG, enable Whitespace mode if ARG is
positive, and disable it otherwise.

If called from Lisp, also enables the mode if ARG is omitted or nil,
and toggles it if ARG is ‘toggle’.

See also ‘whitespace-style’, ‘whitespace-newline’ and
‘whitespace-display-mappings’.

(fn &optional ARG)〉〉enditem49840〈〈whitespace-toggle-options〉〉:〈〈Toggle local ‘whitespace-mode’ options.

If local whitespace-mode is off, toggle the option given by ARG
and turn on local whitespace-mode.

If local whitespace-mode is on, toggle the option given by ARG
and restart local whitespace-mode.

Interactively, it reads one of the following chars:

  CHAR	MEANING
  (VIA FACES)
   f	toggle face visualization
   t	toggle TAB visualization
   s	toggle SPACE and HARD SPACE visualization
   r	toggle trailing blanks visualization
   l	toggle "long lines" visualization
   L	toggle "long lines" tail visualization
   n	toggle NEWLINE visualization
   e	toggle empty line at bob and/or eob visualization
   C-i	toggle indentation SPACEs visualization (via ‘indent-tabs-mode’)
   I	toggle indentation SPACEs visualization
   i	toggle indentation TABs visualization
   C-t	toggle big indentation visualization
   C-a	toggle SPACEs after TAB visualization (via ‘indent-tabs-mode’)
   A	toggle SPACEs after TAB: SPACEs visualization
   a	toggle SPACEs after TAB: TABs visualization
   C-b	toggle SPACEs before TAB visualization (via ‘indent-tabs-mode’)
   B	toggle SPACEs before TAB: SPACEs visualization
   b	toggle SPACEs before TAB: TABs visualization

  (VIA DISPLAY TABLE)
   T	toggle TAB visualization
   S	toggle SPACEs before TAB visualization
   N	toggle NEWLINE visualization

   x	restore ‘whitespace-style’ value
   ?	display brief help

Non-interactively, ARG should be a symbol or a list of symbols.
The valid symbols are:

   face			toggle face visualization
   tabs			toggle TAB visualization
   spaces		toggle SPACE and HARD SPACE visualization
   trailing		toggle trailing blanks visualization
   lines		toggle "long lines" visualization
   lines-tail		toggle "long lines" tail visualization
   newline		toggle NEWLINE visualization
   empty		toggle empty line at bob and/or eob visualization
   indentation		toggle indentation SPACEs visualization
   indentation::tab	toggle indentation SPACEs visualization
   indentation::space	toggle indentation TABs visualization
   big-indent		toggle big indentation visualization
   space-after-tab		toggle SPACEs after TAB visualization
   space-after-tab::tab		toggle SPACEs after TAB: SPACEs visualization
   space-after-tab::space	toggle SPACEs after TAB: TABs visualization
   space-before-tab		toggle SPACEs before TAB visualization
   space-before-tab::tab	toggle SPACEs before TAB: SPACEs visualization
   space-before-tab::space	toggle SPACEs before TAB: TABs visualization

   tab-mark		toggle TAB visualization
   space-mark		toggle SPACEs before TAB visualization
   newline-mark		toggle NEWLINE visualization

   whitespace-style	restore ‘whitespace-style’ value

See ‘whitespace-style’ and ‘indent-tabs-mode’ for documentation.

(fn ARG)〉〉enditem49840〈〈widget-backward〉〉:〈〈Move point to the previous field or button.
With optional ARG, move across that many fields.

(fn ARG)〉〉enditem49840〈〈widget-complete〉〉:〈〈Complete content of editable field from point.
When not inside a field, signal an error.〉〉enditem49840〈〈widget-forward〉〉:〈〈Move point to the next field or button.
With optional ARG, move across that many fields.

(fn ARG)〉〉enditem49840〈〈windmove-default-keybindings〉〉:〈〈Set up keybindings for ‘windmove’.
Keybindings are of the form MODIFIER-{left,right,up,down}.
Default MODIFIER is ‘shift’.

(fn &optional MODIFIER)〉〉enditem49840〈〈windmove-right〉〉:〈〈Select the window to the right of the current one.
With no prefix argument, or with prefix argument equal to zero,
"right" is relative to the position of point in the window;
otherwise it is relative to the top edge (for positive ARG) or the
bottom edge (for negative ARG) of the current window.
If no window is at the desired location, an error is signaled.

(fn &optional ARG)〉〉enditem49840〈〈window-configuration-to-register〉〉:〈〈Store the window configuration of the selected frame in register REGISTER.
Use C-x r j to restore the configuration.
Argument is a character, naming the register.

Interactively, reads the register using ‘register-read-with-preview’.

(fn REGISTER &optional ARG)〉〉enditem49840〈〈window-divider-mode〉〉:〈〈Display dividers between windows (Window Divider mode).
With a prefix argument ARG, enable Window Divider mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

The option ‘window-divider-default-places’ specifies on which
side of a window dividers are displayed.  The options
‘window-divider-default-bottom-width’ and
‘window-divider-default-right-width’ specify their respective
widths.

(fn &optional ARG)〉〉enditem49840〈〈winner-mode〉〉:〈〈Toggle Winner mode on or off.
With a prefix argument ARG, enable Winner mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is ‘toggle’.

Winner mode is a global minor mode that records the changes in
the window configuration (i.e. how the frames are partitioned
into windows) so that the changes can be "undone" using the
command ‘winner-undo’.  By default this one is bound to the key
sequence ‘C-c <left>’.  If you change your mind (while undoing),
you can press ‘C-c <right>’ (calling ‘winner-redo’).

(fn &optional ARG)〉〉enditem49840〈〈woman〉〉:〈〈Browse UN*X man page for TOPIC (Without using external Man program).
The major browsing mode used is essentially the standard Man mode.
Choose the filename for the man page using completion, based on the
topic selected from the directories specified in ‘woman-manpath’ and
‘woman-path’.  The directory expansions and topics are cached for
speed.  With a prefix argument, force the caches to be
updated (e.g. to re-interpret the current directory).

Used non-interactively, arguments are optional: if given then TOPIC
should be a topic string and non-nil RE-CACHE forces re-caching.

(fn &optional TOPIC RE-CACHE)〉〉enditem49840〈〈xdb〉〉:〈〈Run xdb on program FILE in buffer *gud-FILE*.
The directory containing FILE becomes the initial working directory
and source-file directory for your debugger.

You can set the variable ‘gud-xdb-directories’ to a list of program source
directories if your program contains sources from more than one directory.

(fn COMMAND-LINE)〉〉enditem49840〈〈xref-find-apropos〉〉:〈〈Find all meaningful symbols that match PATTERN.
The argument has the same meaning as in ‘apropos’.

(fn PATTERN)〉〉enditem49840〈〈xref-find-definitions-other-frame〉〉:〈〈Like ‘xref-find-definitions’ but switch to the other frame.

(fn IDENTIFIER)〉〉enditem49840〈〈xref-find-definitions-other-window〉〉:〈〈Like ‘xref-find-definitions’ but switch to the other window.

(fn IDENTIFIER)〉〉enditem49840〈〈xref-find-definitions〉〉:〈〈Find the definition of the identifier at point.
With prefix argument or when there’s no identifier at point,
prompt for it.

If sufficient information is available to determine a unique
definition for IDENTIFIER, display it in the selected window.
Otherwise, display the list of the possible definitions in a
buffer where the user can select from the list.

(fn IDENTIFIER)〉〉enditem49840〈〈xref-find-references〉〉:〈〈Find references to the identifier at point.
With prefix argument, prompt for the identifier.

(fn IDENTIFIER)〉〉enditem49840〈〈xref-pop-marker-stack〉〉:〈〈Pop back to where DEL , t was last invoked.〉〉enditem49840〈〈xwidget-webkit-browse-url〉〉:〈〈Ask xwidget-webkit to browse URL.
NEW-SESSION specifies whether to create a new xwidget-webkit session.
Interactively, URL defaults to the string looking like a url around point.

(fn URL &optional NEW-SESSION)〉〉enditem49840〈〈yank-rectangle〉〉:〈〈Yank the last killed rectangle with upper left corner at point.

(fn)〉〉enditem49840〈〈zap-to-char〉〉:〈〈Kill up to and including ARGth occurrence of CHAR.
Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found.

(fn ARG CHAR)〉〉enditem49840〈〈zone〉〉:〈〈Zone out, completely.

(fn)〉〉enditem49840〈〈zrgrep〉〉:〈〈Recursively grep for REGEXP in gzipped FILES in tree rooted at DIR.
Like ‘rgrep’ but uses ‘zgrep’ for ‘grep-program’, sets the default
file name to ‘*.gz’, and sets ‘grep-highlight-matches’ to ‘always’.

(fn REGEXP &optional FILES DIR CONFIRM TEMPLATE)〉〉enditem49840