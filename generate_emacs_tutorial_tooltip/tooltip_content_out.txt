{"debug-on-entry":"Request FUNCTION to invoke debugger each time it is called.¶¶When called interactively, prompt for FUNCTION in the minibuffer.¶¶This works by modifying the definition of FUNCTION.  If you tell the¶debugger to continue, FUNCTION’s execution proceeds.  If FUNCTION is a¶normal function or a macro written in Lisp, you can also step through¶its execution.  FUNCTION can also be a primitive that is not a special¶form, in which case stepping is not possible.  Break-on-entry for¶primitive functions only works when that function is called from Lisp.¶¶Use M-x cancel-debug-on-entry to cancel the effect of this command.¶Redefining FUNCTION also cancels it.¶¶(fn FUNCTION)",
"cancel-debug-on-entry":"Undo effect of M-x debug-on-entry on FUNCTION.¶If FUNCTION is nil, cancel debug-on-entry for all functions.¶When called interactively, prompt for FUNCTION in the minibuffer.¶To specify a nil argument interactively, exit with an empty minibuffer.¶¶(fn &amp;optional FUNCTION)",
"beginning-of-line":"Move point to beginning of current line (in the logical order).¶With argument N not nil or 1, move forward N - 1 lines first.¶If point reaches the beginning or end of buffer, it stops there.¶¶This function constrains point to the current field unless this moves¶point to a different line than the original, unconstrained result.¶If N is nil or 1, and a front-sticky field starts at point, the point¶does not move.  To ignore field boundaries bind¶‘inhibit-field-text-motion’ to t, or use the ‘forward-line’ function¶instead.  For instance, ‘(forward-line 0)’ does the same thing as¶‘(beginning-of-line)’, except that it ignores field boundaries.¶¶(fn &amp;optional N)",
"end-of-line":"Move point to end of current line (in the logical order).¶With argument N not nil or 1, move forward N - 1 lines first.¶If point reaches the beginning or end of buffer, it stops there.¶To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.¶¶This function constrains point to the current field unless this moves¶point to a different line than the original, unconstrained result.  If¶N is nil or 1, and a rear-sticky field ends at point, the point does¶not move.  To ignore field boundaries bind ‘inhibit-field-text-motion’¶to t.¶¶(fn &amp;optional N)",
"forward-line":"Move N lines forward (backward if N is negative).¶Precisely, if point is on line I, move to the start of line I + N¶(&quot;start of line&quot; in the logical order).¶If there isn’t room, go as far as possible (no error).¶¶Returns the count of lines left to move.  If moving forward,¶that is N minus number of lines moved; if backward, N plus number¶moved.¶¶Exception: With positive N, a non-empty line at the end of the¶buffer, or of its accessible portion, counts as one line¶successfully moved (for the return value).  This means that the¶function will move point to the end of such a line and will count¶it as a line moved across, even though there is no next line to¶go to its beginning.¶¶(fn &amp;optional N)",
"count-words":"Count words between START and END.¶If called interactively, START and END are normally the start and¶end of the buffer; but if the region is active, START and END are¶the start and end of the region.  Print a message reporting the¶number of lines, words, and chars.¶¶If called from Lisp, return the number of words between START and¶END, without printing any message.¶¶(fn START END)",
"switch-to-buffer":"Display buffer BUFFER-OR-NAME in the selected window.¶¶WARNING: This is NOT the way to work on another buffer temporarily¶within a Lisp program!  Use ‘set-buffer’ instead.  That avoids¶messing with the window-buffer correspondences.¶¶If the selected window cannot display the specified buffer¶because it is a minibuffer window or strongly dedicated to¶another buffer, call ‘pop-to-buffer’ to select the buffer in¶another window.  In interactive use, if the selected window is¶strongly dedicated to its buffer, the value of the option¶‘switch-to-buffer-in-dedicated-window’ specifies how to proceed.¶¶If called interactively, read the buffer name using the¶minibuffer.  The variable ‘confirm-nonexistent-file-or-buffer’¶determines whether to request confirmation before creating a new¶buffer.¶¶BUFFER-OR-NAME may be a buffer, a string (a buffer name), or nil.¶If BUFFER-OR-NAME is a string that does not identify an existing¶buffer, create a buffer with that name.  If BUFFER-OR-NAME is¶nil, switch to the buffer returned by ‘other-buffer’.¶¶If optional argument NORECORD is non-nil, do not put the buffer¶at the front of the buffer list, and do not make the window¶displaying it the most recently selected one.¶¶If optional argument FORCE-SAME-WINDOW is non-nil, the buffer¶must be displayed in the selected window when called¶non-interactively; if that is impossible, signal an error rather¶than calling ‘pop-to-buffer’.¶¶The option ‘switch-to-buffer-preserve-window-point’ can be used¶to make the buffer appear at its last position in the selected¶window.¶¶Return the buffer switched to.",
"switch-to-buffer-other-window":"Select the buffer specified by BUFFER-OR-NAME in another window.¶BUFFER-OR-NAME may be a buffer, a string (a buffer name), or¶nil.  Return the buffer switched to.¶¶If called interactively, prompt for the buffer name using the¶minibuffer.  The variable ‘confirm-nonexistent-file-or-buffer’¶determines whether to request confirmation before creating a new¶buffer.¶¶If BUFFER-OR-NAME is a string and does not identify an existing¶buffer, create a new buffer with that name.  If BUFFER-OR-NAME is¶nil, switch to the buffer returned by ‘other-buffer’.¶¶Optional second argument NORECORD non-nil means do not put this¶buffer at the front of the list of recently selected ones.¶¶This uses the function ‘display-buffer’ as a subroutine; see its¶documentation for additional customization information.",
"switch-to-buffer-other-frame":"Switch to buffer BUFFER-OR-NAME in another frame.¶BUFFER-OR-NAME may be a buffer, a string (a buffer name), or¶nil.  Return the buffer switched to.¶¶If called interactively, prompt for the buffer name using the¶minibuffer.  The variable ‘confirm-nonexistent-file-or-buffer’¶determines whether to request confirmation before creating a new¶buffer.¶¶If BUFFER-OR-NAME is a string and does not identify an existing¶buffer, create a new buffer with that name.  If BUFFER-OR-NAME is¶nil, switch to the buffer returned by ‘other-buffer’.¶¶Optional second arg NORECORD non-nil means do not put this¶buffer at the front of the list of recently selected ones.¶¶This uses the function ‘display-buffer’ as a subroutine; see its¶documentation for additional customization information.",
"pop-to-buffer":"Select buffer BUFFER in some window, preferably a different one.¶BUFFER may be a buffer, a string (a buffer name), or nil.  If it¶is a string not naming an existent buffer, create a buffer with¶that name.  If BUFFER is nil, choose some other buffer.  Return¶the buffer.¶¶This uses ‘display-buffer’ as a subroutine.  The optional ACTION¶argument is passed to ‘display-buffer’ as its ACTION argument.¶See ‘display-buffer’ for more information.  ACTION is t if called¶interactively with a prefix argument, which means to pop to a¶window other than the selected one even if the buffer is already¶displayed in the selected window.¶¶If the window to show BUFFER is not on the selected¶frame, raise that window’s frame and give it input focus.¶¶Optional third arg NORECORD non-nil means do not put this buffer¶at the front of the list of recently selected ones.",
"indent-relative":"Space out to under next indent point in previous nonblank line.¶An indent point is a non-whitespace character following whitespace.¶The following line shows the indentation points in this line.¶    ^         ^    ^     ^   ^           ^      ^  ^    ^¶If the previous nonblank line has no indent points beyond the¶column point starts at, ‘tab-to-tab-stop’ is done instead, unless¶this command is invoked with a numeric argument, in which case it¶does nothing.¶¶See also ‘indent-relative-maybe’.¶¶(fn &amp;optional UNINDENTED-OK)",
"indent-relative-maybe":"Indent a new line like previous nonblank line.¶If the previous nonblank line has no indent points beyond the¶column point starts at, this command does nothing.¶¶See also ‘indent-relative’.",
"run-at-time":"Perform an action at time TIME.¶Repeat the action every REPEAT seconds, if REPEAT is non-nil.¶REPEAT may be an integer or floating point number.¶TIME should be one of:¶- a string giving today’s time like &quot;11:23pm&quot;¶  (the acceptable formats are HHMM, H:MM, HH:MM, HHam, HHAM,¶  HHpm, HHPM, HH:MMam, HH:MMAM, HH:MMpm, or HH:MMPM;¶  a period ‘.’ can be used instead of a colon ‘:’ to separate¶  the hour and minute parts);¶- a string giving a relative time like &quot;90&quot; or &quot;2 hours 35 minutes&quot;¶  (the acceptable forms are a number of seconds without units¶  or some combination of values using units in ‘timer-duration-words’);¶- nil, meaning now;¶- a number of seconds from now;¶- a value from ‘encode-time’;¶- or t (with non-nil REPEAT) meaning the next integral¶  multiple of REPEAT.¶¶The action is to call FUNCTION with arguments ARGS.¶¶This function returns a timer object which you can use in¶‘cancel-timer’.",
"write-abbrev-file":"Write all user-level abbrev definitions to a file of Lisp code.¶This does not include system abbrevs; it includes only the abbrev tables¶listed in listed in ‘abbrev-table-name-list’.¶The file written can be loaded in another session to define the same abbrevs.¶The argument FILE is the file name to write.  If omitted or nil, the file¶specified in ‘abbrev-file-name’ is used.¶If VERBOSE is non-nil, display a message indicating where abbrevs¶have been saved.¶¶(fn &amp;optional FILE VERBOSE)",
"indent-for-tab-command":"Indent the current line or region, or insert a tab, as appropriate.¶This function either inserts a tab, or indents the current line,¶or performs symbol completion, depending on ‘tab-always-indent’.¶The function called to actually indent the line or insert a tab¶is given by the variable ‘indent-line-function’.¶¶If a prefix argument is given, after this function indents the¶current line or inserts a tab, it also rigidly indents the entire¶balanced expression which starts at the beginning of the current¶line, to reflect the current line’s indentation.¶¶In most major modes, if point was in the current line’s¶indentation, it is moved to the first non-whitespace character¶after indenting; otherwise it stays at the same position relative¶to the text.¶¶If ‘transient-mark-mode’ is turned on and the region is active,¶this function instead calls ‘indent-region’.  In this case, any¶prefix argument is ignored.¶¶(fn &amp;optional ARG)",
"indent-according-to-mode":"Indent line in proper way for current major mode.¶Normally, this is done by calling the function specified by the¶variable ‘indent-line-function’.  However, if the value of that¶variable is ‘indent-relative’ or ‘indent-relative-maybe’, handle¶it specially (since those functions are used for tabbing); in¶that case, indent by aligning to the previous non-blank line.",
"newline-and-indent":"Insert a newline, then indent according to major mode.¶Indentation is done using the value of ‘indent-line-function’.¶In programming language modes, this is the same as TAB.¶In some text modes, where TAB inserts a tab, this command indents to the¶column specified by the function ‘current-left-margin’.",
"reindent-then-newline-and-indent":"Reindent current line, insert newline, then indent the new line.¶Indentation of both lines is done according to the current major mode,¶which means calling the current value of ‘indent-line-function’.¶In programming language modes, this is the same as TAB.¶In some text modes, where TAB inserts a tab, this indents to the¶column specified by the function ‘current-left-margin’.",
"minibuffer-complete-word":"Complete the minibuffer contents at most a single word.¶After one word is completed as much as possible, a space or hyphen¶is added, provided that matches some possible completion.¶Return nil if there is no valid completion, else t.",
"minibuffer-complete":"Complete the minibuffer contents as far as possible.¶Return nil if there is no valid completion, else t.¶If no characters can be completed, display a list of possible completions.¶If you repeat this command after it displayed such a list,¶scroll the window of possible completions.",
"minibuffer-complete-and-exit":"Exit if the minibuffer contains a valid completion.¶Otherwise, try to complete the minibuffer contents.  If¶completion leads to a valid completion, a repetition of this¶command will exit.¶¶If ‘minibuffer-completion-confirm’ is ‘confirm’, do not try to¶ complete; instead, ask for confirmation and accept any input if¶ confirmed.¶If ‘minibuffer-completion-confirm’ is ‘confirm-after-completion’,¶ do not try to complete; instead, ask for confirmation if the¶ preceding minibuffer command was a member of¶ ‘minibuffer-confirm-exit-commands’, and accept the input¶ otherwise.",
"minibuffer-completion-help":"Display a list of possible completions of the current minibuffer contents.¶¶(fn &amp;optional START END)",
"fill-paragraph":"Fill paragraph at or after point.¶¶If JUSTIFY is non-nil (interactively, with prefix argument), justify as well.¶If ‘sentence-end-double-space’ is non-nil, then period followed by one¶space does not end a sentence, so don’t break a line there.¶The variable ‘fill-column’ controls the width for filling.¶¶If ‘fill-paragraph-function’ is non-nil, we call it (passing our¶argument to it), and if it returns non-nil, we simply return its value.¶¶If ‘fill-paragraph-function’ is nil, return the ‘fill-prefix’ used for filling.¶¶The REGION argument is non-nil if called interactively; in that¶case, if Transient Mark mode is enabled and the mark is active,¶call ‘fill-region’ to fill each of the paragraphs in the active¶region, instead of just filling the current paragraph.",
"fill-region":"Fill each of the paragraphs in the region.¶A prefix arg means justify as well.¶The ‘fill-column’ variable controls the width.¶¶Noninteractively, the third argument JUSTIFY specifies which¶kind of justification to do: ‘full’, ‘left’, ‘right’, ‘center’,¶or ‘none’ (equivalent to nil).  A value of t means handle each¶paragraph as specified by its text properties.¶¶The fourth arg NOSQUEEZE non-nil means to leave whitespace other¶than line breaks untouched, and fifth arg TO-EOP non-nil means¶to keep filling to the end of the paragraph (or next hard newline,¶if variable ‘use-hard-newlines’ is on).¶¶Return the fill-prefix used for filling the last paragraph.¶¶If ‘sentence-end-double-space’ is non-nil, then period followed by one¶space does not end a sentence, so don’t break a line there.",
"fill-individual-paragraphs":"Fill paragraphs of uniform indentation within the region.¶This command divides the region into &quot;paragraphs&quot;,¶treating every change in indentation level or prefix as a paragraph boundary,¶then fills each paragraph using its indentation level as the fill prefix.¶¶There is one special case where a change in indentation does not start¶a new paragraph.  This is for text of this form:¶¶   foo&gt;    This line with extra indentation starts¶   foo&gt; a paragraph that continues on more lines.¶¶These lines are filled together.¶¶When calling from a program, pass the range to fill¶as the first two arguments.¶¶Optional third and fourth arguments JUSTIFY and CITATION-REGEXP:¶JUSTIFY to justify paragraphs (prefix arg).¶When filling a mail message, pass a regexp for CITATION-REGEXP¶which will match the prefix of a line which is a citation marker¶plus whitespace, but no other kind of prefix.¶Also, if CITATION-REGEXP is non-nil, don’t fill header lines.",
"fill-region-as-paragraph":"Fill the region as one paragraph.¶It removes any paragraph breaks in the region and extra newlines at the end,¶indents and fills lines between the margins given by the¶‘current-left-margin’ and ‘current-fill-column’ functions.¶(In most cases, the variable ‘fill-column’ controls the width.)¶It leaves point at the beginning of the line following the paragraph.¶¶Normally performs justification according to the ‘current-justification’¶function, but with a prefix arg, does full justification instead.¶¶From a program, optional third arg JUSTIFY can specify any type of¶justification.  Fourth arg NOSQUEEZE non-nil means not to make spaces¶between words canonical before filling.  Fifth arg SQUEEZE-AFTER, if non-nil,¶means don’t canonicalize spaces before that position.¶¶Return the ‘fill-prefix’ used for filling.¶¶If ‘sentence-end-double-space’ is non-nil, then period followed by one¶space does not end a sentence, so don’t break a line there.",
"justify-current-line":"Do some kind of justification on this line.¶Normally does full justification: adds spaces to the line to make it end at¶the column given by ‘current-fill-column’.¶Optional first argument HOW specifies alternate type of justification:¶it can be ‘left’, ‘right’, ‘full’, ‘center’, or ‘none’.¶If HOW is t, will justify however the ‘current-justification’ function says to.¶If HOW is nil or missing, full justification is done by default.¶Second arg EOP non-nil means that this is the last line of the paragraph, so¶it will not be stretched by full justification.¶Third arg NOSQUEEZE non-nil means to leave interior whitespace unchanged,¶otherwise it is made canonical.",
"push-button":"Perform the action specified by a button at location POS.¶POS may be either a buffer position or a mouse-event.  If¶USE-MOUSE-ACTION is non-nil, invoke the button’s ‘mouse-action’¶property instead of its ‘action’ property; if the button has no¶‘mouse-action’, the value of ‘action’ is used instead.¶¶The action in both cases may be either a function to call or a¶marker to display and is invoked using ‘button-activate’ (which¶see).¶¶POS defaults to point, except when ‘push-button’ is invoked¶interactively as the result of a mouse-event, in which case, the¶mouse event is used.¶If there’s no button at POS, do nothing and return nil, otherwise¶return t.",
"forward-button":"Move to the Nth next button, or Nth previous button if N is negative.¶If N is 0, move to the start of any button at point.¶If WRAP is non-nil, moving past either end of the buffer continues from the¶other end.¶If DISPLAY-MESSAGE is non-nil, the button’s help-echo string is displayed.¶Any button with a non-nil ‘skip’ property is skipped over.¶Returns the button found.",
"backward-button":"Move to the Nth previous button, or Nth next button if N is negative.¶If N is 0, move to the start of any button at point.¶If WRAP is non-nil, moving past either end of the buffer continues from the¶other end.¶If DISPLAY-MESSAGE is non-nil, the button’s help-echo string is displayed.¶Any button with a non-nil ‘skip’ property is skipped over.¶Returns the button found.",
"append-to-file":"Append the contents of the region to the end of file FILENAME.¶When called from a function, expects three arguments,¶START, END and FILENAME.  START and END are normally buffer positions¶specifying the part of the buffer to write.¶If START is nil, that means to use the entire buffer contents.¶If START is a string, then output that string to the file¶instead of any buffer contents; END is ignored.¶¶This does character code conversion and applies annotations¶like ‘write-region’ does.¶¶(fn START END FILENAME)",
"write-region":"Write current region into specified file.¶When called from a program, requires three arguments:¶START, END and FILENAME.  START and END are normally buffer positions¶specifying the part of the buffer to write.¶If START is nil, that means to use the entire buffer contents; END is¶ignored.¶If START is a string, then output that string to the file¶instead of any buffer contents; END is ignored.¶¶Optional fourth argument APPEND if non-nil means¶  append to existing file contents (if any).  If it is a number,¶  seek to that offset in the file before writing.¶Optional fifth argument VISIT, if t or a string, means¶  set the last-save-file-modtime of buffer to this file’s modtime¶  and mark buffer not modified.¶If VISIT is a string, it is a second file name;¶  the output goes to FILENAME, but the buffer is marked as visiting VISIT.¶  VISIT is also the file name to lock and unlock for clash detection.¶If VISIT is neither t nor nil nor a string, or if Emacs is in batch mode,¶  do not display the &quot;Wrote file&quot; message.¶The optional sixth arg LOCKNAME, if non-nil, specifies the name to¶  use for locking and unlocking, overriding FILENAME and VISIT.¶The optional seventh arg MUSTBENEW, if non-nil, insists on a check¶  for an existing file with the same name.  If MUSTBENEW is ‘excl’,¶  that means to get an error if the file already exists; never overwrite.¶  If MUSTBENEW is neither nil nor ‘excl’, that means ask for¶  confirmation before overwriting, but do go ahead and overwrite the file¶  if the user confirms.¶¶This does code conversion according to the value of¶‘coding-system-for-write’, ‘buffer-file-coding-system’, or¶‘file-coding-system-alist’, and sets the variable¶‘last-coding-system-used’ to the coding system actually used.¶¶This calls ‘write-region-annotate-functions’ at the start, and¶‘write-region-post-annotation-function’ at the end.¶¶(fn START END FILENAME &amp;optional APPEND VISIT LOCKNAME MUSTBENEW)",
"universal-argument":"Begin a numeric argument for the following command.¶Digits or minus sign following DEL , make up the numeric argument.¶DEL , following the digits or minus sign ends the argument.¶DEL , without digits or minus sign provides 4 as argument.¶Repeating DEL , without digits or minus sign¶ multiplies the argument by 4 each time.¶For some commands, just DEL , by itself serves as a flag¶which is different in effect from any particular numeric argument.¶These commands include y and M-x start-kbd-macro.",
"digit-argument":"Part of the numeric argument for the next command.¶DEL , following digits or minus sign ends the argument.¶¶(fn ARG)",
"negative-argument":"Begin a negative numeric argument for the next command.¶DEL , following digits or minus sign ends the argument.¶¶(fn ARG)",
"suspend-emacs":"Stop Emacs and return to superior process.  You can resume later.¶If ‘cannot-suspend’ is non-nil, or if the system doesn’t support job¶control, run a subshell instead.¶¶If optional arg STUFFSTRING is non-nil, its characters are stuffed¶to be read as terminal input by Emacs’s parent, after suspension.¶¶Before suspending, run the normal hook ‘suspend-hook’.¶After resumption run the normal hook ‘suspend-resume-hook’.¶¶Some operating systems cannot stop the Emacs process and resume it later.¶On such systems, Emacs starts a subshell instead of suspending.¶¶(fn &amp;optional STUFFSTRING)",
"suspend-frame":"Do whatever is right to suspend the current frame.¶Calls ‘suspend-emacs’ if invoked from the controlling tty device,¶‘suspend-tty’ from a secondary tty device, and¶‘iconify-or-deiconify-frame’ from an X frame.",
"set-input-method":"Select and activate input method INPUT-METHOD for the current buffer.¶This also sets the default input method to the one you specify.¶If INPUT-METHOD is nil, this function turns off the input method, and¶also causes you to be prompted for a name of an input method the next¶time you invoke C-⧷.¶When called interactively, the optional arg INTERACTIVE is non-nil,¶which marks the variable ‘default-input-method’ as set for Custom buffers.¶¶To deactivate the input method interactively, use C-⧷.¶To deactivate it programmatically, use ‘deactivate-input-method’.¶¶(fn INPUT-METHOD &amp;optional INTERACTIVE)",
"indent-to":"Indent from point with tabs and spaces until COLUMN is reached.¶Optional second argument MINIMUM says always do at least MINIMUM spaces¶even if that goes past COLUMN; by default, MINIMUM is zero.¶¶The return value is COLUMN.¶¶(fn COLUMN &amp;optional MINIMUM)",
"describe-current-display-table":"Describe the display table in use in the selected window and buffer.",
"read-color":"Read a color name or RGB triplet.¶Completion is available for color names, but not for RGB triplets.¶¶RGB triplets have the form &quot;#RRGGBB&quot;.  Each of the R, G, and B¶components can have one to four digits, but all three components¶must have the same number of digits.  Each digit is a hex value¶between 0 and F; either upper case or lower case for A through F¶are acceptable.¶¶In addition to standard color names and RGB hex values, the¶following are available as color candidates.  In each case, the¶corresponding color is used.¶¶ * ‘foreground at point’   - foreground under the cursor¶ * ‘background at point’   - background under the cursor¶¶Optional arg PROMPT is the prompt; if nil, use a default prompt.¶¶Interactively, or with optional arg CONVERT-TO-RGB-P non-nil,¶convert an input color name to an RGB hex string.  Return the RGB¶hex string.¶¶If optional arg ALLOW-EMPTY-NAME is non-nil, the user is allowed¶to enter an empty color name (the empty string).¶¶Interactively, or with optional arg MSG non-nil, print the¶resulting color name in the echo area.",
"posix-search-forward":"Search forward from point for regular expression REGEXP.¶Find the longest match in accord with Posix regular expression rules.¶Set point to the end of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not end after that position.  A value of nil¶  means search to the end of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, move to limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  backward, instead of forward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth one (or first,¶  if COUNT is 1 or nil) in the buffer located entirely after the¶  origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,¶and ‘replace-match’.¶¶(fn REGEXP &amp;optional BOUND NOERROR COUNT)",
"posix-search-backward":"Search backward from point for match for regular expression REGEXP.¶Find the longest match in accord with Posix regular expression rules.¶Set point to the beginning of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not begin before that position.  A value of nil¶  means search to the beginning of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, position at limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  forward, instead of backward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth to last one (or¶  last, if COUNT is 1 or nil) in the buffer located entirely before¶  the origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,¶and ‘replace-match’.¶¶(fn REGEXP &amp;optional BOUND NOERROR COUNT)",
"save-buffer":"Save current buffer in visited file if modified.¶Variations are described below.¶¶By default, makes the previous version into a backup file¶ if previously requested or if this is the first save.¶Prefixed with one DEL ,, marks this version¶ to become a backup when the next save is done.¶Prefixed with two DEL ,’s,¶ makes the previous version into a backup file.¶Prefixed with three DEL ,’s, marks this version¶ to become a backup when the next save is done,¶ and makes the previous version into a backup file.¶¶With a numeric prefix argument of 0, never make the previous version¶into a backup file.¶¶Note that the various variables that control backups, such¶as ‘version-control’, ‘backup-enable-predicate’, ‘vc-make-backup-files’,¶and ‘backup-inhibited’, to name just the more popular ones, still¶control whether a backup will actually be produced, even when you¶invoke this command prefixed with two or three DEL ,’s.¶¶If a file’s name is FOO, the names of its numbered backup versions are¶ FOO.~i~ for various integers i.  A non-numbered backup file is called FOO~.¶Numeric backups (rather than FOO~) will be made if value of¶ ‘version-control’ is not the atom ‘never’ and either there are already¶ numeric versions of the file being backed up, or ‘version-control’ is¶ non-nil.¶We don’t want excessive versions piling up, so there are variables¶ ‘kept-old-versions’, which tells Emacs how many oldest versions to keep,¶ and ‘kept-new-versions’, which tells how many newest versions to keep.¶ Defaults are 2 old versions and 2 new.¶‘dired-kept-versions’ controls dired’s clean-directory (.) command.¶If ‘delete-old-versions’ is nil, system will query user¶ before trimming versions.  Otherwise it does it silently.¶¶If ‘vc-make-backup-files’ is nil, which is the default,¶ no backup files are made for files managed by version control.¶ (This is because the version control system itself records previous versions.)¶¶See the subroutine ‘basic-save-buffer’ for more information.¶¶(fn &amp;optional ARG)",
"save-some-buffers":"Save some modified file-visiting buffers.  Asks user about each one.¶You can answer ‘y’ to save, ‘n’ not to save, ‘C-r’ to look at the¶buffer in question with ‘view-buffer’ before deciding or ‘d’ to¶view the differences using ‘diff-buffer-with-file’.¶¶This command first saves any buffers where ‘buffer-save-without-query’ is¶non-nil, without asking.¶¶Optional argument (the prefix) non-nil means save all with no questions.¶Optional second argument PRED determines which buffers are considered:¶If PRED is nil, all the file-visiting buffers are considered.¶If PRED is t, then certain non-file buffers will also be considered.¶If PRED is a zero-argument function, it indicates for each buffer whether¶to consider it or not when called with that buffer current.¶¶See ‘save-some-buffers-action-alist’ if you want to¶change the additional actions you can take on files.¶¶(fn &amp;optional ARG PRED)",
"write-file":"Write current buffer into file FILENAME.¶This makes the buffer visit that file, and marks it as not modified.¶¶If you specify just a directory name as FILENAME, that means to use¶the default file name but in that directory.  You can also yank¶the default file name into the minibuffer to edit it, using M-n.¶¶If the buffer is not already visiting a file, the default file name¶for the output file is the buffer name.¶¶If optional second arg CONFIRM is non-nil, this function¶asks for confirmation before overwriting an existing file.¶Interactively, confirmation is required unless you supply a prefix argument.¶¶(fn FILENAME &amp;optional CONFIRM)",
"signal-process":"Send PROCESS the signal with code SIGCODE.¶PROCESS may also be a number specifying the process id of the¶process to signal; in this case, the process need not be a child of¶this Emacs.¶SIGCODE may be an integer, or a symbol whose name is a signal name.¶¶(fn PROCESS SIGCODE)",
"exit-minibuffer":"Terminate this minibuffer argument.",
"self-insert-and-exit":"Terminate minibuffer input.",
"previous-history-element":"Puts previous element of the minibuffer history in the minibuffer.¶With argument N, it uses the Nth previous element.¶¶(fn N)",
"next-history-element":"Puts next element of the minibuffer history in the minibuffer.¶With argument N, it uses the Nth following element.¶¶(fn N)",
"previous-matching-history-element":"Find the previous history element that matches REGEXP.¶(Previous history elements refer to earlier actions.)¶With prefix argument N, search for Nth previous match.¶If N is negative, find the next or Nth next match.¶Normally, history elements are matched case-insensitively if¶‘case-fold-search’ is non-nil, but an uppercase letter in REGEXP¶makes the search case-sensitive.¶See also ‘minibuffer-history-case-insensitive-variables’.¶¶(fn REGEXP N)",
"next-matching-history-element":"Find the next history element that matches REGEXP.¶(The next history element refers to a more recent action.)¶With prefix argument N, search for Nth next match.¶If N is negative, find the previous or Nth previous match.¶Normally, history elements are matched case-insensitively if¶‘case-fold-search’ is non-nil, but an uppercase letter in REGEXP¶makes the search case-sensitive.¶¶(fn REGEXP N)",
"previous-complete-history-element":"Get previous history element which completes the minibuffer before the point.¶The contents of the minibuffer after the point are deleted, and replaced¶by the new completion.¶¶(fn N)",
"next-complete-history-element":"Get next history element which completes the minibuffer before the point.¶The contents of the minibuffer after the point are deleted, and replaced¶by the new completion.¶¶(fn N)",
"load-file":"Load the Lisp file named FILE.¶¶(fn FILE)",
"load-library":"Load the Emacs Lisp library named LIBRARY.¶LIBRARY should be a string.¶This is an interface to the function ‘load’.  LIBRARY is searched¶for in ‘load-path’, both with and without ‘load-suffixes’ (as¶well as ‘load-file-rep-suffixes’).¶¶See Info node ‘(emacs)Lisp Libraries’ for more details.¶See ‘load-file’ for a different interface to ‘load’.¶¶(fn LIBRARY)",
"read-only-mode":"Change whether the current buffer is read-only.¶With prefix argument ARG, make the buffer read-only if ARG is¶positive, otherwise make it writable.  If buffer is read-only¶and ‘view-read-only’ is non-nil, enter view mode.¶¶Do not call this from a Lisp program unless you really intend to¶do the same thing as the DEL n p command, including¶possibly enabling or disabling View mode.  Also, note that this¶command works by setting the variable ‘buffer-read-only’, which¶does not affect read-only regions caused by text properties.  To¶ignore read-only status in a Lisp program (whether due to text¶properties or buffer state), bind ‘inhibit-read-only’ temporarily¶to a non-nil value.¶¶(fn &amp;optional ARG)",
"kill-emacs":"Exit the Emacs job and kill it.¶If ARG is an integer, return ARG as the exit program code.¶If ARG is a string, stuff it as keyboard input.¶¶This function is called upon receipt of the signals SIGTERM¶or SIGHUP, and upon SIGINT in batch mode.¶¶The value of ‘kill-emacs-hook’, if not void,¶is a list of functions (of no args),¶all of which are called before Emacs is actually killed.¶¶(fn &amp;optional ARG)",
"indent-region":"Indent each nonblank line in the region.¶A numeric prefix argument specifies a column: indent each line to that column.¶¶With no prefix argument, the command chooses one of these methods and¶indents all the lines with it:¶¶  1) If ‘fill-prefix’ is non-nil, insert ‘fill-prefix’ at the¶     beginning of each line in the region that does not already begin¶     with it.¶  2) If ‘indent-region-function’ is non-nil, call that function¶     to indent the region.¶  3) Indent each line via ‘indent-according-to-mode’.¶¶Called from a program, START and END specify the region to indent.¶If the third argument COLUMN is an integer, it specifies the¶column to indent to; if it is nil, use one of the three methods above.¶¶(fn START END &amp;optional COLUMN)",
"indent-rigidly":"Indent all lines starting in the region.¶If called interactively with no prefix argument, activate a¶transient mode in which the indentation can be adjusted interactively¶by typing &lt;left&gt;, &lt;right&gt;, &lt;S-left&gt;, or &lt;S-right&gt;.¶Typing any other key deactivates the transient mode.¶¶If called from a program, or interactively with prefix ARG,¶indent all lines starting in the region forward by ARG columns.¶If called from a program, START and END specify the beginning and¶end of the text to act on, in place of the region.¶¶Negative values of ARG indent backward, so you can remove all¶indentation by specifying a large negative ARG.¶¶(fn START END ARG &amp;optional INTERACTIVE)",
"indent-code-rigidly":"Indent all lines of code, starting in the region, sideways by ARG columns.¶Does not affect lines starting inside comments or strings, assuming that¶the start of the region is not inside them.¶¶Called from a program, takes args START, END, COLUMNS and NOCHANGE-REGEXP.¶The last is a regexp which, if matched at the beginning of a line,¶means don’t indent that line.¶¶(fn START END ARG &amp;optional NOCHANGE-REGEXP)",
"play-sound-file":"Play sound stored in FILE.¶VOLUME and DEVICE correspond to the keywords of the sound¶specification for ‘play-sound’.¶¶(fn FILE &amp;optional VOLUME DEVICE)",
"forward-word":"Move point forward ARG words (backward if ARG is negative).¶If ARG is omitted or nil, move point forward one word.¶Normally returns t.¶If an edge of the buffer or a field boundary is reached, point is¶left there and the function returns nil.  Field boundaries are not¶noticed if ‘inhibit-field-text-motion’ is non-nil.¶¶The word boundaries are normally determined by the buffer’s syntax¶table, but ‘find-word-boundary-function-table’, such as set up¶by ‘subword-mode’, can change that.  If a Lisp program needs to¶move by words determined strictly by the syntax table, it should¶use ‘forward-word-strictly’ instead.¶¶(fn &amp;optional ARG)",
"backward-word":"Move backward until encountering the beginning of a word.¶With argument ARG, do this that many times.¶If ARG is omitted or nil, move point backward one word.¶¶The word boundaries are normally determined by the buffer’s syntax¶table, but ‘find-word-boundary-function-table’, such as set up¶by ‘subword-mode’, can change that.  If a Lisp program needs to¶move by words determined strictly by the syntax table, it should¶use ‘backward-word-strictly’ instead.¶¶(fn &amp;optional ARG)",
"auto-save-mode":"Toggle auto-saving in the current buffer (Auto Save mode).¶With a prefix argument ARG, enable Auto Save mode if ARG is¶positive, and disable it otherwise.¶¶If called from Lisp, enable the mode if ARG is omitted or nil.¶¶(fn &amp;optional ARG)",
"do-auto-save":"Auto-save all buffers that need it.¶This is all buffers that have auto-saving enabled¶and are changed since last auto-saved.¶Auto-saving writes the buffer into a file¶so that your editing is not lost if the system crashes.¶This file is not the file you visited; that changes only when you save.¶Normally we run the normal hook ‘auto-save-hook’ before saving.¶¶A non-nil NO-MESSAGE argument means do not print any message if successful.¶A non-nil CURRENT-ONLY argument means save only current buffer.¶¶(fn &amp;optional NO-MESSAGE CURRENT-ONLY)",
"other-window":"Select another window in cyclic ordering of windows.¶COUNT specifies the number of windows to skip, starting with the¶selected window, before making the selection.  If COUNT is¶positive, skip COUNT windows forwards.  If COUNT is negative,¶skip -COUNT windows backwards.  COUNT zero means do not skip any¶window, so select the selected window.  In an interactive call,¶COUNT is the numeric prefix argument.  Return nil.¶¶If the ‘other-window’ parameter of the selected window is a¶function and ‘ignore-window-parameters’ is nil, call that¶function with the arguments COUNT and ALL-FRAMES.¶¶This function does not select a window whose ‘no-other-window’¶window parameter is non-nil.¶¶This function uses ‘next-window’ for finding the window to¶select.  The argument ALL-FRAMES has the same meaning as in¶‘next-window’, but the MINIBUF argument of ‘next-window’ is¶always effectively nil.",
"normal-mode":"Choose the major mode for this buffer automatically.¶Also sets up any specified local variables of the file.¶Uses the visited file name, the -*- line, and the local variables spec.¶¶This function is called automatically from ‘find-file’.  In that case,¶we may set up the file-specified mode and local variables,¶depending on the value of ‘enable-local-variables’.¶In addition, if ‘local-enable-local-variables’ is nil, we do¶not set local variables (though we do notice a mode specified with -*-.)¶¶‘enable-local-variables’ is ignored if you run ‘normal-mode’ interactively,¶or from Lisp without specifying the optional argument FIND-FILE;¶in that case, this function acts as if ‘enable-local-variables’ were t.¶¶(fn &amp;optional FIND-FILE)",
"fundamental-mode":"Major mode not specialized for anything in particular.¶Other major modes are defined by comparison with this one.",
"getenv":"Get the value of environment variable VARIABLE.¶VARIABLE should be a string.  Value is nil if VARIABLE is undefined in¶the environment.  Otherwise, value is a string.¶¶If optional parameter FRAME is non-nil, then it should be a¶frame.  This function will look up VARIABLE in its ‘environment’¶parameter.¶¶Otherwise, this function searches ‘process-environment’ for¶VARIABLE.  If it is not found there, then it continues the search¶in the environment list of the selected frame.¶¶(fn VARIABLE &amp;optional FRAME)",
"setenv":"Set the value of the environment variable named VARIABLE to VALUE.¶VARIABLE should be a string.  VALUE is optional; if not provided or¶nil, the environment variable VARIABLE will be removed.¶¶Interactively, a prefix argument means to unset the variable, and¶otherwise the current value (if any) of the variable appears at¶the front of the history list when you type in the new value.¶This function always replaces environment variables in the new¶value when called interactively.¶¶SUBSTITUTE-ENV-VARS, if non-nil, means to substitute environment¶variables in VALUE with ‘substitute-env-vars’, which see.¶This is normally used only for interactive calls.¶¶The return value is the new value of VARIABLE, or nil if¶it was removed from the environment.¶¶This function works by modifying ‘process-environment’.¶¶As a special case, setting variable ‘TZ’ calls ‘set-time-zone-rule’ as¶a side-effect.¶¶(fn VARIABLE &amp;optional VALUE SUBSTITUTE-ENV-VARS)",
"search-forward":"Search forward from point for STRING.¶Set point to the end of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not end after that position.  A value of nil¶  means search to the end of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, move to limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  backward, instead of forward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth one (or first,¶  if COUNT is 1 or nil) in the buffer located entirely after the¶  origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’ and ‘replace-match’.¶¶(fn STRING &amp;optional BOUND NOERROR COUNT)",
"search-backward":"Search backward from point for STRING.¶Set point to the beginning of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not begin before that position.  A value of nil¶  means search to the beginning of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, position at limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  forward, instead of backward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth to last one (or¶  last, if COUNT is 1 or nil) in the buffer located entirely before¶  the origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’ and ‘replace-match’.¶¶(fn STRING &amp;optional BOUND NOERROR COUNT)",
"word-search-forward":"Search forward from point for STRING, ignoring differences in punctuation.¶Set point to the end of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not end after that position.  A value of nil¶  means search to the end of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, move to limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  backward, instead of forward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth one (or first,¶  if COUNT is 1 or nil) in the buffer located entirely after the¶  origin of the search; correspondingly with COUNT negative.¶¶Relies on the function ‘word-search-regexp’ to convert a sequence¶of words in STRING to a regexp used to search words without regard¶to punctuation.¶This command does not support character folding, and lax space matching¶has no effect on it.",
"word-search-forward-lax":"Search forward from point for STRING, ignoring differences in punctuation.¶Set point to the end of the occurrence found, and return point.¶¶Unlike ‘word-search-forward’, the end of STRING need not match a word¶boundary, unless STRING ends in whitespace.¶¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not end after that position.  A value of nil¶  means search to the end of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, move to limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  backward, instead of forward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth one (or first,¶  if COUNT is 1 or nil) in the buffer located entirely after the¶  origin of the search; correspondingly with COUNT negative.¶¶Relies on the function ‘word-search-regexp’ to convert a sequence¶of words in STRING to a regexp used to search words without regard¶to punctuation.¶This command does not support character folding, and lax space matching¶has no effect on it.",
"word-search-backward":"Search backward from point for STRING, ignoring differences in punctuation.¶Set point to the beginning of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not begin before that position.  A value of nil¶  means search to the beginning of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, position at limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  forward, instead of backward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth to last one (or¶  last, if COUNT is 1 or nil) in the buffer located entirely before¶  the origin of the search; correspondingly with COUNT negative.¶¶Relies on the function ‘word-search-regexp’ to convert a sequence¶of words in STRING to a regexp used to search words without regard¶to punctuation.¶This command does not support character folding, and lax space matching¶has no effect on it.",
"word-search-backward-lax":"Search backward from point for STRING, ignoring differences in punctuation.¶Set point to the beginning of the occurrence found, and return point.¶¶Unlike ‘word-search-backward’, the end of STRING need not match a word¶boundary, unless STRING ends in whitespace.¶¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not begin before that position.  A value of nil¶  means search to the beginning of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, position at limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  forward, instead of backward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth to last one (or¶  last, if COUNT is 1 or nil) in the buffer located entirely before¶  the origin of the search; correspondingly with COUNT negative.¶¶Relies on the function ‘word-search-regexp’ to convert a sequence¶of words in STRING to a regexp used to search words without regard¶to punctuation.¶This command does not support character folding, and lax space matching¶has no effect on it.",
"base64-encode-region":"Base64-encode the region between BEG and END.¶Return the length of the encoded text.¶Optional third argument NO-LINE-BREAK means do not break long lines¶into shorter lines.¶¶(fn BEG END &amp;optional NO-LINE-BREAK)",
"base64-decode-region":"Base64-decode the region between BEG and END.¶Return the length of the decoded text.¶If the region can’t be decoded, signal an error and don’t modify the buffer.¶¶(fn BEG END)",
"compile-defun":"Compile and evaluate the current top-level form.¶Print the result in the echo area.¶With argument ARG, insert value in current buffer after the form.¶¶(fn &amp;optional ARG)",
"byte-compile-file":"Compile a file of Lisp code named FILENAME into a file of byte code.¶The output file’s name is generated by passing FILENAME to the¶function ‘byte-compile-dest-file’ (which see).¶With prefix arg (noninteractively: 2nd arg), LOAD the file after compiling.¶The value is non-nil if there were no errors, nil if errors.¶¶(fn FILENAME &amp;optional LOAD)",
"byte-recompile-directory":"Recompile every ‘.el’ file in DIRECTORY that needs recompilation.¶This happens when a ‘.elc’ file exists but is older than the ‘.el’ file.¶Files in subdirectories of DIRECTORY are processed also.¶¶If the ‘.elc’ file does not exist, normally this function *does not*¶compile the corresponding ‘.el’ file.  However, if the prefix argument¶ARG is 0, that means do compile all those files.  A nonzero¶ARG means ask the user, for each such ‘.el’ file, whether to¶compile it.  A nonzero ARG also means ask about each subdirectory¶before scanning it.¶¶If the third argument FORCE is non-nil, recompile every ‘.el’ file¶that already has a ‘.elc’ file.¶¶(fn DIRECTORY &amp;optional ARG FORCE)",
"execute-extended-command":"Read a command name, then read the arguments and call the command.¶To pass a prefix argument to the command you are¶invoking, give a prefix argument to ‘execute-extended-command’.¶¶(fn PREFIXARG &amp;optional COMMAND-NAME TYPED)",
"backtrace":"Print a trace of Lisp function calls currently active.¶Output stream used is value of ‘standard-output’.¶¶(fn)",
"make-frame-on-display":"Make a frame on display DISPLAY.¶The optional argument PARAMETERS specifies additional frame parameters.¶¶(fn DISPLAY &amp;optional PARAMETERS)",
"find-file":"Edit file FILENAME.¶Switch to a buffer visiting file FILENAME,¶creating one if none already exists.¶Interactively, the default if you just type RET is the current directory,¶but the visited file name is available through the minibuffer history:¶type M-n to pull it into the minibuffer.¶¶You can visit files on remote machines by specifying something¶like /ssh:SOME_REMOTE_MACHINE:FILE for the file name.  You can¶also visit local files as a different user by specifying¶/sudo::FILE for the file name.¶See the Info node ‘(tramp)File name Syntax’ in the Tramp Info¶manual, for more about this.¶¶Interactively, or if WILDCARDS is non-nil in a call from Lisp,¶expand wildcards (if any) and visit multiple files.  You can¶suppress wildcard expansion by setting ‘find-file-wildcards’ to nil.¶¶To visit a file without any kind of conversion and without¶automatically choosing a major mode, use M-x find-file-literally.¶¶(fn FILENAME &amp;optional WILDCARDS)",
"find-file-literally":"Visit file FILENAME with no conversion of any kind.¶Format conversion and character code conversion are both disabled,¶and multibyte characters are disabled in the resulting buffer.¶The major mode used is Fundamental mode regardless of the file name,¶and local variable specifications in the file are ignored.¶Automatic uncompression and adding a newline at the end of the¶file due to ‘require-final-newline’ is also disabled.¶¶You cannot absolutely rely on this function to result in¶visiting the file literally.  If Emacs already has a buffer¶which is visiting the file, you get the existing buffer,¶regardless of whether it was created literally or not.¶¶In a Lisp program, if you want to be sure of accessing a file’s¶contents literally, you should create a temporary buffer and then read¶the file contents into it using ‘insert-file-contents-literally’.¶¶(fn FILENAME)",
"find-file-other-window":"Edit file FILENAME, in another window.¶¶Like C-o (which see), but creates a new window or reuses¶an existing one.  See the function ‘display-buffer’.¶¶Interactively, the default if you just type RET is the current directory,¶but the visited file name is available through the minibuffer history:¶type M-n to pull it into the minibuffer.¶¶Interactively, or if WILDCARDS is non-nil in a call from Lisp,¶expand wildcards (if any) and visit multiple files.¶¶(fn FILENAME &amp;optional WILDCARDS)",
"find-file-read-only":"Edit file FILENAME but don’t allow changes.¶Like C-o, but marks buffer as read-only.¶Use DEL n p to permit editing.¶¶(fn FILENAME &amp;optional WILDCARDS)",
"format-write-file":"Write current buffer into FILENAME, using a format based on FORMAT.¶Constructs the actual format starting from FORMAT, then appending¶any elements from the value of ‘buffer-file-format’ with a non-nil¶‘preserve’ flag (see the documentation of ‘format-alist’), if they¶are not already present in FORMAT.  It then updates ‘buffer-file-format’¶with this format, making it the default for future saves.¶¶If the buffer is already visiting a file, you can specify a¶directory name as FILENAME, to write a file of the same old name¶in that directory.¶¶If optional third arg CONFIRM is non-nil, asks for confirmation before¶overwriting an existing file.  Interactively, requires confirmation¶unless you supply a prefix argument.",
"format-find-file":"Find the file FILENAME using data format FORMAT.¶If FORMAT is nil then do not do any format conversion.",
"format-insert-file":"Insert the contents of file FILENAME using data format FORMAT.¶If FORMAT is nil then do not do any format conversion.¶The optional third and fourth arguments BEG and END specify¶the part (in bytes) of the file to read.¶¶The return value is like the value of ‘insert-file-contents’:¶a list (ABSOLUTE-FILE-NAME SIZE).",
"enable-command":"Allow COMMAND to be executed without special confirmation from now on.¶COMMAND must be a symbol.¶This command alters the user’s .emacs file so that this will apply¶to future sessions.¶¶(fn COMMAND)",
"disable-command":"Require special confirmation to execute COMMAND from now on.¶COMMAND must be a symbol.¶This command alters your init file so that this choice applies to¶future sessions.¶¶(fn COMMAND)",
"switch-to-prev-buffer":"In WINDOW switch to previous buffer.¶WINDOW must be a live window and defaults to the selected one.¶Return the buffer switched to, nil if no suitable buffer could be¶found.¶¶Optional argument BURY-OR-KILL non-nil means the buffer currently¶shown in WINDOW is about to be buried or killed and consequently¶shall not be switched to in future invocations of this command.¶¶As a special case, if BURY-OR-KILL equals ‘append’, this means to¶move the buffer to the end of WINDOW’s previous buffers list so a¶future invocation of ‘switch-to-prev-buffer’ less likely switches¶to it.",
"switch-to-next-buffer":"In WINDOW switch to next buffer.¶WINDOW must be a live window and defaults to the selected one.¶Return the buffer switched to, nil if no suitable buffer could be¶found.",
"describe-buffer-case-table":"Describe the case table of the current buffer.",
"recursive-edit":"Invoke the editor command loop recursively.¶To get out of the recursive edit, a command can throw to ‘exit’ -- for¶instance (throw 'exit nil).¶If you throw a value other than t, ‘recursive-edit’ returns normally¶to the function that called it.  Throwing a t value causes¶‘recursive-edit’ to quit, so that control returns to the command loop¶one level up.¶¶This function is called by the editor initialization to begin editing.¶¶(fn)",
"exit-recursive-edit":"Exit from the innermost recursive edit or minibuffer.¶¶(fn)",
"abort-recursive-edit":"Abort the command that requested this recursive edit or minibuffer input.¶¶(fn)",
"top-level":"Exit all recursive editing levels.¶This also exits all active minibuffers.¶¶(fn)",
"replace-buffer-in-windows":"Replace BUFFER-OR-NAME with some other buffer in all windows showing it.¶BUFFER-OR-NAME may be a buffer or the name of an existing buffer¶and defaults to the current buffer.¶¶When a window showing BUFFER-OR-NAME is dedicated, that window is¶deleted.  If that window is the only window on its frame, the¶frame is deleted too when there are other frames left.  If there¶are no other frames left, some other buffer is displayed in that¶window.¶¶This function removes the buffer denoted by BUFFER-OR-NAME from¶all window-local buffer lists.",
"goto-char":"Set point to POSITION, a number or marker.¶Beginning of buffer is position (point-min), end is (point-max).¶¶The return value is POSITION.¶¶(fn POSITION)",
"forward-char":"Move point N characters forward (backward if N is negative).¶On reaching end or beginning of buffer, stop and signal error.¶Interactively, N is the numeric prefix argument.¶If N is omitted or nil, move point 1 character forward.¶¶Depending on the bidirectional context, the movement may be to the¶right or to the left on the screen.  This is in contrast with¶&lt;right&gt;, which see.¶¶(fn &amp;optional N)",
"backward-char":"Move point N characters backward (forward if N is negative).¶On attempt to pass beginning or end of buffer, stop and signal error.¶Interactively, N is the numeric prefix argument.¶If N is omitted or nil, move point 1 character backward.¶¶Depending on the bidirectional context, the movement may be to the¶right or to the left on the screen.  This is in contrast with¶M-l, which see.¶¶(fn &amp;optional N)",
"set-face-foreground":"Change the foreground color of face FACE to COLOR (a string).¶FRAME nil or not specified means change face on all frames.¶COLOR can be a system-defined color name (see ‘list-colors-display’)¶or a hex spec of the form #RRGGBB.¶When called interactively, prompts for the face and color.",
"set-face-background":"Change the background color of face FACE to COLOR (a string).¶FRAME nil or not specified means change face on all frames.¶COLOR can be a system-defined color name (see ‘list-colors-display’)¶or a hex spec of the form #RRGGBB.¶When called interactively, prompts for the face and color.",
"set-face-stipple":"Change the stipple pixmap of face FACE to STIPPLE.¶FRAME nil or not specified means change face on all frames.¶STIPPLE should be a string, the name of a file of pixmap data.¶The directories listed in the ‘x-bitmap-file-path’ variable are searched.¶¶Alternatively, STIPPLE may be a list of the form (WIDTH HEIGHT DATA)¶where WIDTH and HEIGHT are the size in pixels,¶and DATA is a string, containing the raw bits of the bitmap.",
"set-face-font":"Change font-related attributes of FACE to those of FONT (a string).¶FRAME nil or not specified means change face on all frames.¶This sets the attributes ‘:family’, ‘:foundry’, ‘:width’,¶‘:height’, ‘:weight’, and ‘:slant’.  When called interactively,¶prompt for the face and font.",
"invert-face":"Swap the foreground and background colors of FACE.¶If FRAME is omitted or nil, it means change face on all frames.¶If FACE specifies neither foreground nor background color,¶set its foreground and background to the background and foreground¶of the default face.  Value is FACE.",
"translate-region":"From START to END, translate characters according to TABLE.¶TABLE is a string or a char-table.¶If TABLE is a string, the Nth character in it is the mapping¶for the character with code N.¶If TABLE is a char-table, the element for character N is the mapping¶for the character with code N.¶It returns the number of characters changed.",
"run-with-idle-timer":"Perform an action the next time Emacs is idle for SECS seconds.¶The action is to call FUNCTION with arguments ARGS.¶SECS may be an integer, a floating point number, or the internal¶time format returned by, e.g., ‘current-idle-time’.¶If Emacs is currently idle, and has been idle for N seconds (N &lt; SECS),¶then it will call FUNCTION in SECS - N seconds from now.  Using¶SECS &lt;= N is not recommended if this function is invoked from an idle¶timer, because FUNCTION will then be called immediately.¶¶If REPEAT is non-nil, do the action each time Emacs has been idle for¶exactly SECS seconds (that is, only once for each time Emacs becomes idle).¶¶This function returns a timer object which you can use in ‘cancel-timer’.",
"delete-window":"Delete WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil.¶¶If the variable ‘ignore-window-parameters’ is non-nil or the¶‘delete-window’ parameter of WINDOW equals t, do not process any¶parameters of WINDOW.  Otherwise, if the ‘delete-window’¶parameter of WINDOW specifies a function, call that function with¶WINDOW as its sole argument and return the value returned by that¶function.¶¶Otherwise, if WINDOW is part of an atomic window, call¶‘delete-window’ with the root of the atomic window as its¶argument.  Signal an error if WINDOW is either the only window on¶its frame, the last non-side window, or part of an atomic window¶that is its frame’s root window.",
"delete-other-windows":"Make WINDOW fill its frame.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil.¶¶If the variable ‘ignore-window-parameters’ is non-nil or the¶‘delete-other-windows’ parameter of WINDOW equals t, do not¶process any parameters of WINDOW.  Otherwise, if the¶‘delete-other-windows’ parameter of WINDOW specifies a function,¶call that function with WINDOW as its sole argument and return¶the value returned by that function.¶¶Otherwise, if WINDOW is part of an atomic window, call this¶function with the root of the atomic window as its argument.  If¶WINDOW is a non-side window, make WINDOW the only non-side window¶on the frame.  Side windows are not deleted.  If WINDOW is a side¶window signal an error.",
"delete-windows-on":"Delete all windows showing BUFFER-OR-NAME.¶BUFFER-OR-NAME may be a buffer or the name of an existing buffer¶and defaults to the current buffer.¶¶The following non-nil values of the optional argument FRAME¶have special meanings:¶¶- t means consider all windows on the selected frame only.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Any other value of FRAME means consider all windows on all¶frames.¶¶When a window showing BUFFER-OR-NAME is dedicated and the only¶window of its frame, that frame is deleted when there are other¶frames left.",
"describe-mode":"Display documentation of current major mode and minor modes.¶A brief summary of the minor modes comes first, followed by the¶major mode description.  This is followed by detailed¶descriptions of the minor modes, each on a separate page.¶¶For this to work correctly for a minor mode, the mode’s indicator¶variable (listed in ‘minor-mode-alist’) must also be a function¶whose documentation describes the minor mode.¶¶If called from Lisp with a non-nil BUFFER argument, display¶documentation for the major and minor modes of that buffer.",
"select-frame":"Select FRAME.¶Subsequent editing commands apply to its selected window.¶Optional argument NORECORD means to neither change the order of¶recently selected windows nor the buffer list.¶¶The selection of FRAME lasts until the next time the user does¶something to select a different frame, or until the next time¶this function is called.  If you are using a window system, the¶previously selected frame may be restored as the selected frame¶when returning to the command loop, because it still may have¶the window system’s input focus.  On a text terminal, the next¶redisplay will display FRAME.¶¶This function returns FRAME, or nil if FRAME has been deleted.¶¶(fn FRAME &amp;optional NORECORD)",
"handle-switch-frame":"Handle a switch-frame event EVENT.¶Switch-frame events are usually bound to this function.¶A switch-frame event tells Emacs that the window manager has requested¶that the user’s events be directed to the frame mentioned in the event.¶This function selects the selected window of the frame of EVENT.¶¶If EVENT is frame object, handle it as if it were a switch-frame event¶to that frame.¶¶(fn EVENT)",
"redraw-display":"Clear and redisplay all visible frames.¶¶(fn)",
"apropos":"Show all meaningful Lisp symbols whose names match PATTERN.¶Symbols are shown if they are defined as functions, variables, or¶faces, or if they have nonempty property lists.¶¶PATTERN can be a word, a list of words (separated by spaces),¶or a regexp (using some regexp special characters).  If it is a word,¶search for matches for that word as a substring.  If it is a list of words,¶search for matches for any two (or more) of those words.¶¶With DEL , prefix, or if ‘apropos-do-all’ is non-nil,¶consider all symbols (if they match PATTERN).¶¶Returns list of symbols and documentation found.¶¶(fn PATTERN &amp;optional DO-ALL)",
"describe-prefix-bindings":"Describe the bindings of the prefix used to reach this command.¶The prefix described consists of all but the last event¶of the key sequence that ran this command.",
"Helper-describe-bindings":"Describe local key bindings of current mode.¶¶(fn)",
"Helper-help":"Provide help for current mode.¶¶(fn)",
"revert-buffer":"Replace current buffer text with the text of the visited file on disk.¶This undoes all changes since the file was visited or saved.¶With a prefix argument, offer to revert from latest auto-save file, if¶that is more recent than the visited file.¶¶This command also implements an interface for special buffers¶that contain text which doesn’t come from a file, but reflects¶some other data instead (e.g. Dired buffers, ‘buffer-list’¶buffers).  This is done via the variable ‘revert-buffer-function’.¶In these cases, it should reconstruct the buffer contents from the¶appropriate data.¶¶When called from Lisp, the first argument is IGNORE-AUTO; only offer¶to revert from the auto-save file when this is nil.  Note that the¶sense of this argument is the reverse of the prefix argument, for the¶sake of backward compatibility.  IGNORE-AUTO is optional, defaulting¶to nil.¶¶Optional second argument NOCONFIRM means don’t ask for confirmation¶at all.  (The variable ‘revert-without-query’ offers another way to¶revert buffers without querying for confirmation.)¶¶Optional third argument PRESERVE-MODES non-nil means don’t alter¶the files modes.  Normally we reinitialize them using ‘normal-mode’.¶¶This function binds ‘revert-buffer-in-progress-p’ non-nil while it operates.¶¶This function calls the function that ‘revert-buffer-function’ specifies¶to do the work, with arguments IGNORE-AUTO and NOCONFIRM.¶The default function runs the hooks ‘before-revert-hook’ and¶‘after-revert-hook’.¶¶(fn &amp;optional IGNORE-AUTO NOCONFIRM PRESERVE-MODES)",
"narrow-to-region":"Restrict editing in this buffer to the current region.¶The rest of the text becomes temporarily invisible and untouchable¶but is not deleted; if you save the buffer in a file, the invisible¶text is included in the file.  DEL n h makes all visible again.¶See also ‘save-restriction’.¶¶When calling from a program, pass two arguments; positions (integers¶or markers) bounding the text that should remain visible.¶¶(fn START END)",
"narrow-to-page":"Make text outside current page invisible.¶A numeric arg specifies to move forward or backward by that many pages,¶thus showing a page other than the one point was originally in.",
"widen":"Remove restrictions (narrowing) from current buffer.¶This allows the buffer’s full text to be seen and edited.¶¶(fn)",
"disassemble":"Print disassembled code for OBJECT in (optional) BUFFER.¶OBJECT can be a symbol defined as a function, or a function itself¶(a lambda expression or a compiled-function object).¶If OBJECT is not already compiled, we compile it, but do not¶redefine OBJECT if it is a symbol.¶¶(fn OBJECT &amp;optional BUFFER INDENT INTERACTIVE-P)",
"encode-coding-region":"Encode the current region by specified coding system.¶When called from a program, takes four arguments:¶        START, END, CODING-SYSTEM and DESTINATION.¶START and END are buffer positions.¶¶Optional 4th arguments DESTINATION specifies where the encoded text goes.¶If nil, the region between START and END is replace by the encoded text.¶If buffer, the encoded text is inserted in that buffer after point (point¶does not move).¶In those cases, the length of the encoded text is returned.¶If DESTINATION is t, the encoded text is returned.¶¶This function sets ‘last-coding-system-used’ to the precise coding system¶used (which may be different from CODING-SYSTEM if CODING-SYSTEM is¶not fully specified.)¶¶(fn START END CODING-SYSTEM &amp;optional DESTINATION)",
"decode-coding-region":"Decode the current region from the specified coding system.¶When called from a program, takes four arguments:¶\tSTART, END, CODING-SYSTEM, and DESTINATION.¶START and END are buffer positions.¶¶Optional 4th arguments DESTINATION specifies where the decoded text goes.¶If nil, the region between START and END is replaced by the decoded text.¶If buffer, the decoded text is inserted in that buffer after point (point¶does not move).¶In those cases, the length of the decoded text is returned.¶If DESTINATION is t, the decoded text is returned.¶¶This function sets ‘last-coding-system-used’ to the precise coding system¶used (which may be different from CODING-SYSTEM if CODING-SYSTEM is¶not fully specified.)¶¶(fn START END CODING-SYSTEM &amp;optional DESTINATION)",
"imenu-add-to-menubar":"Add an ‘imenu’ entry to the menu bar for the current buffer.¶NAME is a string used to name the menu bar item.¶See the command ‘imenu’ for more information.¶¶(fn NAME)",
"set-keyboard-coding-system":"Set coding system for keyboard input on TERMINAL to CODING-SYSTEM.¶¶For a list of possible values of CODING-SYSTEM, use M-x list-coding-systems.¶The default is determined by the selected language environment¶or by the previous use of this command.¶¶If CODING-SYSTEM is nil or the coding-type of CODING-SYSTEM is¶‘raw-text’, the decoding of keyboard input is disabled.¶¶TERMINAL may be a terminal object, a frame, or nil for the¶selected frame’s terminal.  The setting has no effect on¶graphical terminals.",
"set-terminal-coding-system":"Set coding system of terminal output to CODING-SYSTEM.¶All text output to TERMINAL will be encoded¶with the specified coding system.¶¶For a list of possible values of CODING-SYSTEM, use M-x list-coding-systems.¶The default is determined by the selected language environment¶or by the previous use of this command.¶¶TERMINAL may be a terminal object, a frame, or nil for the¶selected frame’s terminal.  The setting has no effect on¶graphical terminals.",
"move-to-window-line":"Position point relative to window.¶ARG nil means position point at center of window.¶Else, ARG specifies vertical position within the window;¶zero means top of window, negative means relative to bottom of window.¶¶(fn ARG)",
"display-buffer":"Display BUFFER-OR-NAME in some window, without selecting it.¶BUFFER-OR-NAME must be a buffer or the name of an existing¶buffer.  Return the window chosen for displaying BUFFER-OR-NAME,¶or nil if no such window is found.¶¶Optional argument ACTION, if non-nil, should specify a display¶action.  Its form is described below.¶¶Optional argument FRAME, if non-nil, acts like an additional¶ALIST entry (reusable-frames . FRAME) to the action list of ACTION,¶specifying the frame(s) to search for a window that is already¶displaying the buffer.  See ‘display-buffer-reuse-window’.¶¶If ACTION is non-nil, it should have the form (FUNCTION . ALIST),¶where FUNCTION is either a function or a list of functions, and¶ALIST is an arbitrary association list (alist).¶¶Each such FUNCTION should accept two arguments: the buffer to¶display and an alist.  Based on those arguments, it should¶display the buffer and return the window.  If the caller is¶prepared to handle the case of not displaying the buffer¶and returning nil from ‘display-buffer’ it should pass¶(allow-no-window . t) as an element of the ALIST.¶¶The ‘display-buffer’ function builds a function list and an alist¶by combining the functions and alists specified in¶‘display-buffer-overriding-action’, ‘display-buffer-alist’, the¶ACTION argument, ‘display-buffer-base-action’, and¶‘display-buffer-fallback-action’ (in order).  Then it calls each¶function in the combined function list in turn, passing the¶buffer as the first argument and the combined alist as the second¶argument, until one of the functions returns non-nil.¶¶If ACTION is nil, the function list and the alist are built using¶only the other variables mentioned above.¶¶Available action functions include:¶ ‘display-buffer-same-window’¶ ‘display-buffer-reuse-window’¶ ‘display-buffer-pop-up-frame’¶ ‘display-buffer-pop-up-window’¶ ‘display-buffer-in-previous-window’¶ ‘display-buffer-use-some-window’¶ ‘display-buffer-use-some-frame’¶¶Recognized alist entries include:¶¶ ‘inhibit-same-window’ -- A non-nil value prevents the same¶                          window from being used for display.¶¶ ‘inhibit-switch-frame’ -- A non-nil value prevents any other¶                           frame from being raised or selected,¶                           even if the window is displayed there.¶¶ ‘reusable-frames’ -- Value specifies frame(s) to search for a¶                      window that already displays the buffer.¶                      See ‘display-buffer-reuse-window’.¶¶ ‘pop-up-frame-parameters’ -- Value specifies an alist of frame¶                              parameters to give a new frame, if¶                              one is created.¶¶ ‘window-height’ -- Value specifies either an integer (the number¶    of lines of a new window), a floating point number (the¶    fraction of a new window with respect to the height of the¶    frame’s root window) or a function to be called with one¶    argument - a new window.  The function is supposed to adjust¶    the height of the window; its return value is ignored.¶    Suitable functions are ‘shrink-window-if-larger-than-buffer’¶    and ‘fit-window-to-buffer’.¶¶ ‘window-width’ -- Value specifies either an integer (the number¶    of columns of a new window), a floating point number (the¶    fraction of a new window with respect to the width of the¶    frame’s root window) or a function to be called with one¶    argument - a new window.  The function is supposed to adjust¶    the width of the window; its return value is ignored.¶¶ ‘allow-no-window’ -- A non-nil value indicates readiness for the case¶    of not displaying the buffer and FUNCTION can safely return¶    a non-window value to suppress displaying.¶¶ ‘preserve-size’ -- Value should be either (t . nil) to¶    preserve the width of the window, (nil . t) to preserve its¶    height or (t . t) to preserve both.¶¶The ACTION argument to ‘display-buffer’ can also have a non-nil¶and non-list value.  This means to display the buffer in a window¶other than the selected one, even if it is already displayed in¶the selected window.  If called interactively with a prefix¶argument, ACTION is t.",
"keyboard-quit":"Signal a ‘quit’ condition.¶During execution of Lisp code, this character causes a quit directly.¶At top-level, as an editor command, this simply beeps.",
"open-dribble-file":"Start writing all keyboard characters to a dribble file called FILE.¶If FILE is nil, close any open dribble file.¶The file will be closed when Emacs exits.¶¶Be aware that this records ALL characters you type!¶This may include sensitive information such as passwords.¶¶(fn FILE)",
"make-local-variable":"Make VARIABLE have a separate value in the current buffer.¶Other buffers will continue to share a common default value.¶(The buffer-local value of VARIABLE starts out as the same value¶VARIABLE previously had.  If VARIABLE was void, it remains void.)¶Return VARIABLE.¶¶If the variable is already arranged to become local when set,¶this function causes a local value to exist for this buffer,¶just as setting the variable would do.¶¶This function returns VARIABLE, and therefore¶  (set (make-local-variable 'VARIABLE) VALUE-EXP)¶works.¶¶See also ‘make-variable-buffer-local’.¶¶Do not use ‘make-local-variable’ to make a hook variable buffer-local.¶Instead, use ‘add-hook’ and specify t for the LOCAL argument.¶¶(fn VARIABLE)",
"make-variable-buffer-local":"Make VARIABLE become buffer-local whenever it is set.¶At any time, the value for the current buffer is in effect,¶unless the variable has never been set in this buffer,¶in which case the default value is in effect.¶Note that binding the variable with ‘let’, or setting it while¶a ‘let’-style binding made in this buffer is in effect,¶does not make the variable buffer-local.  Return VARIABLE.¶¶This globally affects all uses of this variable, so it belongs together with¶the variable declaration, rather than with its uses (if you just want to make¶a variable local to the current buffer for one particular use, use¶‘make-local-variable’).  Buffer-local bindings are normally cleared¶while setting up a new major mode, unless they have a ‘permanent-local’¶property.¶¶The function ‘default-value’ gets the default value and ‘set-default’ sets it.¶¶(fn VARIABLE)",
"kill-local-variable":"Make VARIABLE no longer have a separate value in the current buffer.¶From now on the default value will apply in this buffer.  Return VARIABLE.¶¶(fn VARIABLE)",
"rename-buffer":":around advice: ‘uniquify--rename-buffer-advice’¶¶Change current buffer’s name to NEWNAME (a string).¶If second arg UNIQUE is nil or omitted, it is an error if a¶buffer named NEWNAME already exists.¶If UNIQUE is non-nil, come up with a new name using¶‘generate-new-buffer-name’.¶Interactively, you can set UNIQUE with a prefix argument.¶We return the name we actually gave the buffer.¶This does not change the name of the visited file (if any).¶¶(fn NEWNAME &amp;optional UNIQUE)",
"describe-bindings":"Display a buffer showing a list of all defined keys, and their definitions.¶The keys are displayed in order of precedence.¶¶The optional argument PREFIX, if non-nil, should be a key sequence;¶then we display only bindings that start with that prefix.¶The optional argument BUFFER specifies which buffer’s bindings¶to display (default, the current buffer).  BUFFER can be a buffer¶or a buffer name.",
"move-to-column":"Move point to column COLUMN in the current line.¶Interactively, COLUMN is the value of prefix numeric argument.¶The column of a character is calculated by adding together the widths¶as displayed of the previous characters in the line.¶This function ignores line-continuation;¶there is no upper limit on the column number a character can have¶and horizontal scrolling has no effect.¶¶If specified column is within a character, point goes after that character.¶If it’s past end of line, point goes to end of line.¶¶Optional second argument FORCE non-nil means if COLUMN is in the¶middle of a tab character, change it to spaces.¶In addition, if FORCE is t, and the line is too short to reach¶COLUMN, add spaces/tabs to get there.¶¶The return value is the current column.¶¶(fn COLUMN &amp;optional FORCE)",
"eval-region":"Execute the region as Lisp code.¶When called from programs, expects two arguments,¶giving starting and ending indices in the current buffer¶of the text to be executed.¶Programs can pass third argument PRINTFLAG which controls output:¶ a value of nil means discard it; anything else is stream for printing it.¶ See Info node ‘(elisp)Output Streams’ for details on streams.¶Also the fourth argument READ-FUNCTION, if non-nil, is used¶instead of ‘read’ to read each expression.  It gets one argument¶which is the input stream for reading characters.¶¶This function does not move point.¶¶(fn START END &amp;optional PRINTFLAG READ-FUNCTION)",
"eval-buffer":"Execute the accessible portion of current buffer as Lisp code.¶You can use DEL n n to limit the part of buffer to be evaluated.¶When called from a Lisp program (i.e., not interactively), this¶function accepts up to five optional arguments:¶BUFFER is the buffer to evaluate (nil means use current buffer),¶ or a name of a buffer (a string).¶PRINTFLAG controls printing of output by any output functions in the¶ evaluated code, such as ‘print’, ‘princ’, and ‘prin1’:¶  a value of nil means discard it; anything else is the stream to print to.¶  See Info node ‘(elisp)Output Streams’ for details on streams.¶FILENAME specifies the file name to use for ‘load-history’.¶UNIBYTE, if non-nil, specifies ‘load-convert-to-unibyte’ for this¶ invocation.¶DO-ALLOW-PRINT, if non-nil, specifies that output functions in the¶ evaluated code should work normally even if PRINTFLAG is nil, in¶ which case the output is displayed in the echo area.¶¶This function preserves the position of point.¶¶(fn &amp;optional BUFFER PRINTFLAG FILENAME UNIBYTE DO-ALLOW-PRINT)",
"package-initialize":"Load Emacs Lisp packages, and activate them.¶The variable ‘package-load-list’ controls which packages to load.¶If optional arg NO-ACTIVATE is non-nil, don’t activate packages.¶If ‘user-init-file’ does not mention ‘(package-initialize)’, add¶it to the file.¶If called as part of loading ‘user-init-file’, set¶‘package-enable-at-startup’ to nil, to prevent accidentally¶loading packages twice.¶It is not necessary to adjust ‘load-path’ or ‘require’ the¶individual packages after calling ‘package-initialize’ -- this is¶taken care of by ‘package-initialize’.¶¶(fn &amp;optional NO-ACTIVATE)",
"insert-buffer":"Insert after point the contents of BUFFER.¶Puts mark after the inserted text.¶BUFFER may be a buffer or a buffer name.¶¶(fn BUFFER)",
"self-insert-command":"Insert the character you type.¶Whichever character you type to run this command is inserted.¶The numeric prefix argument N says how many times to repeat the insertion.¶Before insertion, ‘expand-abbrev’ is executed if the inserted character does¶not have word syntax and the previous character in the buffer does.¶After insertion, the value of ‘auto-fill-function’ is called if the¶‘auto-fill-chars’ table has a non-nil value for the inserted character.¶At the end, it runs ‘post-self-insert-hook’.¶¶(fn N)",
"newline":"Insert a newline, and move to left margin of the new line if it’s blank.¶If option ‘use-hard-newlines’ is non-nil, the newline is marked with the¶text-property ‘hard’.¶With ARG, insert that many newlines.¶¶If ‘electric-indent-mode’ is enabled, this indents the final new line¶that it adds, and reindents the preceding line.  To just insert¶a newline, use M-x electric-indent-just-newline.¶¶Calls ‘auto-fill-function’ if the current column number is greater¶than the value of ‘fill-column’ and ARG is nil.¶A non-nil INTERACTIVE argument means to run the ‘post-self-insert-hook’.¶¶(fn &amp;optional ARG INTERACTIVE)",
"list-processes":"Display a list of all processes that are Emacs sub-processes.¶If optional argument QUERY-ONLY is non-nil, only processes with¶the query-on-exit flag set are listed.¶Any process listed as exited or signaled is actually eliminated¶after the listing is made.¶Optional argument BUFFER specifies a buffer to use, instead of¶&quot;*Process List*&quot;.¶The return value is always nil.¶¶This function lists only processes that were launched by Emacs.  To¶see other processes running on the system, use ‘list-system-processes’.¶¶(fn &amp;optional QUERY-ONLY BUFFER)",
"quit-window":"Quit WINDOW and bury its buffer.¶WINDOW must be a live window and defaults to the selected one.¶With prefix argument KILL non-nil, kill the buffer instead of¶burying it.¶¶According to information stored in WINDOW’s ‘quit-restore’ window¶parameter either (1) delete WINDOW and its frame, (2) delete¶WINDOW, (3) restore the buffer previously displayed in WINDOW,¶or (4) make WINDOW display some other buffer than the present¶one.  If non-nil, reset ‘quit-restore’ parameter to nil.",
"sort-regexp-fields":"Sort the text in the region region lexicographically.¶If called interactively, prompt for two regular expressions,¶RECORD-REGEXP and KEY-REGEXP.¶¶RECORD-REGEXP specifies the textual units to be sorted.¶  For example, to sort lines, RECORD-REGEXP would be &quot;^.*$&quot;.¶¶KEY-REGEXP specifies the part of each record (i.e. each match for¶  RECORD-REGEXP) to be used for sorting.¶  If it is &quot;⧷⧷digit&quot;, use the digit’th &quot;⧷⧷(...⧷⧷)&quot;¶  match field specified by RECORD-REGEXP.¶  If it is &quot;⧷⧷&amp;&quot;, use the whole record.¶  Otherwise, KEY-REGEXP should be a regular expression with which¶  to search within the record.  If a match for KEY-REGEXP is not¶  found within a record, that record is ignored.¶¶With a negative prefix arg, sort in reverse order.¶¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶For example: to sort lines in the region by the first word on each line¶ starting with the letter &quot;f&quot;,¶ RECORD-REGEXP would be &quot;^.*$&quot; and KEY would be &quot;⧷⧷&lt;f⧷⧷w*⧷⧷&gt;&quot;¶¶(fn REVERSE RECORD-REGEXP KEY-REGEXP BEG END)",
"sort-lines":"Sort lines in region alphabetically; argument means descending order.¶Called from a program, there are three arguments:¶REVERSE (non-nil means reverse order), BEG and END (region to sort).¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶(fn REVERSE BEG END)",
"sort-paragraphs":"Sort paragraphs in region alphabetically; argument means descending order.¶Called from a program, there are three arguments:¶REVERSE (non-nil means reverse order), BEG and END (region to sort).¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶(fn REVERSE BEG END)",
"sort-pages":"Sort pages in region alphabetically; argument means descending order.¶Called from a program, there are three arguments:¶REVERSE (non-nil means reverse order), BEG and END (region to sort).¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶(fn REVERSE BEG END)",
"sort-fields":"Sort lines in region lexicographically by the ARGth field of each line.¶Fields are separated by whitespace and numbered from 1 up.¶With a negative arg, sorts by the ARGth field counted from the right.¶Called from a program, there are three arguments:¶FIELD, BEG and END.  BEG and END specify region to sort.¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶(fn FIELD BEG END)",
"sort-numeric-fields":"Sort lines in region numerically by the ARGth field of each line.¶Fields are separated by whitespace and numbered from 1 up.¶Specified field must contain a number in each line of the region,¶which may begin with &quot;0x&quot; or &quot;0&quot; for hexadecimal and octal values.¶Otherwise, the number is interpreted according to sort-numeric-base.¶With a negative arg, sorts by the ARGth field counted from the right.¶Called from a program, there are three arguments:¶FIELD, BEG and END.  BEG and END specify region to sort.¶¶(fn FIELD BEG END)",
"sort-columns":"Sort lines in region alphabetically by a certain range of columns.¶For the purpose of this command, the region BEG...END includes¶the entire line that point is in and the entire line the mark is in.¶The column positions of point and mark bound the range of columns to sort on.¶A prefix argument means sort into REVERSE order.¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶Note that ‘sort-columns’ rejects text that contains tabs,¶because tabs could be split across the specified columns¶and it doesn’t know how to handle that.  Also, when possible,¶it uses the ‘sort’ utility program, which doesn’t understand tabs.¶Use M-x untabify to convert tabs to spaces before sorting.¶¶(fn REVERSE &amp;optional BEG END)",
"set-left-margin":"Set the left margin of the region to WIDTH.¶If ‘auto-fill-mode’ is active, re-fill the region to fit the new margin.¶¶Interactively, WIDTH is the prefix argument, if specified.¶Without prefix argument, the command prompts for WIDTH.¶¶(fn FROM TO WIDTH)",
"set-right-margin":"Set the right margin of the region to WIDTH.¶If ‘auto-fill-mode’ is active, re-fill the region to fit the new margin.¶¶Interactively, WIDTH is the prefix argument, if specified.¶Without prefix argument, the command prompts for WIDTH.¶¶(fn FROM TO WIDTH)",
"move-to-left-margin":"Move to the left margin of the current line.¶With optional argument, move forward N-1 lines first.¶The column moved to is the one given by the ‘current-left-margin’ function.¶If the line’s indentation appears to be wrong, and this command is called¶interactively or with optional argument FORCE, it will be fixed.¶¶(fn &amp;optional N FORCE)",
"add-name-to-file":"Give FILE additional name NEWNAME.  Both args must be strings.¶Signals a ‘file-already-exists’ error if a file NEWNAME already exists¶unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.¶A number as third arg means request confirmation if NEWNAME already exists.¶This is what happens in interactive use with M-x.¶¶(fn FILE NEWNAME &amp;optional OK-IF-ALREADY-EXISTS)",
"rename-file":"Rename FILE as NEWNAME.  Both args must be strings.¶If file has names other than FILE, it continues to have those names.¶Signals a ‘file-already-exists’ error if a file NEWNAME already exists¶unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.¶A number as third arg means request confirmation if NEWNAME already exists.¶This is what happens in interactive use with M-x.¶¶(fn FILE NEWNAME &amp;optional OK-IF-ALREADY-EXISTS)",
"copy-file":"Copy FILE to NEWNAME.  Both args must be strings.¶If NEWNAME names a directory, copy FILE there.¶¶This function always sets the file modes of the output file to match¶the input file.¶¶The optional third argument OK-IF-ALREADY-EXISTS specifies what to do¶if file NEWNAME already exists.  If OK-IF-ALREADY-EXISTS is nil, we¶signal a ‘file-already-exists’ error without overwriting.  If¶OK-IF-ALREADY-EXISTS is a number, we request confirmation from the user¶about overwriting; this is what happens in interactive use with M-x.¶Any other value for OK-IF-ALREADY-EXISTS means to overwrite the¶existing file.¶¶Fourth arg KEEP-TIME non-nil means give the output file the same¶last-modified time as the old one.  (This works on only some systems.)¶¶A prefix arg makes KEEP-TIME non-nil.¶¶If PRESERVE-UID-GID is non-nil, we try to transfer the¶uid and gid of FILE to NEWNAME.¶¶If PRESERVE-PERMISSIONS is non-nil, copy permissions of FILE to NEWNAME;¶this includes the file modes, along with ACL entries and SELinux¶context if present.  Otherwise, if NEWNAME is created its file¶permission bits are those of FILE, masked by the default file¶permissions.¶¶(fn FILE NEWNAME &amp;optional OK-IF-ALREADY-EXISTS KEEP-TIME PRESERVE-UID-GID PRESERVE-PERMISSIONS)",
"make-symbolic-link":"Make a symbolic link to TARGET, named LINKNAME.¶Both args must be strings.¶Signals a ‘file-already-exists’ error if a file LINKNAME already exists¶unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.¶A number as third arg means request confirmation if LINKNAME already exists.¶This happens for interactive use with M-x.¶¶(fn TARGET LINKNAME &amp;optional OK-IF-ALREADY-EXISTS)",
"delete-file":"Delete file named FILENAME.  If it is a symlink, remove the symlink.¶If file has multiple names, it continues to exist with the other names.¶TRASH non-nil means to trash the file instead of deleting, provided¶‘delete-by-moving-to-trash’ is non-nil.¶¶When called interactively, TRASH is t if no prefix argument is given.¶With a prefix argument, TRASH is nil.¶¶(fn FILENAME &amp;optional TRASH)",
"set-file-modes":"Set mode bits of file named FILENAME to MODE (an integer).¶Only the 12 low bits of MODE are used.¶¶Interactively, mode bits are read by ‘read-file-modes’, which accepts¶symbolic notation, like the ‘chmod’ command from GNU Coreutils.¶¶(fn FILENAME MODE)",
"insert-char":"Insert COUNT copies of CHARACTER.¶Interactively, prompt for CHARACTER.  You can specify CHARACTER in one¶of these ways:¶¶ - As its Unicode character name, e.g. &quot;LATIN SMALL LETTER A&quot;.¶   Completion is available; if you type a substring of the name¶   preceded by an asterisk ‘*’, Emacs shows all names which include¶   that substring, not necessarily at the beginning of the name.¶¶ - As a hexadecimal code point, e.g. 263A.  Note that code points in¶   Emacs are equivalent to Unicode up to 10FFFF (which is the limit of¶   the Unicode code space).¶¶ - As a code point with a radix specified with #, e.g. #o21430¶   (octal), #x2318 (hex), or #10r8984 (decimal).¶¶If called interactively, COUNT is given by the prefix argument.  If¶omitted or nil, it defaults to 1.¶¶Inserting the character(s) relocates point and before-insertion¶markers in the same ways as the function ‘insert’.¶¶The optional third argument INHERIT, if non-nil, says to inherit text¶properties from adjoining text, if those properties are sticky.  If¶called interactively, INHERIT is t.¶¶(fn CHARACTER &amp;optional COUNT INHERIT)",
"emacs-version":"Return string describing the version of Emacs that is running.¶If optional argument HERE is non-nil, insert string at point.¶Don’t use this function in programs to choose actions according¶to the system configuration; look at ‘system-configuration’ instead.",
"iconify-frame":"Make the frame FRAME into an icon.¶If omitted, FRAME defaults to the currently selected frame.¶¶(fn &amp;optional FRAME)",
"make-frame-visible":"Make the frame FRAME visible (assuming it is an X window).¶If omitted, FRAME defaults to the currently selected frame.¶¶(fn &amp;optional FRAME)",
"make-frame-invisible":"Make the frame FRAME invisible.¶If omitted, FRAME defaults to the currently selected frame.¶On graphical displays, invisible frames are not updated and are¶usually not displayed at all, even in a window system’s &quot;taskbar&quot;.¶¶Normally you may not make FRAME invisible if all other frames are invisible,¶but if the second optional argument FORCE is non-nil, you may do so.¶¶This function has no effect on text terminal frames.  Such frames are¶always considered visible, whether or not they are currently being¶displayed in the terminal.¶¶(fn &amp;optional FRAME FORCE)",
"minibuffer-inactive-mode":"Major-mode.¶Uses keymap ‘minibuffer-inactive-mode-map’ and syntax-table ‘minibuffer-inactive-mode-syntax-table’.¶¶This mode runs the hook ‘minibuffer-inactive-mode-hook’, as the final step¶during initialization.¶¶key             binding¶---             -------¶¶0 .. 9          digit-argument¶e .. f          find-file-other-frame¶¶-               negative-argument¶b               switch-to-buffer-other-frame¶i               info¶m               mail¶n               make-frame¶&lt;down-mouse-1&gt;  ignore¶&lt;mouse-1&gt;       view-echo-area-messages¶&lt;remap&gt;         Prefix Command¶¶",
"scroll-up":"Scroll text of selected window upward ARG lines.¶If ARG is omitted or nil, scroll upward by a near full screen.¶A near full screen is ‘next-screen-context-lines’ less than a full screen.¶Negative ARG means scroll downward.¶If ARG is the atom ‘-’, scroll downward by nearly full screen.¶When calling from a program, supply as argument a number, nil, or ‘-’.¶¶(fn &amp;optional ARG)",
"scroll-down":"Scroll text of selected window down ARG lines.¶If ARG is omitted or nil, scroll down by a near full screen.¶A near full screen is ‘next-screen-context-lines’ less than a full screen.¶Negative ARG means scroll upward.¶If ARG is the atom ‘-’, scroll upward by nearly full screen.¶When calling from a program, supply as argument a number, nil, or ‘-’.¶¶(fn &amp;optional ARG)",
"scroll-up-command":"Scroll text of selected window upward ARG lines; or near full screen if no ARG.¶If ‘scroll-error-top-bottom’ is non-nil and ‘scroll-up’ cannot¶scroll window further, move cursor to the bottom line.¶When point is already on that position, then signal an error.¶A near full screen is ‘next-screen-context-lines’ less than a full screen.¶Negative ARG means scroll downward.¶If ARG is the atom ‘-’, scroll downward by nearly full screen.",
"scroll-down-command":"Scroll text of selected window down ARG lines; or near full screen if no ARG.¶If ‘scroll-error-top-bottom’ is non-nil and ‘scroll-down’ cannot¶scroll window further, move cursor to the top line.¶When point is already on that position, then signal an error.¶A near full screen is ‘next-screen-context-lines’ less than a full screen.¶Negative ARG means scroll upward.¶If ARG is the atom ‘-’, scroll upward by nearly full screen.",
"scroll-other-window":"Scroll next window upward ARG lines; or near full screen if no ARG.¶A near full screen is ‘next-screen-context-lines’ less than a full screen.¶The next window is the one below the current one; or the one at the top¶if the current one is at the bottom.  Negative ARG means scroll downward.¶If ARG is the atom ‘-’, scroll downward by nearly full screen.¶When calling from a program, supply as argument a number, nil, or ‘-’.¶¶If ‘other-window-scroll-buffer’ is non-nil, scroll the window¶showing that buffer, popping the buffer up if necessary.¶If in the minibuffer, ‘minibuffer-scroll-window’ if non-nil¶specifies the window to scroll.  This takes precedence over¶‘other-window-scroll-buffer’.¶¶(fn &amp;optional ARG)",
"recenter":"Center point in selected window and maybe redisplay frame.¶With a numeric prefix argument ARG, recenter putting point on screen line ARG¶relative to the selected window.  If ARG is negative, it counts up from the¶bottom of the window.  (ARG should be less than the height of the window.)¶¶If ARG is omitted or nil, then recenter with point on the middle line of¶the selected window; if the variable ‘recenter-redisplay’ is non-nil,¶also erase the entire frame and redraw it (when ‘auto-resize-tool-bars’¶is set to ‘grow-only’, this resets the tool-bar’s height to the minimum¶height needed); if ‘recenter-redisplay’ has the special value ‘tty’,¶then only tty frames are redrawn.¶¶Just C-u as prefix means put point in the center of the window¶and redisplay normally--don’t erase and redraw the frame.¶¶(fn &amp;optional ARG)",
"recenter-top-bottom":"Move current buffer line to the specified window line.¶With no prefix argument, successive calls place point according¶to the cycling order defined by ‘recenter-positions’.¶¶A prefix argument is handled like ‘recenter’:¶ With numeric prefix ARG, move current line to window-line ARG.¶ With plain ‘C-u’, move current line to window center.",
"modify-syntax-entry":"Set syntax for character CHAR according to string NEWENTRY.¶The syntax is changed only for table SYNTAX-TABLE, which defaults to¶ the current buffer’s syntax table.¶CHAR may be a cons (MIN . MAX), in which case, syntaxes of all characters¶in the range MIN to MAX are changed.¶The first character of NEWENTRY should be one of the following:¶  Space or -  whitespace syntax.    w   word constituent.¶  _           symbol constituent.   .   punctuation.¶  (           open-parenthesis.     )   close-parenthesis.¶  &quot;           string quote.         ⧷   escape.¶  $           paired delimiter.     '   expression quote or prefix operator.¶  &lt;           comment starter.      &gt;   comment ender.¶  /           character-quote.      @   inherit from parent table.¶  |           generic string fence. !   generic comment fence.¶¶Only single-character comment start and end sequences are represented thus.¶Two-character sequences are represented as described below.¶The second character of NEWENTRY is the matching parenthesis,¶ used only if the first character is ‘(’ or ‘)’.¶Any additional characters are flags.¶Defined flags are the characters 1, 2, 3, 4, b, p, and n.¶ 1 means CHAR is the start of a two-char comment start sequence.¶ 2 means CHAR is the second character of such a sequence.¶ 3 means CHAR is the start of a two-char comment end sequence.¶ 4 means CHAR is the second character of such a sequence.¶¶There can be several orthogonal comment sequences.  This is to support¶language modes such as C++.  By default, all comment sequences are of style¶a, but you can set the comment sequence style to b (on the second character¶of a comment-start, and the first character of a comment-end sequence) and/or¶c (on any of its chars) using this flag:¶ b means CHAR is part of comment sequence b.¶ c means CHAR is part of comment sequence c.¶ n means CHAR is part of a nestable comment sequence.¶¶ p means CHAR is a prefix character for ‘backward-prefix-chars’;¶   such characters are treated as whitespace when they occur¶   between expressions.¶¶(fn CHAR NEWENTRY &amp;optional SYNTAX-TABLE)",
"describe-syntax":"Describe the syntax specifications in the syntax table of BUFFER.¶The descriptions are inserted in a help buffer, which is then displayed.¶BUFFER defaults to the current buffer.¶¶(fn &amp;optional BUFFER)",
"re-search-forward":"Search forward from point for regular expression REGEXP.¶Set point to the end of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not end after that position.  A value of nil¶  means search to the end of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, move to limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  backward, instead of forward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth one (or first,¶  if COUNT is 1 or nil) in the buffer located entirely after the¶  origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,¶and ‘replace-match’.¶¶(fn REGEXP &amp;optional BOUND NOERROR COUNT)",
"re-search-backward":"Search backward from point for match for regular expression REGEXP.¶Set point to the beginning of the occurrence found, and return point.¶An optional second argument bounds the search; it is a buffer position.¶  The match found must not begin before that position.  A value of nil¶  means search to the beginning of the accessible portion of the buffer.¶Optional third argument, if t, means if fail just return nil (no error).¶  If not nil and not t, position at limit of search and return nil.¶Optional fourth argument COUNT, if a positive number, means to search¶  for COUNT successive occurrences.  If COUNT is negative, search¶  forward, instead of backward, for -COUNT occurrences.  A value of¶  nil means the same as 1.¶With COUNT positive, the match found is the COUNTth to last one (or¶  last, if COUNT is 1 or nil) in the buffer located entirely before¶  the origin of the search; correspondingly with COUNT negative.¶¶Search case-sensitivity is determined by the value of the variable¶‘case-fold-search’, which see.¶¶See also the functions ‘match-beginning’, ‘match-end’, ‘match-string’,¶and ‘replace-match’.¶¶(fn REGEXP &amp;optional BOUND NOERROR COUNT)",
"emacs-uptime":"Return a string giving the uptime of this instance of Emacs.¶FORMAT is a string to format the result, using ‘format-seconds’.¶For example, the Unix uptime command format is &quot;%D, %z%2h:%.2m&quot;.¶¶(fn &amp;optional FORMAT)",
"emacs-init-time":"Return a string giving the duration of the Emacs initialization.¶¶(fn)",
"delete-horizontal-space":"Delete all spaces and tabs around point.¶If BACKWARD-ONLY is non-nil, only delete them before point.¶¶(fn &amp;optional BACKWARD-ONLY)",
"delete-indentation":"Join this line to previous and fix up whitespace at join.¶If there is a fill prefix, delete it from the beginning of this line.¶With argument, join this line to following line.¶¶(fn &amp;optional ARG)",
"fixup-whitespace":"Fixup white space between objects around point.¶Leave one space or none, according to the context.",
"just-one-space":"Delete all spaces and tabs around point, leaving one space (or N spaces).¶If N is negative, delete newlines as well, leaving -N spaces.¶See also ‘cycle-spacing’.¶¶(fn &amp;optional N)",
"delete-blank-lines":"On blank line, delete all surrounding blank lines, leaving just one.¶On isolated blank line, delete that one.¶On nonblank line, delete any immediately following blank lines.",
"delete-trailing-whitespace":"Delete trailing whitespace between START and END.¶If called interactively, START and END are the start/end of the¶region if the mark is active, or of the buffer’s accessible¶portion if the mark is inactive.¶¶This command deletes whitespace characters after the last¶non-whitespace character in each line between START and END.  It¶does not consider formfeed characters to be whitespace.¶¶If this command acts on the entire buffer (i.e. if called¶interactively with the mark inactive, or called from Lisp with¶END nil), it also deletes all trailing lines at the end of the¶buffer if the variable ‘delete-trailing-lines’ is non-nil.¶¶(fn &amp;optional START END)",
"debug":"Enter debugger.  ‘c’ returns from the debugger.¶Arguments are mainly for use when this is called from the internals¶of the evaluator.¶¶You may call with no args, or you may pass nil as the first arg and¶any other args you like.  In that case, the list of args after the¶first will be printed into the backtrace buffer.¶¶(fn &amp;rest ARGS)",
"scroll-left":"Scroll selected window display ARG columns left.¶Default for ARG is window width minus 2.¶Value is the total amount of leftward horizontal scrolling in¶effect after the change.¶If SET-MINIMUM is non-nil, the new scroll amount becomes the¶lower bound for automatic scrolling, i.e. automatic scrolling¶will not scroll a window to a column less than the value returned¶by this function.  This happens in an interactive call.¶¶(fn &amp;optional ARG SET-MINIMUM)",
"scroll-right":"Scroll selected window display ARG columns right.¶Default for ARG is window width minus 2.¶Value is the total amount of leftward horizontal scrolling in¶effect after the change.¶If SET-MINIMUM is non-nil, the new scroll amount becomes the¶lower bound for automatic scrolling, i.e. automatic scrolling¶will not scroll a window to a column less than the value returned¶by this function.  This happens in an interactive call.¶¶(fn &amp;optional ARG SET-MINIMUM)",
"blink-matching-open":"Momentarily highlight the beginning of the sexp before point.",
"global-set-key":"Give KEY a global binding as COMMAND.¶COMMAND is the command definition to use; usually it is¶a symbol naming an interactively-callable function.¶KEY is a key sequence; noninteractively, it is a string or vector¶of characters or event types, and non-ASCII characters with codes¶above 127 (such as ISO Latin-1) can be included if you use a vector.¶¶Note that if KEY has a local binding in the current buffer,¶that local binding will continue to shadow any global binding¶that you make with this function.¶¶(fn KEY COMMAND)",
"global-unset-key":"Remove global binding of KEY.¶KEY is a string or vector representing a sequence of keystrokes.¶¶(fn KEY)",
"local-set-key":"Give KEY a local binding as COMMAND.¶COMMAND is the command definition to use; usually it is¶a symbol naming an interactively-callable function.¶KEY is a key sequence; noninteractively, it is a string or vector¶of characters or event types, and non-ASCII characters with codes¶above 127 (such as ISO Latin-1) can be included if you use a vector.¶¶The binding goes in the current buffer’s local map, which in most¶cases is shared with all other buffers in the same major mode.¶¶(fn KEY COMMAND)",
"local-unset-key":"Remove local binding of KEY.¶KEY is a string or vector representing a sequence of keystrokes.¶¶(fn KEY)",
"raise-frame":"Bring FRAME to the front, so it occludes any frames it overlaps.¶If FRAME is invisible or iconified, make it visible.¶If you don’t specify a frame, the selected frame is used.¶If Emacs is displaying on an ordinary terminal or some other device which¶doesn’t support multiple overlapping frames, this function selects FRAME.¶¶(fn &amp;optional FRAME)",
"lower-frame":"Send FRAME to the back, so it is occluded by any frames that overlap it.¶If you don’t specify a frame, the selected frame is used.¶If Emacs is displaying on an ordinary terminal or some other device which¶doesn’t support multiple overlapping frames, this function does nothing.¶¶(fn &amp;optional FRAME)",
"delete-frame":"Delete FRAME, permanently eliminating it from use.¶FRAME defaults to the selected frame.¶¶A frame may not be deleted if its minibuffer serves as surrogate¶minibuffer for another frame.  Normally, you may not delete a frame if¶all other frames are invisible, but if the second optional argument¶FORCE is non-nil, you may do so.¶¶This function runs ‘delete-frame-functions’ before actually¶deleting the frame, unless the frame is a tooltip.¶The functions are run with one argument, the frame to be deleted.¶¶(fn &amp;optional FRAME FORCE)",
"fit-window-to-buffer":"Adjust size of WINDOW to display its buffer’s contents exactly.¶WINDOW must be a live window and defaults to the selected one.¶¶If WINDOW is part of a vertical combination, adjust WINDOW’s¶height.  The new height is calculated from the actual height of¶the accessible portion of its buffer.  The optional argument¶MAX-HEIGHT specifies a maximum height and defaults to the height¶of WINDOW’s frame.  The optional argument MIN-HEIGHT specifies a¶minimum height and defaults to ‘window-min-height’.  Both¶MAX-HEIGHT and MIN-HEIGHT are specified in lines and include mode¶and header line and a bottom divider, if any.¶¶If WINDOW is part of a horizontal combination and the value of¶the option ‘fit-window-to-buffer-horizontally’ is non-nil, adjust¶WINDOW’s width.  The new width of WINDOW is calculated from the¶maximum length of its buffer’s lines that follow the current¶start position of WINDOW.  The optional argument MAX-WIDTH¶specifies a maximum width and defaults to the width of WINDOW’s¶frame.  The optional argument MIN-WIDTH specifies a minimum width¶and defaults to ‘window-min-width’.  Both MAX-WIDTH and MIN-WIDTH¶are specified in columns and include fringes, margins, a¶scrollbar and a vertical divider, if any.¶¶If the optional argument ‘preserve-size’ is non-nil, preserve the¶size of WINDOW (see ‘window-preserve-size’).¶¶Fit pixelwise if the option ‘window-resize-pixelwise’ is non-nil.¶If WINDOW is its frame’s root window and the option¶‘fit-frame-to-buffer’ is non-nil, call ‘fit-frame-to-buffer’ to¶adjust the frame’s size.¶¶Note that even if this function makes WINDOW large enough to show¶_all_ parts of its buffer you might not see the first part when¶WINDOW was scrolled.  If WINDOW is resized horizontally, you will¶not see the top of its buffer unless WINDOW starts at its minimum¶accessible position.",
"fit-frame-to-buffer":"Adjust size of FRAME to display the contents of its buffer exactly.¶FRAME can be any live frame and defaults to the selected one.¶Fit only if FRAME’s root window is live.  MAX-HEIGHT, MIN-HEIGHT,¶MAX-WIDTH and MIN-WIDTH specify bounds on the new total size of¶FRAME’s root window.  MIN-HEIGHT and MIN-WIDTH default to the values of¶‘window-min-height’ and ‘window-min-width’ respectively.¶¶If the optional argument ONLY is ‘vertically’, resize the frame¶vertically only.  If ONLY is ‘horizontally’, resize the frame¶horizontally only.¶¶The new position and size of FRAME can be additionally determined¶by customizing the options ‘fit-frame-to-buffer-sizes’ and¶‘fit-frame-to-buffer-margins’ or the corresponding parameters of¶FRAME.",
"shrink-window-if-larger-than-buffer":"Shrink height of WINDOW if its buffer doesn’t need so many lines.¶More precisely, shrink WINDOW vertically to be as small as¶possible, while still showing the full contents of its buffer.¶WINDOW must be a live window and defaults to the selected one.¶¶Do not shrink WINDOW to less than ‘window-min-height’ lines.  Do¶nothing if the buffer contains more lines than the present window¶height, or if some of the window’s contents are scrolled out of¶view, or if shrinking this window would also shrink another¶window, or if the window is the only window of its frame.¶¶Return non-nil if the window was shrunk, nil otherwise.",
"balance-windows":"Balance the sizes of windows of WINDOW-OR-FRAME.¶WINDOW-OR-FRAME is optional and defaults to the selected frame.¶If WINDOW-OR-FRAME denotes a frame, balance the sizes of all¶windows of that frame.  If WINDOW-OR-FRAME denotes a window,¶recursively balance the sizes of all child windows of that¶window.",
"balance-windows-area":"Make all visible windows the same area (approximately).¶See also ‘window-area-factor’ to change the relative size of¶specific buffers.",
"maximize-window":"Maximize WINDOW.¶Make WINDOW as large as possible without deleting any windows.¶WINDOW must be a valid window and defaults to the selected one.¶¶If the option ‘window-resize-pixelwise’ is non-nil maximize¶WINDOW pixelwise.",
"minimize-window":"Minimize WINDOW.¶Make WINDOW as small as possible without deleting any windows.¶WINDOW must be a valid window and defaults to the selected one.¶¶If the option ‘window-resize-pixelwise’ is non-nil minimize¶WINDOW pixelwise.",
"delete-minibuffer-contents":"Delete all user input in a minibuffer.¶If the current buffer is not a minibuffer, erase its entire contents.",
"open-termscript":"Start writing all terminal output to FILE as well as the terminal.¶FILE = nil means just close any termscript file currently open.¶¶(fn FILE)",
"erase-buffer":"Delete the entire contents of the current buffer.¶Any narrowing restriction in effect (see ‘narrow-to-region’) is removed,¶so the buffer is truly empty after this.¶¶(fn)",
"delete-region":"Delete the text between START and END.¶If called interactively, delete the region between point and mark.¶This command deletes buffer text without modifying the kill ring.¶¶(fn START END)",
"delete-char":"Delete the following N characters (previous if N is negative).¶Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).¶Interactively, N is the prefix arg, and KILLFLAG is set if¶N was explicitly specified.¶¶The command ‘delete-forward-char’ is preferable for interactive use, e.g.¶because it respects values of ‘delete-active-region’ and ‘overwrite-mode’.¶¶(fn N &amp;optional KILLFLAG)",
"delete-backward-char":"Delete the previous N characters (following if N is negative).¶If Transient Mark mode is enabled, the mark is active, and N is 1,¶delete the text in the region and deactivate the mark instead.¶To disable this, set option ‘delete-active-region’ to nil.¶¶Optional second arg KILLFLAG, if non-nil, means to kill (save in¶kill ring) instead of delete.  Interactively, N is the prefix¶arg, and KILLFLAG is set if N is explicitly specified.¶¶When killing, the killed text is filtered by¶‘filter-buffer-substring’ before it is saved in the kill ring, so¶the actual saved text might be different from what was killed.¶¶In Overwrite mode, single character backward deletion may replace¶tabs with spaces so as to back over columns, unless point is at¶the end of the line.¶¶(fn N &amp;optional KILLFLAG)",
"backward-delete-char-untabify":"Delete characters backward, changing tabs into spaces.¶The exact behavior depends on ‘backward-delete-char-untabify-method’.¶Delete ARG chars, and kill (save in kill ring) if KILLP is non-nil.¶Interactively, ARG is the prefix arg (default 1)¶and KILLP is t if a prefix arg was specified.¶¶(fn ARG &amp;optional KILLP)",
"capitalize-region":"Convert the region to capitalized form.¶Capitalized form means each word’s first character is upper case¶and the rest of it is lower case.¶In programs, give two arguments, the starting and ending¶character positions to operate on.¶¶(fn BEG END)",
"downcase-region":"Convert the region to lower case.  In programs, wants two arguments.¶These arguments specify the starting and ending character numbers of¶the region to operate on.  When used as a command, the text between¶point and the mark is operated on.¶¶(fn BEG END &amp;optional REGION-NONCONTIGUOUS-P)",
"upcase-region":"Convert the region to upper case.  In programs, wants two arguments.¶These arguments specify the starting and ending character numbers of¶the region to operate on.  When used as a command, the text between¶point and the mark is operated on.¶See also ‘capitalize-region’.¶¶(fn BEG END)",
"capitalize-word":"Capitalize from point to the end of word, moving over.¶With numerical argument ARG, capitalize the next ARG-1 words as well.¶This gives the word(s) a first character in upper case¶and the rest lower case.¶¶If point is in the middle of a word, the part of that word before point¶is ignored when moving forward.¶¶With negative argument, capitalize previous words but do not move.¶¶(fn ARG)",
"downcase-word":"Convert to lower case from point to end of word, moving over.¶¶If point is in the middle of a word, the part of that word before point¶is ignored when moving forward.¶¶With negative argument, convert previous words but do not move.¶¶(fn ARG)",
"upcase-word":"Convert to upper case from point to end of word, moving over.¶¶If point is in the middle of a word, the part of that word before point¶is ignored when moving forward.¶¶With negative argument, convert previous words but do not move.¶See also ‘capitalize-word’.¶¶(fn ARG)",
"bury-buffer":"Put BUFFER-OR-NAME at the end of the list of all buffers.¶There it is the least likely candidate for ‘other-buffer’ to¶return; thus, the least likely buffer for DEL u to¶select by default.¶¶You can specify a buffer name as BUFFER-OR-NAME, or an actual¶buffer object.  If BUFFER-OR-NAME is nil or omitted, bury the¶current buffer.  Also, if BUFFER-OR-NAME is nil or omitted,¶remove the current buffer from the selected window if it is¶displayed there.",
"unbury-buffer":"Switch to the last buffer in the buffer list.",
"make-frame":"Return a newly created frame displaying the current buffer.¶Optional argument PARAMETERS is an alist of frame parameters for¶the new frame.  Each element of PARAMETERS should have the¶form (NAME . VALUE), for example:¶¶ (name . STRING)\tThe frame should be named STRING.¶¶ (width . NUMBER)\tThe frame should be NUMBER characters in width.¶ (height . NUMBER)\tThe frame should be NUMBER text lines high.¶¶You cannot specify either ‘width’ or ‘height’, you must specify¶neither or both.¶¶ (minibuffer . t)\tThe frame should have a minibuffer.¶ (minibuffer . nil)\tThe frame should have no minibuffer.¶ (minibuffer . only)\tThe frame should contain only a minibuffer.¶ (minibuffer . WINDOW)\tThe frame should use WINDOW as its minibuffer window.¶¶ (window-system . nil)\tThe frame should be displayed on a terminal device.¶ (window-system . x)\tThe frame should be displayed in an X window.¶¶ (display . &quot;:0&quot;)     The frame should appear on display :0.¶¶ (terminal . TERMINAL)  The frame should use the terminal object TERMINAL.¶¶In addition, any parameter specified in ‘default-frame-alist’,¶but not present in PARAMETERS, is applied.¶¶Before creating the frame (via ‘frame-creation-function-alist’),¶this function runs the hook ‘before-make-frame-hook’.  After¶creating the frame, it runs the hook ‘after-make-frame-functions’¶with one arg, the newly created frame.¶¶If a display parameter is supplied and a window-system is not,¶guess the window-system from the display.¶¶On graphical displays, this function does not itself make the new¶frame the selected frame.  However, the window system may select¶the new frame according to its own rules.¶¶(fn &amp;optional PARAMETERS)",
"view-register":"Display what is contained in register named REGISTER.¶The Lisp value REGISTER is a character.¶¶Interactively, reads the register using ‘register-read-with-preview’.¶¶(fn REGISTER)",
"insert-register":"Insert contents of register REGISTER.  (REGISTER is a character.)¶Normally puts point before and mark after the inserted text.¶If optional second arg is non-nil, puts mark before and point after.¶Interactively, second arg is nil if prefix arg is supplied and t¶otherwise.¶¶Interactively, reads the register using ‘register-read-with-preview’.¶¶(fn REGISTER &amp;optional ARG)",
"kill-region":"Kill (&quot;cut&quot;) text between point and mark.¶This deletes the text from the buffer and saves it in the kill ring.¶The command C-v can retrieve it from there.¶(If you want to save the region without killing it, use M-w.)¶¶If you want to append the killed region to the last killed text,¶use C-M-w before &lt;S-delete&gt;.¶¶Any command that calls this function is a &quot;kill command&quot;.¶If the previous command was also a kill command,¶the text killed this time appends to the text killed last time¶to make one entry in the kill ring.¶¶The killed text is filtered by ‘filter-buffer-substring’ before it is¶saved in the kill ring, so the actual saved text might be different¶from what was killed.¶¶If the buffer is read-only, Emacs will beep and refrain from deleting¶the text, but put the text in the kill ring anyway.  This means that¶you can use the killing commands to copy text from a read-only buffer.¶¶Lisp programs should use this function for killing text.¶ (To delete text, use ‘delete-region’.)¶Supply two arguments, character positions BEG and END indicating the¶ stretch of text to be killed.  If the optional argument REGION is¶ non-nil, the function ignores BEG and END, and kills the current¶ region instead.¶¶(fn BEG END &amp;optional REGION)",
"copy-region-as-kill":"Save the region as if killed, but don’t kill it.¶In Transient Mark mode, deactivate the mark.¶If ‘interprogram-cut-function’ is non-nil, also save the text for a window¶system cut and paste.¶¶The copied text is filtered by ‘filter-buffer-substring’ before it is¶saved in the kill ring, so the actual saved text might be different¶from what was in the buffer.¶¶When called from Lisp, save in the kill ring the stretch of text¶between BEG and END, unless the optional argument REGION is¶non-nil, in which case ignore BEG and END, and save the current¶region instead.¶¶This command’s old key binding has been given to ‘kill-ring-save’.¶¶(fn BEG END &amp;optional REGION)",
"expand-abbrev":"Expand the abbrev before point, if there is an abbrev there.¶Effective when explicitly called even when ‘abbrev-mode’ is nil.¶Before doing anything else, runs ‘pre-abbrev-expand-hook’.¶Calls ‘abbrev-expand-function’ with no argument to do the work,¶and returns whatever it does.  (This should be the abbrev symbol¶if expansion occurred, else nil.)",
"abbrev-prefix-mark":"Mark current point as the beginning of an abbrev.¶Abbrev to be expanded starts here rather than at beginning of word.¶This way, you can expand an abbrev with a prefix: insert the prefix,¶use this command, then insert the abbrev.  This command inserts a¶temporary hyphen after the prefix (until the intended abbrev¶expansion occurs).¶If the prefix is itself an abbrev, this command expands it, unless¶ARG is non-nil.  Interactively, ARG is the prefix argument.¶¶(fn &amp;optional ARG)",
"set-frame-font":"Set the default font to FONT.¶When called interactively, prompt for the name of a font, and use¶that font on the selected frame.  When called from Lisp, FONT¶should be a font name (a string), a font object, font entity, or¶font spec.¶¶If KEEP-SIZE is nil, keep the number of frame lines and columns¶fixed.  If KEEP-SIZE is non-nil (or with a prefix argument), try¶to keep the current frame size fixed (in pixels) by adjusting the¶number of lines and columns.¶¶If FRAMES is nil, apply the font to the selected frame only.¶If FRAMES is non-nil, it should be a list of frames to act upon,¶or t meaning all existing graphical frames.¶Also, if FRAMES is non-nil, alter the user’s Customization settings¶as though the font-related attributes of the ‘default’ face had been¶&quot;set in this session&quot;, so that the font is applied to future frames.¶¶(fn FONT &amp;optional KEEP-SIZE FRAMES)",
"list-charset-chars":"Display a list of characters in character set CHARSET.¶¶(fn CHARSET)",
"make-indirect-buffer":"Create and return an indirect buffer for buffer BASE-BUFFER, named NAME.¶BASE-BUFFER should be a live buffer, or the name of an existing buffer.¶NAME should be a string which is not the name of an existing buffer.¶Optional argument CLONE non-nil means preserve BASE-BUFFER’s state,¶such as major and minor modes, in the indirect buffer.¶CLONE nil means the indirect buffer’s state is reset to default values.¶¶(fn BASE-BUFFER NAME &amp;optional CLONE)",
"clone-indirect-buffer":"Create an indirect buffer that is a twin copy of the current buffer.¶¶Give the indirect buffer name NEWNAME.  Interactively, read NEWNAME¶from the minibuffer when invoked with a prefix arg.  If NEWNAME is nil¶or if not called with a prefix arg, NEWNAME defaults to the current¶buffer’s name.  The name is modified by adding a ‘&lt;N&gt;’ suffix to it¶or by incrementing the N in an existing suffix.  Trying to clone a¶buffer whose major mode symbol has a non-nil ‘no-clone-indirect’¶property results in an error.¶¶DISPLAY-FLAG non-nil means show the new buffer with ‘pop-to-buffer’.¶This is always done when called interactively.¶¶Optional third arg NORECORD non-nil means do not put this buffer at the¶front of the list of recently selected ones.¶¶Returns the newly created indirect buffer.¶¶(fn NEWNAME DISPLAY-FLAG &amp;optional NORECORD)",
"make-directory":"Create the directory DIR and optionally any nonexistent parent dirs.¶If DIR already exists as a directory, signal an error, unless¶PARENTS is non-nil.¶¶Interactively, the default choice of directory to create is the¶current buffer’s default directory.  That is useful when you have¶visited a file in a nonexistent directory.¶¶Noninteractively, the second (optional) argument PARENTS, if¶non-nil, says whether to create parent directories that don’t¶exist.  Interactively, this happens by default.¶¶If creating the directory or directories fail, an error will be¶raised.¶¶(fn DIR &amp;optional PARENTS)",
"copy-directory":"Copy DIRECTORY to NEWNAME.  Both args must be strings.¶This function always sets the file modes of the output files to match¶the corresponding input file.¶¶The third arg KEEP-TIME non-nil means give the output files the same¶last-modified time as the old ones.  (This works on only some systems.)¶¶A prefix arg makes KEEP-TIME non-nil.¶¶Noninteractively, the last argument PARENTS says whether to¶create parent directories if they don’t exist.  Interactively,¶this happens by default.¶¶If NEWNAME names an existing directory, copy DIRECTORY as a¶subdirectory there.  However, if called from Lisp with a non-nil¶optional argument COPY-CONTENTS, copy the contents of DIRECTORY¶directly into NEWNAME instead.¶¶(fn DIRECTORY NEWNAME &amp;optional KEEP-TIME PARENTS COPY-CONTENTS)",
"delete-directory":"Delete the directory named DIRECTORY.  Does not follow symlinks.¶If RECURSIVE is non-nil, all files in DIRECTORY are deleted as well.¶TRASH non-nil means to trash the directory instead, provided¶‘delete-by-moving-to-trash’ is non-nil.¶¶When called interactively, TRASH is t if no prefix argument is¶given.  With a prefix argument, TRASH is nil.¶¶(fn DIRECTORY &amp;optional RECURSIVE TRASH)",
"locate-library":"Show the precise file name of Emacs library LIBRARY.¶LIBRARY should be a relative file name of the library, a string.¶It can omit the suffix (a.k.a. file-name extension) if NOSUFFIX is¶nil (which is the default, see below).¶This command searches the directories in ‘load-path’ like ‘M-x load-library’¶to find the file that ‘M-x load-library RET LIBRARY RET’ would load.¶Optional second arg NOSUFFIX non-nil means don’t add suffixes ‘load-suffixes’¶to the specified name LIBRARY.¶¶If the optional third arg PATH is specified, that list of directories¶is used instead of ‘load-path’.¶¶When called from a program, the file name is normally returned as a¶string.  When run interactively, the argument INTERACTIVE-CALL is t,¶and the file name is displayed in the echo area.¶¶(fn LIBRARY &amp;optional NOSUFFIX PATH INTERACTIVE-CALL)",
"list-load-path-shadows":"Display a list of Emacs Lisp files that shadow other files.¶¶If STRINGP is non-nil, returns any shadows as a string.¶Otherwise, if interactive shows any shadows in a ‘*Shadows*’ buffer;¶else prints messages listing any shadows.¶¶This function lists potential load path problems.  Directories in¶the ‘load-path’ variable are searched, in order, for Emacs Lisp¶files.  When a previously encountered file name is found again, a¶message is displayed indicating that the later file is &quot;hidden&quot; by¶the earlier.¶¶For example, suppose ‘load-path’ is set to¶¶(&quot;/usr/share/emacs/site-lisp&quot; &quot;/usr/share/emacs/24.3/lisp&quot;)¶¶and that each of these directories contains a file called XXX.el.  Then¶XXX.el in the site-lisp directory is referred to by all of:¶(require 'XXX), (autoload .... &quot;XXX&quot;), (load-library &quot;XXX&quot;) etc.¶¶The first XXX.el file prevents Emacs from seeing the second (unless¶the second is loaded explicitly via ‘load-file’).¶¶When not intended, such shadowings can be the source of subtle¶problems.  For example, the above situation may have arisen because the¶XXX package was not distributed with versions of Emacs prior to¶24.3.  A system administrator downloaded XXX from elsewhere and installed¶it.  Later, XXX was updated and included in the Emacs distribution.¶Unless the system administrator checks for this, the new version of XXX¶will be hidden behind the old (which may no longer work with the new¶Emacs version).¶¶This function performs these checks and flags all possible¶shadowings.  Because a .el file may exist without a corresponding .elc¶(or vice-versa), these suffixes are essentially ignored.  A file¶XXX.elc in an early directory (that does not contain XXX.el) is¶considered to shadow a later file XXX.el, and vice-versa.¶¶Shadowings are located by calling the (non-interactive) companion¶function, ‘load-path-shadows-find’.¶¶(fn &amp;optional STRINGP)",
"tab-to-tab-stop":"Insert spaces or tabs to next defined tab-stop column.¶The variable ‘tab-stop-list’ is a list of columns at which there are tab stops.¶Use M-x edit-tab-stops to edit them interactively.",
"kill-buffer":"Kill the buffer specified by BUFFER-OR-NAME.¶The argument may be a buffer or the name of an existing buffer.¶Argument nil or omitted means kill the current buffer.  Return t if the¶buffer is actually killed, nil otherwise.¶¶The functions in ‘kill-buffer-query-functions’ are called with the¶buffer to be killed as the current buffer.  If any of them returns nil,¶the buffer is not killed.  The hook ‘kill-buffer-hook’ is run before the¶buffer is actually killed.  The buffer being killed will be current¶while the hook is running.  Functions called by any of these hooks are¶supposed to not change the current buffer.¶¶Any processes that have this buffer as the ‘process-buffer’ are killed¶with SIGHUP.  This function calls ‘replace-buffer-in-windows’ for¶cleaning up all windows currently displaying the buffer to be killed.¶¶(fn &amp;optional BUFFER-OR-NAME)",
"back-to-indentation":"Move point to the first non-whitespace character on this line.",
"backward-to-indentation":"Move backward ARG lines and position at first nonblank character.¶¶(fn &amp;optional ARG)",
"forward-to-indentation":"Move forward ARG lines and position at first nonblank character.¶¶(fn &amp;optional ARG)",
"unload-feature":"Unload the library that provided FEATURE.¶If the feature is required by any other loaded code, and prefix arg FORCE¶is nil, raise an error.¶¶Standard unloading activities include restoring old autoloads for¶functions defined by the library, undoing any additions that the¶library has made to hook variables or to ‘auto-mode-alist’, undoing¶ELP profiling of functions in that library, unproviding any features¶provided by the library, and canceling timers held in variables¶defined by the library.¶¶If a function ‘FEATURE-unload-function’ is defined, this function¶calls it with no arguments, before doing anything else.  That function¶can do whatever is appropriate to undo the loading of the library.  If¶‘FEATURE-unload-function’ returns non-nil, that suppresses the¶standard unloading of the library.  Otherwise the standard unloading¶proceeds.¶¶‘FEATURE-unload-function’ has access to the package’s list of¶definitions in the variable ‘unload-function-defs-list’ and could¶remove symbols from it in the event that the package has done¶something strange, such as redefining an Emacs function.¶¶(fn FEATURE &amp;optional FORCE)",
"read-kbd-macro":"Read the region as a keyboard macro definition.¶The region is interpreted as spelled-out keystrokes, e.g., &quot;M-x abc RET&quot;.¶See documentation for ‘edmacro-mode’ for details.¶Leading/trailing &quot;C-x (&quot; and &quot;C-x )&quot; in the text are allowed and ignored.¶The resulting macro is installed as the &quot;current&quot; keyboard macro.¶¶In Lisp, may also be called with a single STRING argument in which case¶the result is returned rather than being installed as the current macro.¶The result will be a string if possible, otherwise an event vector.¶Second argument NEED-VECTOR means to return an event vector always.",
"serial-term":"Start a terminal-emulator for a serial port in a new buffer.¶PORT is the path or name of the serial port.  For example, this¶could be &quot;/dev/ttyS0&quot; on Unix.  On Windows, this could be¶&quot;COM1&quot; or &quot;⧷⧷.⧷COM10&quot;.¶SPEED is the speed of the serial port in bits per second.  9600¶is a common value.  SPEED can be nil, see¶‘serial-process-configure’ for details.¶The buffer is in Term mode; see ‘term-mode’ for the commands to¶use in that buffer.¶Type C-c b to switch to another buffer.",
"buffer-enable-undo":"Start keeping undo information for buffer BUFFER.¶No argument or nil as argument means do this for the current buffer.¶¶(fn &amp;optional BUFFER)",
"buffer-disable-undo":"Make BUFFER stop keeping undo information.¶No argument or nil as argument means do this for the current buffer.¶¶(fn &amp;optional BUFFER)",
"text-mode":"Major mode for editing text written for humans to read.¶In this mode, paragraphs are delimited only by blank or white lines.¶You can thus get the full benefit of adaptive filling¶ (see the variable ‘adaptive-fill-mode’).¶key             binding¶---             -------¶¶ESC             Prefix Command¶¶C-M-i           ispell-complete-word¶¶¶Turning on Text mode runs the normal hook ‘text-mode-hook’.",
"prog-mode":"Major mode for editing programming language source code.¶¶This mode runs the hook ‘prog-mode-hook’, as the final step¶during initialization.¶¶key             binding¶---             -------¶¶ESC             Prefix Command¶¶C-M-q           prog-indent-sexp¶¶",
"special-mode":"Parent major mode from which special major modes should inherit.¶¶This mode runs the hook ‘special-mode-hook’, as the final step¶during initialization.¶¶key             binding¶---             -------¶¶SPC             scroll-up-command¶-               negative-argument¶0 .. 9          digit-argument¶&lt;               beginning-of-buffer¶&gt;               end-of-buffer¶?               describe-mode¶g               revert-buffer¶h               describe-mode¶q               quit-window¶DEL             scroll-down-command¶S-SPC           scroll-down-command¶&lt;remap&gt;         Prefix Command¶¶",
"beginning-of-buffer":"Move point to the beginning of the buffer.¶With numeric arg N, put point N/10 of the way from the beginning.¶If the buffer is narrowed, this command uses the beginning of the¶accessible part of the buffer.¶¶Push mark at previous position, unless either a DEL , prefix¶is supplied, or Transient Mark mode is enabled and the mark is active.¶¶(fn &amp;optional ARG)",
"end-of-buffer":"Move point to the end of the buffer.¶With numeric arg N, put point N/10 of the way from the end.¶If the buffer is narrowed, this command uses the end of the¶accessible part of the buffer.¶¶Push mark at previous position, unless either a DEL , prefix¶is supplied, or Transient Mark mode is enabled and the mark is active.¶¶(fn &amp;optional ARG)",
"forward-list":"Move forward across one balanced group of parentheses.¶This command will also work on other parentheses-like expressions¶defined by the current language mode.¶With ARG, do it that many times.¶Negative arg -N means move backward across N groups of parentheses.¶This command assumes point is not in a string or comment.¶¶(fn &amp;optional ARG)",
"backward-list":"Move backward across one balanced group of parentheses.¶This command will also work on other parentheses-like expressions¶defined by the current language mode.¶With ARG, do it that many times.¶Negative arg -N means move forward across N groups of parentheses.¶This command assumes point is not in a string or comment.¶¶(fn &amp;optional ARG)",
"up-list":"Move forward out of one level of parentheses.¶This command will also work on other parentheses-like expressions¶defined by the current language mode.  With ARG, do this that¶many times.  A negative argument means move backward but still to¶a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is¶interactively), move out of enclosing strings as well. If¶NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to¶break out of any enclosing string instead of moving to the start¶of a list broken across multiple strings.  On error, location of¶point is unspecified.¶¶(fn &amp;optional ARG ESCAPE-STRINGS NO-SYNTAX-CROSSING)",
"backward-up-list":"Move backward out of one level of parentheses.¶This command will also work on other parentheses-like expressions¶defined by the current language mode.  With ARG, do this that¶many times.  A negative argument means move forward but still to¶a less deep spot.  If ESCAPE-STRINGS is non-nil (as it is¶interactively), move out of enclosing strings as well.  If¶NO-SYNTAX-CROSSING is non-nil (as it is interactively), prefer to¶break out of any enclosing string instead of moving to the start¶of a list broken across multiple strings.  On error, location of¶point is unspecified.¶¶(fn &amp;optional ARG ESCAPE-STRINGS NO-SYNTAX-CROSSING)",
"down-list":"Move forward down one level of parentheses.¶This command will also work on other parentheses-like expressions¶defined by the current language mode.¶With ARG, do this that many times.¶A negative argument means move backward but still go down a level.¶This command assumes point is not in a string or comment.¶¶(fn &amp;optional ARG)",
"forward-sexp":"Move forward across one balanced expression (sexp).¶With ARG, do it that many times.  Negative arg -N means move¶backward across N balanced expressions.  This command assumes¶point is not in a string or comment.  Calls¶‘forward-sexp-function’ to do the work, if that is non-nil.  If¶unable to move over a sexp, signal ‘scan-error’ with three¶arguments: a message, the start of the obstacle (usually a¶parenthesis or list marker of some kind), and end of the¶obstacle.¶¶(fn &amp;optional ARG)",
"backward-sexp":"Move backward across one balanced expression (sexp).¶With ARG, do it that many times.  Negative arg -N means¶move forward across N balanced expressions.¶This command assumes point is not in a string or comment.¶Uses ‘forward-sexp’ to do the work.¶¶(fn &amp;optional ARG)",
"beginning-of-defun":"Move backward to the beginning of a defun.¶With ARG, do it that many times.  Negative ARG means move forward¶to the ARGth following beginning of defun.¶¶If search is successful, return t; point ends up at the beginning¶of the line where the search succeeded.  Otherwise, return nil.¶¶When ‘open-paren-in-column-0-is-defun-start’ is non-nil, a defun¶is assumed to start where there is a char with open-parenthesis¶syntax at the beginning of a line.  If ‘defun-prompt-regexp’ is¶non-nil, then a string which matches that regexp may also precede¶the open-parenthesis.  If ‘defun-prompt-regexp’ and¶‘open-paren-in-column-0-is-defun-start’ are both nil, this¶function instead finds an open-paren at the outermost level.¶¶If the variable ‘beginning-of-defun-function’ is non-nil, its¶value is called as a function, with argument ARG, to find the¶defun’s beginning.¶¶Regardless of the values of ‘defun-prompt-regexp’ and¶‘beginning-of-defun-function’, point always moves to the¶beginning of the line whenever the search is successful.¶¶(fn &amp;optional ARG)",
"end-of-defun":"Move forward to next end of defun.¶With argument, do it that many times.¶Negative argument -N means move back to Nth preceding end of defun.¶¶An end of a defun occurs right after the close-parenthesis that¶matches the open-parenthesis that starts a defun; see function¶‘beginning-of-defun’.¶¶If variable ‘end-of-defun-function’ is non-nil, its value¶is called as a function to find the defun’s end.¶¶(fn &amp;optional ARG)",
"gui-set-selection":"Make an X selection of type TYPE and value DATA.¶The argument TYPE (nil means ‘PRIMARY’) says which selection, and¶DATA specifies the contents.  TYPE must be a symbol.  (It can also¶be a string, which stands for the symbol with that name, but this¶is considered obsolete.)  DATA may be a string, a symbol, an¶integer (or a cons of two integers or list of two integers).¶¶The selection may also be a cons of two markers pointing to the same buffer,¶or an overlay.  In these cases, the selection is considered to be the text¶between the markers *at whatever time the selection is examined*.¶Thus, editing done in the buffer after you specify the selection¶can alter the effective value of the selection.¶¶The data may also be a vector of valid non-vector selection values.¶¶The return value is DATA.¶¶Interactively, this command sets the primary selection.  Without¶prefix argument, it reads the selection in the minibuffer.  With¶prefix argument, it uses the text of the region as the selection value.¶¶Note that on MS-Windows, primary and secondary selections set by Emacs¶are not available to other programs.¶¶(fn TYPE DATA)",
"undefined":"Beep to tell the user this binding is undefined.",
"garbage-collect":"Reclaim storage for Lisp objects no longer needed.¶Garbage collection happens automatically if you cons more than¶‘gc-cons-threshold’ bytes of Lisp data since previous garbage collection.¶‘garbage-collect’ normally returns a list with info on amount of space in use,¶where each entry has the form (NAME SIZE USED FREE), where:¶- NAME is a symbol describing the kind of objects this entry represents,¶- SIZE is the number of bytes used by each one,¶- USED is the number of those objects that were found live in the heap,¶- FREE is the number of those objects that are not live but that Emacs¶  keeps around for future allocations (maybe because it does not know how¶  to return them to the OS).¶However, if there was overflow in pure space, ‘garbage-collect’¶returns nil, because real GC can’t be done.¶See Info node ‘(elisp)Garbage Collection’.¶¶(fn)",
"describe-categories":"Describe the category specifications in the current category table.¶The descriptions are inserted in a buffer, which is then displayed.¶If BUFFER is non-nil, then describe BUFFER’s category table instead.¶BUFFER should be a buffer or a buffer name.¶¶(fn &amp;optional BUFFER)",
"load-theme":"Load Custom theme named THEME from its file.¶The theme file is named THEME-theme.el, in one of the directories¶specified by ‘custom-theme-load-path’.¶¶If the theme is not considered safe by ‘custom-safe-themes’,¶prompt the user for confirmation before loading it.  But if¶optional arg NO-CONFIRM is non-nil, load the theme without¶prompting.¶¶Normally, this function also enables THEME.  If optional arg¶NO-ENABLE is non-nil, load the theme but don’t enable it, unless¶the theme was already enabled.¶¶This function is normally called through Customize when setting¶‘custom-enabled-themes’.  If used directly in your init file, it¶should be called with a non-nil NO-CONFIRM argument, or after¶‘custom-safe-themes’ has been loaded.¶¶Return t if THEME was successfully loaded, nil otherwise.",
"enable-theme":"Reenable all variable and face settings defined by THEME.¶THEME should be either ‘user’, or a theme loaded via ‘load-theme’.¶After this function completes, THEME will have the highest¶precedence (after ‘user’).",
"disable-theme":"Disable all variable and face settings defined by THEME.¶See ‘custom-enabled-themes’ for a list of enabled themes.",
"not-modified":"Mark current buffer as unmodified, not needing to be saved.¶With prefix ARG, mark buffer as modified, so C-s will save.¶¶It is not a good idea to use this function in Lisp programs, because it¶prints a message in the minibuffer.  Instead, use ‘set-buffer-modified-p’.¶¶(fn &amp;optional ARG)",
"yank":"Reinsert (&quot;paste&quot;) the last stretch of killed text.¶More precisely, reinsert the most recent kill, which is the¶stretch of killed text most recently killed OR yanked.  Put point¶at the end, and set mark at the beginning without activating it.¶With just DEL , as argument, put point at beginning, and mark at end.¶With argument N, reinsert the Nth most recent kill.¶¶When this command inserts text into the buffer, it honors the¶‘yank-handled-properties’ and ‘yank-excluded-properties’¶variables, and the ‘yank-handler’ text property.  See¶‘insert-for-yank-1’ for details.¶¶See also the command ‘yank-pop’ (M-y).¶¶(fn &amp;optional ARG)",
"yank-pop":"Replace just-yanked stretch of killed text with a different stretch.¶This command is allowed only immediately after a ‘yank’ or a ‘yank-pop’.¶At such a time, the region contains a stretch of reinserted¶previously-killed text.  ‘yank-pop’ deletes that text and inserts in its¶place a different stretch of killed text.¶¶With no argument, the previous kill is inserted.¶With argument N, insert the Nth previous kill.¶If N is negative, this is a more recent kill.¶¶The sequence of kills wraps around, so that after the oldest one¶comes the newest one.¶¶When this command inserts killed text into the buffer, it honors¶‘yank-excluded-properties’ and ‘yank-handler’ as described in the¶doc string for ‘insert-for-yank-1’, which see.¶¶(fn &amp;optional ARG)",
"split-window-right":"Split the selected window into two side-by-side windows.¶The selected window is on the left.  The newly split-off window¶is on the right and displays the same buffer.  Return the new¶window.¶¶If optional argument SIZE is omitted or nil, both windows get the¶same width, or close to it.  If SIZE is positive, the left-hand¶(selected) window gets SIZE columns.  If SIZE is negative, the¶right-hand (new) window gets -SIZE columns.  Here, SIZE includes¶the width of the window’s scroll bar; if there are no scroll¶bars, it includes the width of the divider column to the window’s¶right, if any.",
"split-window-below":"Split the selected window into two windows, one above the other.¶The selected window is above.  The newly split-off window is¶below and displays the same buffer.  Return the new window.¶¶If optional argument SIZE is omitted or nil, both windows get the¶same height, or close to it.  If SIZE is positive, the upper¶(selected) window gets SIZE lines.  If SIZE is negative, the¶lower (new) window gets -SIZE lines.¶¶If the variable ‘split-window-keep-point’ is non-nil, both¶windows get the same value of point as the selected window.¶Otherwise, the window starts are chosen so as to minimize the¶amount of redisplay; this is convenient on slow terminals.",
"set-visited-file-name":"Change name of file visited in current buffer to FILENAME.¶This also renames the buffer to correspond to the new file.¶The next time the buffer is saved it will go in the newly specified file.¶FILENAME nil or an empty string means mark buffer as not visiting any file.¶Remember to delete the initial contents of the minibuffer¶if you wish to pass an empty string as the argument.¶¶The optional second argument NO-QUERY, if non-nil, inhibits asking for¶confirmation in the case where another buffer is already visiting FILENAME.¶¶The optional third argument ALONG-WITH-FILE, if non-nil, means that¶the old visited file has been renamed to the new name FILENAME.¶¶(fn FILENAME &amp;optional NO-QUERY ALONG-WITH-FILE)",
"mouse-on-link-p":"Return non-nil if POS is on a link in the current buffer.¶POS must specify a buffer position in the current buffer, as a list¶of the form returned by the ‘event-start’ and ‘event-end’ functions,¶or a mouse event location in the selected window (see ‘event-start’).¶However, if ‘mouse-1-click-in-non-selected-windows’ is non-nil,¶POS may be a mouse event location in any window.¶¶A clickable link is identified by one of the following methods:¶¶- If the character at POS has a non-nil ‘follow-link’ text or¶overlay property, the value of that property determines what to do.¶¶- If there is a local key-binding or a keybinding at position POS¶for the ‘follow-link’ event, the binding of that event determines¶what to do.¶¶The resulting value determine whether POS is inside a link:¶¶- If the value is ‘mouse-face’, POS is inside a link if there¶is a non-nil ‘mouse-face’ property at POS.  Return t in this case.¶¶- If the value is a function, FUNC, POS is inside a link if¶the call (FUNC POS) returns non-nil.  Return the return value¶from that call.  Arg is (posn-point POS) if POS is a mouse event.¶¶- Otherwise, return the value itself.¶¶The return value is interpreted as follows:¶¶- If it is a string, the mouse-1 event is translated into the¶first character of the string, i.e. the action of the mouse-1¶click is the local or global binding of that character.¶¶- If it is a vector, the mouse-1 event is translated into the¶first element of that vector, i.e. the action of the mouse-1¶click is the local or global binding of that event.¶¶- Otherwise, the mouse-1 event is translated into a mouse-2 event¶at the same position.¶¶(fn POS)",
"macrop":"Non-nil if and only if OBJECT is a macro.¶¶(fn OBJECT)",
"run-hooks":"Run each hook in HOOKS.¶Each argument should be a symbol, a hook variable.¶These symbols are processed in the order specified.¶If a hook symbol has a non-nil value, that value may be a function¶or a list of functions to be called to run the hook.¶If the value is a function, it is called with no arguments.¶If it is a list, the elements are called, in order, with no arguments.¶¶Major modes should not use this function directly to run their mode¶hook; they should use ‘run-mode-hooks’ instead.¶¶Do not use ‘make-local-variable’ to make a hook variable buffer-local.¶Instead, use ‘add-hook’ and specify t for the LOCAL argument.¶¶(fn &amp;rest HOOKS)",
"run-hook-with-args":"Run HOOK with the specified arguments ARGS.¶HOOK should be a symbol, a hook variable.  The value of HOOK¶may be nil, a function, or a list of functions.  Call each¶function in order with arguments ARGS.  The final return value¶is unspecified.¶¶Do not use ‘make-local-variable’ to make a hook variable buffer-local.¶Instead, use ‘add-hook’ and specify t for the LOCAL argument.¶¶(fn HOOK &amp;rest ARGS)",
"run-hook-with-args-until-failure":"Run HOOK with the specified arguments ARGS.¶HOOK should be a symbol, a hook variable.  The value of HOOK¶may be nil, a function, or a list of functions.  Call each¶function in order with arguments ARGS, stopping at the first¶one that returns nil, and return nil.  Otherwise (if all functions¶return non-nil, or if there are no functions to call), return non-nil¶(do not rely on the precise return value in this case).¶¶Do not use ‘make-local-variable’ to make a hook variable buffer-local.¶Instead, use ‘add-hook’ and specify t for the LOCAL argument.¶¶(fn HOOK &amp;rest ARGS)",
"run-hook-with-args-until-success":"Run HOOK with the specified arguments ARGS.¶HOOK should be a symbol, a hook variable.  The value of HOOK¶may be nil, a function, or a list of functions.  Call each¶function in order with arguments ARGS, stopping at the first¶one that returns non-nil, and return that value.  Otherwise (if¶all functions return nil, or if there are no functions to call),¶return nil.¶¶Do not use ‘make-local-variable’ to make a hook variable buffer-local.¶Instead, use ‘add-hook’ and specify t for the LOCAL argument.¶¶(fn HOOK &amp;rest ARGS)",
"define-fringe-bitmap":"Define fringe bitmap BITMAP from BITS of size HEIGHT x WIDTH.¶BITMAP is a symbol identifying the new fringe bitmap.¶BITS is either a string or a vector of integers.¶HEIGHT is height of bitmap.  If HEIGHT is nil, use length of BITS.¶WIDTH must be an integer between 1 and 16, or nil which defaults to 8.¶Optional fifth arg ALIGN may be one of ‘top’, ‘center’, or ‘bottom’,¶indicating the positioning of the bitmap relative to the rows where it¶is used; the default is to center the bitmap.  Fifth arg may also be a¶list (ALIGN PERIODIC) where PERIODIC non-nil specifies that the bitmap¶should be repeated.¶If BITMAP already exists, the existing definition is replaced.¶¶(fn BITMAP BITS &amp;optional HEIGHT WIDTH ALIGN)",
"destroy-fringe-bitmap":"Destroy fringe bitmap BITMAP.¶If BITMAP overrides a standard fringe bitmap, the original bitmap is restored.¶¶(fn BITMAP)",
"set-fringe-bitmap-face":"Set face for fringe bitmap BITMAP to FACE.¶FACE is merged with the ‘fringe’ face, so normally FACE should specify¶only the foreground color.¶If FACE is nil, reset face to default fringe face.¶¶(fn BITMAP &amp;optional FACE)",
"file-name-directory":"Return the directory component in file name FILENAME.¶Return nil if FILENAME does not include a directory.¶Otherwise return a directory name.¶Given a Unix syntax file name, returns a string ending in slash.¶¶(fn FILENAME)",
"file-name-nondirectory":"Return file name FILENAME sans its directory.¶For example, in a Unix-syntax file name,¶this is everything after the last slash,¶or the entire name if it contains no slash.¶¶(fn FILENAME)",
"file-name-sans-versions":"Return file NAME sans backup versions or strings.¶This is a separate procedure so your site-init or startup file can¶redefine it.¶If the optional argument KEEP-BACKUP-VERSION is non-nil,¶we do not remove backup version numbers, only true file version numbers.¶See also ‘file-name-version-regexp’.¶¶(fn NAME &amp;optional KEEP-BACKUP-VERSION)",
"file-name-extension":"Return FILENAME’s final &quot;extension&quot;.¶The extension, in a file name, is the part that begins with the last ‘.’,¶excluding version numbers and backup suffixes, except that a leading ‘.’¶of the file name, if there is one, doesn’t count.¶Return nil for extensionless file names such as ‘foo’.¶Return the empty string for file names such as ‘foo.’.¶¶By default, the returned value excludes the period that starts the¶extension, but if the optional argument PERIOD is non-nil, the period¶is included in the value, and in that case, if FILENAME has no¶extension, the value is &quot;&quot;.¶¶(fn FILENAME &amp;optional PERIOD)",
"file-name-sans-extension":"Return FILENAME sans final &quot;extension&quot;.¶The extension, in a file name, is the part that begins with the last ‘.’,¶except that a leading ‘.’ of the file name, if there is one, doesn’t count.¶¶(fn FILENAME)",
"file-name-base":"Return the base name of the FILENAME: no directory, no extension.¶FILENAME defaults to ‘buffer-file-name’.¶¶(fn &amp;optional FILENAME)",
"buffer-file-name":"Return name of file BUFFER is visiting, or nil if none.¶No argument or nil as argument means use the current buffer.¶¶(fn &amp;optional BUFFER)",
"get-file-buffer":"Return the buffer visiting file FILENAME (a string).¶The buffer’s ‘buffer-file-name’ must match exactly the expansion of FILENAME.¶If there is no such live buffer, return nil.¶See also ‘find-buffer-visiting’.¶¶(fn FILENAME)",
"find-buffer-visiting":"Return the buffer visiting file FILENAME (a string).¶This is like ‘get-file-buffer’, except that it checks for any buffer¶visiting the same file, possibly under a different name.¶If PREDICATE is non-nil, only buffers satisfying it are eligible,¶and others are ignored.¶If there is no such live buffer, return nil.¶¶(fn FILENAME &amp;optional PREDICATE)",
"split-window":"Make a new window adjacent to WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return the new window which is always a live window.¶¶Optional argument SIZE a positive number means make WINDOW SIZE¶lines or columns tall.  If SIZE is negative, make the new window¶-SIZE lines or columns tall.  If and only if SIZE is non-nil, its¶absolute value can be less than ‘window-min-height’ or¶‘window-min-width’; so this command can make a new window as¶small as one line or two columns.  SIZE defaults to half of¶WINDOW’s size.¶¶Optional third argument SIDE nil (or ‘below’) specifies that the¶new window shall be located below WINDOW.  SIDE ‘above’ means the¶new window shall be located above WINDOW.  In both cases SIZE¶specifies the new number of lines for WINDOW (or the new window¶if SIZE is negative) including space reserved for the mode and/or¶header line.¶¶SIDE t (or ‘right’) specifies that the new window shall be¶located on the right side of WINDOW.  SIDE ‘left’ means the new¶window shall be located on the left of WINDOW.  In both cases¶SIZE specifies the new number of columns for WINDOW (or the new¶window provided SIZE is negative) including space reserved for¶fringes and the scrollbar or a divider column.  Any other non-nil¶value for SIDE is currently handled like t (or ‘right’).¶¶PIXELWISE, if non-nil, means to interpret SIZE pixelwise.¶¶If the variable ‘ignore-window-parameters’ is non-nil or the¶‘split-window’ parameter of WINDOW equals t, do not process any¶parameters of WINDOW.  Otherwise, if the ‘split-window’ parameter¶of WINDOW specifies a function, call that function with all three¶arguments and return the value returned by that function.¶¶Otherwise, if WINDOW is part of an atomic window, &quot;split&quot; the¶root of that atomic window.  The new window does not become a¶member of that atomic window.¶¶If WINDOW is live, properties of the new window like margins and¶scrollbars are inherited from WINDOW.  If WINDOW is an internal¶window, these properties as well as the buffer displayed in the¶new window are inherited from the window selected on WINDOW’s¶frame.  The selected window is not changed by this function.",
"window-total-height":"Return the height of window WINDOW in lines.¶WINDOW must be a valid window and defaults to the selected one.¶¶The return value includes the heights of WINDOW’s mode and header line¶and its bottom divider, if any.  If WINDOW is an internal window, the¶total height is the height of the screen areas spanned by its children.¶¶If WINDOW’s pixel height is not an integral multiple of its frame’s¶character height, the number of lines occupied by WINDOW is rounded¶internally.  This is done in a way such that, if WINDOW is a parent¶window, the sum of the total heights of all its children internally¶equals the total height of WINDOW.¶¶If the optional argument ROUND is ‘ceiling’, return the smallest integer¶larger than WINDOW’s pixel height divided by the character height of¶WINDOW’s frame.  ROUND ‘floor’ means to return the largest integer¶smaller than WINDOW’s pixel height divided by the character height of¶WINDOW’s frame.  Any other value of ROUND means to return the internal¶total height of WINDOW.¶¶(fn &amp;optional WINDOW ROUND)",
"window-total-width":"Return the total width of window WINDOW in columns.¶WINDOW must be a valid window and defaults to the selected one.¶¶The return value includes the widths of WINDOW’s fringes, margins,¶scroll bars and its right divider, if any.  If WINDOW is an internal¶window, the total width is the width of the screen areas spanned by its¶children.¶¶If WINDOW’s pixel width is not an integral multiple of its frame’s¶character width, the number of lines occupied by WINDOW is rounded¶internally.  This is done in a way such that, if WINDOW is a parent¶window, the sum of the total widths of all its children internally¶equals the total width of WINDOW.¶¶If the optional argument ROUND is ‘ceiling’, return the smallest integer¶larger than WINDOW’s pixel width divided by the character width of¶WINDOW’s frame.  ROUND ‘floor’ means to return the largest integer¶smaller than WINDOW’s pixel width divided by the character width of¶WINDOW’s frame.  Any other value of ROUND means to return the internal¶total width of WINDOW.¶¶(fn &amp;optional WINDOW ROUND)",
"window-total-size":"Return the total height or width of WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶¶If HORIZONTAL is omitted or nil, return the total height of¶WINDOW, in lines.  If WINDOW is live, its total height includes,¶in addition to the height of WINDOW’s text, the heights of¶WINDOW’s mode and header line and a bottom divider, if any.¶¶If HORIZONTAL is non-nil, return the total width of WINDOW, in¶columns.  If WINDOW is live, its total width includes, in¶addition to the width of WINDOW’s text, the widths of WINDOW’s¶fringes, margins, scroll bars and its right divider, if any.¶¶If WINDOW is internal, return the respective size of the screen¶areas spanned by its children.¶¶Optional argument ROUND is handled as for ‘window-total-height’¶and ‘window-total-width’.",
"window-pixel-height":"Return the height of window WINDOW in pixels.¶WINDOW must be a valid window and defaults to the selected one.¶¶The return value includes the mode line and header line and the bottom¶divider, if any.  If WINDOW is an internal window, its pixel height is¶the height of the screen areas spanned by its children.¶¶(fn &amp;optional WINDOW)",
"window-pixel-width":"Return the width of window WINDOW in pixels.¶WINDOW must be a valid window and defaults to the selected one.¶¶The return value includes the fringes and margins of WINDOW as well as¶any vertical dividers or scroll bars belonging to WINDOW.  If WINDOW is¶an internal window, its pixel width is the width of the screen areas¶spanned by its children.¶¶(fn &amp;optional WINDOW)",
"window-full-height-p":"Return t if WINDOW is as high as its containing frame.¶More precisely, return t if and only if the total height of¶WINDOW equals the total height of the root window of WINDOW’s¶frame.  WINDOW must be a valid window and defaults to the¶selected one.",
"window-full-width-p":"Return t if WINDOW is as wide as its containing frame.¶More precisely, return t if and only if the total width of WINDOW¶equals the total width of the root window of WINDOW’s frame.¶WINDOW must be a valid window and defaults to the selected one.",
"window-body-height":"Return the height of WINDOW’s text area.¶WINDOW must be a live window and defaults to the selected one.  Optional¶argument PIXELWISE non-nil means return the height of WINDOW’s text area¶in pixels.  The return value does not include the mode line or header¶line or any horizontal divider.¶¶If PIXELWISE is nil, return the largest integer smaller than WINDOW’s¶pixel height divided by the character height of WINDOW’s frame.  This¶means that if a line at the bottom of the text area is only partially¶visible, that line is not counted.¶¶(fn &amp;optional WINDOW PIXELWISE)",
"window-body-width":"Return the width of WINDOW’s text area.¶WINDOW must be a live window and defaults to the selected one.  Optional¶argument PIXELWISE non-nil means return the width in pixels.  The return¶value does not include any vertical dividers, fringes or marginal areas,¶or scroll bars.¶¶If PIXELWISE is nil, return the largest integer smaller than WINDOW’s¶pixel width divided by the character width of WINDOW’s frame.  This¶means that if a column at the right of the text area is only partially¶visible, that column is not counted.¶¶Note that the returned value includes the column reserved for the¶continuation glyph.¶¶(fn &amp;optional WINDOW PIXELWISE)",
"window-body-size":"Return the height or width of WINDOW’s text area.¶WINDOW must be a live window and defaults to the selected one.¶¶If HORIZONTAL is omitted or nil, return the height of the text¶area, like ‘window-body-height’.  Otherwise, return the width of¶the text area, like ‘window-body-width’.  In either case, the¶optional argument PIXELWISE is passed to the functions.",
"window-mode-line-height":"Return the height in pixels of WINDOW’s mode-line.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-header-line-height":"Return the height in pixels of WINDOW’s header-line.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-max-chars-per-line":"Return the number of characters that can be displayed on one line in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶The character width of FACE is used for the calculation.  If FACE¶is nil or omitted, the default face is used.  If FACE is¶remapped (see ‘face-remapping-alist’), the function uses the¶remapped face.¶¶This function is different from ‘window-body-width’ in two¶ways.  First, it accounts for the portions of the line reserved¶for the continuation glyph.  Second, it accounts for the size of¶the font.",
"window-min-size":"Return the minimum size of WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Optional argument HORIZONTAL non-nil means return the minimum¶number of columns of WINDOW; otherwise return the minimum number¶of WINDOW’s lines.¶¶The optional argument IGNORE has the same meaning as for¶‘window-resizable’.  Optional argument PIXELWISE non-nil means¶return the minimum pixel-size of WINDOW.",
"window-edges":"Return a list of the edge distances of WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶The list returned has the form (LEFT TOP RIGHT BOTTOM).¶¶If the optional argument BODY is nil, this means to return the¶edges corresponding to the total size of WINDOW.  BODY non-nil¶means to return the edges of WINDOW’s body (aka text area).  If¶BODY is non-nil, WINDOW must specify a live window.¶¶Optional argument ABSOLUTE nil means to return edges relative to¶the position of WINDOW’s native frame.  ABSOLUTE non-nil means to¶return coordinates relative to the origin - the position (0, 0) -¶of FRAME’s display.  On non-graphical systems this argument has¶no effect.¶¶Optional argument PIXELWISE nil means to return the coordinates¶in terms of the canonical character width and height of WINDOW’s¶frame, rounded if necessary.  PIXELWISE non-nil means to return¶the coordinates in pixels where the values for RIGHT and BOTTOM¶are one more than the actual value of these edges.  Note that if¶ABSOLUTE is non-nil, PIXELWISE is implicitly non-nil too.",
"window-body-edges":"Return a list of the edge coordinates of WINDOW’s body.¶The return value is that of ‘window-edges’ called with argument¶BODY non-nil.",
"window-at":"Return window containing coordinates X and Y on FRAME.¶FRAME must be a live frame and defaults to the selected one.¶The top left corner of the frame is considered to be row 0,¶column 0.¶¶(fn X Y &amp;optional FRAME)",
"coordinates-in-window-p":"Return non-nil if COORDINATES are in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶COORDINATES is a cons of the form (X . Y), X and Y being distances¶measured in characters from the upper-left corner of the frame.¶(0 . 0) denotes the character in the upper left corner of the¶frame.¶If COORDINATES are in the text portion of WINDOW,¶   the coordinates relative to the window are returned.¶If they are in the bottom divider of WINDOW, ‘bottom-divider’ is returned.¶If they are in the right divider of WINDOW, ‘right-divider’ is returned.¶If they are in the mode line of WINDOW, ‘mode-line’ is returned.¶If they are in the header line of WINDOW, ‘header-line’ is returned.¶If they are in the left fringe of WINDOW, ‘left-fringe’ is returned.¶If they are in the right fringe of WINDOW, ‘right-fringe’ is returned.¶If they are on the border between WINDOW and its right sibling,¶  ‘vertical-line’ is returned.¶If they are in the windows’s left or right marginal areas, ‘left-margin’¶  or ‘right-margin’ is returned.¶¶(fn COORDINATES WINDOW)",
"window-pixel-edges":"Return a list of the edge pixel coordinates of WINDOW.¶The return value is that of ‘window-edges’ called with argument¶PIXELWISE non-nil.",
"window-body-pixel-edges":"Return a list of the edge pixel coordinates of WINDOW’s body.¶The return value is that of ‘window-edges’ called with arguments¶BODY and PIXELWISE non-nil.",
"window-absolute-pixel-edges":"Return a list of the edge pixel coordinates of WINDOW.¶The return value is that of ‘window-edges’ called with argument¶ABSOLUTE non-nil.",
"window-absolute-body-pixel-edges":"Return a list of the edge pixel coordinates of WINDOW’s text area.¶The return value is that of ‘window-edges’ called with arguments¶BODY and ABSOLUTE non-nil.",
"window-absolute-pixel-position":"Return display coordinates of POSITION in WINDOW.¶If the buffer position POSITION is visible in window WINDOW,¶return the display coordinates of the upper/left corner of the¶glyph at POSITION.  The return value is a cons of the X- and¶Y-coordinates of that corner, relative to an origin at (0, 0) of¶WINDOW’s display.  Return nil if POSITION is not visible in¶WINDOW.¶¶WINDOW must be a live window and defaults to the selected window.¶POSITION defaults to the value of ‘window-point’ of WINDOW.",
"buffer-modified-p":"Return t if BUFFER was modified since its file was last read or saved.¶No argument or nil as argument means use current buffer as BUFFER.¶¶(fn &amp;optional BUFFER)",
"set-buffer-modified-p":"Mark current buffer as modified or unmodified according to FLAG.¶A non-nil FLAG means mark the buffer modified.¶¶(fn FLAG)",
"restore-buffer-modified-p":"Like ‘set-buffer-modified-p’, with a difference concerning redisplay.¶It is not ensured that mode lines will be updated to show the modified¶state of the current buffer.  Use with care.¶¶(fn FLAG)",
"buffer-modified-tick":"Return BUFFER’s tick counter, incremented for each change in text.¶Each buffer has a tick counter which is incremented each time the¶text in that buffer is changed.  It wraps around occasionally.¶No argument or nil as argument means use current buffer as BUFFER.¶¶(fn &amp;optional BUFFER)",
"buffer-chars-modified-tick":"Return BUFFER’s character-change tick counter.¶Each buffer has a character-change tick counter, which is set to the¶value of the buffer’s tick counter (see ‘buffer-modified-tick’), each¶time text in that buffer is inserted or deleted.  By comparing the¶values returned by two individual calls of ‘buffer-chars-modified-tick’,¶you can tell whether a character change occurred in that buffer in¶between these calls.  No argument or nil as argument means use current¶buffer as BUFFER.¶¶(fn &amp;optional BUFFER)",
"decode-time":"Decode a time value as (SEC MINUTE HOUR DAY MONTH YEAR DOW DST UTCOFF).¶The optional SPECIFIED-TIME should be a list of (HIGH LOW . IGNORED),¶as from ‘current-time’ and ‘file-attributes’, or nil to use the¶current time.  The obsolete form (HIGH . LOW) is also still accepted.¶The optional ZONE is omitted or nil for Emacs local time, t for¶Universal Time, ‘wall’ for system wall clock time, or a string as in¶the TZ environment variable.¶¶The list has the following nine members: SEC is an integer between 0¶and 60; SEC is 60 for a leap second, which only some operating systems¶support.  MINUTE is an integer between 0 and 59.  HOUR is an integer¶between 0 and 23.  DAY is an integer between 1 and 31.  MONTH is an¶integer between 1 and 12.  YEAR is an integer indicating the¶four-digit year.  DOW is the day of week, an integer between 0 and 6,¶where 0 is Sunday.  DST is t if daylight saving time is in effect,¶otherwise nil.  UTCOFF is an integer indicating the UTC offset in¶seconds, i.e., the number of seconds east of Greenwich.  (Note that¶Common Lisp has different meanings for DOW and UTCOFF.)¶¶(fn &amp;optional TIME ZONE)",
"encode-time":"Convert SECOND, MINUTE, HOUR, DAY, MONTH, YEAR and ZONE to internal time.¶This is the reverse operation of ‘decode-time’, which see.¶The optional ZONE is omitted or nil for Emacs local time, t for¶Universal Time, ‘wall’ for system wall clock time, or a string as in¶the TZ environment variable.  It can also be a list (as from¶‘current-time-zone’) or an integer (as from ‘decode-time’) applied¶without consideration for daylight saving time.¶¶You can pass more than 7 arguments; then the first six arguments¶are used as SECOND through YEAR, and the *last* argument is used as ZONE.¶The intervening arguments are ignored.¶This feature lets (apply 'encode-time (decode-time ...)) work.¶¶Out-of-range values for SECOND, MINUTE, HOUR, DAY, or MONTH are allowed;¶for example, a DAY of 0 means the day preceding the given month.¶Year numbers less than 100 are treated just like other year numbers.¶If you want them to stand for years in this century, you must do that yourself.¶¶Years before 1970 are not guaranteed to work.  On some systems,¶year values as low as 1901 do work.¶¶(fn SECOND MINUTE HOUR DAY MONTH YEAR &amp;optional ZONE)",
"marker-position":"Return the position of MARKER, or nil if it points nowhere.¶¶(fn MARKER)",
"marker-buffer":"Return the buffer that MARKER points into, or nil if none.¶Returns nil if MARKER points into a dead buffer.¶¶(fn MARKER)",
"create-fontset-from-fontset-spec":"Create a fontset from fontset specification string FONTSET-SPEC.¶FONTSET-SPEC is a string of the format:¶\tFONTSET-NAME[,SCRIPT-NAME0:FONT-NAME0,SCRIPT-NAME1:FONT-NAME1] ...¶Any number of SPACE, TAB, and NEWLINE can be put before and after commas.¶¶When a frame uses the fontset as the ‘font’ parameter, the frame’s¶default font name is derived from FONTSET-NAME by substituting¶&quot;iso8859-1&quot; for the tail part &quot;fontset-XXX&quot;.  But, if SCRIPT-NAMEn¶is &quot;ascii&quot;, use the corresponding FONT-NAMEn as the default font¶name.¶¶Optional 2nd and 3rd arguments exist just for backward compatibility,¶and are ignored.¶¶It returns a name of the created fontset.¶¶For backward compatibility, SCRIPT-NAME may be a charset name, in¶which case, the corresponding script is decided by the variable¶‘charset-script-alist’ (which see).",
"set-fontset-font":"Modify fontset NAME to use FONT-SPEC for TARGET characters.¶¶NAME is a fontset name string, nil for the fontset of FRAME, or t for¶the default fontset.¶¶TARGET may be a single character to use FONT-SPEC for.¶¶Target may be a cons (FROM . TO), where FROM and TO are characters.¶In that case, use FONT-SPEC for all characters in the range FROM¶and TO (inclusive).¶¶TARGET may be a script name symbol.  In that case, use FONT-SPEC for¶all characters that belong to the script.¶¶TARGET may be a charset.  In that case, use FONT-SPEC for all¶characters in the charset.¶¶TARGET may be nil.  In that case, use FONT-SPEC for any characters for¶that no FONT-SPEC is specified.¶¶FONT-SPEC may one of these:¶ * A font-spec object made by the function ‘font-spec’ (which see).¶ * A cons (FAMILY . REGISTRY), where FAMILY is a font family name and¶   REGISTRY is a font registry name.  FAMILY may contain foundry¶   name, and REGISTRY may contain encoding name.¶ * A font name string.¶ * nil, which explicitly specifies that there’s no font for TARGET.¶¶Optional 4th argument FRAME is a frame or nil for the selected frame¶that is concerned in the case that NAME is nil.¶¶Optional 5th argument ADD, if non-nil, specifies how to add FONT-SPEC¶to the font specifications for TARGET previously set.  If it is¶‘prepend’, FONT-SPEC is prepended.  If it is ‘append’, FONT-SPEC is¶appended.  By default, FONT-SPEC overrides the previous settings.¶¶(fn NAME TARGET FONT-SPEC &amp;optional FRAME ADD)",
"char-displayable-p":"Return non-nil if we should be able to display CHAR.¶On a multi-font display, the test is only whether there is an¶appropriate font from the selected frame’s fontset to display¶CHAR’s charset in general.  Since fonts may be specified on a¶per-character basis, this may not be accurate.¶¶(fn CHAR)",
"custom-add-frequent-value":"To the variable SYMBOL add OPTION.¶¶If SYMBOL’s custom type is a hook, OPTION should be a hook member.¶If SYMBOL’s custom type is an alist, OPTION specifies a symbol¶to offer to the user as a possible key in the alist.¶For other custom types, this has no effect.",
"custom-reevaluate-setting":"Reset the value of SYMBOL by re-evaluating its saved or standard value.¶Use the :set function to do so.  This is useful for customizable options¶that are defined before their standard value can really be computed.¶E.g. dumped variables whose default depends on run-time information.",
"custom-variable-p":"Return non-nil if VARIABLE is a customizable variable.¶A customizable variable is either (i) a variable whose property¶list contains a non-nil ‘standard-value’ or ‘custom-autoload’¶property, or (ii) an alias for another customizable variable.",
"custom-theme-set-variables":"Initialize variables for theme THEME according to settings in ARGS.¶Each of the arguments in ARGS should be a list of this form:¶¶  (SYMBOL EXP [NOW [REQUEST [COMMENT]]])¶¶SYMBOL is the variable name, and EXP is an expression which¶evaluates to the customized value.  EXP will also be stored,¶without evaluating it, in SYMBOL’s ‘saved-value’ property, so¶that it can be restored via the Customize interface.  It is also¶added to the alist in SYMBOL’s ‘theme-value’ property (by¶calling ‘custom-push-theme’).¶¶NOW, if present and non-nil, means to install the variable’s¶value directly now, even if its ‘defcustom’ declaration has not¶been executed.  This is for internal use only.¶¶REQUEST is a list of features to ‘require’ (which are loaded¶prior to evaluating EXP).¶¶COMMENT is a comment string about SYMBOL.",
"custom-theme-set-faces":"Apply a list of face specs associated with theme THEME.¶THEME should be a theme name (a symbol).  The special theme named¶‘user’ refers to user settings applied via Customize.¶¶The remaining ARGS should be a list where each entry is a list of¶the form:¶¶  (FACE SPEC [NOW [COMMENT]])¶¶FACE should be a face name (a symbol).  If FACE is a face alias,¶the setting refers to the parent face.¶¶SPEC should be a face spec.  For details, see ‘defface’.¶¶NOW, if present and non-nil, forces the face settings to take¶immediate effect in the Emacs display; in particular, FACE is¶initialized as a face if it is not yet one.  If NOW is omitted or¶nil, the caller is responsible for making the settings take¶effect later, by calling ‘custom-theme-recalc-face’ or¶‘face-spec-recalc’.¶¶COMMENT is a string comment about FACE.¶¶This function works by calling ‘custom-push-theme’ to record each¶SPEC in each FACE’s ‘theme-face’ property, and in THEME’s¶‘theme-settings’ property.  If FACE has not already been¶customized, it also stores SPEC in the ‘saved-face’ property.¶¶If THEME has a non-nil ‘theme-immediate’ property, this is¶equivalent to providing the NOW argument to all faces in the¶argument list.",
"custom-theme-p":"Non-nil when THEME has been defined.",
"add-to-list":"Add ELEMENT to the value of LIST-VAR if it isn’t there yet.¶The test for presence of ELEMENT is done with ‘equal’, or with¶COMPARE-FN if that’s non-nil.¶If ELEMENT is added, it is added at the beginning of the list,¶unless the optional argument APPEND is non-nil, in which case¶ELEMENT is added at the end.¶¶The return value is the new value of LIST-VAR.¶¶This is handy to add some elements to configuration variables,¶but please do not abuse it in Elisp code, where you are usually¶better off using ‘push’ or ‘cl-pushnew’.¶¶If you want to use ‘add-to-list’ on a variable that is not¶defined until a certain package is loaded, you should put the¶call to ‘add-to-list’ into a hook function that will be run only¶after loading the package.  ‘eval-after-load’ provides one way to¶do this.  In some cases other hooks, such as major mode hooks,¶can do the job.¶¶(fn LIST-VAR ELEMENT &amp;optional APPEND COMPARE-FN)",
"add-to-ordered-list":"Add ELEMENT to the value of LIST-VAR if it isn’t there yet.¶The test for presence of ELEMENT is done with ‘eq’.¶¶The resulting list is reordered so that the elements are in the¶order given by each element’s numeric list order.  Elements¶without a numeric list order are placed at the end of the list.¶¶If the third optional argument ORDER is a number (integer or¶float), set the element’s list order to the given value.  If¶ORDER is nil or omitted, do not change the numeric order of¶ELEMENT.  If ORDER has any other value, remove the numeric order¶of ELEMENT if it has one.¶¶The list order for each element is stored in LIST-VAR’s¶‘list-order’ property.¶¶The return value is the new value of LIST-VAR.¶¶(fn LIST-VAR ELEMENT &amp;optional ORDER)",
"sin":"Return the sine of ARG.¶¶(fn ARG)",
"cos":"Return the cosine of ARG.¶¶(fn ARG)",
"tan":"Return the tangent of ARG.¶¶(fn ARG)",
"asin":"Return the inverse sine of ARG.¶¶(fn ARG)",
"acos":"Return the inverse cosine of ARG.¶¶(fn ARG)",
"atan":"Return the inverse tangent of the arguments.¶If only one argument Y is given, return the inverse tangent of Y.¶If two arguments Y and X are given, return the inverse tangent of Y¶divided by X, i.e. the angle in radians between the vector (X, Y)¶and the x-axis.¶¶(fn Y &amp;optional X)",
"exp":"Return the exponential base e of ARG.¶¶(fn ARG)",
"log":"Return the natural logarithm of ARG.¶If the optional argument BASE is given, return log ARG using that base.¶¶(fn ARG &amp;optional BASE)",
"expt":"Return the exponential ARG1 ** ARG2.¶¶(fn ARG1 ARG2)",
"sqrt":"Return the square root of ARG.¶¶(fn ARG)",
"get-char-code-property":"Return the value of CHAR’s PROPNAME property.¶¶(fn CHAR PROPNAME)",
"char-code-property-description":"Return a description string of character property PROP’s value VALUE.¶If there’s no description string for VALUE, return nil.¶¶(fn PROP VALUE)",
"put-char-code-property":"Store CHAR’s PROPNAME property with VALUE.¶It can be retrieved with ‘(get-char-code-property CHAR PROPNAME)’.¶¶(fn CHAR PROPNAME VALUE)",
"prepare-change-group":"Return a handle for the current buffer’s state, for a change group.¶If you specify BUFFER, make a handle for BUFFER’s state instead.¶¶Pass the handle to ‘activate-change-group’ afterward to initiate¶the actual changes of the change group.¶¶To finish the change group, call either ‘accept-change-group’ or¶‘cancel-change-group’ passing the same handle as argument.  Call¶‘accept-change-group’ to accept the changes in the group as final;¶call ‘cancel-change-group’ to undo them all.  You should use¶‘unwind-protect’ to make sure the group is always finished.  The call¶to ‘activate-change-group’ should be inside the ‘unwind-protect’.¶Once you finish the group, don’t use the handle again--don’t try to¶finish the same group twice.  For a simple example of correct use, see¶the source code of ‘atomic-change-group’.¶¶The handle records only the specified buffer.  To make a multibuffer¶change group, call this function once for each buffer you want to¶cover, then use ‘nconc’ to combine the returned values, like this:¶¶  (nconc (prepare-change-group buffer-1)¶         (prepare-change-group buffer-2))¶¶You can then activate that multibuffer change group with a single¶call to ‘activate-change-group’ and finish it with a single call¶to ‘accept-change-group’ or ‘cancel-change-group’.¶¶(fn &amp;optional BUFFER)",
"activate-change-group":"Activate a change group made with ‘prepare-change-group’ (which see).¶¶(fn HANDLE)",
"accept-change-group":"Finish a change group made with ‘prepare-change-group’ (which see).¶This finishes the change group by accepting its changes as final.¶¶(fn HANDLE)",
"cancel-change-group":"Finish a change group made with ‘prepare-change-group’ (which see).¶This finishes the change group by reverting all of its changes.¶¶(fn HANDLE)",
"active-minibuffer-window":"Return the currently active minibuffer window, or nil if none.¶¶(fn)",
"minibuffer-window":"Return the minibuffer window for frame FRAME.¶If FRAME is omitted or nil, it defaults to the selected frame.¶¶(fn &amp;optional FRAME)",
"set-minibuffer-window":"Specify which minibuffer window to use for the minibuffer.¶This affects where the minibuffer is displayed if you put text in it¶without invoking the usual minibuffer commands.¶¶(fn WINDOW)",
"window-minibuffer-p":"Return non-nil if WINDOW is a minibuffer window.¶WINDOW must be a valid window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"minibuffer-window-active-p":"Return t if WINDOW is the currently active minibuffer window.",
"define-category":"Define CATEGORY as a category which is described by DOCSTRING.¶CATEGORY should be an ASCII printing character in the range ‘ ’ to ‘~’.¶DOCSTRING is the documentation string of the category.  The first line¶should be a terse text (preferably less than 16 characters),¶and the rest lines should be the full description.¶The category is defined only in category table TABLE, which defaults to¶the current buffer’s category table.¶¶(fn CATEGORY DOCSTRING &amp;optional TABLE)",
"category-docstring":"Return the documentation string of CATEGORY, as defined in TABLE.¶TABLE should be a category table and defaults to the current buffer’s¶category table.¶¶(fn CATEGORY &amp;optional TABLE)",
"get-unused-category":"Return a category which is not yet defined in TABLE.¶If no category remains available, return nil.¶The optional argument TABLE specifies which category table to modify;¶it defaults to the current buffer’s category table.¶¶(fn &amp;optional TABLE)",
"category-table":"Return the current category table.¶This is the one specified by the current buffer.¶¶(fn)",
"category-table-p":"Return t if ARG is a category table.¶¶(fn ARG)",
"standard-category-table":"Return the standard category table.¶This is the one used for new buffers.¶¶(fn)",
"copy-category-table":"Construct a new category table and return it.¶It is a copy of the TABLE, which defaults to the standard category table.¶¶(fn &amp;optional TABLE)",
"set-category-table":"Specify TABLE as the category table for the current buffer.¶Return TABLE.¶¶(fn TABLE)",
"make-category-table":"Construct a new and empty category table and return it.¶¶(fn)",
"make-category-set":"Return a newly created category-set which contains CATEGORIES.¶CATEGORIES is a string of category mnemonics.¶The value is a bool-vector which has t at the indices corresponding to¶those categories.¶¶(fn CATEGORIES)",
"char-category-set":"Return the category set of CHAR.¶¶(fn CHAR)",
"category-set-mnemonics":"Return a string containing mnemonics of the categories in CATEGORY-SET.¶CATEGORY-SET is a bool-vector, and the categories &quot;in&quot; it are those¶that are indexes where t occurs in the bool-vector.¶The return value is a string containing those same categories.¶¶(fn CATEGORY-SET)",
"modify-category-entry":"Modify the category set of CHARACTER by adding CATEGORY to it.¶The category is changed only for table TABLE, which defaults to¶the current buffer’s category table.¶CHARACTER can be either a single character or a cons representing the¶lower and upper ends of an inclusive character range to modify.¶CATEGORY must be a category name (a character between ‘ ’ and ‘~’).¶Use ‘describe-categories’ to see existing category names.¶If optional fourth argument RESET is non-nil,¶then delete CATEGORY from the category set instead of adding it.¶¶(fn CHARACTER CATEGORY &amp;optional TABLE RESET)",
"memory-limit":"Return the address of the last byte Emacs has allocated, divided by 1024.¶This may be helpful in debugging Emacs’s memory usage.¶We divide the value by 1024 to make sure it fits in a Lisp integer.¶¶(fn)",
"memory-use-counts":"Return a list of counters that measure how much consing there has been.¶Each of these counters increments for a certain kind of object.¶The counters wrap around from the largest positive integer to zero.¶Garbage collection does not decrease them.¶The elements of the value are as follows:¶  (CONSES FLOATS VECTOR-CELLS SYMBOLS STRING-CHARS MISCS INTERVALS STRINGS)¶All are in units of 1 = one object consed¶except for VECTOR-CELLS and STRING-CHARS, which count the total length of¶objects consed.¶MISCS include overlays, markers, and some internal types.¶Frames, windows, buffers, and subprocesses count as vectors¶  (but the contents of a buffer’s text do not count here).¶¶(fn)",
"memory-info":"Return a list of (TOTAL-RAM FREE-RAM TOTAL-SWAP FREE-SWAP).¶All values are in Kbytes.  If there is no swap space,¶last two values are zero.  If the system is not supported¶or memory information can’t be obtained, return nil.¶¶(fn)",
"lookup-key":"In keymap KEYMAP, look up key sequence KEY.  Return the definition.¶A value of nil means undefined.  See doc of ‘define-key’¶for kinds of definitions.¶¶A number as value means KEY is &quot;too long&quot;;¶that is, characters or symbols in it except for the last one¶fail to be a valid sequence of prefix characters in KEYMAP.¶The number is how many characters at the front of KEY¶it takes to reach a non-prefix key.¶¶Normally, ‘lookup-key’ ignores bindings for t, which act as default¶bindings, used when nothing else in the keymap applies; this makes it¶usable as a general function for probing keymaps.  However, if the¶third optional argument ACCEPT-DEFAULT is non-nil, ‘lookup-key’ will¶recognize the default bindings, just as ‘read-key-sequence’ does.¶¶(fn KEYMAP KEY &amp;optional ACCEPT-DEFAULT)",
"local-key-binding":"Return the binding for command KEYS in current local keymap only.¶KEYS is a string or vector, a sequence of keystrokes.¶The binding is probably a symbol with a function definition.¶¶If optional argument ACCEPT-DEFAULT is non-nil, recognize default¶bindings; see the description of ‘lookup-key’ for more details about this.¶¶(fn KEYS &amp;optional ACCEPT-DEFAULT)",
"global-key-binding":"Return the binding for command KEYS in current global keymap only.¶KEYS is a string or vector, a sequence of keystrokes.¶The binding is probably a symbol with a function definition.¶This function’s return values are the same as those of ‘lookup-key’¶(which see).¶¶If optional argument ACCEPT-DEFAULT is non-nil, recognize default¶bindings; see the description of ‘lookup-key’ for more details about this.¶¶(fn KEYS &amp;optional ACCEPT-DEFAULT)",
"minor-mode-key-binding":"Find the visible minor mode bindings of KEY.¶Return an alist of pairs (MODENAME . BINDING), where MODENAME is¶the symbol which names the minor mode binding KEY, and BINDING is¶KEY’s definition in that mode.  In particular, if KEY has no¶minor-mode bindings, return nil.  If the first binding is a¶non-prefix, all subsequent bindings will be omitted, since they would¶be ignored.  Similarly, the list doesn’t include non-prefix bindings¶that come after prefix bindings.¶¶If optional argument ACCEPT-DEFAULT is non-nil, recognize default¶bindings; see the description of ‘lookup-key’ for more details about this.¶¶(fn KEY &amp;optional ACCEPT-DEFAULT)",
"gui-get-selection":"Return the value of an X Windows selection.¶The argument TYPE (default ‘PRIMARY’) says which selection,¶and the argument DATA-TYPE (default ‘STRING’) says¶how to convert the data.¶¶TYPE may be any symbol (but nil stands for ‘PRIMARY’).  However,¶only a few symbols are commonly used.  They conventionally have¶all upper-case names.  The most often used ones, in addition to¶‘PRIMARY’, are ‘SECONDARY’ and ‘CLIPBOARD’.¶¶DATA-TYPE is usually ‘STRING’, but can also be one of the symbols¶in ‘selection-converter-alist’, which see.  This argument is¶ignored on NS, MS-Windows and MS-DOS.¶¶(fn &amp;optional TYPE DATA-TYPE)",
"point":"Return value of point, as an integer.¶Beginning of buffer is position (point-min).¶¶(fn)",
"point-min":"Return the minimum permissible value of point in the current buffer.¶This is 1, unless narrowing (a buffer restriction) is in effect.¶¶(fn)",
"point-max":"Return the maximum permissible value of point in the current buffer.¶This is (1+ (buffer-size)), unless narrowing (a buffer restriction)¶is in effect, in which case it is less.¶¶(fn)",
"buffer-end":"Return the &quot;far end&quot; position of the buffer, in direction ARG.¶If ARG is positive, that’s the end of the buffer.¶Otherwise, that’s the beginning of the buffer.¶¶(fn ARG)",
"buffer-size":"Return the number of characters in the current buffer.¶If BUFFER is not nil, return the number of characters in that buffer¶instead.¶¶This does not take narrowing into account; to count the number of¶characters in the accessible portion of the current buffer, use¶‘(- (point-max) (point-min))’, and to count the number of characters¶in some other BUFFER, use¶‘(with-current-buffer BUFFER (- (point-max) (point-min)))’.¶¶(fn &amp;optional BUFFER)",
"add-to-history":"Add NEWELT to the history list stored in the variable HISTORY-VAR.¶Return the new history list.¶If MAXELT is non-nil, it specifies the maximum length of the history.¶Otherwise, the maximum history length is the value of the ‘history-length’¶property on symbol HISTORY-VAR, if set, or the value of the ‘history-length’¶variable.¶Remove duplicates of NEWELT if ‘history-delete-duplicates’ is non-nil.¶If optional fourth arg KEEP-ALL is non-nil, add NEWELT to history even¶if it is empty or a duplicate.¶¶(fn HISTORY-VAR NEWELT &amp;optional MAXELT KEEP-ALL)",
"car":"Return the car of LIST.  If arg is nil, return nil.¶Error if arg is not nil and not a cons cell.  See also ‘car-safe’.¶¶See Info node ‘(elisp)Cons Cells’ for a discussion of related basic¶Lisp concepts such as car, cdr, cons cell and list.¶¶(fn LIST)",
"cdr":"Return the cdr of LIST.  If arg is nil, return nil.¶Error if arg is not nil and not a cons cell.  See also ‘cdr-safe’.¶¶See Info node ‘(elisp)Cons Cells’ for a discussion of related basic¶Lisp concepts such as cdr, car, cons cell and list.¶¶(fn LIST)",
"car-safe":"Return the car of OBJECT if it is a cons cell, or else nil.¶¶(fn OBJECT)",
"cdr-safe":"Return the cdr of OBJECT if it is a cons cell, or else nil.¶¶(fn OBJECT)",
"nth":"Return the Nth element of LIST.¶N counts from zero.  If LIST is not that long, nil is returned.¶¶(fn N LIST)",
"nthcdr":"Take cdr N times on LIST, return the result.¶¶(fn N LIST)",
"last":"Return the last link of LIST.  Its car is the last element.¶If LIST is nil, return nil.¶If N is non-nil, return the Nth-to-last link of LIST.¶If N is bigger than the length of LIST, return LIST.¶¶(fn LIST &amp;optional N)",
"safe-length":"Return the length of a list, but avoid error or infinite loop.¶This function never gets an error.  If LIST is not really a list,¶it returns 0.  If LIST is circular, it returns a finite value¶which is at least the number of distinct elements.¶¶(fn LIST)",
"caar":"Return the car of the car of X.¶¶(fn X)",
"cadr":"Return the car of the cdr of X.¶¶(fn X)",
"cdar":"Return the cdr of the car of X.¶¶(fn X)",
"cddr":"Return the cdr of the cdr of X.¶¶(fn X)",
"butlast":"Return a copy of LIST with the last N elements removed.¶If N is omitted or nil, the last element is removed from the¶copy.¶¶(fn LIST &amp;optional N)",
"nbutlast":"Modifies LIST to remove the last N elements.¶If N is omitted or nil, remove the last element.¶¶(fn LIST &amp;optional N)",
"macroexpand":"Return result of expanding macros at top level of FORM.¶If FORM is not a macro call, it is returned unchanged.¶Otherwise, the macro is expanded and the expansion is considered¶in place of FORM.  When a non-macro-call results, it is returned.¶¶The second optional arg ENVIRONMENT specifies an environment of macro¶definitions to shadow the loaded ones for use in file byte-compilation.¶¶(fn FORM &amp;optional ENVIRONMENT)",
"macroexpand-all":"Return result of expanding macros at all levels in FORM.¶If no macros are expanded, FORM is returned unchanged.¶The second optional arg ENVIRONMENT specifies an environment of macro¶definitions to shadow the loaded ones for use in file byte-compilation.¶¶(fn FORM &amp;optional ENVIRONMENT)",
"string-to-syntax":"Convert a syntax descriptor STRING into a raw syntax descriptor.¶STRING should be a string of the form allowed as argument of¶‘modify-syntax-entry’.  The return value is a raw syntax descriptor: a¶cons cell (CODE . MATCHING-CHAR) which can be used, for example, as¶the value of a ‘syntax-table’ text property.¶¶(fn STRING)",
"syntax-after":"Return the raw syntax descriptor for the char after POS.¶If POS is outside the buffer’s accessible portion, return nil.¶¶(fn POS)",
"syntax-class":"Return the code for the syntax class described by SYNTAX.¶¶SYNTAX should be a raw syntax descriptor; the return value is a¶integer which encodes the corresponding syntax class.  See Info¶node ‘(elisp)Syntax Table Internals’ for a list of codes.¶¶If SYNTAX is nil, return nil.¶¶(fn SYNTAX)",
"make-finalizer":"Make a finalizer that will run FUNCTION.¶FUNCTION will be called after garbage collection when the returned¶finalizer object becomes unreachable.  If the finalizer object is¶reachable only through references from finalizer objects, it does not¶count as reachable for the purpose of deciding whether to run¶FUNCTION.  FUNCTION will be run once per finalizer object.¶¶(fn FUNCTION)",
"unsafep":"Return nil if evaluating FORM couldn’t possibly do any harm.¶Otherwise result is a reason why FORM is unsafe.¶UNSAFEP-VARS is a list of symbols with local bindings.¶¶(fn FORM &amp;optional UNSAFEP-VARS)",
"set-buffer-multibyte":"Set the multibyte flag of the current buffer to FLAG.¶If FLAG is t, this makes the buffer a multibyte buffer.¶If FLAG is nil, this makes the buffer a single-byte buffer.¶In these cases, the buffer contents remain unchanged as a sequence of¶bytes but the contents viewed as characters do change.¶If FLAG is ‘to’, this makes the buffer a multibyte buffer by changing¶all eight-bit bytes to eight-bit characters.¶If the multibyte flag was really changed, undo information of the¶current buffer is cleared.¶¶(fn FLAG)",
"string-as-unibyte":"Return a unibyte string with the same individual bytes as STRING.¶If STRING is unibyte, the result is STRING itself.¶Otherwise it is a newly created string, with no text properties.¶If STRING is multibyte and contains a character of charset¶‘eight-bit’, it is converted to the corresponding single byte.¶¶(fn STRING)",
"string-as-multibyte":"Return a multibyte string with the same individual bytes as STRING.¶If STRING is multibyte, the result is STRING itself.¶Otherwise it is a newly created string, with no text properties.¶¶If STRING is unibyte and contains an individual 8-bit byte (i.e. not¶part of a correct utf-8 sequence), it is converted to the corresponding¶multibyte character of charset ‘eight-bit’.¶See also ‘string-to-multibyte’.¶¶Beware, this often doesn’t really do what you think it does.¶It is similar to (decode-coding-string STRING 'utf-8-emacs).¶If you’re not sure, whether to use ‘string-as-multibyte’ or¶‘string-to-multibyte’, use ‘string-to-multibyte’.¶¶(fn STRING)",
"tabulated-list-init-header":"Set up header line for the Tabulated List buffer.",
"tabulated-list-print":"Populate the current Tabulated List mode buffer.¶This sorts the ‘tabulated-list-entries’ list if sorting is¶specified by ‘tabulated-list-sort-key’.  It then erases the¶buffer and inserts the entries with ‘tabulated-list-printer’.¶¶Optional argument REMEMBER-POS, if non-nil, means to move point¶to the entry with the same ID element as the current line and¶recenter window line accordingly.¶¶Non-nil UPDATE argument means to use an alternative printing¶method which is faster if most entries haven’t changed since the¶last print.  The only difference in outcome is that tags will not¶be removed from entries that haven’t changed (see¶‘tabulated-list-put-tag’).  Don’t use this immediately after¶changing ‘tabulated-list-sort-key’.¶¶(fn &amp;optional REMEMBER-POS UPDATE)",
"ffloor":"Return the largest integer no greater than ARG, as a float.¶(Round towards -inf.)¶¶(fn ARG)",
"fceiling":"Return the smallest integer no less than ARG, as a float.¶(Round toward +inf.)¶¶(fn ARG)",
"ftruncate":"Truncate a floating point number to an integral float value.¶Rounds the value toward zero.¶¶(fn ARG)",
"fround":"Return the nearest integer to ARG, as a float.¶¶(fn ARG)",
"assoc":"Return non-nil if KEY is ‘equal’ to the car of an element of LIST.¶The value is actually the first element of LIST whose car equals KEY.¶¶(fn KEY LIST)",
"rassoc":"Return non-nil if KEY is ‘equal’ to the cdr of an element of LIST.¶The value is actually the first element of LIST whose cdr equals KEY.¶¶(fn KEY LIST)",
"assq":"Return non-nil if KEY is ‘eq’ to the car of an element of LIST.¶The value is actually the first element of LIST whose car is KEY.¶Elements of LIST that are not conses are ignored.¶¶(fn KEY LIST)",
"alist-get":"Return the value associated with KEY in ALIST, using ‘assq’.¶If KEY is not found in ALIST, return DEFAULT.¶¶This is a generalized variable suitable for use with ‘setf’.¶When using it to set a value, optional argument REMOVE non-nil¶means to remove KEY from ALIST if the new value is ‘eql’ to DEFAULT.¶¶(fn KEY ALIST &amp;optional DEFAULT REMOVE)",
"rassq":"Return non-nil if KEY is ‘eq’ to the cdr of an element of LIST.¶The value is actually the first element of LIST whose cdr is KEY.¶¶(fn KEY LIST)",
"assoc-default":"Find object KEY in a pseudo-alist ALIST.¶ALIST is a list of conses or objects.  Each element¶ (or the element’s car, if it is a cons) is compared with KEY by¶ calling TEST, with two arguments: (i) the element or its car,¶ and (ii) KEY.¶If that is non-nil, the element matches; then ‘assoc-default’¶ returns the element’s cdr, if it is a cons, or DEFAULT if the¶ element is not a cons.¶¶If no element matches, the value is nil.¶If TEST is omitted or nil, ‘equal’ is used.¶¶(fn KEY ALIST &amp;optional TEST DEFAULT)",
"copy-alist":"Return a copy of ALIST.¶This is an alist which represents the same mapping from objects to objects,¶but does not share the alist structure with ALIST.¶The objects mapped (cars and cdrs of elements of the alist)¶are shared, however.¶Elements of ALIST that are not conses are also shared.¶¶(fn ALIST)",
"assq-delete-all":"Delete from ALIST all elements whose car is ‘eq’ to KEY.¶Return the modified alist.¶Elements of ALIST that are not conses are ignored.¶¶(fn KEY ALIST)",
"rassq-delete-all":"Delete from ALIST all elements whose cdr is ‘eq’ to VALUE.¶Return the modified alist.¶Elements of ALIST that are not conses are ignored.¶¶(fn VALUE ALIST)",
"make-serial-process":"Create and return a serial port process.¶¶In Emacs, serial port connections are represented by process objects,¶so input and output work as for subprocesses, and ‘delete-process’¶closes a serial port connection.  However, a serial process has no¶process id, it cannot be signaled, and the status codes are different¶from normal processes.¶¶‘make-serial-process’ creates a process and a buffer, on which you¶probably want to use ‘process-send-string’.  Try M-x serial-term for¶an interactive terminal.  See below for examples.¶¶Arguments are specified as keyword/argument pairs.  The following¶arguments are defined:¶¶:port PORT -- (mandatory) PORT is the path or name of the serial port.¶For example, this could be &quot;/dev/ttyS0&quot; on Unix.  On Windows, this¶could be &quot;COM1&quot;, or &quot;⧷⧷.⧷COM10&quot; for ports higher than COM9 (double¶the backslashes in strings).¶¶:speed SPEED -- (mandatory) is handled by ‘serial-process-configure’,¶which this function calls.¶¶:name NAME -- NAME is the name of the process.  If NAME is not given,¶the value of PORT is used.¶¶:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate¶with the process.  Process output goes at the end of that buffer,¶unless you specify an output stream or filter function to handle the¶output.  If BUFFER is not given, the value of NAME is used.¶¶:coding CODING -- If CODING is a symbol, it specifies the coding¶system used for both reading and writing for this process.  If CODING¶is a cons (DECODING . ENCODING), DECODING is used for reading, and¶ENCODING is used for writing.¶¶:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and¶the process is running.  If BOOL is not given, query before exiting.¶¶:stop BOOL -- Start process in the ‘stopped’ state if BOOL is non-nil.¶In the stopped state, a serial process does not accept incoming data,¶but you can send outgoing data.  The stopped state is cleared by¶‘continue-process’ and set by ‘stop-process’.¶¶:filter FILTER -- Install FILTER as the process filter.¶¶:sentinel SENTINEL -- Install SENTINEL as the process sentinel.¶¶:plist PLIST -- Install PLIST as the initial plist of the process.¶¶:bytesize¶:parity¶:stopbits¶:flowcontrol¶-- This function calls ‘serial-process-configure’ to handle these¶arguments.¶¶The original argument list, possibly modified by later configuration,¶is available via the function ‘process-contact’.¶¶Examples:¶¶(make-serial-process :port &quot;/dev/ttyS0&quot; :speed 9600)¶¶(make-serial-process :port &quot;COM1&quot; :speed 115200 :stopbits 2)¶¶(make-serial-process :port &quot;⧷⧷.⧷COM13&quot; :speed 1200 :bytesize 7 :parity 'odd)¶¶(make-serial-process :port &quot;/dev/tty.BlueConsole-SPP-1&quot; :speed nil)¶¶(fn &amp;rest ARGS)",
"serial-process-configure":"Configure speed, bytesize, etc. of a serial process.¶¶Arguments are specified as keyword/argument pairs.  Attributes that¶are not given are re-initialized from the process’s current¶configuration (available via the function ‘process-contact’) or set to¶reasonable default values.  The following arguments are defined:¶¶:process PROCESS¶:name NAME¶:buffer BUFFER¶:port PORT¶-- Any of these arguments can be given to identify the process that is¶to be configured.  If none of these arguments is given, the current¶buffer’s process is used.¶¶:speed SPEED -- SPEED is the speed of the serial port in bits per¶second, also called baud rate.  Any value can be given for SPEED, but¶most serial ports work only at a few defined values between 1200 and¶115200, with 9600 being the most common value.  If SPEED is nil, the¶serial port is not configured any further, i.e., all other arguments¶are ignored.  This may be useful for special serial ports such as¶Bluetooth-to-serial converters which can only be configured through AT¶commands.  A value of nil for SPEED can be used only when passed¶through ‘make-serial-process’ or ‘serial-term’.¶¶:bytesize BYTESIZE -- BYTESIZE is the number of bits per byte, which¶can be 7 or 8.  If BYTESIZE is not given or nil, a value of 8 is used.¶¶:parity PARITY -- PARITY can be nil (don’t use parity), the symbol¶‘odd’ (use odd parity), or the symbol ‘even’ (use even parity).  If¶PARITY is not given, no parity is used.¶¶:stopbits STOPBITS -- STOPBITS is the number of stopbits used to¶terminate a byte transmission.  STOPBITS can be 1 or 2.  If STOPBITS¶is not given or nil, 1 stopbit is used.¶¶:flowcontrol FLOWCONTROL -- FLOWCONTROL determines the type of¶flowcontrol to be used, which is either nil (don’t use flowcontrol),¶the symbol ‘hw’ (use RTS/CTS hardware flowcontrol), or the symbol ‘sw’¶(use XON/XOFF software flowcontrol).  If FLOWCONTROL is not given, no¶flowcontrol is used.¶¶‘serial-process-configure’ is called by ‘make-serial-process’ for the¶initial configuration of the serial port.¶¶Examples:¶¶(serial-process-configure :process &quot;/dev/ttyS0&quot; :speed 1200)¶¶(serial-process-configure¶    :buffer &quot;COM1&quot; :stopbits 1 :parity 'odd :flowcontrol 'hw)¶¶(serial-process-configure :port &quot;⧷⧷.⧷COM13&quot; :bytesize 7)¶¶(fn &amp;rest ARGS)",
"make-temp-file":"Create a temporary file.¶The returned file name (created by appending some random characters at the end¶of PREFIX, and expanding against ‘temporary-file-directory’ if necessary),¶is guaranteed to point to a newly created empty file.¶You can then use ‘write-region’ to write new data into the file.¶¶If DIR-FLAG is non-nil, create a new empty directory instead of a file.¶¶If SUFFIX is non-nil, add that at the end of the file name.¶¶(fn PREFIX &amp;optional DIR-FLAG SUFFIX)",
"make-temp-name":"Generate temporary file name (string) starting with PREFIX (a string).¶The Emacs process number forms part of the result, so there is no¶danger of generating a name being used by another Emacs process¶(so long as only a single host can access the containing directory...).¶¶This function tries to choose a name that has no existing file.¶For this to work, PREFIX should be an absolute file name.¶¶There is a race condition between calling ‘make-temp-name’ and creating the¶file, which opens all kinds of security holes.  For that reason, you should¶normally use ‘make-temp-file’ instead.¶¶(fn PREFIX)",
"current-time-zone":"Return the offset and name for the local time zone.¶This returns a list of the form (OFFSET NAME).¶OFFSET is an integer number of seconds ahead of UTC (east of Greenwich).¶    A negative value means west of Greenwich.¶NAME is a string giving the name of the time zone.¶If SPECIFIED-TIME is given, the time zone offset is determined from it¶instead of using the current time.  The argument should have the form¶(HIGH LOW . IGNORED).  Thus, you can use times obtained from¶‘current-time’ and from ‘file-attributes’.  SPECIFIED-TIME can also¶have the form (HIGH . LOW), but this is considered obsolete.¶Optional second arg ZONE is omitted or nil for the local time zone, or¶a string as in the TZ environment variable.¶¶Some operating systems cannot provide all this information to Emacs;¶in this case, ‘current-time-zone’ returns a list containing nil for¶the data it can’t find.¶¶(fn &amp;optional SPECIFIED-TIME ZONE)",
"key-description":"Return a pretty description of key-sequence KEYS.¶Optional arg PREFIX is the sequence of keys leading up to KEYS.¶For example, [?C-x ?l] is converted into the string &quot;C-x l&quot;.¶¶For an approximate inverse of this, see ‘kbd’.¶¶(fn KEYS &amp;optional PREFIX)",
"single-key-description":"Return a pretty description of command character KEY.¶Control characters turn into C-whatever, etc.¶Optional argument NO-ANGLES non-nil means don’t put angle brackets¶around function keys and event symbols.¶¶(fn KEY &amp;optional NO-ANGLES)",
"text-char-description":"Return a pretty description of file-character CHARACTER.¶Control characters turn into &quot;^char&quot;, etc.  This differs from¶‘single-key-description’ which turns them into &quot;C-char&quot;.¶Also, this function recognizes the 2**7 bit as the Meta character,¶whereas ‘single-key-description’ uses the 2**27 bit for Meta.¶See Info node ‘(elisp)Describing Characters’ for examples.¶¶(fn CHARACTER)",
"vectorp":"Return t if OBJECT is a vector.¶¶(fn OBJECT)",
"vector":"Return a newly created vector with specified arguments as elements.¶Any number of arguments, even zero arguments, are allowed.¶¶(fn &amp;rest OBJECTS)",
"make-vector":"Return a newly created vector of length LENGTH, with each element being INIT.¶See also the function ‘vector’.¶¶(fn LENGTH INIT)",
"vconcat":"Concatenate all the arguments and make the result a vector.¶The result is a vector whose elements are the elements of all the arguments.¶Each argument may be a list, vector or string.¶¶(fn &amp;rest SEQUENCES)",
"create-file-buffer":":around advice: ‘uniquify--create-file-buffer-advice’¶¶Create a suitably named buffer for visiting FILENAME, and return it.¶FILENAME (sans directory) is used unchanged if that name is free;¶otherwise a string &lt;2&gt; or &lt;3&gt; or ... is appended to get an unused name.¶¶Emacs treats buffers whose names begin with a space as internal buffers.¶To avoid confusion when visiting a file whose name begins with a space,¶this function prepends a &quot;|&quot; to the final result if necessary.¶¶(fn FILENAME)",
"after-find-file":"Called after finding a file and by the default revert function.¶Sets buffer mode, parses local variables.¶Optional args ERROR, WARN, and NOAUTO: ERROR non-nil means there was an¶error in reading the file.  WARN non-nil means warn if there¶exists an auto-save file more recent than the visited file.¶NOAUTO means don’t mess with auto-save mode.¶Fourth arg AFTER-FIND-FILE-FROM-REVERT-BUFFER is ignored¶(see ‘revert-buffer-in-progress-p’ for similar functionality).¶Fifth arg NOMODES non-nil means don’t alter the file’s modes.¶Finishes by calling the functions in ‘find-file-hook’¶unless NOMODES is non-nil.¶¶(fn &amp;optional ERROR WARN NOAUTO AFTER-FIND-FILE-FROM-REVERT-BUFFER NOMODES)",
"buffer-live-p":"Return non-nil if OBJECT is a buffer which has not been killed.¶Value is nil if OBJECT is not a buffer or if it has been killed.¶¶(fn OBJECT)",
"transpose-regions":"Transpose region STARTR1 to ENDR1 with STARTR2 to ENDR2.¶The regions should not be overlapping, because the size of the buffer is¶never changed in a transposition.¶¶Optional fifth arg LEAVE-MARKERS, if non-nil, means don’t update¶any markers that happen to be located in the regions.¶¶Transposing beyond buffer boundaries is an error.¶¶(fn STARTR1 ENDR1 STARTR2 ENDR2 &amp;optional LEAVE-MARKERS)",
"number-to-string":"Return the decimal representation of NUMBER as a string.¶Uses a minus sign if negative.¶NUMBER may be an integer or a floating point number.¶¶(fn NUMBER)",
"string-to-number":"Parse STRING as a decimal number and return the number.¶Ignore leading spaces and tabs, and all trailing chars.  Return 0 if¶STRING cannot be parsed as an integer or floating point number.¶¶If BASE, interpret STRING as a number in that base.  If BASE isn’t¶present, base 10 is used.  BASE must be between 2 and 16 (inclusive).¶If the base used is not 10, STRING is always parsed as an integer.¶¶(fn STRING &amp;optional BASE)",
"char-to-string":"Convert arg CHAR to a string containing that character.¶¶(fn CHAR)",
"string-to-char":"Return the first character in STRING.¶¶(fn STRING)",
"makunbound":"Make SYMBOL’s value be void.¶Return SYMBOL.¶¶(fn SYMBOL)",
"boundp":"Return t if SYMBOL’s value is not void.¶Note that if ‘lexical-binding’ is in effect, this refers to the¶global value outside of any lexical scope.¶¶(fn SYMBOL)",
"consp":"Return t if OBJECT is a cons cell.¶¶(fn OBJECT)",
"atom":"Return t if OBJECT is not a cons cell.  This includes nil.¶¶(fn OBJECT)",
"listp":"Return t if OBJECT is a list, that is, a cons cell or nil.¶Otherwise, return nil.¶¶(fn OBJECT)",
"nlistp":"Return t if OBJECT is not a list.  Lists include nil.¶¶(fn OBJECT)",
"null":"Return t if OBJECT is nil, and return nil otherwise.¶¶(fn OBJECT)",
"buffer-base-buffer":"Return the base buffer of indirect buffer BUFFER.¶If BUFFER is not indirect, return nil.¶BUFFER defaults to the current buffer.¶¶(fn &amp;optional BUFFER)",
"charsetp":"Return non-nil if and only if OBJECT is a charset.¶¶(fn OBJECT)",
"charset-priority-list":"Return the list of charsets ordered by priority.¶HIGHESTP non-nil means just return the highest priority one.¶¶(fn &amp;optional HIGHESTP)",
"set-charset-priority":"Assign higher priority to the charsets given as arguments.¶¶(fn &amp;rest charsets)",
"char-charset":"Return the charset of highest priority that contains CH.¶ASCII characters are an exception: for them, this function always¶returns ‘ascii’.¶If optional 2nd arg RESTRICTION is non-nil, it is a list of charsets¶from which to find the charset.  It may also be a coding system.  In¶that case, find the charset from what supported by that coding system.¶¶(fn CH &amp;optional RESTRICTION)",
"charset-plist":"Return the property list of CHARSET.¶¶(fn CHARSET)",
"put-charset-property":"Set CHARSETS’s PROPNAME property to value VALUE.¶It can be retrieved with ‘(get-charset-property CHARSET PROPNAME)’.",
"get-charset-property":"Return the value of CHARSET’s PROPNAME property.¶This is the last value stored with¶ (put-charset-property CHARSET PROPNAME VALUE).",
"decode-char":"Decode the pair of CHARSET and CODE-POINT into a character.¶Return nil if CODE-POINT is not valid in CHARSET.¶¶CODE-POINT may be a cons (HIGHER-16-BIT-VALUE . LOWER-16-BIT-VALUE).¶¶(fn CHARSET CODE-POINT &amp;optional RESTRICTION)",
"encode-char":"Encode the character CH into a code-point of CHARSET.¶Return nil if CHARSET doesn’t include CH.¶¶(fn CH CHARSET &amp;optional RESTRICTION)",
"map-charset-chars":"Call FUNCTION for all characters in CHARSET.¶FUNCTION is called with an argument RANGE and the optional 3rd¶argument ARG.¶¶RANGE is a cons (FROM .  TO), where FROM and TO indicate a range of¶characters contained in CHARSET.¶¶The optional 4th and 5th arguments FROM-CODE and TO-CODE specify the¶range of code points (in CHARSET) of target characters.¶¶(fn FUNCTION CHARSET &amp;optional ARG FROM-CODE TO-CODE)",
"x-list-fonts":"Return a list of the names of available fonts matching PATTERN.¶If optional arguments FACE and FRAME are specified, return only fonts¶the same size as FACE on FRAME.¶¶PATTERN should be a string containing a font name in the XLFD,¶Fontconfig, or GTK format.  A font name given in the XLFD format may¶contain wildcard characters:¶  the * character matches any substring, and¶  the ? character matches any single character.¶  PATTERN is case-insensitive.¶¶The return value is a list of strings, suitable as arguments to¶‘set-face-font’.¶¶Fonts Emacs can’t use may or may not be excluded¶even if they match PATTERN and FACE.¶The optional fourth argument MAXIMUM sets a limit on how many¶fonts to match.  The first MAXIMUM fonts are reported.¶The optional fifth argument WIDTH, if specified, is a number of columns¶occupied by a character of a font.  In that case, return only fonts¶the WIDTH times as wide as FACE on FRAME.¶¶(fn PATTERN &amp;optional FACE FRAME MAXIMUM WIDTH)",
"x-family-fonts":"Return a list of available fonts of family FAMILY on FRAME.¶If FAMILY is omitted or nil, list all families.¶Otherwise, FAMILY must be a string, possibly containing wildcards¶‘?’ and ‘*’.¶If FRAME is omitted or nil, use the selected frame.¶Each element of the result is a vector [FAMILY WIDTH POINT-SIZE WEIGHT¶SLANT FIXED-P FULL REGISTRY-AND-ENCODING].¶FAMILY is the font family name.  POINT-SIZE is the size of the¶font in 1/10 pt.  WIDTH, WEIGHT, and SLANT are symbols describing the¶width, weight and slant of the font.  These symbols are the same as for¶face attributes.  FIXED-P is non-nil if the font is fixed-pitch.¶FULL is the full name of the font, and REGISTRY-AND-ENCODING is a string¶giving the registry and encoding of the font.¶The result list is sorted according to the current setting of¶the face font sort order.¶¶(fn &amp;optional FAMILY FRAME)",
"momentary-string-display":"Momentarily display STRING in the buffer at POS.¶Display remains until next event is input.¶If POS is a marker, only its position is used; its buffer is ignored.¶Optional third arg EXIT-CHAR can be a character, event or event¶description list.  EXIT-CHAR defaults to SPC.  If the input is¶EXIT-CHAR it is swallowed; otherwise it is then available as¶input (as a command if nothing else).¶Display MESSAGE (optional fourth arg) in the echo area.¶If MESSAGE is nil, instructions to type EXIT-CHAR are displayed there.¶¶(fn STRING POS &amp;optional EXIT-CHAR MESSAGE)",
"frame-char-height":"Height in pixels of a line in the font in frame FRAME.¶If FRAME is omitted or nil, the selected frame is used.¶For a terminal frame, the value is always 1.¶¶(fn &amp;optional FRAME)",
"frame-char-width":"Width in pixels of characters in the font in frame FRAME.¶If FRAME is omitted or nil, the selected frame is used.¶On a graphical screen, the width is the standard width of the default font.¶For a terminal screen, the value is always 1.¶¶(fn &amp;optional FRAME)",
"abbrev-symbol":"Return the symbol representing abbrev named ABBREV.¶This symbol’s name is ABBREV, but it is not the canonical symbol of that name;¶it is interned in an abbrev-table rather than the normal obarray.¶The value is nil if that abbrev is not defined.¶Optional second arg TABLE is abbrev table to look it up in.¶The default is to try buffer’s mode-specific abbrev table, then global table.¶¶(fn ABBREV &amp;optional TABLE)",
"abbrev-expansion":"Return the string that ABBREV expands into in the current buffer.¶Optionally specify an abbrev table as second arg;¶then ABBREV is looked up in that table only.¶¶(fn ABBREV &amp;optional TABLE)",
"abbrev-insert":"Insert abbrev ABBREV at point.¶If non-nil, NAME is the name by which this abbrev was found.¶If non-nil, WORDSTART is the place where to insert the abbrev.¶If WORDEND is non-nil, the abbrev replaces the previous text between¶WORDSTART and WORDEND.¶Return ABBREV if the expansion should be considered as having taken place.¶The return value can be influenced by a ‘no-self-insert’ property;¶see ‘define-abbrev’ for details.¶¶(fn ABBREV &amp;optional NAME WORDSTART WORDEND)",
"setcdr":"Set the cdr of CELL to be NEWCDR.  Returns NEWCDR.¶¶(fn CELL NEWCDR)",
"fill-context-prefix":"Compute a fill prefix from the text between FROM and TO.¶This uses the variables ‘adaptive-fill-regexp’ and ‘adaptive-fill-function’¶and ‘adaptive-fill-first-line-regexp’.  ‘paragraph-start’ also plays a role;¶we reject a prefix based on a one-line paragraph if that prefix would¶act as a paragraph-separator.",
"position-bytes":"Return the byte position for character position POSITION.¶If POSITION is out of range, the value is nil.¶¶(fn POSITION)",
"byte-to-position":"Return the character position for byte position BYTEPOS.¶If BYTEPOS is out of range, the value is nil.¶¶(fn BYTEPOS)",
"bufferpos-to-filepos":"Try to return the file byte corresponding to a particular buffer POSITION.¶Value is the file position given as a (0-based) byte count.¶The function presumes the file is encoded with CODING-SYSTEM, which defaults¶to ‘buffer-file-coding-system’.¶QUALITY can be:¶  ‘approximate’, in which case we may cut some corners to avoid¶    excessive work.¶  ‘exact’, in which case we may end up re-(en/de)coding a large¶    part of the file/buffer.¶  nil, in which case we may return nil rather than an approximation.¶¶(fn POSITION &amp;optional QUALITY CODING-SYSTEM)",
"filepos-to-bufferpos":"Try to return the buffer position corresponding to a particular file position.¶The file position is given as a (0-based) BYTE count.¶The function presumes the file is encoded with CODING-SYSTEM, which defaults¶to ‘buffer-file-coding-system’.¶QUALITY can be:¶  ‘approximate’, in which case we may cut some corners to avoid¶    excessive work.¶  ‘exact’, in which case we may end up re-(en/de)coding a large¶    part of the file/buffer.¶  nil, in which case we may return nil rather than an approximation.¶¶(fn BYTE &amp;optional QUALITY CODING-SYSTEM)",
"multibyte-string-p":"Return t if OBJECT is a multibyte string.¶Return nil if OBJECT is either a unibyte string, or not a string.¶¶(fn OBJECT)",
"string-bytes":"Return the number of bytes in STRING.¶If STRING is multibyte, this may be greater than the length of STRING.¶¶(fn STRING)",
"unibyte-string":"Concatenate all the argument bytes and make the result a unibyte string.¶¶(fn &amp;rest BYTES)",
"split-window-sensibly":"Split WINDOW in a way suitable for ‘display-buffer’.¶WINDOW defaults to the currently selected window.¶If ‘split-height-threshold’ specifies an integer, WINDOW is at¶least ‘split-height-threshold’ lines tall and can be split¶vertically, split WINDOW into two windows one above the other and¶return the lower window.  Otherwise, if ‘split-width-threshold’¶specifies an integer, WINDOW is at least ‘split-width-threshold’¶columns wide and can be split horizontally, split WINDOW into two¶windows side by side and return the window on the right.  If this¶can’t be done either and WINDOW is the only window on its frame,¶try to split WINDOW vertically disregarding any value specified¶by ‘split-height-threshold’.  If that succeeds, return the lower¶window.  Return nil otherwise.¶¶By default ‘display-buffer’ routines call this function to split¶the largest or least recently used window.  To change the default¶customize the option ‘split-window-preferred-function’.¶¶You can enforce this function to not split WINDOW horizontally,¶by setting (or binding) the variable ‘split-width-threshold’ to¶nil.  If, in addition, you set ‘split-height-threshold’ to zero,¶chances increase that this function does split WINDOW vertically.¶¶In order to not split WINDOW vertically, set (or bind) the¶variable ‘split-height-threshold’ to nil.  Additionally, you can¶set ‘split-width-threshold’ to zero to make a horizontal split¶more likely to occur.¶¶Have a look at the function ‘window-splittable-p’ if you want to¶know how ‘split-window-sensibly’ determines whether WINDOW can be¶split.",
"same-window-p":"Return non-nil if a buffer named BUFFER-NAME would be shown in the &quot;same&quot; window.¶This function returns non-nil if ‘display-buffer’ or¶‘pop-to-buffer’ would show a buffer named BUFFER-NAME in the¶selected rather than (as usual) some other window.  See¶‘same-window-buffer-names’ and ‘same-window-regexps’.",
"get-text-property":"Return the value of POSITION’s property PROP, in OBJECT.¶OBJECT should be a buffer or a string; if omitted or nil, it defaults¶to the current buffer.¶If POSITION is at the end of OBJECT, the value is nil.¶¶(fn POSITION PROP &amp;optional OBJECT)",
"get-char-property":"Return the value of POSITION’s property PROP, in OBJECT.¶Both overlay properties and text properties are checked.¶OBJECT is optional and defaults to the current buffer.¶If POSITION is at the end of OBJECT, the value is nil.¶If OBJECT is a buffer, then overlay properties are considered as well as¶text properties.¶If OBJECT is a window, then that window’s buffer is used, but window-specific¶overlays are considered only if they are associated with OBJECT.¶¶(fn POSITION PROP &amp;optional OBJECT)",
"get-pos-property":"Return the value of POSITION’s property PROP, in OBJECT.¶Almost identical to ‘get-char-property’ except for the following difference:¶Whereas ‘get-char-property’ returns the property of the char at (i.e. right¶after) POSITION, this pays attention to properties’s stickiness and overlays’s¶advancement settings, in order to find the property of POSITION itself,¶i.e. the property that a char would inherit if it were inserted¶at POSITION.¶¶(fn POSITION PROP &amp;optional OBJECT)",
"get-char-property-and-overlay":"Like ‘get-char-property’, but with extra overlay information.¶The value is a cons cell.  Its car is the return value of ‘get-char-property’¶with the same arguments--that is, the value of POSITION’s property¶PROP in OBJECT.  Its cdr is the overlay in which the property was¶found, or nil, if it was found as a text property or not found at all.¶¶OBJECT is optional and defaults to the current buffer.  OBJECT may be¶a string, a buffer or a window.  For strings, the cdr of the return¶value is always nil, since strings do not have overlays.  If OBJECT is¶a window, then that window’s buffer is used, but window-specific¶overlays are considered only if they are associated with OBJECT.  If¶POSITION is at the end of OBJECT, both car and cdr are nil.¶¶(fn POSITION PROP &amp;optional OBJECT)",
"text-properties-at":"Return the list of properties of the character at POSITION in OBJECT.¶If the optional second argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶If POSITION is at the end of OBJECT, the value is nil.¶¶(fn POSITION &amp;optional OBJECT)",
"color-defined-p":"Return non-nil if COLOR is supported on frame FRAME.¶COLOR should be a string naming a color (e.g. &quot;white&quot;), or a¶string specifying a color’s RGB components (e.g. &quot;#ff12ec&quot;), or¶the symbol ‘unspecified’.¶¶This function returns nil if COLOR is the symbol ‘unspecified’,¶or one of the strings &quot;unspecified-fg&quot; or &quot;unspecified-bg&quot;.¶¶If FRAME is omitted or nil, use the selected frame.",
"defined-colors":"Return a list of colors supported for a particular frame.¶The argument FRAME specifies which frame to try.¶The value may be different for frames on different display types.¶If FRAME doesn’t support colors, the value is nil.¶If FRAME is nil, that stands for the selected frame.",
"color-supported-p":"Return non-nil if COLOR can be displayed on FRAME.¶BACKGROUND-P non-nil means COLOR is used as a background.¶Otherwise, this function tells whether it can be used as a foreground.¶If FRAME is nil or omitted, use the selected frame.¶COLOR must be a valid color name.¶¶(fn COLOR &amp;optional FRAME BACKGROUND-P)",
"color-gray-p":"Return non-nil if COLOR is a shade of gray (or white or black).¶FRAME specifies the frame and thus the display for interpreting COLOR.¶If FRAME is nil or omitted, use the selected frame.¶¶(fn COLOR &amp;optional FRAME)",
"color-values":"Return a description of the color named COLOR on frame FRAME.¶COLOR should be a string naming a color (e.g. &quot;white&quot;), or a¶string specifying a color’s RGB components (e.g. &quot;#ff12ec&quot;).¶¶Return a list of three integers, (RED GREEN BLUE), each between 0¶and either 65280 or 65535 (the maximum depends on the system).¶Use ‘color-name-to-rgb’ if you want RGB floating-point values¶normalized to 1.0.¶¶If FRAME is omitted or nil, use the selected frame.¶If FRAME cannot display COLOR, the value is nil.¶¶COLOR can also be the symbol ‘unspecified’ or one of the strings¶&quot;unspecified-fg&quot; or &quot;unspecified-bg&quot;, in which case the¶return value is nil.",
"scroll-bar-event-ratio":"Given a scroll bar event EVENT, return the scroll bar position as a ratio.¶The value is a cons cell (PORTION . WHOLE) containing two integers¶whose ratio gives the event’s vertical position in the scroll bar, with 0¶referring to the top and 1 to the bottom.",
"scroll-bar-scale":"Given a pair (NUM . DENOM) and WHOLE, return (/ (* NUM WHOLE) DENOM).¶This is handy for scaling a position on a scroll bar into real units,¶like buffer positions.  If SCROLL-BAR-POS is the (PORTION . WHOLE) pair¶from a scroll bar event, then (scroll-bar-scale SCROLL-BAR-POS¶(buffer-size)) is the position in the current buffer corresponding to¶that scroll bar position.",
"get-register":"Return contents of Emacs register named REGISTER, or nil if none.¶¶(fn REGISTER)",
"set-register":"Set contents of Emacs register named REGISTER to VALUE.  Returns VALUE.¶See the documentation of the variable ‘register-alist’ for possible VALUEs.¶¶(fn REGISTER VALUE)",
"register-read-with-preview":"Read and return a register name, possibly showing existing registers.¶Prompt with the string PROMPT.  If ‘register-alist’ and¶‘register-preview-delay’ are both non-nil, display a window¶listing existing registers after ‘register-preview-delay’ seconds.¶If ‘help-char’ (or a member of ‘help-event-list’) is pressed,¶display such a window regardless.¶¶(fn PROMPT)",
"button-start":"Return the position at which BUTTON starts.",
"button-end":"Return the position at which BUTTON ends.",
"button-get":"Get the property of button BUTTON named PROP.",
"button-put":"Set BUTTON’s PROP property to VAL.",
"button-activate":"Call BUTTON’s ‘action’ property.¶If USE-MOUSE-ACTION is non-nil, invoke the button’s ‘mouse-action’¶property instead of ‘action’; if the button has no ‘mouse-action’,¶the value of ‘action’ is used instead.¶¶The action can either be a marker or a function.  If it’s a¶marker then goto it.  Otherwise it it is a function then it is¶called with BUTTON as only argument.  BUTTON is either an¶overlay, a buffer position, or (for buttons in the mode-line or¶header-line) a string.",
"button-label":"Return BUTTON’s text label.",
"button-type":"Return BUTTON’s button-type.",
"button-has-type-p":"Return t if BUTTON has button-type TYPE, or one of TYPE’s subtypes.",
"button-at":"Return the button at position POS in the current buffer, or nil.¶If the button at POS is a text property button, the return value¶is a marker pointing to POS.",
"button-type-put":"Set the button-type TYPE’s PROP property to VAL.",
"button-type-get":"Get the property of button-type TYPE named PROP.",
"button-type-subtype-p":"Return t if button-type TYPE is a subtype of SUPERTYPE.",
"buffer-list":"Return a list of all existing live buffers.¶If the optional arg FRAME is a frame, we return the buffer list in the¶proper order for that frame: the buffers show in FRAME come first,¶followed by the rest of the buffers.¶¶(fn &amp;optional FRAME)",
"other-buffer":"Return most recently selected buffer other than BUFFER.¶Buffers not visible in windows are preferred to visible buffers, unless¶optional second argument VISIBLE-OK is non-nil.  Ignore the argument¶BUFFER unless it denotes a live buffer.  If the optional third argument¶FRAME specifies a live frame, then use that frame’s buffer list instead¶of the selected frame’s buffer list.¶¶The buffer is found by scanning the selected or specified frame’s buffer¶list first, followed by the list of all buffers.  If no other buffer¶exists, return the buffer ‘*scratch*’ (creating it if necessary).¶¶(fn &amp;optional BUFFER VISIBLE-OK FRAME)",
"last-buffer":"Return the last buffer in FRAME’s buffer list.¶If BUFFER is the last buffer, return the preceding buffer¶instead.  Buffers not visible in windows are preferred to visible¶buffers, unless optional argument VISIBLE-OK is non-nil.¶Optional third argument FRAME nil or omitted means use the¶selected frame’s buffer list.  If no such buffer exists, return¶the buffer ‘*scratch*’, creating it if necessary.",
"current-frame-configuration":"Return a list describing the positions and states of all frames.¶Its car is ‘frame-configuration’.¶Each element of the cdr is a list of the form (FRAME ALIST WINDOW-CONFIG),¶where¶  FRAME is a frame object,¶  ALIST is an association list specifying some of FRAME’s parameters, and¶  WINDOW-CONFIG is a window configuration object for FRAME.",
"set-frame-configuration":"Restore the frames to the state described by CONFIGURATION.¶Each frame listed in CONFIGURATION has its position, size, window¶configuration, and other parameters set as specified in CONFIGURATION.¶However, this function does not restore deleted frames.¶¶Ordinarily, this function deletes all existing frames not¶listed in CONFIGURATION.  But if optional second argument NODELETE¶is given and non-nil, the unwanted frames are iconified instead.¶¶(fn CONFIGURATION &amp;optional NODELETE)",
"funcall":"Call first argument as a function, passing remaining arguments to it.¶Return the value that function returns.¶Thus, (funcall 'cons 'x 'y) returns (x . y).¶¶(fn FUNCTION &amp;rest ARGUMENTS)",
"apply":"Call FUNCTION with our remaining args, using our last arg as list of args.¶Then return the value FUNCTION returns.¶Thus, (apply '+ 1 2 '(3 4)) returns 10.¶¶(fn FUNCTION &amp;rest ARGUMENTS)",
"apply-partially":"Return a function that is a partial application of FUN to ARGS.¶ARGS is a list of the first N arguments to pass to FUN.¶The result is a new function which does the same as FUN, except that¶the first N arguments are fixed at the values with which this function¶was called.¶¶(fn FUN &amp;rest ARGS)",
"identity":"Return the argument unchanged.¶¶(fn ARG)",
"ignore":"Do nothing and return nil.¶This function accepts any number of arguments, but ignores them.¶¶(fn &amp;rest IGNORE)",
"file-name-as-directory":"Return a string representing the file name FILE interpreted as a directory.¶This operation exists because a directory is also a file, but its name as¶a directory is different from its name as a file.¶The result can be used as the value of ‘default-directory’¶or passed as second argument to ‘expand-file-name’.¶For a Unix-syntax file name, just appends a slash.¶¶(fn FILE)",
"directory-name-p":"Return non-nil if NAME ends with a directory separator character.¶¶(fn NAME)",
"directory-file-name":"Returns the file name of the directory named DIRECTORY.¶This is the name of the file that holds the data for the directory DIRECTORY.¶This operation exists because a directory is also a file, but its name as¶a directory is different from its name as a file.¶In Unix-syntax, this function just removes the final slash.¶¶(fn DIRECTORY)",
"abbreviate-file-name":"Return a version of FILENAME shortened using ‘directory-abbrev-alist’.¶This also substitutes &quot;~&quot; for the user’s home directory (unless the¶home directory is a root directory) and removes automounter prefixes¶(see the variable ‘automount-dir-prefix’).¶¶(fn FILENAME)",
"delete-and-extract-region":"Delete the text between START and END and return it.¶¶(fn START END)",
"map-y-or-n-p":"Ask a series of boolean questions.¶Takes args PROMPTER ACTOR LIST, and optional args HELP and ACTION-ALIST.¶¶LIST is a list of objects, or a function of no arguments to return the next¶object or nil.¶¶If PROMPTER is a string, the prompt is (format PROMPTER OBJECT).  If not¶a string, PROMPTER is a function of one arg (an object from LIST), which¶returns a string to be used as the prompt for that object.  If the return¶value is not a string, it may be nil to ignore the object or non-nil to act¶on the object without asking the user.¶¶ACTOR is a function of one arg (an object from LIST),¶which gets called with each object that the user answers ‘yes’ for.¶¶If HELP is given, it is a list (OBJECT OBJECTS ACTION),¶where OBJECT is a string giving the singular noun for an elt of LIST;¶OBJECTS is the plural noun for elts of LIST, and ACTION is a transitive¶verb describing ACTOR.  The default is (&quot;object&quot; &quot;objects&quot; &quot;act on&quot;).¶¶At the prompts, the user may enter y, Y, or SPC to act on that object;¶n, N, or DEL to skip that object; ! to act on all following objects;¶ESC or q to exit (skip all following objects); . (period) to act on the¶current object and then exit; or C-h to get help.¶¶If ACTION-ALIST is given, it is an alist (KEY FUNCTION HELP) of extra keys¶that will be accepted.  KEY is a character; FUNCTION is a function of one¶arg (an object from LIST); HELP is a string.  When the user hits KEY,¶FUNCTION is called.  If it returns non-nil, the object is considered¶&quot;acted upon&quot;, and the next object from LIST is processed.  If it returns¶nil, the prompt is repeated for the same object.¶¶Final optional argument NO-CURSOR-IN-ECHO-AREA non-nil says not to set¶‘cursor-in-echo-area’ while prompting.¶¶This function uses ‘query-replace-map’ to define the standard responses,¶but not all of the responses which ‘query-replace’ understands¶are meaningful here.¶¶Returns the number of actions taken.¶¶(fn PROMPTER ACTOR LIST &amp;optional HELP ACTION-ALIST NO-CURSOR-IN-ECHO-AREA)",
"message":"Display a message at the bottom of the screen.¶The message also goes into the ‘*Messages*’ buffer, if ‘message-log-max’¶is non-nil.  (In keyboard macros, that’s all it does.)¶Return the message.¶¶In batch mode, the message is printed to the standard error stream,¶followed by a newline.¶¶The first argument is a format control string, and the rest are data¶to be formatted under control of the string.  See ‘format-message’ for¶details.¶¶Note: (message &quot;%s&quot; VALUE) displays the string VALUE without¶interpreting format characters like ‘%’, ‘`’, and ‘'’.¶¶If the first argument is nil or the empty string, the function clears¶any existing message; this lets the minibuffer contents show.  See¶also ‘current-message’.¶¶(fn FORMAT-STRING &amp;rest ARGS)",
"message-or-box":"Display a message in a dialog box or in the echo area.¶If this command was invoked with the mouse, use a dialog box if¶‘use-dialog-box’ is non-nil.¶Otherwise, use the echo area.¶The first argument is a format control string, and the rest are data¶to be formatted under control of the string.  See ‘format-message’ for¶details.¶¶If the first argument is nil or the empty string, clear any existing¶message; let the minibuffer contents show.¶¶(fn FORMAT-STRING &amp;rest ARGS)",
"message-box":"Display a message, in a dialog box if possible.¶If a dialog box is not available, use the echo area.¶The first argument is a format control string, and the rest are data¶to be formatted under control of the string.  See ‘format-message’ for¶details.¶¶If the first argument is nil or the empty string, clear any existing¶message; let the minibuffer contents show.¶¶(fn FORMAT-STRING &amp;rest ARGS)",
"display-message-or-buffer":"Display MESSAGE in the echo area if possible, otherwise in a pop-up buffer.¶MESSAGE may be either a string or a buffer.¶¶A pop-up buffer is displayed using ‘display-buffer’ if MESSAGE is too long¶for maximum height of the echo area, as defined by ‘max-mini-window-height’¶if ‘resize-mini-windows’ is non-nil.¶¶Returns either the string shown in the echo area, or when a pop-up¶buffer is used, the window used to display it.¶¶If MESSAGE is a string, then the optional argument BUFFER-NAME is the¶name of the buffer used to display it in the case where a pop-up buffer¶is used, defaulting to ‘*Message*’.  In the case where MESSAGE is a¶string and it is displayed in the echo area, it is not specified whether¶the contents are inserted into the buffer anyway.¶¶Optional arguments ACTION and FRAME are as for ‘display-buffer’,¶and are only used if a pop-up buffer is displayed.¶¶(fn MESSAGE &amp;optional BUFFER-NAME ACTION FRAME)",
"current-message":"Return the string currently displayed in the echo area, or nil if none.¶¶(fn)",
"ding":"Beep, or flash the screen.¶Also, unless an argument is given,¶terminate any keyboard macro currently executing.¶¶(fn &amp;optional ARG)",
"beep":"Beep, or flash the screen.¶Also, unless an argument is given,¶terminate any keyboard macro currently executing.¶¶(fn &amp;optional ARG)",
"x-popup-dialog":"Pop up a dialog box and return user’s selection.¶POSITION specifies which frame to use.¶This is normally a mouse button event or a window or frame.¶If POSITION is t, it means to use the frame the mouse is on.¶The dialog box appears in the middle of the specified frame.¶¶CONTENTS specifies the alternatives to display in the dialog box.¶It is a list of the form (DIALOG ITEM1 ITEM2...).¶Each ITEM is a cons cell (STRING . VALUE).¶The return value is VALUE from the chosen item.¶¶An ITEM may also be just a string--that makes a nonselectable item.¶An ITEM may also be nil--that means to put all preceding items¶on the left of the dialog box and all following items on the right.¶(By default, approximately half appear on each side.)¶¶If HEADER is non-nil, the frame title for the box is &quot;Information&quot;,¶otherwise it is &quot;Question&quot;.¶¶If the user gets rid of the dialog box without making a valid choice,¶for instance using the window manager, then this produces a quit and¶‘x-popup-dialog’ does not return.¶¶(fn POSITION CONTENTS &amp;optional HEADER)",
"network-interface-list":"Return an alist of all network interfaces and their network address.¶Each element is a cons, the car of which is a string containing the¶interface name, and the cdr is the network address in internal¶format; see the description of ADDRESS in ‘make-network-process’.¶¶If the information is not available, return nil.¶¶(fn)",
"network-interface-info":"Return information about network interface named IFNAME.¶The return value is a list (ADDR BCAST NETMASK HWADDR FLAGS),¶where ADDR is the layer 3 address, BCAST is the layer 3 broadcast address,¶NETMASK is the layer 3 network mask, HWADDR is the layer 2 address, and¶FLAGS is the current flags of the interface.¶¶Data that is unavailable is returned as nil.¶¶(fn IFNAME)",
"format-network-address":"Convert network ADDRESS from internal format to a string.¶A 4 or 5 element vector represents an IPv4 address (with port number).¶An 8 or 9 element vector represents an IPv6 address (with port number).¶If optional second argument OMIT-PORT is non-nil, don’t include a port¶number in the string, even when present in ADDRESS.¶Returns nil if format of ADDRESS is invalid.¶¶(fn ADDRESS &amp;optional OMIT-PORT)",
"floatp":"Return t if OBJECT is a floating point number.¶¶(fn OBJECT)",
"integerp":"Return t if OBJECT is an integer.¶¶(fn OBJECT)",
"numberp":"Return t if OBJECT is a number (floating point or integer).¶¶(fn OBJECT)",
"natnump":"Return t if OBJECT is a nonnegative integer.¶¶(fn OBJECT)",
"zerop":"Return t if NUMBER is zero.¶¶(fn NUMBER)",
"imagemagick-types":"Return a list of image types supported by ImageMagick.¶Each entry in this list is a symbol named after an ImageMagick format¶tag.  See the ImageMagick manual for a list of ImageMagick formats and¶their descriptions (http://www.imagemagick.org/script/formats.php).¶You can also try the shell command: ‘identify -list format’.¶¶Note that ImageMagick recognizes many file-types that Emacs does not¶recognize as images, such as C.  See ‘imagemagick-types-enable’¶and ‘imagemagick-types-inhibit’.¶¶(fn)",
"completion-table-dynamic":"Use function FUN as a dynamic completion table.¶FUN is called with one argument, the string for which completion is required,¶and it should return an alist containing all the intended possible completions.¶This alist may be a full list of possible completions so that FUN can ignore¶the value of its argument.¶If SWITCH-BUFFER is non-nil and completion is performed in the¶minibuffer, FUN will be called in the buffer from which the minibuffer¶was entered.¶¶The result of the ‘completion-table-dynamic’ form is a function¶that can be used as the COLLECTION argument to ‘try-completion’ and¶‘all-completions’.  See Info node ‘(elisp)Programmed Completion’.¶¶See also the related function ‘completion-table-with-cache’.¶¶(fn FUN &amp;optional SWITCH-BUFFER)",
"completion-table-with-cache":"Create dynamic completion table from function FUN, with cache.¶This is a wrapper for ‘completion-table-dynamic’ that saves the last¶argument-result pair from FUN, so that several lookups with the¶same argument (or with an argument that starts with the first one)¶only need to call FUN once.  This can be useful when FUN performs a¶relatively slow operation, such as calling an external process.¶¶When IGNORE-CASE is non-nil, FUN is expected to be case-insensitive.¶¶(fn FUN &amp;optional IGNORE-CASE)",
"mouse-position":"Return a list (FRAME X . Y) giving the current mouse frame and position.¶The position is given in canonical character cells, where (0, 0) is the¶upper-left corner of the frame, X is the horizontal offset, and Y is the¶vertical offset, measured in units of the frame’s default character size.¶If Emacs is running on a mouseless terminal or hasn’t been programmed¶to read the mouse position, it returns the selected frame for FRAME¶and nil for X and Y.¶If ‘mouse-position-function’ is non-nil, ‘mouse-position’ calls it,¶passing the normal return value to that function as an argument,¶and returns whatever that function returns.¶¶(fn)",
"set-mouse-position":"Move the mouse pointer to the center of character cell (X,Y) in FRAME.¶Coordinates are relative to the frame, not a window,¶so the coordinates of the top left character in the frame¶may be nonzero due to left-hand scroll bars or the menu bar.¶¶The position is given in canonical character cells, where (0, 0) is¶the upper-left corner of the frame, X is the horizontal offset, and¶Y is the vertical offset, measured in units of the frame’s default¶character size.¶¶This function is a no-op for an X frame that is not visible.¶If you have just created a frame, you must wait for it to become visible¶before calling this function on it, like this.¶  (while (not (frame-visible-p frame)) (sleep-for .5))¶¶(fn FRAME X Y)",
"mouse-pixel-position":"Return a list (FRAME X . Y) giving the current mouse frame and position.¶The position is given in pixel units, where (0, 0) is the¶upper-left corner of the frame, X is the horizontal offset, and Y is¶the vertical offset.¶If Emacs is running on a mouseless terminal or hasn’t been programmed¶to read the mouse position, it returns the selected frame for FRAME¶and nil for X and Y.¶¶(fn)",
"set-mouse-pixel-position":"Move the mouse pointer to pixel position (X,Y) in FRAME.¶The position is given in pixels, where (0, 0) is the upper-left corner¶of the frame, X is the horizontal offset, and Y is the vertical offset.¶¶Note, this is a no-op for an X frame that is not visible.¶If you have just created a frame, you must wait for it to become visible¶before calling this function on it, like this.¶  (while (not (frame-visible-p frame)) (sleep-for .5))¶¶(fn FRAME X Y)",
"mouse-absolute-pixel-position":"Return absolute position of mouse cursor in pixels.¶The position is returned as a cons cell (X . Y) of the¶coordinates of the mouse cursor position in pixels relative to a¶position (0, 0) of the selected frame’s terminal.",
"set-mouse-absolute-pixel-position":"Move mouse pointer to absolute pixel position (X, Y).¶The coordinates X and Y are interpreted in pixels relative to a¶position (0, 0) of the selected frame’s terminal.¶¶(fn X Y)",
"frame-pointer-visible-p":"Return t if the mouse pointer displayed on FRAME is visible.¶Otherwise it returns nil.  FRAME omitted or nil means the¶selected frame.  This is useful when ‘make-pointer-invisible’ is set.¶¶(fn &amp;optional FRAME)",
"tool-bar-add-item":"Add an item to the tool bar.¶ICON names the image, DEF is the key definition and KEY is a symbol¶for the fake function key in the menu keymap.  Remaining arguments¶PROPS are additional items to add to the menu item specification.  See¶Info node ‘(elisp)Tool Bar’.  Items are added from left to right.¶¶ICON is the base name of a file containing the image to use.  The¶function will first try to use low-color/ICON.xpm if ‘display-color-cells’¶is less or equal to 256, then ICON.xpm, then ICON.pbm, and finally¶ICON.xbm, using ‘find-image’.¶¶Use this function only to make bindings in the global value of ‘tool-bar-map’.¶To define items in any other map, use ‘tool-bar-local-item’.",
"tool-bar-add-item-from-menu":"Define tool bar binding for COMMAND in keymap MAP using the given ICON.¶This makes a binding for COMMAND in ‘tool-bar-map’, copying its¶binding from the menu bar in MAP (which defaults to ‘global-map’), but¶modifies the binding by adding an image specification for ICON.  It¶finds ICON just like ‘tool-bar-add-item’.  PROPS are additional¶properties to add to the binding.¶¶MAP must contain appropriate binding for ‘[menu-bar]’ which holds a keymap.¶¶Use this function only to make bindings in the global value of ‘tool-bar-map’.¶To define items in any other map, use ‘tool-bar-local-item-from-menu’.",
"tool-bar-local-item-from-menu":"Define local tool bar binding for COMMAND using the given ICON.¶This makes a binding for COMMAND in IN-MAP, copying its binding from¶the menu bar in FROM-MAP (which defaults to ‘global-map’), but¶modifies the binding by adding an image specification for ICON.  It¶finds ICON just like ‘tool-bar-add-item’.  PROPS are additional¶properties to add to the binding.¶¶FROM-MAP must contain appropriate binding for ‘[menu-bar]’ which¶holds a keymap.",
"send-string-to-terminal":"Send STRING to the terminal without alteration.¶Control characters in STRING will have terminal-dependent effects.¶¶Optional parameter TERMINAL specifies the tty terminal device to use.¶It may be a terminal object, a frame, or nil for the terminal used by¶the currently selected frame.  In batch mode, STRING is sent to stdout¶when TERMINAL is nil.¶¶(fn STRING &amp;optional TERMINAL)",
"insert-and-inherit":"Insert the arguments at point, inheriting properties from adjoining text.¶Point and after-insertion markers move forward to end up¶ after the inserted text.¶Any other markers at the point of insertion remain before the text.¶¶If the current buffer is multibyte, unibyte strings are converted¶to multibyte for insertion (see ‘unibyte-char-to-multibyte’).¶If the current buffer is unibyte, multibyte strings are converted¶to unibyte for insertion.¶¶(fn &amp;rest ARGS)",
"insert-before-markers-and-inherit":"Insert text at point, relocating markers and inheriting properties.¶Point and markers move forward to end up after the inserted text.¶¶If the current buffer is multibyte, unibyte strings are converted¶to multibyte for insertion (see ‘unibyte-char-to-multibyte’).¶If the current buffer is unibyte, multibyte strings are converted¶to unibyte for insertion.¶¶(fn &amp;rest ARGS)",
"completing-read":"Read a string in the minibuffer, with completion.¶PROMPT is a string to prompt with; normally it ends in a colon and a space.¶COLLECTION can be a list of strings, an alist, an obarray or a hash table.¶COLLECTION can also be a function to do the completion itself.¶PREDICATE limits completion to a subset of COLLECTION.¶See ‘try-completion’, ‘all-completions’, ‘test-completion’,¶and ‘completion-boundaries’, for more details on completion,¶COLLECTION, and PREDICATE.  See also Info nodes ‘(elisp)Basic Completion’¶for the details about completion, and ‘(elisp)Programmed Completion’ for¶expectations from COLLECTION when it’s a function.¶¶REQUIRE-MATCH can take the following values:¶- t means that the user is not allowed to exit unless¶  the input is (or completes to) an element of COLLECTION or is null.¶- nil means that the user can exit with any input.¶- ‘confirm’ means that the user can exit with any input, but she needs¶  to confirm her choice if the input is not an element of COLLECTION.¶- ‘confirm-after-completion’ means that the user can exit with any¶  input, but she needs to confirm her choice if she called¶  ‘minibuffer-complete’ right before ‘minibuffer-complete-and-exit’¶  and the input is not an element of COLLECTION.¶- anything else behaves like t except that typing RET does not exit if it¶  does non-null completion.¶¶If the input is null, ‘completing-read’ returns DEF, or the first element¶of the list of default values, or an empty string if DEF is nil,¶regardless of the value of REQUIRE-MATCH.¶¶If INITIAL-INPUT is non-nil, insert it in the minibuffer initially,¶  with point positioned at the end.¶  If it is (STRING . POSITION), the initial input is STRING, but point¶  is placed at _zero-indexed_ position POSITION in STRING.  (*Note*¶  that this is different from ‘read-from-minibuffer’ and related¶  functions, which use one-indexing for POSITION.)  This feature is¶  deprecated--it is best to pass nil for INITIAL-INPUT and supply the¶  default value DEF instead.  The user can yank the default value into¶  the minibuffer easily using M-n.¶¶HIST, if non-nil, specifies a history list and optionally the initial¶  position in the list.  It can be a symbol, which is the history list¶  variable to use, or it can be a cons cell (HISTVAR . HISTPOS).  In¶  that case, HISTVAR is the history list variable to use, and HISTPOS¶  is the initial position (the position in the list used by the¶  minibuffer history commands).  For consistency, you should also¶  specify that element of the history as the value of¶  INITIAL-INPUT.  (This is the only case in which you should use¶  INITIAL-INPUT instead of DEF.)  Positions are counted starting from¶  1 at the beginning of the list.  The variable ‘history-length’¶  controls the maximum length of a history list.¶¶DEF, if non-nil, is the default value or the list of default values.¶¶If INHERIT-INPUT-METHOD is non-nil, the minibuffer inherits¶  the current input method and the setting of ‘enable-multibyte-characters’.¶¶Completion ignores case if the ambient value of¶  ‘completion-ignore-case’ is non-nil.¶¶See also ‘completing-read-function’.¶¶(fn PROMPT COLLECTION &amp;optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)",
"minibuffer-prompt":"Return the prompt string of the currently-active minibuffer.¶If no minibuffer is active, return nil.¶¶(fn)",
"minibuffer-prompt-end":"Return the buffer position of the end of the minibuffer prompt.¶Return (point-min) if current buffer is not a minibuffer.¶¶(fn)",
"minibuffer-prompt-width":"Return the display width of the minibuffer prompt.¶Return 0 if current buffer is not a minibuffer.",
"minibuffer-contents":"Return the user input in a minibuffer as a string.¶If the current buffer is not a minibuffer, return its entire contents.¶¶(fn)",
"minibuffer-contents-no-properties":"Return the user input in a minibuffer as a string, without text-properties.¶If the current buffer is not a minibuffer, return its entire contents.¶¶(fn)",
"windowp":"Return t if OBJECT is a window and nil otherwise.¶¶(fn OBJECT)",
"window-live-p":"Return t if OBJECT is a live window and nil otherwise.¶A live window is a window that displays a buffer.¶Internal windows and deleted windows are not live.¶¶(fn OBJECT)",
"window-valid-p":"Return t if OBJECT is a valid window and nil otherwise.¶A valid window is either a window that displays a buffer or an internal¶window.  Windows that have been deleted are not valid.¶¶(fn OBJECT)",
"selected-window":"Return the selected window.¶The selected window is the window in which the standard cursor for¶selected windows appears and to which many commands apply.¶¶(fn)",
"selected-window-group":"Return the list of windows in the group containing the selected window.¶When a grouping mode (such as Follow Mode) is not active, the¶result is a list containing only the selected window.",
"window-resizable":"Return DELTA if WINDOW can be resized vertically by DELTA lines.¶WINDOW must be a valid window and defaults to the selected one.¶Optional argument HORIZONTAL non-nil means return DELTA if WINDOW¶can be resized horizontally by DELTA columns.  A return value of¶zero means that WINDOW is not resizable.¶¶DELTA positive means WINDOW shall be enlarged by DELTA lines or¶columns.  If WINDOW cannot be enlarged by DELTA lines or columns¶return the maximum value in the range 0..DELTA by which WINDOW¶can be enlarged.¶¶DELTA negative means WINDOW shall be shrunk by -DELTA lines or¶columns.  If WINDOW cannot be shrunk by -DELTA lines or columns,¶return the minimum value in the range DELTA..0 that can be used¶for shrinking WINDOW.¶¶Optional argument IGNORE, if non-nil, means to ignore restraints¶induced by fixed size windows or the values of the variables¶‘window-min-height’ and ‘window-min-width’.  The following values¶have special meanings: ‘safe’ means that in addition live windows¶are allowed to get as small as ‘window-safe-min-height’ lines and¶‘window-safe-min-width’ columns.  ‘preserved’ means to ignore¶only restrictions induced by ‘window-preserve-size’.  If IGNORE¶is a window, then ignore restrictions for that window only.¶¶Optional argument PIXELWISE non-nil means interpret DELTA as¶pixels.",
"window-resize":"Resize WINDOW vertically by DELTA lines.¶WINDOW can be an arbitrary window and defaults to the selected¶one.  An attempt to resize the root window of a frame will raise¶an error though.¶¶DELTA a positive number means WINDOW shall be enlarged by DELTA¶lines.  DELTA negative means WINDOW shall be shrunk by -DELTA¶lines.¶¶Optional argument HORIZONTAL non-nil means resize WINDOW¶horizontally by DELTA columns.  In this case a positive DELTA¶means enlarge WINDOW by DELTA columns.  DELTA negative means¶WINDOW shall be shrunk by -DELTA columns.¶¶Optional argument IGNORE, if non-nil, means to ignore restraints¶induced by fixed size windows or the values of the variables¶‘window-min-height’ and ‘window-min-width’.  The following values¶have special meanings: ‘safe’ means that in addition live windows¶are allowed to get as small as ‘window-safe-min-height’ lines and¶‘window-safe-min-width’ columns.  ‘preserved’ means to ignore¶only restrictions induced by ‘window-preserve-size’.  If IGNORE¶is a window, then ignore restrictions for that window only.¶¶Optional argument PIXELWISE non-nil means resize WINDOW by DELTA¶pixels.¶¶This function resizes other windows proportionally and never¶deletes any windows.  If you want to move only the low (right)¶edge of WINDOW consider using ‘adjust-window-trailing-edge’¶instead.",
"adjust-window-trailing-edge":"Move WINDOW’s bottom edge by DELTA lines.¶Optional argument HORIZONTAL non-nil means move WINDOW’s right¶edge by DELTA columns.  WINDOW must be a valid window and¶defaults to the selected one.¶¶Optional argument PIXELWISE non-nil means interpret DELTA as¶number of pixels.¶¶If DELTA is greater than zero, move the edge downwards or to the¶right.  If DELTA is less than zero, move the edge upwards or to¶the left.  If the edge can’t be moved by DELTA lines or columns,¶move it as far as possible in the desired direction.",
"frame-live-p":"Return non-nil if OBJECT is a frame which has not been deleted.¶Value is nil if OBJECT is not a live frame.  If object is a live¶frame, the return value indicates what sort of terminal device it is¶displayed on.  See the documentation of ‘framep’ for possible¶return values.¶¶(fn OBJECT)",
"window-frame":"Return the frame that window WINDOW is on.¶WINDOW must be a valid window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-list":"Return a list of windows on FRAME, starting with WINDOW.¶FRAME nil or omitted means use the selected frame.¶WINDOW nil or omitted means use the window selected within FRAME.¶MINIBUF t means include the minibuffer window, even if it isn’t active.¶MINIBUF nil or omitted means include the minibuffer window only¶if it’s active.¶MINIBUF neither nil nor t means never include the minibuffer window.¶¶(fn &amp;optional FRAME MINIBUF WINDOW)",
"frame-root-window":"Return the root window of FRAME-OR-WINDOW.¶If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.¶With a frame argument, return that frame’s root window.¶With a window argument, return the root window of that window’s frame.¶¶(fn &amp;optional FRAME-OR-WINDOW)",
"window-parent":"Return the parent window of window WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil for a window with no parent (e.g. a root window).¶¶(fn &amp;optional WINDOW)",
"window-top-child":"Return the topmost child window of window WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil if WINDOW is a live window (live windows have no children).¶Return nil if WINDOW is an internal window whose children form a¶horizontal combination.¶¶(fn &amp;optional WINDOW)",
"window-left-child":"Return the leftmost child window of window WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil if WINDOW is a live window (live windows have no children).¶Return nil if WINDOW is an internal window whose children form a¶vertical combination.¶¶(fn &amp;optional WINDOW)",
"window-child":"Return WINDOW’s first child window.¶WINDOW can be any window.",
"window-combined-p":"Return non-nil if WINDOW has siblings in a given direction.¶WINDOW must be a valid window and defaults to the selected one.¶¶HORIZONTAL determines a direction for the window combination.  If¶HORIZONTAL is omitted or nil, return non-nil if WINDOW is part of¶a vertical window combination.  If HORIZONTAL is non-nil, return¶non-nil if WINDOW is part of a horizontal window combination.",
"window-next-sibling":"Return the next sibling window of window WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil if WINDOW has no next sibling.¶¶(fn &amp;optional WINDOW)",
"window-prev-sibling":"Return the previous sibling window of window WINDOW.¶WINDOW must be a valid window and defaults to the selected one.¶Return nil if WINDOW has no previous sibling.¶¶(fn &amp;optional WINDOW)",
"frame-first-window":"Return the topmost, leftmost live window on FRAME-OR-WINDOW.¶If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.¶Else if FRAME-OR-WINDOW denotes a valid window, return the first window¶of that window’s frame.  If FRAME-OR-WINDOW denotes a live frame, return¶the first window of that frame.¶¶(fn &amp;optional FRAME-OR-WINDOW)",
"window-in-direction":"Return window in DIRECTION as seen from WINDOW.¶More precisely, return the nearest window in direction DIRECTION¶as seen from the position of ‘window-point’ in window WINDOW.¶DIRECTION must be one of ‘above’, ‘below’, ‘left’ or ‘right’.¶WINDOW must be a live window and defaults to the selected one.¶¶Do not return a window whose ‘no-other-window’ parameter is¶non-nil.  If the nearest window’s ‘no-other-window’ parameter is¶non-nil, try to find another window in the indicated direction.¶If, however, the optional argument IGNORE is non-nil, return that¶window even if its ‘no-other-window’ parameter is non-nil.¶¶Optional argument SIGN a negative number means to use the right¶or bottom edge of WINDOW as reference position instead of¶‘window-point’.  SIGN a positive number means to use the left or¶top edge of WINDOW as reference position.¶¶Optional argument WRAP non-nil means to wrap DIRECTION around¶frame borders.  This means to return for WINDOW at the top of the¶frame and DIRECTION ‘above’ the minibuffer window if the frame¶has one, and a window at the bottom of the frame otherwise.¶¶Optional argument MINI nil means to return the minibuffer window¶if and only if it is currently active.  MINI non-nil means to¶return the minibuffer window even when it’s not active.  However,¶if WRAP is non-nil, always act as if MINI were nil.¶¶Return nil if no suitable window can be found.",
"window-tree":"Return the window tree of frame FRAME.¶FRAME must be a live frame and defaults to the selected frame.¶The return value is a list of the form (ROOT MINI), where ROOT¶represents the window tree of the frame’s root window, and MINI¶is the frame’s minibuffer window.¶¶If the root window is not split, ROOT is the root window itself.¶Otherwise, ROOT is a list (DIR EDGES W1 W2 ...) where DIR is nil¶for a horizontal split, and t for a vertical split.  EDGES gives¶the combined size and position of the child windows in the split,¶and the rest of the elements are the child windows in the split.¶Each of the child windows may again be a window or a list¶representing a window split, and so on.  EDGES is a list (LEFT¶TOP RIGHT BOTTOM) as returned by ‘window-edges’.",
"tty-top-frame":"Return the topmost terminal frame on TERMINAL.¶TERMINAL can be a terminal object, a frame or nil (meaning the¶selected frame’s terminal).  This function returns nil if TERMINAL¶does not refer to a text terminal.  Otherwise, it returns the¶top-most frame on the text terminal.¶¶(fn &amp;optional TERMINAL)",
"font-family-list":"List available font families on the current frame.¶If FRAME is omitted or nil, the selected frame is used.¶¶(fn &amp;optional FRAME)",
"bitmap-spec-p":"Value is non-nil if OBJECT is a valid bitmap specification.¶A bitmap specification is either a string, a file name, or a list¶(WIDTH HEIGHT DATA) where WIDTH is the pixel width of the bitmap,¶HEIGHT is its height, and DATA is a string containing the bits of¶the pixmap.  Bits are stored row by row, each row occupies¶(WIDTH + 7)/8 bytes.¶¶(fn OBJECT)",
"region-beginning":"Return the integer value of point or mark, whichever is smaller.¶¶(fn)",
"region-end":"Return the integer value of point or mark, whichever is larger.¶¶(fn)",
"use-region-p":"Return t if the region is active and it is appropriate to act on it.¶This is used by commands that act specially on the region under¶Transient Mark mode.¶¶The return value is t if Transient Mark mode is enabled and the¶mark is active; furthermore, if ‘use-empty-active-region’ is nil,¶the region must not be empty.  Otherwise, the return value is nil.¶¶For some commands, it may be appropriate to ignore the value of¶‘use-empty-active-region’; in that case, use ‘region-active-p’.",
"default-value":"Return SYMBOL’s default value.¶This is the value that is seen in buffers that do not have their own values¶for this variable.  The default value is meaningful for variables with¶local bindings in certain buffers.¶¶(fn SYMBOL)",
"default-boundp":"Return t if SYMBOL has a non-void default value.¶This is the value that is seen in buffers that do not have their own values¶for this variable.¶¶(fn SYMBOL)",
"set-default":"Set SYMBOL’s default value to VALUE.  SYMBOL and VALUE are evaluated.¶The default value is seen in buffers that do not have their own values¶for this variable.¶¶(fn SYMBOL VALUE)",
"put-text-property":"Set one property of the text from START to END.¶The third and fourth arguments PROPERTY and VALUE¶specify the property to add.¶If the optional fifth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶¶(fn START END PROPERTY VALUE &amp;optional OBJECT)",
"add-text-properties":"Add properties to the text from START to END.¶The third argument PROPERTIES is a property list¶specifying the property values to add.  If the optional fourth argument¶OBJECT is a buffer (or nil, which means the current buffer),¶START and END are buffer positions (integers or markers).¶If OBJECT is a string, START and END are 0-based indices into it.¶Return t if any property value actually changed, nil otherwise.¶¶(fn START END PROPERTIES &amp;optional OBJECT)",
"remove-text-properties":"Remove some properties from text from START to END.¶The third argument PROPERTIES is a property list¶whose property names specify the properties to remove.¶(The values stored in PROPERTIES are ignored.)¶If the optional fourth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶Return t if any property was actually removed, nil otherwise.¶¶Use ‘set-text-properties’ if you want to remove all text properties.¶¶(fn START END PROPERTIES &amp;optional OBJECT)",
"remove-list-of-text-properties":"Remove some properties from text from START to END.¶The third argument LIST-OF-PROPERTIES is a list of property names to remove.¶If the optional fourth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶Return t if any property was actually removed, nil otherwise.¶¶(fn START END LIST-OF-PROPERTIES &amp;optional OBJECT)",
"set-text-properties":"Completely replace properties of text from START to END.¶The third argument PROPERTIES is the new property list.¶If the optional fourth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶If PROPERTIES is nil, the effect is to remove all properties from¶the designated part of OBJECT.¶¶(fn START END PROPERTIES &amp;optional OBJECT)",
"add-face-text-property":"Add the face property to the text from START to END.¶FACE specifies the face to add.  It should be a valid value of the¶‘face’ property (typically a face name or a plist of face attributes¶and values).¶¶If any text in the region already has a non-nil ‘face’ property, those¶face(s) are retained.  This is done by setting the ‘face’ property to¶a list of faces, with FACE as the first element (by default) and the¶pre-existing faces as the remaining elements.¶¶If optional fourth argument APPEND is non-nil, append FACE to the end¶of the face list instead.¶¶If optional fifth argument OBJECT is a buffer (or nil, which means the¶current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices¶into it.¶¶(fn START END FACE &amp;optional APPEND OBJECT)",
"propertize":"Return a copy of STRING with text properties added.¶First argument is the string to copy.¶Remaining arguments form a sequence of PROPERTY VALUE pairs for text¶properties to add to the result.¶¶(fn STRING &amp;rest PROPERTIES)",
"not":"Return t if OBJECT is nil, and return nil otherwise.¶¶(fn OBJECT)",
"error":"Signal an error, making a message by passing args to ‘format-message’.¶In Emacs, the convention is that error messages start with a capital¶letter but *do not* end with a period.  Please follow this convention¶for the sake of consistency.¶¶Note: (error &quot;%s&quot; VALUE) makes the message VALUE without¶interpreting format characters like ‘%’, ‘`’, and ‘'’.¶¶(fn &amp;rest ARGS)",
"signal":"Signal an error.  Args are ERROR-SYMBOL and associated DATA.¶This function does not return.¶¶An error symbol is a symbol with an ‘error-conditions’ property¶that is a list of condition names.¶A handler for any of those names will get to handle this signal.¶The symbol ‘error’ should normally be one of them.¶¶DATA should be a list.  Its elements are printed as part of the error message.¶See Info anchor ‘(elisp)Definition of signal’ for some details on how this¶error message is constructed.¶If the signal is handled, DATA is made available to the handler.¶See also the function ‘condition-case’.¶¶(fn ERROR-SYMBOL DATA)",
"user-error":"Signal a pilot error, making a message by passing args to ‘format-message’.¶In Emacs, the convention is that error messages start with a capital¶letter but *do not* end with a period.  Please follow this convention¶for the sake of consistency.¶This is just like ‘error’ except that ‘user-error’s are expected to be the¶result of an incorrect manipulation on the part of the user, rather than the¶result of an actual problem.¶¶Note: (user-error &quot;%s&quot; VALUE) makes the message VALUE without¶interpreting format characters like ‘%’, ‘`’, and ‘'’.¶¶(fn FORMAT &amp;rest ARGS)",
"set-marker":"Position MARKER before character number POSITION in BUFFER.¶If BUFFER is omitted or nil, it defaults to the current buffer.  If¶POSITION is nil, makes marker point nowhere so it no longer slows down¶editing in any buffer.  Returns MARKER.¶¶(fn MARKER POSITION &amp;optional BUFFER)",
"move-marker":"Position MARKER before character number POSITION in BUFFER.¶If BUFFER is omitted or nil, it defaults to the current buffer.  If¶POSITION is nil, makes marker point nowhere so it no longer slows down¶editing in any buffer.  Returns MARKER.¶¶(fn MARKER POSITION &amp;optional BUFFER)",
"frame-current-scroll-bars":"Return the current scroll-bar types for frame FRAME.¶Value is a cons (VERTICAL . HORIZ0NTAL) where VERTICAL specifies¶the current location of the vertical scroll-bars (‘left’, ‘right’¶or nil), and HORIZONTAL specifies the current location of the¶horizontal scroll bars (‘bottom’ or nil).  FRAME must specify a¶live frame and defaults to the selected one.¶¶(fn &amp;optional FRAME)",
"frame-scroll-bar-width":"Return scroll bar width of FRAME in pixels.¶¶(fn &amp;optional FRAME)",
"frame-scroll-bar-height":"Return scroll bar height of FRAME in pixels.¶¶(fn &amp;optional FRAME)",
"set-window-scroll-bars":"Set width and type of scroll bars of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Second parameter WIDTH specifies the pixel width for the vertical scroll¶bar.  If WIDTH is nil, use the scroll-bar width of WINDOW’s frame.¶Third parameter VERTICAL-TYPE specifies the type of the vertical scroll¶bar: left, right, or nil.  If VERTICAL-TYPE is t, this means use the¶frame’s scroll-bar type.¶¶Fourth parameter HEIGHT specifies the pixel height for the horizontal¶scroll bar.  If HEIGHT is nil, use the scroll-bar height of WINDOW’s¶frame.  Fifth parameter HORIZONTAL-TYPE specifies the type of the¶horizontal scroll bar: nil, bottom, or t.  If HORIZONTAL-TYPE is t, this¶means to use the frame’s horizontal scroll-bar type.¶¶Return t if scroll bars were actually changed and nil otherwise.¶¶(fn WINDOW &amp;optional WIDTH VERTICAL-TYPE HEIGHT HORIZONTAL-TYPE)",
"window-scroll-bars":"Get width and type of scroll bars of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Value is a list of the form (WIDTH COLUMNS VERTICAL-TYPE HEIGHT LINES¶HORIZONTAL-TYPE).  If WIDTH or HEIGHT is nil or VERTICAL-TYPE or¶HORIZONTAL-TYPE is t, the window is using the frame’s corresponding¶value.¶¶(fn &amp;optional WINDOW)",
"window-current-scroll-bars":"Return the current scroll bar types for WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶The return value is a cons cell (VERTICAL . HORIZONTAL) where¶VERTICAL specifies the current location of the vertical scroll¶bar (‘left’, ‘right’ or nil), and HORIZONTAL specifies the¶current location of the horizontal scroll bar (‘bottom’ or nil).¶¶Unlike ‘window-scroll-bars’, this function reports the scroll bar¶type actually used, once frame defaults and ‘scroll-bar-mode’ are¶taken into account.",
"window-scroll-bar-width":"Return the width in pixels of WINDOW’s vertical scrollbar.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-scroll-bar-height":"Return the height in pixels of WINDOW’s horizontal scrollbar.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-hscroll":"Return the number of columns by which WINDOW is scrolled from left margin.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"set-window-hscroll":"Set number of columns WINDOW is scrolled from left margin to NCOL.¶WINDOW must be a live window and defaults to the selected one.¶Clip the number to a reasonable value if out of range.¶Return the new number.  NCOL should be zero or positive.¶¶Note that if ‘automatic-hscrolling’ is non-nil, you cannot scroll the¶window so that the location of point moves off-window.¶¶(fn WINDOW NCOL)",
"create-image":"Create an image.¶FILE-OR-DATA is an image file name or image data.¶Optional TYPE is a symbol describing the image type.  If TYPE is omitted¶or nil, try to determine the image type from its first few bytes¶of image data.  If that doesn’t work, and FILE-OR-DATA is a file name,¶use its file extension as image type.¶Optional DATA-P non-nil means FILE-OR-DATA is a string containing image data.¶Optional PROPS are additional image attributes to assign to the image,¶like, e.g. ‘:mask MASK’.¶Value is the image created, or nil if images of type TYPE are not supported.¶¶Images should not be larger than specified by ‘max-image-size’.¶¶Image file names that are not absolute are searched for in the¶&quot;images&quot; sub-directory of ‘data-directory’ and¶‘x-bitmap-file-path’ (in that order).",
"find-image":"Find an image, choosing one of a list of image specifications.¶¶SPECS is a list of image specifications.¶¶Each image specification in SPECS is a property list.  The contents of¶a specification are image type dependent.  All specifications must at¶least contain the properties ‘:type TYPE’ and either ‘:file FILE’ or¶‘:data DATA’, where TYPE is a symbol specifying the image type,¶e.g. ‘xbm’, FILE is the file to load the image from, and DATA is a¶string containing the actual image data.  The specification whose TYPE¶is supported, and FILE exists, is used to construct the image¶specification to be returned.  Return nil if no specification is¶satisfied.¶¶The image is looked for in ‘image-load-path’.¶¶Image files should not be larger than specified by ‘max-image-size’.",
"image-load-path-for-library":"Return a suitable search path for images used by LIBRARY.¶¶It searches for IMAGE in ‘image-load-path’ (excluding¶&quot;‘data-directory’/images&quot;) and ‘load-path’, followed by a path¶suitable for LIBRARY, which includes &quot;../../etc/images&quot; and¶&quot;../etc/images&quot; relative to the library file itself, and then¶in &quot;‘data-directory’/images&quot;.¶¶Then this function returns a list of directories which contains¶first the directory in which IMAGE was found, followed by the¶value of ‘load-path’.  If PATH is given, it is used instead of¶‘load-path’.¶¶If NO-ERROR is non-nil and a suitable path can’t be found, don’t¶signal an error.  Instead, return a list of directories as before,¶except that nil appears in place of the image directory.¶¶Here is an example that uses a common idiom to provide¶compatibility with versions of Emacs that lack the variable¶‘image-load-path’:¶¶    ;; Shush compiler.¶    (defvar image-load-path)¶¶    (let* ((load-path (image-load-path-for-library &quot;mh-e&quot; &quot;mh-logo.xpm&quot;))¶           (image-load-path (cons (car load-path)¶                                  (when (boundp 'image-load-path)¶                                    image-load-path))))¶      (mh-tool-bar-folder-buttons-init))",
"make-byte-code":"Create a byte-code object with specified arguments as elements.¶The arguments should be the ARGLIST, bytecode-string BYTE-CODE, constant¶vector CONSTANTS, maximum stack size DEPTH, (optional) DOCSTRING,¶and (optional) INTERACTIVE-SPEC.¶The first four arguments are required; at most six have any¶significance.¶The ARGLIST can be either like the one of ‘lambda’, in which case the arguments¶will be dynamically bound before executing the byte code, or it can be an¶integer of the form NNNNNNNRMMMMMMM where the 7bit MMMMMMM specifies the¶minimum number of arguments, the 7-bit NNNNNNN specifies the maximum number¶of arguments (ignoring &amp;rest) and the R bit specifies whether there is a &amp;rest¶argument to catch the left-over arguments.  If such an integer is used, the¶arguments will not be dynamically bound but will be instead pushed on the¶stack before executing the byte-code.¶¶(fn ARGLIST BYTE-CODE CONSTANTS DEPTH &amp;optional DOCSTRING INTERACTIVE-SPEC &amp;rest ELEMENTS)",
"field-beginning":"Return the beginning of the field surrounding POS.¶A field is a region of text with the same ‘field’ property.¶If POS is nil, the value of point is used for POS.¶If ESCAPE-FROM-EDGE is non-nil and POS is at the beginning of its¶field, then the beginning of the *previous* field is returned.¶If LIMIT is non-nil, it is a buffer position; if the beginning of the field¶is before LIMIT, then LIMIT will be returned instead.¶¶(fn &amp;optional POS ESCAPE-FROM-EDGE LIMIT)",
"field-end":"Return the end of the field surrounding POS.¶A field is a region of text with the same ‘field’ property.¶If POS is nil, the value of point is used for POS.¶If ESCAPE-FROM-EDGE is non-nil and POS is at the end of its field,¶then the end of the *following* field is returned.¶If LIMIT is non-nil, it is a buffer position; if the end of the field¶is after LIMIT, then LIMIT will be returned instead.¶¶(fn &amp;optional POS ESCAPE-FROM-EDGE LIMIT)",
"field-string":"Return the contents of the field surrounding POS as a string.¶A field is a region of text with the same ‘field’ property.¶If POS is nil, the value of point is used for POS.¶¶(fn &amp;optional POS)",
"field-string-no-properties":"Return the contents of the field around POS, without text properties.¶A field is a region of text with the same ‘field’ property.¶If POS is nil, the value of point is used for POS.¶¶(fn &amp;optional POS)",
"delete-field":"Delete the field surrounding POS.¶A field is a region of text with the same ‘field’ property.¶If POS is nil, the value of point is used for POS.¶¶(fn &amp;optional POS)",
"constrain-to-field":"Return the position closest to NEW-POS that is in the same field as OLD-POS.¶A field is a region of text with the same ‘field’ property.¶¶If NEW-POS is nil, then use the current point instead, and move point¶to the resulting constrained position, in addition to returning that¶position.¶¶If OLD-POS is at the boundary of two fields, then the allowable¶positions for NEW-POS depends on the value of the optional argument¶ESCAPE-FROM-EDGE: If ESCAPE-FROM-EDGE is nil, then NEW-POS is¶constrained to the field that has the same ‘field’ char-property¶as any new characters inserted at OLD-POS, whereas if ESCAPE-FROM-EDGE¶is non-nil, NEW-POS is constrained to the union of the two adjacent¶fields.  Additionally, if two fields are separated by another field with¶the special value ‘boundary’, then any point within this special field is¶also considered to be ‘on the boundary’.¶¶If the optional argument ONLY-IN-LINE is non-nil and constraining¶NEW-POS would move it to a different line, NEW-POS is returned¶unconstrained.  This is useful for commands that move by line, like¶t or M-x beginning-of-line, which should generally respect field boundaries¶only in the case where they can still move to the right line.¶¶If the optional argument INHIBIT-CAPTURE-PROPERTY is non-nil, and OLD-POS has¶a non-nil property of that name, then any field boundaries are ignored.¶¶Field boundaries are not noticed if ‘inhibit-field-text-motion’ is non-nil.¶¶(fn NEW-POS OLD-POS &amp;optional ESCAPE-FROM-EDGE ONLY-IN-LINE INHIBIT-CAPTURE-PROPERTY)",
"insert-for-yank":"Call ‘insert-for-yank-1’ repetitively for each ‘yank-handler’ segment.¶¶See ‘insert-for-yank-1’ for more details.¶¶(fn STRING)",
"insert-buffer-substring-as-yank":"Insert before point a part of BUFFER, stripping some text properties.¶BUFFER may be a buffer or a buffer name.¶Arguments START and END are character positions specifying the substring.¶They default to the values of (point-min) and (point-max) in BUFFER.¶Before insertion, process text properties according to¶‘yank-handled-properties’ and ‘yank-excluded-properties’.¶¶(fn BUFFER &amp;optional START END)",
"get-internal-run-time":"Return the current run time used by Emacs.¶The time is returned as a list (HIGH LOW USEC PSEC), using the same¶style as (current-time).¶¶On systems that can’t determine the run time, ‘get-internal-run-time’¶does the same thing as ‘current-time’.¶¶(fn)",
"eq":"Return t if the two args are the same Lisp object.¶¶(fn OBJ1 OBJ2)",
"equal":"Return t if two Lisp objects have similar structure and contents.¶They must have the same data type.¶Conses are compared by comparing the cars and the cdrs.¶Vectors and strings are compared element by element.¶Numbers are compared by value, but integers cannot equal floats.¶ (Use ‘=’ if you want integers and floats to be able to be equal.)¶Symbols must match exactly.¶¶(fn O1 O2)",
"equal-including-properties":"Return t if two Lisp objects have similar structure and contents.¶This is like ‘equal’ except that it compares the text properties¶of strings.  (‘equal’ ignores text properties.)¶¶(fn O1 O2)",
"define-package":"Define a new package.¶NAME-STRING is the name of the package, as a string.¶VERSION-STRING is the version of the package, as a string.¶DOCSTRING is a short description of the package, a string.¶REQUIREMENTS is a list of dependencies on other packages.¶ Each requirement is of the form (OTHER-PACKAGE OTHER-VERSION),¶ where OTHER-VERSION is a string.¶¶EXTRA-PROPERTIES is currently unused.¶¶(fn NAME-STRING VERSION-STRING &amp;optional DOCSTRING REQUIREMENTS &amp;rest EXTRA-PROPERTIES)",
"print":"Output the printed representation of OBJECT, with newlines around it.¶Quoting characters are printed when needed to make output that ‘read’¶can handle, whenever this is possible.  For complex objects, the behavior¶is controlled by ‘print-level’ and ‘print-length’, which see.¶¶OBJECT is any of the Lisp data types: a number, a string, a symbol,¶a list, a buffer, a window, a frame, etc.¶¶A printed representation of an object is text which describes that object.¶¶Optional argument PRINTCHARFUN is the output stream, which can be one¶of these:¶¶   - a buffer, in which case output is inserted into that buffer at point;¶   - a marker, in which case output is inserted at marker’s position;¶   - a function, in which case that function is called once for each¶     character of OBJECT’s printed representation;¶   - a symbol, in which case that symbol’s function definition is called; or¶   - t, in which case the output is displayed in the echo area.¶¶If PRINTCHARFUN is omitted, the value of ‘standard-output’ (which see)¶is used instead.¶¶(fn OBJECT &amp;optional PRINTCHARFUN)",
"princ":"Output the printed representation of OBJECT, any Lisp object.¶No quoting characters are used; no delimiters are printed around¶the contents of strings.¶¶OBJECT is any of the Lisp data types: a number, a string, a symbol,¶a list, a buffer, a window, a frame, etc.¶¶A printed representation of an object is text which describes that object.¶¶Optional argument PRINTCHARFUN is the output stream, which can be one¶of these:¶¶   - a buffer, in which case output is inserted into that buffer at point;¶   - a marker, in which case output is inserted at marker’s position;¶   - a function, in which case that function is called once for each¶     character of OBJECT’s printed representation;¶   - a symbol, in which case that symbol’s function definition is called; or¶   - t, in which case the output is displayed in the echo area.¶¶If PRINTCHARFUN is omitted, the value of ‘standard-output’ (which see)¶is used instead.¶¶(fn OBJECT &amp;optional PRINTCHARFUN)",
"terpri":"Output a newline to stream PRINTCHARFUN.¶If ENSURE is non-nil only output a newline if not already at the¶beginning of a line.  Value is non-nil if a newline is printed.¶If PRINTCHARFUN is omitted or nil, the value of ‘standard-output’ is used.¶¶(fn &amp;optional PRINTCHARFUN ENSURE)",
"write-char":"Output character CHARACTER to stream PRINTCHARFUN.¶PRINTCHARFUN defaults to the value of ‘standard-output’ (which see).¶¶(fn CHARACTER &amp;optional PRINTCHARFUN)",
"pp":"Output the pretty-printed representation of OBJECT, any Lisp object.¶Quoting characters are printed as needed to make output that ‘read’¶can handle, whenever this is possible.¶Output stream is STREAM, or value of ‘standard-output’ (which see).",
"set-process-sentinel":"Give PROCESS the sentinel SENTINEL; nil for default.¶The sentinel is called as a function when the process changes state.¶It gets two arguments: the process, and a string describing the change.¶¶(fn PROCESS SENTINEL)",
"process-sentinel":"Return the sentinel of PROCESS.¶See ‘set-process-sentinel’ for more info on sentinels.¶¶(fn PROCESS)",
"waiting-for-user-input-p":"Return non-nil if Emacs is waiting for input from the user.¶This is intended for use by asynchronous process output filters and sentinels.¶¶(fn)",
"make-char-table":"Return a newly created char-table, with purpose PURPOSE.¶Each element is initialized to INIT, which defaults to nil.¶¶PURPOSE should be a symbol.  If it has a ‘char-table-extra-slots’¶property, the property’s value should be an integer between 0 and 10¶that specifies how many extra slots the char-table has.  Otherwise,¶the char-table has no extra slot.¶¶(fn PURPOSE &amp;optional INIT)",
"char-table-p":"Return t if OBJECT is a char-table.¶¶(fn OBJECT)",
"char-table-subtype":"Return the subtype of char-table CHAR-TABLE.  The value is a symbol.¶¶(fn CHAR-TABLE)",
"char-table-parent":"Return the parent char-table of CHAR-TABLE.¶The value is either nil or another char-table.¶If CHAR-TABLE holds nil for a given character,¶then the actual applicable value is inherited from the parent char-table¶(or from its parents, if necessary).¶¶(fn CHAR-TABLE)",
"set-char-table-parent":"Set the parent char-table of CHAR-TABLE to PARENT.¶Return PARENT.  PARENT must be either nil or another char-table.¶¶(fn CHAR-TABLE PARENT)",
"char-table-extra-slot":"Return the value of CHAR-TABLE’s extra-slot number N.¶¶(fn CHAR-TABLE N)",
"set-char-table-extra-slot":"Set CHAR-TABLE’s extra-slot number N to VALUE.¶¶(fn CHAR-TABLE N VALUE)",
"char-table-range":"Return the value in CHAR-TABLE for a range of characters RANGE.¶RANGE should be nil (for the default value),¶a cons of character codes (for characters in the range), or a character code.¶¶(fn CHAR-TABLE RANGE)",
"set-char-table-range":"Set the value in CHAR-TABLE for a range of characters RANGE to VALUE.¶RANGE should be t (for all characters), nil (for the default value),¶a cons of character codes (for characters in the range),¶or a character code.  Return VALUE.¶¶(fn CHAR-TABLE RANGE VALUE)",
"map-char-table":"Call FUNCTION for each character in CHAR-TABLE that has non-nil value.¶FUNCTION is called with two arguments, KEY and VALUE.¶KEY is a character code or a cons of character codes specifying a¶range of characters that have the same value.¶VALUE is what (char-table-range CHAR-TABLE KEY) returns.¶¶(fn FUNCTION CHAR-TABLE)",
"string-match":"Return index of start of first match for REGEXP in STRING, or nil.¶Matching ignores case if ‘case-fold-search’ is non-nil.¶If third arg START is non-nil, start search at that index in STRING.¶For index of first char beyond the match, do (match-end 0).¶‘match-end’ and ‘match-beginning’ also give indices of substrings¶matched by parenthesis constructs in the pattern.¶¶You can use the function ‘match-string’ to extract the substrings¶matched by the parenthesis constructions in REGEXP.¶¶(fn REGEXP STRING &amp;optional START)",
"string-match-p":"Same as ‘string-match’ except this function does not change the match data.¶¶(fn REGEXP STRING &amp;optional START)",
"looking-at":"Return t if text after point matches regular expression REGEXP.¶This function modifies the match data that ‘match-beginning’,¶‘match-end’ and ‘match-data’ access; save and restore the match¶data if you want to preserve them.¶¶(fn REGEXP)",
"looking-back":"Return non-nil if text before point matches regular expression REGEXP.¶Like ‘looking-at’ except matches before point, and is slower.¶LIMIT if non-nil speeds up the search by specifying a minimum¶starting position, to avoid checking matches that would start¶before LIMIT.¶¶If GREEDY is non-nil, extend the match backwards as far as¶possible, stopping when a single additional previous character¶cannot be part of a match for REGEXP.  When the match is¶extended, its starting position is allowed to occur before¶LIMIT.¶¶As a general recommendation, try to avoid using ‘looking-back’¶wherever possible, since it is slow.¶¶(fn REGEXP &amp;optional LIMIT GREEDY)",
"looking-at-p":"Same as ‘looking-at’ except this function does not change the match data.¶¶(fn REGEXP)",
"make-syntax-table":"Return a new syntax table.¶Create a syntax table which inherits from OLDTABLE (if non-nil) or¶from ‘standard-syntax-table’ otherwise.¶¶(fn &amp;optional OLDTABLE)",
"copy-syntax-table":"Construct a new syntax table and return it.¶It is a copy of the TABLE, which defaults to the standard syntax table.¶¶(fn &amp;optional TABLE)",
"char-syntax":"Return the syntax code of CHARACTER, described by a character.¶For example, if CHARACTER is a word constituent, the¶character ‘w’ (119) is returned.¶The characters that correspond to various syntax codes¶are listed in the documentation of ‘modify-syntax-entry’.¶¶(fn CHARACTER)",
"set-syntax-table":"Select a new syntax table for the current buffer.¶One argument, a syntax table.¶¶(fn TABLE)",
"syntax-table":"Return the current syntax table.¶This is the one specified by the current buffer.¶¶(fn)",
"face-remap-add-relative":"Add a face remapping entry of FACE to SPECS in the current buffer.¶Return a cookie which can be used to delete this remapping with¶‘face-remap-remove-relative’.¶¶The remaining arguments, SPECS, should form a list of faces.¶Each list element should be either a face name or a property list¶of face attribute/value pairs.  If more than one face is listed,¶that specifies an aggregate face, in the same way as in a ‘face’¶text property, except for possible priority changes noted below.¶¶The face remapping specified by SPECS takes effect alongside the¶remappings from other calls to ‘face-remap-add-relative’ for the¶same FACE, as well as the normal definition of FACE (at lowest¶priority).  This function tries to sort multiple remappings for¶the same face, so that remappings specifying relative face¶attributes are applied after remappings specifying absolute face¶attributes.¶¶The base (lowest priority) remapping may be set to something¶other than the normal definition of FACE via ‘face-remap-set-base’.¶¶(fn FACE &amp;rest SPECS)",
"face-remap-remove-relative":"Remove a face remapping previously added by ‘face-remap-add-relative’.¶COOKIE should be the return value from that function.¶¶(fn COOKIE)",
"face-remap-set-base":"Set the base remapping of FACE in the current buffer to SPECS.¶This causes the remappings specified by ‘face-remap-add-relative’¶to apply on top of the face specification given by SPECS.¶¶The remaining arguments, SPECS, should form a list of faces.¶Each list element should be either a face name or a property list¶of face attribute/value pairs, like in a ‘face’ text property.¶¶If SPECS is empty, call ‘face-remap-reset-base’ to use the normal¶definition of FACE as the base remapping; note that this is¶different from SPECS containing a single value nil, which means¶not to inherit from the global definition of FACE at all.¶¶(fn FACE &amp;rest SPECS)",
"face-remap-reset-base":"Set the base remapping of FACE to the normal definition of FACE.¶This causes the remappings specified by ‘face-remap-add-relative’¶to apply on top of the normal definition of FACE.¶¶(fn FACE)",
"keymap-parent":"Return the parent keymap of KEYMAP.¶If KEYMAP has no parent, return nil.¶¶(fn KEYMAP)",
"set-keymap-parent":"Modify KEYMAP to set its parent map to PARENT.¶Return PARENT.  PARENT should be nil or another keymap.¶¶(fn KEYMAP PARENT)",
"make-composed-keymap":"Construct a new keymap composed of MAPS and inheriting from PARENT.¶When looking up a key in the returned map, the key is looked in each¶keymap of MAPS in turn until a binding is found.¶If no binding is found in MAPS, the lookup continues in PARENT, if non-nil.¶As always with keymap inheritance, a nil binding in MAPS overrides¶any corresponding binding in PARENT, but it does not override corresponding¶bindings in other keymaps of MAPS.¶MAPS can be a list of keymaps or a single keymap.¶PARENT if non-nil should be a keymap.¶¶(fn MAPS &amp;optional PARENT)",
"define-key":"In KEYMAP, define key sequence KEY as DEF.¶KEYMAP is a keymap.¶¶KEY is a string or a vector of symbols and characters, representing a¶sequence of keystrokes and events.  Non-ASCII characters with codes¶above 127 (such as ISO Latin-1) can be represented by vectors.¶Two types of vector have special meanings:¶ [remap COMMAND] remaps any key binding for COMMAND.¶ [t] creates a default definition, which applies to any event with no¶    other definition in KEYMAP.¶¶DEF is anything that can be a key’s definition:¶ nil (means key is undefined in this keymap),¶ a command (a Lisp function suitable for interactive calling),¶ a string (treated as a keyboard macro),¶ a keymap (to define a prefix key),¶ a symbol (when the key is looked up, the symbol will stand for its¶    function definition, which should at that time be one of the above,¶    or another symbol whose function definition is used, etc.),¶ a cons (STRING . DEFN), meaning that DEFN is the definition¶    (DEFN should be a valid definition in its own right),¶ or a cons (MAP . CHAR), meaning use definition of CHAR in keymap MAP,¶ or an extended menu item definition.¶ (See info node ‘(elisp)Extended Menu Items’.)¶¶If KEYMAP is a sparse keymap with a binding for KEY, the existing¶binding is altered.  If there is no binding for KEY, the new pair¶binding KEY to DEF is added at the front of KEYMAP.¶¶(fn KEYMAP KEY DEF)",
"substitute-key-definition":"Replace OLDDEF with NEWDEF for any keys in KEYMAP now defined as OLDDEF.¶In other words, OLDDEF is replaced with NEWDEF where ever it appears.¶Alternatively, if optional fourth argument OLDMAP is specified, we redefine¶in KEYMAP as NEWDEF those keys which are defined as OLDDEF in OLDMAP.¶¶If you don’t specify OLDMAP, you can usually get the same results¶in a cleaner way with command remapping, like this:¶  (define-key KEYMAP [remap OLDDEF] NEWDEF)¶¶(fn OLDDEF NEWDEF KEYMAP &amp;optional OLDMAP)",
"suppress-keymap":"Make MAP override all normally self-inserting keys to be undefined.¶Normally, as an exception, digits and minus-sign are set to make prefix args,¶but optional second arg NODIGITS non-nil treats them like other chars.¶¶(fn MAP &amp;optional NODIGITS)",
"plist-get":"Extract a value from a property list.¶PLIST is a property list, which is a list of the form¶(PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value¶corresponding to the given PROP, or nil if PROP is not one of the¶properties on the list.  This function never signals an error.¶¶(fn PLIST PROP)",
"plist-put":"Change value in PLIST of PROP to VAL.¶PLIST is a property list, which is a list of the form¶(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol and VAL is any object.¶If PROP is already a property on the list, its value is set to VAL,¶otherwise the new PROP VAL pair is added.  The new plist is returned;¶use ‘(setq x (plist-put x prop val))’ to be sure to use the new value.¶The PLIST is modified by side effects.¶¶(fn PLIST PROP VAL)",
"lax-plist-get":"Extract a value from a property list, comparing with ‘equal’.¶PLIST is a property list, which is a list of the form¶(PROP1 VALUE1 PROP2 VALUE2...).  This function returns the value¶corresponding to the given PROP, or nil if PROP is not¶one of the properties on the list.¶¶(fn PLIST PROP)",
"lax-plist-put":"Change value in PLIST of PROP to VAL, comparing with ‘equal’.¶PLIST is a property list, which is a list of the form¶(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP and VAL are any objects.¶If PROP is already a property on the list, its value is set to VAL,¶otherwise the new PROP VAL pair is added.  The new plist is returned;¶use ‘(setq x (lax-plist-put x prop val))’ to be sure to use the new value.¶The PLIST is modified by side effects.¶¶(fn PLIST PROP VAL)",
"plist-member":"Return non-nil if PLIST has the property PROP.¶PLIST is a property list, which is a list of the form¶(PROP1 VALUE1 PROP2 VALUE2 ...).  PROP is a symbol.¶Unlike ‘plist-get’, this allows you to distinguish between a missing¶property and a property with the value nil.¶The value is actually the tail of PLIST whose car is PROP.¶¶(fn PLIST PROP)",
"libxml-parse-html-region":"Parse the region as an HTML document and return the parse tree.¶If BASE-URL is non-nil, it is used to expand relative URLs.¶If DISCARD-COMMENTS is non-nil, all HTML comments are discarded.¶¶(fn START END &amp;optional BASE-URL DISCARD-COMMENTS)",
"shr-insert-document":"Render the parsed document DOM into the current buffer.¶DOM should be a parse tree as generated by¶‘libxml-parse-html-region’ or similar.",
"libxml-parse-xml-region":"Parse the region as an XML document and return the parse tree.¶If BASE-URL is non-nil, it is used to expand relative URLs.¶If DISCARD-COMMENTS is non-nil, all HTML comments are discarded.¶¶(fn START END &amp;optional BASE-URL DISCARD-COMMENTS)",
"recenter-window-group":"Center point in the group of windows containing the selected window¶and maybe redisplay frame.  When a grouping mode (such as Follow Mode)¶is not active, this function is identical to ‘recenter’.¶¶With a numeric prefix argument ARG, recenter putting point on screen line ARG¶relative to the first window in the selected window group.  If ARG is¶negative, it counts up from the bottom of the last window in the¶group.  (ARG should be less than the total height of the window group.)¶¶If ARG is omitted or nil, then recenter with point on the middle line of¶the selected window group; if the variable ‘recenter-redisplay’ is¶non-nil, also erase the entire frame and redraw it (when¶‘auto-resize-tool-bars’ is set to ‘grow-only’, this resets the¶tool-bar’s height to the minimum height needed); if¶‘recenter-redisplay’ has the special value ‘tty’, then only tty frames¶are redrawn.¶¶Just C-u as prefix means put point in the center of the window¶and redisplay normally--don’t erase and redraw the frame.",
"called-interactively-p":"Return t if the containing function was called by ‘call-interactively’.¶If KIND is ‘interactive’, then only return t if the call was made¶interactively by the user, i.e. not in ‘noninteractive’ mode nor¶when ‘executing-kbd-macro’.¶If KIND is ‘any’, on the other hand, it will return t for any kind of¶interactive call, including being called as the binding of a key or¶from a keyboard macro, even in ‘noninteractive’ mode.¶¶This function is very brittle, it may fail to return the intended result when¶the code is debugged, advised, or instrumented in some form.  Some macros and¶special forms (such as ‘condition-case’) may also sometimes wrap their bodies¶in a ‘lambda’, so any call to ‘called-interactively-p’ from those bodies will¶indicate whether that lambda (rather than the surrounding function) was called¶interactively.¶¶Instead of using this function, it is cleaner and more reliable to give your¶function an extra optional argument whose ‘interactive’ spec specifies¶non-nil unconditionally (&quot;p&quot; is a good way to do this), or via¶(not (or executing-kbd-macro noninteractive)).¶¶The only known proper use of ‘interactive’ for KIND is in deciding¶whether to display a helpful message, or how to display it.  If you’re¶thinking of using it for any other purpose, it is quite likely that¶you’re making a mistake.  Think: what do you want to do when the¶command is called from a keyboard macro?¶¶(fn &amp;optional KIND)",
"keywordp":"Return t if OBJECT is a keyword.¶This means that it is a symbol with a print name beginning with ‘:’¶interned in the initial obarray.¶¶(fn OBJECT)",
"compare-buffer-substrings":"Compare two substrings of two buffers; return result as number.¶Return -N if first string is less after N-1 chars, +N if first string is¶greater after N-1 chars, or 0 if strings match.¶The first substring is in BUFFER1 from START1 to END1 and the second¶is in BUFFER2 from START2 to END2.¶The value of ‘case-fold-search’ in the current buffer¶determines whether case is significant or ignored.¶¶(fn BUFFER1 START1 END1 BUFFER2 START2 END2)",
"sequencep":"Return t if OBJECT is a sequence (list or array).¶¶(fn OBJECT)",
"length":"Return the length of vector, list or string SEQUENCE.¶A byte-code function object is also allowed.¶If the string contains multibyte characters, this is not necessarily¶the number of bytes in the string; it is the number of characters.¶To get the number of bytes, use ‘string-bytes’.¶¶(fn SEQUENCE)",
"elt":"Return element of SEQUENCE at index N.¶¶(fn SEQUENCE N)",
"copy-sequence":"Return a copy of a list, vector, string or char-table.¶The elements of a list or vector are not copied; they are shared¶with the original.¶¶(fn ARG)",
"reverse":"Return the reversed copy of list, vector, or string SEQ.¶See also the function ‘nreverse’, which is used more often.¶¶(fn SEQ)",
"nreverse":"Reverse order of items in a list, vector or string SEQ.¶If SEQ is a list, it should be nil-terminated.¶This function may destructively modify SEQ to produce the value.¶¶(fn SEQ)",
"sort":"Sort SEQ, stably, comparing elements using PREDICATE.¶Returns the sorted sequence.  SEQ should be a list or vector.  SEQ is¶modified by side effects.  PREDICATE is called with two elements of¶SEQ, and should return non-nil if the first element should sort before¶the second.¶¶(fn SEQ PREDICATE)",
"seq-elt":"Return Nth element of SEQUENCE.¶¶(fn SEQUENCE N)",
"seq-length":"Return the number of elements of SEQUENCE.¶¶(fn SEQUENCE)",
"seqp":"Return non-nil if SEQUENCE is a sequence, nil otherwise.¶¶(fn SEQUENCE)",
"seq-drop":"Remove the first N elements of SEQUENCE and return the result.¶The result is a sequence of the same type as SEQUENCE.¶¶If N is a negative integer or zero, SEQUENCE is returned.¶¶(fn SEQUENCE N)",
"seq-take":"Take the first N elements of SEQUENCE and return the result.¶The result is a sequence of the same type as SEQUENCE.¶¶If N is a negative integer or zero, an empty sequence is¶returned.¶¶(fn SEQUENCE N)",
"seq-take-while":"Take the successive elements of SEQUENCE for which PRED returns non-nil.¶PRED is a function of one argument.  The result is a sequence of¶the same type as SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-drop-while":"Remove the successive elements of SEQUENCE for which PRED returns non-nil.¶PRED is a function of one argument.  The result is a sequence of¶the same type as SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-do":"Apply FUNCTION to each element of SEQUENCE, presumably for side effects.¶Return SEQUENCE.¶¶(fn FUNCTION SEQUENCE)",
"seq-map":"Return the result of applying FUNCTION to each element of SEQUENCE.¶¶(fn FUNCTION SEQUENCE)",
"seq-mapn":"Like ‘seq-map’ but FUNCTION is mapped over all SEQUENCES.¶The arity of FUNCTION must match the number of SEQUENCES, and the¶mapping stops on the shortest sequence.¶Return a list of the results.¶¶(fn FUNCTION SEQUENCES...)",
"seq-filter":"Return a list of all the elements for which (PRED element) is non-nil in SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-remove":"Return a list of all the elements for which (PRED element) is nil in SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-reduce":"Reduce the function FUNCTION across SEQUENCE, starting with INITIAL-VALUE.¶¶Return the result of calling FUNCTION with INITIAL-VALUE and the¶first element of SEQUENCE, then calling FUNCTION with that result and¶the second element of SEQUENCE, then with that result and the third¶element of SEQUENCE, etc.¶¶If SEQUENCE is empty, return INITIAL-VALUE and FUNCTION is not called.¶¶(fn FUNCTION SEQUENCE INITIAL-VALUE)",
"seq-some":"Return the first value for which if (PRED element) is non-nil for in SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-find":"Return the first element for which (PRED element) is non-nil in SEQUENCE.¶If no element is found, return DEFAULT.¶¶Note that ‘seq-find’ has an ambiguity if the found element is¶identical to DEFAULT, as it cannot be known if an element was¶found or not.¶¶(fn PRED SEQUENCE &amp;optional DEFAULT)",
"seq-every-p":"Return non-nil if (PRED element) is non-nil for all elements of SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-empty-p":"Return non-nil if the SEQUENCE is empty, nil otherwise.¶¶(fn SEQUENCE)",
"seq-count":"Return the number of elements for which (PRED element) is non-nil in SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-sort":"Sort SEQUENCE using PRED as comparison function.¶The result is a sequence of the same type as SEQUENCE.¶¶(fn PRED SEQUENCE)",
"seq-contains":"Return the first element in SEQUENCE that is equal to ELT.¶Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.¶¶(fn SEQUENCE ELT &amp;optional TESTFN)",
"seq-position":"Return the index of the first element in SEQUENCE that is equal to ELT.¶Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.¶¶(fn SEQUENCE ELT &amp;optional TESTFN)",
"seq-uniq":"Return a list of the elements of SEQUENCE with duplicates removed.¶TESTFN is used to compare elements, or ‘equal’ if TESTFN is nil.¶¶(fn SEQUENCE &amp;optional TESTFN)",
"seq-subseq":"Return the sequence of elements of SEQUENCE from START to END.¶END is exclusive.¶¶If END is omitted, it defaults to the length of the sequence.  If¶START or END is negative, it counts from the end.  Signal an¶error if START or END are outside of the sequence (i.e too large¶if positive or too small if negative).¶¶(fn SEQUENCE START &amp;optional END)",
"seq-concatenate":"Concatenate SEQUENCES into a single sequence of type TYPE.¶TYPE must be one of following symbols: vector, string or list.¶¶¶(fn TYPE SEQUENCE...)",
"seq-mapcat":"Concatenate the result of applying FUNCTION to each element of SEQUENCE.¶The result is a sequence of type TYPE, or a list if TYPE is nil.¶¶(fn FUNCTION SEQUENCE &amp;optional TYPE)",
"seq-partition":"Return a list of the elements of SEQUENCE grouped into sub-sequences of length N.¶The last sequence may contain less than N elements.  If N is a¶negative integer or 0, nil is returned.¶¶(fn SEQUENCE N)",
"seq-intersection":"Return a list of the elements that appear in both SEQUENCE1 and SEQUENCE2.¶Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.¶¶(fn SEQUENCE1 SEQUENCE2 &amp;optional TESTFN)",
"seq-difference":"Return a list of the elements that appear in SEQUENCE1 but not in SEQUENCE2.¶Equality is defined by TESTFN if non-nil or by ‘equal’ if nil.¶¶(fn SEQUENCE1 SEQUENCE2 &amp;optional TESTFN)",
"seq-group-by":"Apply FUNCTION to each element of SEQUENCE.¶Separate the elements of SEQUENCE into an alist using the results as¶keys.  Keys are compared using ‘equal’.¶¶(fn FUNCTION SEQUENCE)",
"seq-into":"Concatenate the elements of SEQUENCE into a sequence of type TYPE.¶TYPE can be one of the following symbols: vector, string or¶list.¶¶(fn SEQUENCE TYPE)",
"seq-min":"Return the smallest element of SEQUENCE.¶SEQUENCE must be a sequence of numbers or markers.¶¶(fn SEQUENCE)",
"seq-max":"Return the largest element of SEQUENCE.¶SEQUENCE must be a sequence of numbers or markers.¶¶(fn SEQUENCE)",
"stringp":"Return t if OBJECT is a string.¶¶(fn OBJECT)",
"string-or-null-p":"Return t if OBJECT is a string or nil.¶Otherwise, return nil.¶¶(fn OBJECT)",
"char-or-string-p":"Return t if OBJECT is a character or a string.¶¶(fn OBJECT)",
"ewoc-create":"Create an empty ewoc.¶¶The ewoc will be inserted in the current buffer at the current position.¶¶PRETTY-PRINTER should be a function that takes one argument, an¶element, and inserts a string representing it in the buffer (at¶point).  The string PRETTY-PRINTER inserts may be empty or span¶several lines.  The PRETTY-PRINTER should use ‘insert’, and not¶‘insert-before-markers’.¶¶Optional second and third arguments HEADER and FOOTER are strings,¶possibly empty, that will always be present at the top and bottom,¶respectively, of the ewoc.¶¶Normally, a newline is automatically inserted after the header,¶the footer and every node’s printed representation.  Optional¶fourth arg NOSEP non-nil inhibits this.¶¶(fn PRETTY-PRINTER &amp;optional HEADER FOOTER NOSEP)",
"indirect-function":"Return the function at the end of OBJECT’s function chain.¶If OBJECT is not a symbol, just return it.  Otherwise, follow all¶function indirections to find the final function binding and return it.¶Signal a cyclic-function-indirection error if there is a loop in the¶function chain of symbols.¶¶(fn OBJECT &amp;optional NOERROR)",
"set-network-process-option":"For network process PROCESS set option OPTION to value VALUE.¶See ‘make-network-process’ for a list of options and values.¶If optional fourth arg NO-ERROR is non-nil, don’t signal an error if¶OPTION is not a supported option, return nil instead; otherwise return t.¶¶(fn PROCESS OPTION VALUE &amp;optional NO-ERROR)",
"face-spec-set":"Set the face spec SPEC for FACE.¶See ‘defface’ for the format of SPEC.¶¶The appearance of each face is controlled by its specs (set via¶this function), and by the internal frame-specific face¶attributes (set via ‘set-face-attribute’).¶¶This function also defines FACE as a valid face name if it is not¶already one, and (re)calculates its attributes on existing¶frames.¶¶The argument SPEC-TYPE determines which spec to set:¶  nil or ‘face-override-spec’ means the override spec (which is¶    usually what you want if calling this function outside of¶    Custom code);¶  ‘customized-face’ or ‘saved-face’ means the customized spec or¶    the saved custom spec;¶  ‘face-defface-spec’ means the default spec¶    (usually set only via ‘defface’);¶  ‘reset’ means to ignore SPEC, but clear the ‘customized-face’¶    and ‘face-override-spec’ specs;¶Any other value means not to set any spec, but to run the¶function for its other effects.",
"substitute-command-keys":"Substitute key descriptions for command names in STRING.¶Each substring of the form ⧷[COMMAND] is replaced by either a¶keystroke sequence that invokes COMMAND, or &quot;M-x COMMAND&quot; if COMMAND¶is not on any keys.¶¶Each substring of the form ⧷{MAPVAR} is replaced by a summary of¶the value of MAPVAR as a keymap.  This summary is similar to the one¶produced by ‘describe-bindings’.  The summary ends in two newlines¶(used by the helper function ‘help-make-xrefs’ to find the end of the¶summary).¶¶Each substring of the form ⧷&lt;MAPVAR&gt; specifies the use of MAPVAR¶as the keymap for future ⧷[COMMAND] substrings.¶¶Each ‘ and ` is replaced by left quote, and each ’ and '¶is replaced by right quote.  Left and right quote characters are¶specified by ‘text-quoting-style’.¶¶⧷= quotes the following character and is discarded; thus,¶⧷=⧷= puts ⧷= into the output, ⧷=⧷[ puts ⧷[ into the output, and¶⧷=` puts ` into the output.¶¶Return the original STRING if no substitutions are made.¶Otherwise, return a new string.¶¶(fn STRING)",
"make-progress-reporter":"Return progress reporter object for use with ‘progress-reporter-update’.¶¶MESSAGE is shown in the echo area, with a status indicator¶appended to the end.  When you call ‘progress-reporter-done’, the¶word &quot;done&quot; is printed after the MESSAGE.  You can change the¶MESSAGE of an existing progress reporter by calling¶‘progress-reporter-force-update’.¶¶MIN-VALUE and MAX-VALUE, if non-nil, are starting (0% complete)¶and final (100% complete) states of operation; the latter should¶be larger.  In this case, the status message shows the percentage¶progress.¶¶If MIN-VALUE and/or MAX-VALUE is omitted or nil, the status¶message shows a &quot;spinning&quot;, non-numeric indicator.¶¶Optional CURRENT-VALUE is the initial progress; the default is¶MIN-VALUE.¶Optional MIN-CHANGE is the minimal change in percents to report;¶the default is 1%.¶CURRENT-VALUE and MIN-CHANGE do not have any effect if MIN-VALUE¶and/or MAX-VALUE are nil.¶¶Optional MIN-TIME specifies the minimum interval time between¶echo area updates (default is 0.2 seconds.)  If the function¶‘float-time’ is not present, time is not tracked at all.  If the¶OS is not capable of measuring fractions of seconds, this¶parameter is effectively rounded up.¶¶(fn MESSAGE &amp;optional MIN-VALUE MAX-VALUE CURRENT-VALUE MIN-CHANGE MIN-TIME)",
"progress-reporter-update":"Report progress of an operation in the echo area.¶REPORTER should be the result of a call to ‘make-progress-reporter’.¶¶If REPORTER is a numerical progress reporter---i.e. if it was¶ made using non-nil MIN-VALUE and MAX-VALUE arguments to¶ ‘make-progress-reporter’---then VALUE should be a number between¶ MIN-VALUE and MAX-VALUE.¶¶If REPORTER is a non-numerical reporter, VALUE should be nil.¶¶This function is relatively inexpensive.  If the change since¶last update is too small or insufficient time has passed, it does¶nothing.¶¶(fn REPORTER &amp;optional VALUE)",
"progress-reporter-force-update":"Report progress of an operation in the echo area unconditionally.¶¶The first two arguments are the same as in ‘progress-reporter-update’.¶NEW-MESSAGE, if non-nil, sets a new message for the reporter.¶¶(fn REPORTER &amp;optional VALUE NEW-MESSAGE)",
"progress-reporter-done":"Print reporter’s message followed by word &quot;done&quot; in echo area.¶¶(fn REPORTER)",
"current-buffer":"Return the current buffer as a Lisp object.¶¶(fn)",
"set-buffer":"Make buffer BUFFER-OR-NAME current for editing operations.¶BUFFER-OR-NAME may be a buffer or the name of an existing buffer.¶See also ‘with-current-buffer’ when you want to make a buffer current¶temporarily.  This function does not display the buffer, so its effect¶ends when the current command terminates.  Use ‘switch-to-buffer’ or¶‘pop-to-buffer’ to switch buffers permanently.¶The return value is the buffer made current.¶¶(fn BUFFER-OR-NAME)",
"minibufferp":"Return t if BUFFER is a minibuffer.¶No argument or nil as argument means use current buffer as BUFFER.¶BUFFER can be a buffer or a buffer name.¶¶(fn &amp;optional BUFFER)",
"minibuffer-selected-window":"Return the window which was selected when entering the minibuffer.¶Returns nil, if selected window is not a minibuffer window.¶¶(fn)",
"minibuffer-message":"Temporarily display MESSAGE at the end of the minibuffer.¶The text is displayed for ‘minibuffer-message-timeout’ seconds,¶or until the next input event arrives, whichever comes first.¶Enclose MESSAGE in [...] if this is not yet the case.¶If ARGS are provided, then pass MESSAGE through ‘format-message’.¶¶(fn MESSAGE &amp;rest ARGS)",
"this-command-keys":"Return the key sequence that invoked this command.¶However, if the command has called ‘read-key-sequence’, it returns¶the last key sequence that has been read.¶The value is a string or a vector.¶¶See also ‘this-command-keys-vector’.¶¶(fn)",
"this-command-keys-vector":"Return the key sequence that invoked this command, as a vector.¶However, if the command has called ‘read-key-sequence’, it returns¶the last key sequence that has been read.¶¶See also ‘this-command-keys’.¶¶(fn)",
"clear-this-command-keys":"Clear out the vector that ‘this-command-keys’ returns.¶Also clear the record of the last 100 events, unless optional arg¶KEEP-RECORD is non-nil.¶¶(fn &amp;optional KEEP-RECORD)",
"markerp":"Return t if OBJECT is a marker (editor pointer).¶¶(fn OBJECT)",
"integer-or-marker-p":"Return t if OBJECT is an integer or a marker (editor pointer).¶¶(fn OBJECT)",
"number-or-marker-p":"Return t if OBJECT is a number or a marker.¶¶(fn OBJECT)",
"make-translation-table":"Make a translation table from arguments.¶A translation table is a char table intended for character¶translation in CCL programs.¶¶Each argument is a list of elements of the form (FROM . TO), where FROM¶is a character to be translated to TO.¶¶The arguments and forms in each argument are processed in the given¶order, and if a previous form already translates TO to some other¶character, say TO-ALT, FROM is also translated to TO-ALT.",
"make-translation-table-from-vector":"Make translation table from decoding vector VEC.¶VEC is an array of 256 elements to map unibyte codes to multibyte¶characters.  Elements may be nil for undefined code points.",
"make-translation-table-from-alist":"Make translation table from N&lt;-&gt;M mapping in ALIST.¶ALIST is an alist, each element has the form (FROM . TO).¶FROM and TO are a character or a vector of characters.¶If FROM is a character, that character is translated to TO.¶If FROM is a vector of characters, that sequence is translated to TO.¶The first extra-slot of the value is a translation table for reverse mapping.¶¶FROM and TO may be nil.  If TO is nil, the translation from FROM¶to nothing is defined in the translation table and that element¶is ignored in the reverse map.  If FROM is nil, the translation¶from TO to nothing is defined in the reverse map only.  A vector¶of length zero has the same meaning as specifying nil.",
"sit-for":"Redisplay, then wait for SECONDS seconds.  Stop when input is available.¶SECONDS may be a floating-point value.¶(On operating systems that do not support waiting for fractions of a¶second, floating-point values are rounded down to the nearest integer.)¶¶If optional arg NODISP is t, don’t redisplay, just wait for input.¶Redisplay does not happen if input is available before it starts.¶¶Value is t if waited the full time with no input arriving, and nil otherwise.¶¶An obsolete, but still supported form is¶(sit-for SECONDS &amp;optional MILLISECONDS NODISP)¶where the optional arg MILLISECONDS specifies an additional wait period,¶in milliseconds; this was useful when Emacs was built without¶floating point support.¶¶(fn SECONDS &amp;optional NODISP OBSOLETE)",
"sleep-for":"Pause, without updating display, for SECONDS seconds.¶SECONDS may be a floating-point value, meaning that you can wait for a¶fraction of a second.  Optional second arg MILLISECONDS specifies an¶additional wait period, in milliseconds; this is for backwards compatibility.¶(Not all operating systems support waiting for a fraction of a second.)¶¶(fn SECONDS &amp;optional MILLISECONDS)",
"read-from-minibuffer":"Read a string from the minibuffer, prompting with string PROMPT.¶The optional second arg INITIAL-CONTENTS is an obsolete alternative to¶  DEFAULT-VALUE.  It normally should be nil in new code, except when¶  HIST is a cons.  It is discussed in more detail below.¶¶Third arg KEYMAP is a keymap to use whilst reading;¶  if omitted or nil, the default is ‘minibuffer-local-map’.¶¶If fourth arg READ is non-nil, interpret the result as a Lisp object¶  and return that object:¶  in other words, do ‘(car (read-from-string INPUT-STRING))’¶¶Fifth arg HIST, if non-nil, specifies a history list and optionally¶  the initial position in the list.  It can be a symbol, which is the¶  history list variable to use, or a cons cell (HISTVAR . HISTPOS).¶  In that case, HISTVAR is the history list variable to use, and¶  HISTPOS is the initial position for use by the minibuffer history¶  commands.  For consistency, you should also specify that element of¶  the history as the value of INITIAL-CONTENTS.  Positions are counted¶  starting from 1 at the beginning of the list.¶¶Sixth arg DEFAULT-VALUE, if non-nil, should be a string, which is used¶  as the default to ‘read’ if READ is non-nil and the user enters¶  empty input.  But if READ is nil, this function does _not_ return¶  DEFAULT-VALUE for empty input!  Instead, it returns the empty string.¶¶  Whatever the value of READ, DEFAULT-VALUE is made available via the¶  minibuffer history commands.  DEFAULT-VALUE can also be a list of¶  strings, in which case all the strings are available in the history,¶  and the first string is the default to ‘read’ if READ is non-nil.¶¶Seventh arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits¶ the current input method and the setting of ‘enable-multibyte-characters’.¶¶If the variable ‘minibuffer-allow-text-properties’ is non-nil,¶ then the string which is returned includes whatever text properties¶ were present in the minibuffer.  Otherwise the value has no text properties.¶¶The remainder of this documentation string describes the¶INITIAL-CONTENTS argument in more detail.  It is only relevant when¶studying existing code, or when HIST is a cons.  If non-nil,¶INITIAL-CONTENTS is a string to be inserted into the minibuffer before¶reading input.  Normally, point is put at the end of that string.¶However, if INITIAL-CONTENTS is (STRING . POSITION), the initial¶input is STRING, but point is placed at _one-indexed_ position¶POSITION in the minibuffer.  Any integer value less than or equal to¶one puts point at the beginning of the string.  *Note* that this¶behavior differs from the way such arguments are used in ‘completing-read’¶and some related functions, which use zero-indexing for POSITION.¶¶(fn PROMPT &amp;optional INITIAL-CONTENTS KEYMAP READ HIST DEFAULT-VALUE INHERIT-INPUT-METHOD)",
"read-string":"Read a string from the minibuffer, prompting with string PROMPT.¶If non-nil, second arg INITIAL-INPUT is a string to insert before reading.¶  This argument has been superseded by DEFAULT-VALUE and should normally be nil¶  in new code.  It behaves as INITIAL-CONTENTS in ‘read-from-minibuffer’ (which¶  see).¶The third arg HISTORY, if non-nil, specifies a history list¶  and optionally the initial position in the list.¶See ‘read-from-minibuffer’ for details of HISTORY argument.¶Fourth arg DEFAULT-VALUE is the default value or the list of default values.¶ If non-nil, it is used for history commands, and as the value (or the first¶ element of the list of default values) to return if the user enters the¶ empty string.¶Fifth arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits¶ the current input method and the setting of ‘enable-multibyte-characters’.¶¶(fn PROMPT &amp;optional INITIAL-INPUT HISTORY DEFAULT-VALUE INHERIT-INPUT-METHOD)",
"read-regexp":"Read and return a regular expression as a string.¶Prompt with the string PROMPT.  If PROMPT ends in &quot;:&quot; (followed by¶optional whitespace), use it as-is.  Otherwise, add &quot;: &quot; to the end,¶possibly preceded by the default result (see below).¶¶The optional argument DEFAULTS can be either: nil, a string, a list¶of strings, or a symbol.  We use DEFAULTS to construct the default¶return value in case of empty input.¶¶If DEFAULTS is a string, we use it as-is.¶¶If DEFAULTS is a list of strings, the first element is the¶default return value, but all the elements are accessible¶using the history command M-n.¶¶If DEFAULTS is a non-nil symbol, then if ‘read-regexp-defaults-function’¶is non-nil, we use that in place of DEFAULTS in the following:¶  If DEFAULTS is the symbol ‘regexp-history-last’, we use the first¶  element of HISTORY (if specified) or ‘regexp-history’.¶  If DEFAULTS is a function, we call it with no arguments and use¶  what it returns, which should be either nil, a string, or a list of strings.¶¶We append the standard values from ‘read-regexp-suggestions’ to DEFAULTS¶before using it.¶¶If the first element of DEFAULTS is non-nil (and if PROMPT does not end¶in &quot;:&quot;, followed by optional whitespace), we add it to the prompt.¶¶The optional argument HISTORY is a symbol to use for the history list.¶If nil, uses ‘regexp-history’.",
"read-no-blanks-input":"Read a string from the terminal, not allowing blanks.¶Prompt with PROMPT.  Whitespace terminates the input.  If INITIAL is¶non-nil, it should be a string, which is used as initial input, with¶point positioned at the end, so that SPACE will accept the input.¶(Actually, INITIAL can also be a cons of a string and an integer.¶Such values are treated as in ‘read-from-minibuffer’, but are normally¶not useful in this function.)¶Third arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits¶the current input method and the setting of‘enable-multibyte-characters’.¶¶(fn PROMPT &amp;optional INITIAL INHERIT-INPUT-METHOD)",
"frame-visible-p":"Return t if FRAME is &quot;visible&quot; (actually in use for display).¶Return the symbol ‘icon’ if FRAME is iconified or &quot;minimized&quot;.¶Return nil if FRAME was made invisible, via ‘make-frame-invisible’.¶On graphical displays, invisible frames are not updated and are¶usually not displayed at all, even in a window system’s &quot;taskbar&quot;.¶¶If FRAME is a text terminal frame, this always returns t.¶Such frames are always considered visible, whether or not they are¶currently being displayed on the terminal.¶¶(fn FRAME)",
"make-process":"Start a program in a subprocess.  Return the process object for it.¶¶This is similar to ‘start-process’, but arguments are specified as¶keyword/argument pairs.  The following arguments are defined:¶¶:name NAME -- NAME is name for process.  It is modified if necessary¶to make it unique.¶¶:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate¶with the process.  Process output goes at end of that buffer, unless¶you specify an output stream or filter function to handle the output.¶BUFFER may be also nil, meaning that this process is not associated¶with any buffer.¶¶:command COMMAND -- COMMAND is a list starting with the program file¶name, followed by strings to give to the program as arguments.¶¶:coding CODING -- If CODING is a symbol, it specifies the coding¶system used for both reading and writing for this process.  If CODING¶is a cons (DECODING . ENCODING), DECODING is used for reading, and¶ENCODING is used for writing.¶¶:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and¶the process is running.  If BOOL is not given, query before exiting.¶¶:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.¶In the stopped state, a process does not accept incoming data, but you¶can send outgoing data.  The stopped state is cleared by¶‘continue-process’ and set by ‘stop-process’.¶¶:connection-type TYPE -- TYPE is control type of device used to¶communicate with subprocesses.  Values are ‘pipe’ to use a pipe, ‘pty’¶to use a pty, or nil to use the default specified through¶‘process-connection-type’.¶¶:filter FILTER -- Install FILTER as the process filter.¶¶:sentinel SENTINEL -- Install SENTINEL as the process sentinel.¶¶:stderr STDERR -- STDERR is either a buffer or a pipe process attached¶to the standard error of subprocess.  Specifying this implies¶‘:connection-type’ is set to ‘pipe’.¶¶(fn &amp;rest ARGS)",
"make-pipe-process":"Create and return a bidirectional pipe process.¶¶In Emacs, pipes are represented by process objects, so input and¶output work as for subprocesses, and ‘delete-process’ closes a pipe.¶However, a pipe process has no process id, it cannot be signaled,¶and the status codes are different from normal processes.¶¶Arguments are specified as keyword/argument pairs.  The following¶arguments are defined:¶¶:name NAME -- NAME is the name of the process.  It is modified if necessary to make it unique.¶¶:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate¶with the process.  Process output goes at the end of that buffer,¶unless you specify an output stream or filter function to handle the¶output.  If BUFFER is not given, the value of NAME is used.¶¶:coding CODING -- If CODING is a symbol, it specifies the coding¶system used for both reading and writing for this process.  If CODING¶is a cons (DECODING . ENCODING), DECODING is used for reading, and¶ENCODING is used for writing.¶¶:noquery BOOL -- When exiting Emacs, query the user if BOOL is nil and¶the process is running.  If BOOL is not given, query before exiting.¶¶:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.¶In the stopped state, a pipe process does not accept incoming data,¶but you can send outgoing data.  The stopped state is cleared by¶‘continue-process’ and set by ‘stop-process’.¶¶:filter FILTER -- Install FILTER as the process filter.¶¶:sentinel SENTINEL -- Install SENTINEL as the process sentinel.¶¶(fn &amp;rest ARGS)",
"start-process":"Start a program in a subprocess.  Return the process object for it.¶NAME is name for process.  It is modified if necessary to make it unique.¶BUFFER is the buffer (or buffer name) to associate with the process.¶¶Process output (both standard output and standard error streams) goes¶at end of BUFFER, unless you specify an output stream or filter¶function to handle the output.  BUFFER may also be nil, meaning that¶this process is not associated with any buffer.¶¶PROGRAM is the program file name.  It is searched for in ‘exec-path’¶(which see).  If nil, just associate a pty with the buffer.  Remaining¶arguments are strings to give program as arguments.¶¶If you want to separate standard output from standard error, use¶‘make-process’ or invoke the command through a shell and redirect¶one of them using the shell syntax.¶¶(fn NAME BUFFER PROGRAM &amp;rest PROGRAM-ARGS)",
"start-file-process":"Start a program in a subprocess.  Return the process object for it.¶¶Similar to ‘start-process’, but may invoke a file handler based on¶‘default-directory’.  See Info node ‘(elisp)Magic File Names’.¶¶This handler ought to run PROGRAM, perhaps on the local host,¶perhaps on a remote host that corresponds to ‘default-directory’.¶In the latter case, the local part of ‘default-directory’ becomes¶the working directory of the process.¶¶PROGRAM and PROGRAM-ARGS might be file names.  They are not¶objects of file handler invocation.  File handlers might not¶support pty association, if PROGRAM is nil.¶¶(fn NAME BUFFER PROGRAM &amp;rest PROGRAM-ARGS)",
"start-process-shell-command":"Start a program in a subprocess.  Return the process object for it.¶NAME is name for process.  It is modified if necessary to make it unique.¶BUFFER is the buffer (or buffer name) to associate with the process.¶ Process output goes at end of that buffer, unless you specify¶ an output stream or filter function to handle the output.¶ BUFFER may be also nil, meaning that this process is not associated¶ with any buffer¶COMMAND is the shell command to run.¶¶An old calling convention accepted any number of arguments after COMMAND,¶which were just concatenated to COMMAND.  This is still supported but strongly¶discouraged.¶¶(fn NAME BUFFER &amp;rest ARGS)",
"start-file-process-shell-command":"Start a program in a subprocess.  Return the process object for it.¶Similar to ‘start-process-shell-command’, but calls ‘start-file-process’.¶¶(fn NAME BUFFER &amp;rest ARGS)",
"find-file-name-handler":"Return FILENAME’s handler function for OPERATION, if it has one.¶Otherwise, return nil.¶A file name is handled if one of the regular expressions in¶‘file-name-handler-alist’ matches it.¶¶If OPERATION equals ‘inhibit-file-name-operation’, then we ignore¶any handlers that are members of ‘inhibit-file-name-handlers’,¶but we still do run any other handlers.  This lets handlers¶use the standard functions without calling themselves recursively.¶¶(fn FILENAME OPERATION)",
"file-local-copy":"Copy the file FILE into a temporary file on this machine.¶Returns the name of the local copy, or nil, if FILE is directly¶accessible.¶¶(fn FILE)",
"file-remote-p":"Test whether FILE specifies a location on a remote system.¶A file is considered remote if accessing it is likely to¶be slower or less reliable than accessing local files.¶¶‘file-remote-p’ never opens a new remote connection.  It can¶only reuse a connection that is already open.¶¶Return nil or a string identifying the remote connection¶(ideally a prefix of FILE).  Return nil if FILE is a relative¶file name.¶¶When IDENTIFICATION is nil, the returned string is a complete¶remote identifier: with components method, user, and host.  The¶components are those present in FILE, with defaults filled in for¶any that are missing.¶¶IDENTIFICATION can specify which part of the identification to¶return.  IDENTIFICATION can be the symbol ‘method’, ‘user’,¶‘host’, or ‘localname’.  Any other value is handled like nil and¶means to return the complete identification.  The string returned¶for IDENTIFICATION ‘localname’ can differ depending on whether¶there is an existing connection.¶¶If CONNECTED is non-nil, return an identification only if FILE is¶located on a remote system and a connection is established to¶that remote system.¶¶Tip: You can use this expansion of remote identifier components¶     to derive a new remote file name from an existing one.  For¶     example, if FILE is &quot;/sudo::/path/to/file&quot; then¶¶       (concat (file-remote-p FILE) &quot;/bin/sh&quot;)¶¶     returns a remote file name for file &quot;/bin/sh&quot; that has the¶     same remote identifier as FILE but expanded; a name such as¶     &quot;/sudo:root@myhost:/bin/sh&quot;.¶¶(fn FILE &amp;optional IDENTIFICATION CONNECTED)",
"unhandled-file-name-directory":"Return a directly usable directory name somehow associated with FILENAME.¶A ‘directly usable’ directory name is one that may be used without the¶intervention of any file handler.¶If FILENAME is a directly usable file itself, return¶(file-name-as-directory FILENAME).¶If FILENAME refers to a file which is not accessible from a local process,¶then this should return nil.¶The ‘call-process’ and ‘start-process’ functions use this function to¶get a current directory to run processes in.¶¶(fn FILENAME)",
"match-data":"Return a list describing what the last search matched.¶Element 2N is ‘(match-beginning N)’; element 2N + 1 is ‘(match-end N)’.¶All the elements are markers or nil (nil if the Nth pair didn’t match)¶if the last match was on a buffer; integers or nil if a string was matched.¶Use ‘set-match-data’ to reinstate the data in this list.¶¶If INTEGERS (the optional first argument) is non-nil, always use¶integers (rather than markers) to represent buffer positions.  In¶this case, and if the last match was in a buffer, the buffer will get¶stored as one additional element at the end of the list.¶¶If REUSE is a list, reuse it as part of the value.  If REUSE is long¶enough to hold all the values, and if INTEGERS is non-nil, no consing¶is done.¶¶If optional third arg RESEAT is non-nil, any previous markers on the¶REUSE list will be modified to point to nowhere.¶¶Return value is undefined if the last search failed.¶¶(fn &amp;optional INTEGERS REUSE RESEAT)",
"set-match-data":"Set internal data on last search match from elements of LIST.¶LIST should have been created by calling ‘match-data’ previously.¶¶If optional arg RESEAT is non-nil, make markers on LIST point nowhere.¶¶(fn LIST &amp;optional RESEAT)",
"overlay-get":"Get the property of overlay OVERLAY with property name PROP.¶¶(fn OVERLAY PROP)",
"overlay-put":"Set one property of overlay OVERLAY: give property PROP value VALUE.¶VALUE will be returned.¶¶(fn OVERLAY PROP VALUE)",
"overlay-properties":"Return a list of the properties on OVERLAY.¶This is a copy of OVERLAY’s plist; modifying its conses has no effect on¶OVERLAY.¶¶(fn OVERLAY)",
"file-name-absolute-p":"Return t if file FILENAME specifies an absolute file name.¶On Unix, this is a name starting with a ‘/’ or a ‘~’.¶¶(fn FILENAME)",
"file-relative-name":"Convert FILENAME to be relative to DIRECTORY (default: ‘default-directory’).¶This function returns a relative file name which is equivalent to FILENAME¶when used with that default directory as the default.¶If FILENAME is a relative file name, it will be interpreted as existing in¶‘default-directory’.¶If FILENAME and DIRECTORY lie on different machines or on different drives¶on a DOS/Windows machine, it returns FILENAME in expanded form.¶¶(fn FILENAME &amp;optional DIRECTORY)",
"hack-dir-local-variables":"Read per-directory local variables for the current buffer.¶Store the directory-local variables in ‘dir-local-variables-alist’¶and ‘file-local-variables-alist’, without applying them.¶¶This does nothing if either ‘enable-local-variables’ or¶‘enable-dir-local-variables’ are nil.",
"hack-dir-local-variables-non-file-buffer":"Apply directory-local variables to a non-file buffer.¶For non-file buffers, such as Dired buffers, directory-local¶variables are looked for in ‘default-directory’ and its parent¶directories.",
"dir-locals-set-class-variables":"Map the type CLASS to a list of variable settings.¶CLASS is the project class, a symbol.  VARIABLES is a list¶that declares directory-local variables for the class.¶An element in VARIABLES is either of the form:¶    (MAJOR-MODE . ALIST)¶or¶    (DIRECTORY . LIST)¶¶In the first form, MAJOR-MODE is a symbol, and ALIST is an alist¶whose elements are of the form (VARIABLE . VALUE).¶¶In the second form, DIRECTORY is a directory name (a string), and¶LIST is a list of the form accepted by the function.¶¶When a file is visited, the file’s class is found.  A directory¶may be assigned a class using ‘dir-locals-set-directory-class’.¶Then variables are set in the file’s buffer according to the¶VARIABLES list of the class.  The list is processed in order.¶¶* If the element is of the form (MAJOR-MODE . ALIST), and the¶  buffer’s major mode is derived from MAJOR-MODE (as determined¶  by ‘derived-mode-p’), then all the variables in ALIST are¶  applied.  A MAJOR-MODE of nil may be used to match any buffer.¶  ‘make-local-variable’ is called for each variable before it is¶  set.¶¶* If the element is of the form (DIRECTORY . LIST), and DIRECTORY¶  is an initial substring of the file’s directory, then LIST is¶  applied by recursively following these rules.¶¶(fn CLASS VARIABLES)",
"dir-locals-set-directory-class":"Declare that the DIRECTORY root is an instance of CLASS.¶DIRECTORY is the name of a directory, a string.¶CLASS is the name of a project class, a symbol.¶MTIME is either the modification time of the directory-local¶variables file that defined this class, or nil.¶¶When a file beneath DIRECTORY is visited, the mode-specific¶variables from CLASS are applied to the buffer.  The variables¶for a class are defined using ‘dir-locals-set-class-variables’.¶¶(fn DIRECTORY CLASS &amp;optional MTIME)",
"make-button":"Make a button from BEG to END in the current buffer.¶The remaining arguments form a sequence of PROPERTY VALUE pairs,¶specifying properties to add to the button.¶In addition, the keyword argument :type may be used to specify a¶button-type from which to inherit other properties; see¶‘define-button-type’.¶¶Also see ‘make-text-button’, ‘insert-button’.",
"insert-button":"Insert a button with the label LABEL.¶The remaining arguments form a sequence of PROPERTY VALUE pairs,¶specifying properties to add to the button.¶In addition, the keyword argument :type may be used to specify a¶button-type from which to inherit other properties; see¶‘define-button-type’.¶¶Also see ‘insert-text-button’, ‘make-button’.",
"make-text-button":"Make a button from BEG to END in the current buffer.¶The remaining arguments form a sequence of PROPERTY VALUE pairs,¶specifying properties to add to the button.¶In addition, the keyword argument :type may be used to specify a¶button-type from which to inherit other properties; see¶‘define-button-type’.¶¶This function is like ‘make-button’, except that the button is actually¶part of the text instead of being a property of the buffer.  That is,¶this function uses text properties, the other uses overlays.¶Creating large numbers of buttons can also be somewhat faster¶using ‘make-text-button’.  Note, however, that if there is an existing¶face property at the site of the button, the button face may not be visible.¶You may want to use ‘make-button’ in that case.¶¶BEG can also be a string, in which case it is made into a button.¶¶Also see ‘insert-text-button’.",
"insert-text-button":"Insert a button with the label LABEL.¶The remaining arguments form a sequence of PROPERTY VALUE pairs,¶specifying properties to add to the button.¶In addition, the keyword argument :type may be used to specify a¶button-type from which to inherit other properties; see¶‘define-button-type’.¶¶This function is like ‘insert-button’, except that the button is¶actually part of the text instead of being a property of the buffer.¶Creating large numbers of buttons can also be somewhat faster using¶‘insert-text-button’.¶¶Also see ‘make-text-button’.",
"insert-image":"Insert IMAGE into current buffer at point.¶IMAGE is displayed by inserting STRING into the current buffer¶with a ‘display’ property whose value is the image.  STRING¶defaults to a single space if you omit it.¶AREA is where to display the image.  AREA nil or omitted means¶display it in the text area, a value of ‘left-margin’ means¶display it in the left marginal area, a value of ‘right-margin’¶means display it in the right marginal area.¶SLICE specifies slice of IMAGE to insert.  SLICE nil or omitted¶means insert whole image.  SLICE is a list (X Y WIDTH HEIGHT)¶specifying the X and Y positions and WIDTH and HEIGHT of image area¶to insert.  A float value 0.0 - 1.0 means relative to the width or¶height of the image; integer values are taken as pixel values.",
"insert-sliced-image":"Insert IMAGE into current buffer at point.¶IMAGE is displayed by inserting STRING into the current buffer¶with a ‘display’ property whose value is the image.  The default¶STRING is a single space.¶AREA is where to display the image.  AREA nil or omitted means¶display it in the text area, a value of ‘left-margin’ means¶display it in the left marginal area, a value of ‘right-margin’¶means display it in the right marginal area.¶The image is automatically split into ROWS x COLS slices.",
"put-image":"Put image IMAGE in front of POS in the current buffer.¶IMAGE must be an image created with ‘create-image’ or ‘defimage’.¶IMAGE is displayed by putting an overlay into the current buffer with a¶‘before-string’ STRING that has a ‘display’ property whose value is the¶image.  STRING is defaulted if you omit it.¶The overlay created will have the ‘put-image’ property set to t.¶POS may be an integer or marker.¶AREA is where to display the image.  AREA nil or omitted means¶display it in the text area, a value of ‘left-margin’ means¶display it in the left marginal area, a value of ‘right-margin’¶means display it in the right marginal area.",
"remove-images":"Remove images between START and END in BUFFER.¶Remove only images that were put in BUFFER with calls to ‘put-image’.¶BUFFER nil or omitted means use the current buffer.",
"image-size":"Return the size of image SPEC as pair (WIDTH . HEIGHT).¶PIXELS non-nil means return the size in pixels, otherwise return the¶size in canonical character units.¶FRAME is the frame on which the image will be displayed.  FRAME nil¶or omitted means use the selected frame.¶¶(fn SPEC &amp;optional PIXELS FRAME)",
"insert-file-contents":"Insert contents of file FILENAME after point.¶Returns list of absolute file name and number of characters inserted.¶If second argument VISIT is non-nil, the buffer’s visited filename and¶last save file modtime are set, and it is marked unmodified.  If¶visiting and the file does not exist, visiting is completed before the¶error is signaled.¶¶The optional third and fourth arguments BEG and END specify what portion¶of the file to insert.  These arguments count bytes in the file, not¶characters in the buffer.  If VISIT is non-nil, BEG and END must be nil.¶¶If optional fifth argument REPLACE is non-nil, replace the current¶buffer contents (in the accessible portion) with the file contents.¶This is better than simply deleting and inserting the whole thing¶because (1) it preserves some marker positions and (2) it puts less data¶in the undo list.  When REPLACE is non-nil, the second return value is¶the number of characters that replace previous buffer contents.¶¶This function does code conversion according to the value of¶‘coding-system-for-read’ or ‘file-coding-system-alist’, and sets the¶variable ‘last-coding-system-used’ to the coding system actually used.¶¶In addition, this function decodes the inserted text from known formats¶by calling ‘format-decode’, which see.¶¶(fn FILENAME &amp;optional VISIT BEG END REPLACE)",
"insert-file-contents-literally":"Like ‘insert-file-contents’, but only reads in the file literally.¶See ‘insert-file-contents’ for an explanation of the parameters.¶A buffer may be modified in several ways after reading into the buffer,¶due to Emacs features such as format decoding, character code¶conversion, ‘find-file-hook’, automatic uncompression, etc.¶¶This function ensures that none of these modifications will take place.¶¶(fn FILENAME &amp;optional VISIT BEG END REPLACE)",
"format":"Format a string out of a format-string and arguments.¶The first argument is a format control string.¶The other arguments are substituted into it to make the result, a string.¶¶The format control string may contain %-sequences meaning to substitute¶the next available argument:¶¶%s means print a string argument.  Actually, prints any object, with ‘princ’.¶%d means print as number in decimal (%o octal, %x hex).¶%X is like %x, but uses upper case.¶%e means print a number in exponential notation.¶%f means print a number in decimal-point notation.¶%g means print a number in exponential notation¶  or decimal-point notation, whichever uses fewer characters.¶%c means print a number as a single character.¶%S means print any object as an s-expression (using ‘prin1’).¶¶The argument used for %d, %o, %x, %e, %f, %g or %c must be a number.¶Use %% to put a single % into the output.¶¶A %-sequence may contain optional flag, width, and precision¶specifiers, as follows:¶¶  %&lt;flags&gt;&lt;width&gt;&lt;precision&gt;character¶¶where flags is [+ #-0]+, width is [0-9]+, and precision is .[0-9]+¶¶The + flag character inserts a + before any positive number, while a¶space inserts a space before any positive number; these flags only¶affect %d, %e, %f, and %g sequences, and the + flag takes precedence.¶The - and 0 flags affect the width specifier, as described below.¶¶The # flag means to use an alternate display form for %o, %x, %X, %e,¶%f, and %g sequences: for %o, it ensures that the result begins with¶&quot;0&quot;; for %x and %X, it prefixes the result with &quot;0x&quot; or &quot;0X&quot;;¶for %e, %f, and %g, it causes a decimal point to be included even if¶the precision is zero.¶¶The width specifier supplies a lower limit for the length of the¶printed representation.  The padding, if any, normally goes on the¶left, but it goes on the right if the - flag is present.  The padding¶character is normally a space, but it is 0 if the 0 flag is present.¶The 0 flag is ignored if the - flag is present, or the format sequence¶is something other than %d, %e, %f, and %g.¶¶For %e, %f, and %g sequences, the number after the &quot;.&quot; in the¶precision specifier says how many decimal places to show; if zero, the¶decimal point itself is omitted.  For %s and %S, the precision¶specifier truncates the string to the given width.¶¶(fn STRING &amp;rest OBJECTS)",
"format-message":"Format a string out of a format-string and arguments.¶The first argument is a format control string.¶The other arguments are substituted into it to make the result, a string.¶¶This acts like ‘format’, except it also replaces each left single¶quotation mark (‘) and grave accent (`) by a left quote, and each¶right single quotation mark (’) and apostrophe (') by a right quote.¶The left and right quote replacement characters are specified by¶‘text-quoting-style’.¶¶(fn STRING &amp;rest OBJECTS)",
"run-mode-hooks":"Run mode hooks ‘delayed-mode-hooks’ and HOOKS, or delay HOOKS.¶If the variable ‘delay-mode-hooks’ is non-nil, does not run any hooks,¶just adds the HOOKS to the list ‘delayed-mode-hooks’.¶Otherwise, runs hooks in the sequence: ‘change-major-mode-after-body-hook’,¶‘delayed-mode-hooks’ (in reverse order), HOOKS, and finally¶‘after-change-major-mode-hook’.  Major mode functions should use¶this instead of ‘run-hooks’ when running their FOO-mode-hook.¶¶(fn &amp;rest HOOKS)",
"cl-call-next-method":"Function to call the next applicable method.¶Can only be used from within the lexical body of a primary or around method.¶¶(fn &amp;rest ARGS)",
"cl-next-method-p":"Return non-nil if there is a next method.¶Can only be used from within the lexical body of a primary or around method.",
"char-equal":"Return t if two characters match, optionally ignoring case.¶Both arguments must be characters (i.e. integers).¶Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.¶¶(fn C1 C2)",
"string-equal":"Return t if two strings have identical contents.¶Case is significant, but text properties are ignored.¶Symbols are also allowed; their print names are used instead.¶¶(fn S1 S2)",
"string-collate-equalp":"Return t if two strings have identical contents.¶Symbols are also allowed; their print names are used instead.¶¶This function obeys the conventions for collation order in your locale¶settings.  For example, characters with different coding points but¶the same meaning might be considered as equal, like different grave¶accent Unicode characters:¶¶(string-collate-equalp (string ?⧷uFF40) (string ?⧷u1FEF))¶  =&gt; t¶¶The optional argument LOCALE, a string, overrides the setting of your¶current locale identifier for collation.  The value is system¶dependent; a LOCALE &quot;en_US.UTF-8&quot; is applicable on POSIX systems,¶while it would be &quot;enu_USA.1252&quot; on MS Windows systems.¶¶If IGNORE-CASE is non-nil, characters are converted to lower-case¶before comparing them.¶¶To emulate Unicode-compliant collation on MS-Windows systems,¶bind ‘w32-collate-ignore-punctuation’ to a non-nil value, since¶the codeset part of the locale cannot be &quot;UTF-8&quot; on MS-Windows.¶¶If your system does not support a locale environment, this function¶behaves like ‘string-equal’.¶¶Do NOT use this function to compare file names for equality.¶¶(fn S1 S2 &amp;optional LOCALE IGNORE-CASE)",
"string-prefix-p":"Return non-nil if PREFIX is a prefix of STRING.¶If IGNORE-CASE is non-nil, the comparison is done without paying attention¶to case differences.¶¶(fn PREFIX STRING &amp;optional IGNORE-CASE)",
"string-suffix-p":"Return non-nil if SUFFIX is a suffix of STRING.¶If IGNORE-CASE is non-nil, the comparison is done without paying¶attention to case differences.¶¶(fn SUFFIX STRING &amp;optional IGNORE-CASE)",
"string-lessp":"Return non-nil if STRING1 is less than STRING2 in lexicographic order.¶Case is significant.¶Symbols are also allowed; their print names are used instead.¶¶(fn STRING1 STRING2)",
"string-greaterp":"Return non-nil if STRING1 is greater than STRING2 in lexicographic order.¶Case is significant.¶Symbols are also allowed; their print names are used instead.¶¶(fn STRING1 STRING2)",
"string-collate-lessp":"Return t if first arg string is less than second in collation order.¶Symbols are also allowed; their print names are used instead.¶¶This function obeys the conventions for collation order in your¶locale settings.  For example, punctuation and whitespace characters¶might be considered less significant for sorting:¶¶(sort '(&quot;11&quot; &quot;12&quot; &quot;1 1&quot; &quot;1 2&quot; &quot;1.1&quot; &quot;1.2&quot;) 'string-collate-lessp)¶  =&gt; (&quot;11&quot; &quot;1 1&quot; &quot;1.1&quot; &quot;12&quot; &quot;1 2&quot; &quot;1.2&quot;)¶¶The optional argument LOCALE, a string, overrides the setting of your¶current locale identifier for collation.  The value is system¶dependent; a LOCALE &quot;en_US.UTF-8&quot; is applicable on POSIX systems,¶while it would be, e.g., &quot;enu_USA.1252&quot; on MS-Windows systems.¶¶If IGNORE-CASE is non-nil, characters are converted to lower-case¶before comparing them.¶¶To emulate Unicode-compliant collation on MS-Windows systems,¶bind ‘w32-collate-ignore-punctuation’ to a non-nil value, since¶the codeset part of the locale cannot be &quot;UTF-8&quot; on MS-Windows.¶¶If your system does not support a locale environment, this function¶behaves like ‘string-lessp’.¶¶(fn S1 S2 &amp;optional LOCALE IGNORE-CASE)",
"compare-strings":"Compare the contents of two strings, converting to multibyte if needed.¶The arguments START1, END1, START2, and END2, if non-nil, are¶positions specifying which parts of STR1 or STR2 to compare.  In¶string STR1, compare the part between START1 (inclusive) and END1¶(exclusive).  If START1 is nil, it defaults to 0, the beginning of¶the string; if END1 is nil, it defaults to the length of the string.¶Likewise, in string STR2, compare the part between START2 and END2.¶Like in ‘substring’, negative values are counted from the end.¶¶The strings are compared by the numeric values of their characters.¶For instance, STR1 is &quot;less than&quot; STR2 if its first differing¶character has a smaller numeric value.  If IGNORE-CASE is non-nil,¶characters are converted to upper-case before comparing them.  Unibyte¶strings are converted to multibyte for comparison.¶¶The value is t if the strings (or specified portions) match.¶If string STR1 is less, the value is a negative number N;¶  - 1 - N is the number of characters that match at the beginning.¶If string STR1 is greater, the value is a positive number N;¶  N - 1 is the number of characters that match at the beginning.¶¶(fn STR1 START1 END1 STR2 START2 END2 &amp;optional IGNORE-CASE)",
"assoc-string":"Like ‘assoc’ but specifically for strings (and symbols).¶¶This returns the first element of LIST whose car matches the string or¶symbol KEY, or nil if no match exists.  When performing the¶comparison, symbols are first converted to strings, and unibyte¶strings to multibyte.  If the optional arg CASE-FOLD is non-nil, both¶KEY and the elements of LIST are upcased for comparison.¶¶Unlike ‘assoc’, KEY can also match an entry in LIST consisting of a¶single string, rather than a cons cell whose car is a string.¶¶(fn KEY LIST &amp;optional CASE-FOLD)",
"display-popup-menus-p":"Return non-nil if popup menus are supported on DISPLAY.¶DISPLAY can be a display name, a frame, or nil (meaning the selected¶frame’s display).¶Support for popup menus requires that the mouse be available.¶¶(fn &amp;optional DISPLAY)",
"display-graphic-p":"Return non-nil if DISPLAY is a graphic display.¶Graphical displays are those which are capable of displaying several¶frames and several different fonts at once.  This is true for displays¶that use a window system such as X, and false for text-only terminals.¶DISPLAY can be a display name, a frame, or nil (meaning the selected¶frame’s display).¶¶(fn &amp;optional DISPLAY)",
"display-mouse-p":"Return non-nil if DISPLAY has a mouse available.¶DISPLAY can be a display name, a frame, or nil (meaning the selected¶frame’s display).¶¶(fn &amp;optional DISPLAY)",
"display-color-p":"Return t if DISPLAY supports color.¶The optional argument DISPLAY specifies which display to ask about.¶DISPLAY should be either a frame or a display name (a string).¶If omitted or nil, that stands for the selected frame’s display.",
"display-grayscale-p":"Return non-nil if frames on DISPLAY can display shades of gray.¶DISPLAY should be either a frame or a display name (a string).¶If omitted or nil, that stands for the selected frame’s display.",
"display-supports-face-attributes-p":"Return non-nil if all the face attributes in ATTRIBUTES are supported.¶The optional argument DISPLAY can be a display name, a frame, or¶nil (meaning the selected frame’s display).¶¶The definition of ‘supported’ is somewhat heuristic, but basically means¶that a face containing all the attributes in ATTRIBUTES, when merged¶with the default face for display, can be represented in a way that’s¶¶ (1) different in appearance than the default face, and¶ (2) ‘close in spirit’ to what the attributes specify, if not exact.¶¶Point (2) implies that a ‘:weight black’ attribute will be satisfied by¶any display that can display bold, and a ‘:foreground &quot;yellow&quot;’ as long¶as it can display a yellowish color, but ‘:slant italic’ will _not_ be¶satisfied by the tty display code’s automatic substitution of a ‘dim’¶face for italic.¶¶(fn ATTRIBUTES &amp;optional DISPLAY)",
"display-selections-p":"Return non-nil if DISPLAY supports selections.¶A selection is a way to transfer text or other data between programs¶via special system buffers called ‘selection’ or ‘clipboard’.¶DISPLAY can be a display name, a frame, or nil (meaning the selected¶frame’s display).¶¶(fn &amp;optional DISPLAY)",
"display-images-p":"Return non-nil if DISPLAY can display images.¶¶DISPLAY can be a display name, a frame, or nil (meaning the selected¶frame’s display).¶¶(fn &amp;optional DISPLAY)",
"display-screens":"Return the number of screens associated with DISPLAY.¶DISPLAY should be either a frame or a display name (a string).¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"display-pixel-height":"Return the height of DISPLAY’s screen in pixels.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶For character terminals, each character counts as a single pixel.¶¶For graphical terminals, note that on &quot;multi-monitor&quot; setups this¶refers to the pixel height for all physical monitors associated¶with DISPLAY.  To get information for each physical monitor, use¶‘display-monitor-attributes-list’.¶¶(fn &amp;optional DISPLAY)",
"display-pixel-width":"Return the width of DISPLAY’s screen in pixels.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶For character terminals, each character counts as a single pixel.¶¶For graphical terminals, note that on &quot;multi-monitor&quot; setups this¶refers to the pixel width for all physical monitors associated¶with DISPLAY.  To get information for each physical monitor, use¶‘display-monitor-attributes-list’.¶¶(fn &amp;optional DISPLAY)",
"display-mm-height":"Return the height of DISPLAY’s screen in millimeters.¶If the information is unavailable, this function returns nil.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶You can override what the system thinks the result should be by¶adding an entry to ‘display-mm-dimensions-alist’.¶¶For graphical terminals, note that on &quot;multi-monitor&quot; setups this¶refers to the height in millimeters for all physical monitors¶associated with DISPLAY.  To get information for each physical¶monitor, use ‘display-monitor-attributes-list’.¶¶(fn &amp;optional DISPLAY)",
"display-mm-width":"Return the width of DISPLAY’s screen in millimeters.¶If the information is unavailable, this function returns nil.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶You can override what the system thinks the result should be by¶adding an entry to ‘display-mm-dimensions-alist’.¶¶For graphical terminals, note that on &quot;multi-monitor&quot; setups this¶refers to the width in millimeters for all physical monitors¶associated with DISPLAY.  To get information for each physical¶monitor, use ‘display-monitor-attributes-list’.¶¶(fn &amp;optional DISPLAY)",
"display-backing-store":"Return the backing store capability of DISPLAY’s screen.¶The value may be ‘always’, ‘when-mapped’, ‘not-useful’, or nil if¶the question is inapplicable to a certain kind of display.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"display-save-under":"Return non-nil if DISPLAY’s screen supports the SaveUnder feature.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"display-planes":"Return the number of planes supported by DISPLAY.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"display-visual-class":"Return the visual class of DISPLAY.¶The value is one of the symbols ‘static-gray’, ‘gray-scale’,¶‘static-color’, ‘pseudo-color’, ‘true-color’, or ‘direct-color’.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"display-color-cells":"Return the number of color cells supported by DISPLAY.¶DISPLAY can be a display name or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶¶(fn &amp;optional DISPLAY)",
"x-server-version":"Return the version numbers of the GUI software on TERMINAL.¶The value is a list of three integers specifying the version of the GUI¶software in use.¶¶For GNU and Unix system, the first 2 numbers are the version of the X¶Protocol used on TERMINAL and the 3rd number is the distributor-specific¶release number.  For MS-Windows, the 3 numbers report the version and¶the build number of the OS.¶¶See also the function ‘x-server-vendor’.¶¶The optional argument TERMINAL specifies which display to ask about.¶TERMINAL should be a terminal object, a frame or a display name (a string).¶If omitted or nil, that stands for the selected frame’s display.¶¶(fn &amp;optional TERMINAL)",
"x-server-vendor":"Return the &quot;vendor ID&quot; string of the GUI software on TERMINAL.¶¶(Labeling every distributor as a &quot;vendor&quot; embodies the false assumption¶that operating systems cannot be developed and distributed noncommercially.)¶The optional argument TERMINAL specifies which display to ask about.¶¶For GNU and Unix systems, this queries the X server software; for¶MS-Windows, this queries the OS.¶¶TERMINAL should be a terminal object, a frame or a display name (a string).¶If omitted or nil, that stands for the selected frame’s display.¶¶(fn &amp;optional TERMINAL)",
"define-prefix-command":"Define COMMAND as a prefix command.  COMMAND should be a symbol.¶A new sparse keymap is stored as COMMAND’s function definition and its¶value.¶This prepares COMMAND for use as a prefix key’s binding.¶If a second optional argument MAPVAR is given, it should be a symbol.¶The map is then stored as MAPVAR’s value instead of as COMMAND’s¶value; but COMMAND is still defined as a function.¶The third optional argument NAME, if given, supplies a menu name¶string for the map.  This is required to use the keymap as a menu.¶This function returns COMMAND.¶¶(fn COMMAND &amp;optional MAPVAR NAME)",
"insert":"Insert the arguments, either strings or characters, at point.¶Point and after-insertion markers move forward to end up¶ after the inserted text.¶Any other markers at the point of insertion remain before the text.¶¶If the current buffer is multibyte, unibyte strings are converted¶to multibyte for insertion (see ‘string-make-multibyte’).¶If the current buffer is unibyte, multibyte strings are converted¶to unibyte for insertion (see ‘string-make-unibyte’).¶¶When operating on binary data, it may be necessary to preserve the¶original bytes of a unibyte string when inserting it into a multibyte¶buffer; to accomplish this, apply ‘string-as-multibyte’ to the string¶and insert the result.¶¶(fn &amp;rest ARGS)",
"insert-before-markers":"Insert strings or characters at point, relocating markers after the text.¶Point and markers move forward to end up after the inserted text.¶¶If the current buffer is multibyte, unibyte strings are converted¶to multibyte for insertion (see ‘unibyte-char-to-multibyte’).¶If the current buffer is unibyte, multibyte strings are converted¶to unibyte for insertion.¶¶If an overlay begins at the insertion point, the inserted text falls¶outside the overlay; if a nonempty overlay ends at the insertion¶point, the inserted text falls inside that overlay.¶¶(fn &amp;rest ARGS)",
"insert-buffer-substring":"Insert before point a substring of the contents of BUFFER.¶BUFFER may be a buffer or a buffer name.¶Arguments START and END are character positions specifying the substring.¶They default to the values of (point-min) and (point-max) in BUFFER.¶¶Point and before-insertion markers move forward to end up after the¶inserted text.¶Any other markers at the point of insertion remain before the text.¶¶If the current buffer is multibyte and BUFFER is unibyte, or vice¶versa, strings are converted from unibyte to multibyte or vice versa¶using ‘string-make-multibyte’ or ‘string-make-unibyte’, which see.¶¶(fn BUFFER &amp;optional START END)",
"insert-buffer-substring-no-properties":"Insert before point a substring of BUFFER, without text properties.¶BUFFER may be a buffer or a buffer name.¶Arguments START and END are character positions specifying the substring.¶They default to the values of (point-min) and (point-max) in BUFFER.¶¶(fn BUFFER &amp;optional START END)",
"replace-match":"Replace text matched by last search with NEWTEXT.¶Leave point at the end of the replacement text.¶¶If optional second arg FIXEDCASE is non-nil, do not alter the case of¶the replacement text.  Otherwise, maybe capitalize the whole text, or¶maybe just word initials, based on the replaced text.  If the replaced¶text has only capital letters and has at least one multiletter word,¶convert NEWTEXT to all caps.  Otherwise if all words are capitalized¶in the replaced text, capitalize each word in NEWTEXT.¶¶If optional third arg LITERAL is non-nil, insert NEWTEXT literally.¶Otherwise treat ‘⧷’ as special:¶  ‘⧷&amp;’ in NEWTEXT means substitute original matched text.¶  ‘⧷N’ means substitute what matched the Nth ‘⧷(...⧷)’.¶       If Nth parens didn’t match, substitute nothing.¶  ‘⧷⧷’ means insert one ‘⧷’.¶  ‘⧷?’ is treated literally¶       (for compatibility with ‘query-replace-regexp’).¶  Any other character following ‘⧷’ signals an error.¶Case conversion does not apply to these substitutions.¶¶If optional fourth argument STRING is non-nil, it should be a string¶to act on; this should be the string on which the previous match was¶done via ‘string-match’.  In this case, ‘replace-match’ creates and¶returns a new string, made by copying STRING and replacing the part of¶STRING that was matched (the original STRING itself is not altered).¶¶The optional fifth argument SUBEXP specifies a subexpression;¶it says to replace just that subexpression with NEWTEXT,¶rather than replacing the entire matched text.¶This is, in a vague sense, the inverse of using ‘⧷N’ in NEWTEXT;¶‘⧷N’ copies subexp N into NEWTEXT, but using N as SUBEXP puts¶NEWTEXT in place of subexp N.¶This is useful only after a regular expression search or match,¶since only regular expressions have distinguished subexpressions.¶¶(fn NEWTEXT &amp;optional FIXEDCASE LITERAL STRING SUBEXP)",
"match-substitute-replacement":"Return REPLACEMENT as it will be inserted by ‘replace-match’.¶In other words, all back-references in the form ‘⧷&amp;’ and ‘⧷N’¶are substituted with actual strings matched by the last search.¶Optional FIXEDCASE, LITERAL, STRING and SUBEXP have the same¶meaning as for ‘replace-match’.¶¶(fn REPLACEMENT &amp;optional FIXEDCASE LITERAL STRING SUBEXP)",
"set-input-mode":"Set mode of reading keyboard input.¶First arg INTERRUPT non-nil means use input interrupts;¶ nil means use CBREAK mode.¶Second arg FLOW non-nil means use ^S/^Q flow control for output to terminal¶ (no effect except in CBREAK mode).¶Third arg META t means accept 8-bit input (for a Meta key).¶ META nil means ignore the top bit, on the assumption it is parity.¶ Otherwise, accept 8-bit input and don’t use the top bit for Meta.¶Optional fourth arg QUIT if non-nil specifies character to use for quitting.¶See also ‘current-input-mode’.¶¶(fn INTERRUPT FLOW META &amp;optional QUIT)",
"current-input-mode":"Return information about the way Emacs currently reads keyboard input.¶The value is a list of the form (INTERRUPT FLOW META QUIT), where¶  INTERRUPT is non-nil if Emacs is using interrupt-driven input; if¶    nil, Emacs is using CBREAK mode.¶  FLOW is non-nil if Emacs uses ^S/^Q flow control for output to the¶    terminal; this does not apply if Emacs uses interrupt-driven input.¶  META is t if accepting 8-bit input with 8th bit as Meta flag.¶    META nil means ignoring the top bit, on the assumption it is parity.¶    META is neither t nor nil if accepting 8-bit input and using¶    all 8 bits as the character code.¶  QUIT is the character Emacs currently uses to quit.¶The elements of this list correspond to the arguments of¶‘set-input-mode’.¶¶(fn)",
"tty-color-define":"Specify a tty color by its NAME, terminal INDEX and RGB values.¶NAME is a string, INDEX is typically a small integer used to send to¶the terminal driver a command to switch this color on, and RGB is a¶list of 3 numbers that specify the intensity of red, green, and blue¶components of the color.¶If specified, each one of the RGB components must be a number between¶0 and 65535.  If RGB is omitted, the specified color will never be used¶by ‘tty-color-translate’ as an approximation to another color.¶FRAME is the frame where the defined color should be used.¶If FRAME is not specified or is nil, it defaults to the selected frame.",
"tty-color-clear":"Clear the list of supported tty colors for frame FRAME.¶If FRAME is unspecified or nil, it defaults to the selected frame.",
"tty-color-alist":"Return an alist of colors supported by FRAME’s terminal.¶FRAME defaults to the selected frame.¶Each element of the returned alist is of the form:¶ (NAME INDEX R G B)¶where NAME is the name of the color, a string;¶INDEX is the index of this color to be sent to the terminal driver¶when the color should be displayed; it is typically a small integer;¶R, G, and B are the intensities of, accordingly, red, green, and blue¶components of the color, represented as numbers between 0 and 65535.¶The file ‘etc/rgb.txt’ in the Emacs distribution lists the standard¶RGB values of the X colors.  If RGB is nil, this color will not be¶considered by ‘tty-color-translate’ as an approximation to another¶color.",
"tty-color-approximate":"Find the color in ‘tty-color-alist’ that best approximates RGB.¶Value is a list of the form (NAME INDEX R G B).¶The argument RGB should be an rgb value, that is, a list of three¶integers in the 0..65535 range.¶FRAME defaults to the selected frame.",
"tty-color-translate":"Given a color COLOR, return the index of the corresponding TTY color.¶¶COLOR must be a string that is either the color’s name, or its X-style¶specification like &quot;#RRGGBB&quot; or &quot;RGB:rr/gg/bb&quot;, where each primary.¶color can be given with 1 to 4 hex digits.¶¶If COLOR is a color name that is found among supported colors in¶‘tty-color-alist’, the associated index is returned.  Otherwise, the¶RGB values of the color, either as given by the argument or from¶looking up the name in ‘color-name-rgb-alist’, are used to find the¶supported color that is the best approximation for COLOR in the RGB¶space.¶If COLOR is neither a valid X RGB specification of the color, nor a¶name of a color in ‘color-name-rgb-alist’, the returned value is nil.¶¶If FRAME is unspecified or nil, it defaults to the selected frame.",
"call-process":"Call PROGRAM synchronously in separate process.¶The remaining arguments are optional.¶The program’s input comes from file INFILE (nil means ‘/dev/null’).¶Insert output in DESTINATION before point; t means current buffer; nil for DESTINATION¶ means discard it; 0 means discard and don’t wait; and ‘(:file FILE)’, where¶ FILE is a file name string, means that it should be written to that file¶ (if the file already exists it is overwritten).¶DESTINATION can also have the form (REAL-BUFFER STDERR-FILE); in that case,¶REAL-BUFFER says what to do with standard output, as above,¶while STDERR-FILE says what to do with standard error in the child.¶STDERR-FILE may be nil (discard standard error output),¶t (mix it with ordinary output), or a file name string.¶¶Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.¶Remaining arguments are strings passed as command arguments to PROGRAM.¶¶If executable PROGRAM can’t be found as an executable, ‘call-process’¶signals a Lisp error.  ‘call-process’ reports errors in execution of¶the program only through its return and output.¶¶If DESTINATION is 0, ‘call-process’ returns immediately with value nil.¶Otherwise it waits for PROGRAM to terminate¶and returns a numeric exit status or a signal description string.¶If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.¶¶(fn PROGRAM &amp;optional INFILE DESTINATION DISPLAY &amp;rest ARGS)",
"process-file":"Process files synchronously in a separate process.¶Similar to ‘call-process’, but may invoke a file handler based on¶‘default-directory’.  The current working directory of the¶subprocess is ‘default-directory’.¶¶File names in INFILE and BUFFER are handled normally, but file¶names in ARGS should be relative to ‘default-directory’, as they¶are passed to the process verbatim.  (This is a difference to¶‘call-process’ which does not support file handlers for INFILE¶and BUFFER.)¶¶Some file handlers might not support all variants, for example¶they might behave as if DISPLAY was nil, regardless of the actual¶value passed.¶¶(fn PROGRAM &amp;optional INFILE BUFFER DISPLAY &amp;rest ARGS)",
"call-process-region":"Send text from START to END to a synchronous process running PROGRAM.¶¶START and END are normally buffer positions specifying the part of the¶buffer to send to the process.¶If START is nil, that means to use the entire buffer contents; END is¶ignored.¶If START is a string, then send that string to the process¶instead of any buffer contents; END is ignored.¶The remaining arguments are optional.¶Delete the text if fourth arg DELETE is non-nil.¶¶Insert output in BUFFER before point; t means current buffer; nil for¶ BUFFER means discard it; 0 means discard and don’t wait; and ‘(:file¶ FILE)’, where FILE is a file name string, means that it should be¶ written to that file (if the file already exists it is overwritten).¶BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,¶REAL-BUFFER says what to do with standard output, as above,¶while STDERR-FILE says what to do with standard error in the child.¶STDERR-FILE may be nil (discard standard error output),¶t (mix it with ordinary output), or a file name string.¶¶Sixth arg DISPLAY non-nil means redisplay buffer as output is inserted.¶Remaining args are passed to PROGRAM at startup as command args.¶¶If BUFFER is 0, ‘call-process-region’ returns immediately with value nil.¶Otherwise it waits for PROGRAM to terminate¶and returns a numeric exit status or a signal description string.¶If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.¶¶(fn START END PROGRAM &amp;optional DELETE BUFFER DISPLAY &amp;rest ARGS)",
"call-process-shell-command":"Execute the shell command COMMAND synchronously in separate process.¶The remaining arguments are optional.¶The program’s input comes from file INFILE (nil means ‘/dev/null’).¶Insert output in BUFFER before point; t means current buffer;¶ nil for BUFFER means discard it; 0 means discard and don’t wait.¶BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,¶REAL-BUFFER says what to do with standard output, as above,¶while STDERR-FILE says what to do with standard error in the child.¶STDERR-FILE may be nil (discard standard error output),¶t (mix it with ordinary output), or a file name string.¶¶Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.¶Wildcards and redirection are handled as usual in the shell.¶¶If BUFFER is 0, ‘call-process-shell-command’ returns immediately with value nil.¶Otherwise it waits for COMMAND to terminate and returns a numeric exit¶status or a signal description string.¶If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.¶¶An old calling convention accepted any number of arguments after DISPLAY,¶which were just concatenated to COMMAND.  This is still supported but strongly¶discouraged.¶¶(fn COMMAND &amp;optional INFILE BUFFER DISPLAY &amp;rest ARGS)",
"process-file-shell-command":"Process files synchronously in a separate process.¶Similar to ‘call-process-shell-command’, but calls ‘process-file’.¶¶(fn COMMAND &amp;optional INFILE BUFFER DISPLAY &amp;rest ARGS)",
"shell-command-to-string":"Execute shell command COMMAND and return its output as a string.¶¶(fn COMMAND)",
"process-lines":"Execute PROGRAM with ARGS, returning its output as a list of lines.¶Signal an error if the program returns with a non-zero exit status.¶¶(fn PROGRAM &amp;rest ARGS)",
"current-kill":"Rotate the yanking point by N places, and then return that kill.¶If N is zero and ‘interprogram-paste-function’ is set to a¶function that returns a string or a list of strings, and if that¶function doesn’t return nil, then that string (or list) is added¶to the front of the kill ring and the string (or first string in¶the list) is returned as the latest kill.¶¶If N is not zero, and if ‘yank-pop-change-selection’ is¶non-nil, use ‘interprogram-cut-function’ to transfer the¶kill at the new yank point into the window system selection.¶¶If optional arg DO-NOT-MOVE is non-nil, then don’t actually¶move the yanking point; just return the Nth kill forward.¶¶(fn N &amp;optional DO-NOT-MOVE)",
"kill-new":"Make STRING the latest kill in the kill ring.¶Set ‘kill-ring-yank-pointer’ to point to it.¶If ‘interprogram-cut-function’ is non-nil, apply it to STRING.¶Optional second argument REPLACE non-nil means that STRING will replace¶the front of the kill ring, rather than being added to the list.¶¶When ‘save-interprogram-paste-before-kill’ and ‘interprogram-paste-function’¶are non-nil, saves the interprogram paste string(s) into ‘kill-ring’ before¶STRING.¶¶When the yank handler has a non-nil PARAM element, the original STRING¶argument is not used by ‘insert-for-yank’.  However, since Lisp code¶may access and use elements from the kill ring directly, the STRING¶argument should still be a &quot;useful&quot; string for such uses.¶¶(fn STRING &amp;optional REPLACE)",
"kill-append":"Append STRING to the end of the latest kill in the kill ring.¶If BEFORE-P is non-nil, prepend STRING to the kill.¶Also removes the last undo boundary in the current buffer,¶ depending on ‘kill-append-merge-undo’.¶If ‘interprogram-cut-function’ is set, pass the resulting kill to it.¶¶(fn STRING BEFORE-P)",
"symbol-function":"Return SYMBOL’s function definition, or nil if that is void.¶¶(fn SYMBOL)",
"fboundp":"Return t if SYMBOL’s function definition is not void.¶¶(fn SYMBOL)",
"fmakunbound":"Make SYMBOL’s function definition be nil.¶Return SYMBOL.¶¶(fn SYMBOL)",
"fset":"Set SYMBOL’s function definition to DEFINITION, and return DEFINITION.¶¶(fn SYMBOL DEFINITION)",
"hack-local-variables":"Parse and put into effect this buffer’s local variables spec.¶Uses ‘hack-local-variables-apply’ to apply the variables.¶¶If MODE-ONLY is non-nil, all we do is check whether a &quot;mode:&quot;¶is specified, and return the corresponding mode symbol, or nil.¶In this case, we try to ignore minor-modes, and only return a¶major-mode.¶¶If ‘enable-local-variables’ or ‘local-enable-local-variables’ is nil,¶this function does nothing.  If ‘inhibit-local-variables-regexps’¶applies to the file in question, the file is not scanned for¶local variables, but directory-local variables may still be applied.¶¶(fn &amp;optional MODE-ONLY)",
"safe-local-variable-p":"Non-nil if SYM is safe as a file-local variable with value VAL.¶It is safe if any of these conditions are met:¶¶ * There is a matching entry (SYM . VAL) in the¶   ‘safe-local-variable-values’ user option.¶¶ * The ‘safe-local-variable’ property of SYM is a function that¶   evaluates to a non-nil value with VAL as an argument.¶¶(fn SYM VAL)",
"risky-local-variable-p":"Non-nil if SYM could be dangerous as a file-local variable.¶It is dangerous if either of these conditions are met:¶¶ * Its ‘risky-local-variable’ property is non-nil.¶¶ * Its name ends with &quot;hook(s)&quot;, &quot;function(s)&quot;, &quot;form(s)&quot;, &quot;map&quot;,¶   &quot;program&quot;, &quot;command(s)&quot;, &quot;predicate(s)&quot;, &quot;frame-alist&quot;,¶   &quot;mode-alist&quot;, &quot;font-lock-(syntactic-)keyword*&quot;,¶   &quot;map-alist&quot;, or &quot;bindat-spec&quot;.¶¶(fn SYM &amp;optional IGNORED)",
"keymapp":"Return t if OBJECT is a keymap.¶¶A keymap is a list (keymap . ALIST),¶or a symbol whose function definition is itself a keymap.¶ALIST elements look like (CHAR . DEFN) or (SYMBOL . DEFN);¶a vector of densely packed bindings for small character codes¶is also allowed as an element.¶¶(fn OBJECT)",
"select-safe-coding-system":"Ask a user to select a safe coding system from candidates.¶The candidates of coding systems which can safely encode a text¶between FROM and TO are shown in a popup window.  Among them, the most¶proper one is suggested as the default.¶¶The list of ‘buffer-file-coding-system’ of the current buffer, the¶default ‘buffer-file-coding-system’, and the most preferred coding¶system (if it corresponds to a MIME charset) is treated as the¶default coding system list.  Among them, the first one that safely¶encodes the text is normally selected silently and returned without¶any user interaction.  See also the command ‘prefer-coding-system’.¶¶However, the user is queried if the chosen coding system is¶inconsistent with what would be selected by ‘find-auto-coding’ from¶coding cookies &amp;c. if the contents of the region were read from a¶file.  (That could lead to data corruption in a file subsequently¶re-visited and edited.)¶¶Optional 3rd arg DEFAULT-CODING-SYSTEM specifies a coding system or a¶list of coding systems to be prepended to the default coding system¶list.  However, if DEFAULT-CODING-SYSTEM is a list and the first¶element is t, the cdr part is used as the default coding system list,¶i.e. current ‘buffer-file-coding-system’, default ‘buffer-file-coding-system’,¶and the most preferred coding system are not used.¶¶Optional 4th arg ACCEPT-DEFAULT-P, if non-nil, is a function to¶determine the acceptability of the silently selected coding system.¶It is called with that coding system, and should return nil if it¶should not be silently selected and thus user interaction is required.¶¶Optional 5th arg FILE is the file name to use for this purpose.¶That is different from ‘buffer-file-name’ when handling ‘write-region’¶(for example).¶¶The variable ‘select-safe-coding-system-accept-default-p’, if non-nil,¶overrides ACCEPT-DEFAULT-P.¶¶Kludgy feature: if FROM is a string, the string is the target text,¶and TO is ignored.¶¶(fn FROM TO &amp;optional DEFAULT-CODING-SYSTEM ACCEPT-DEFAULT-P FILE)",
"read-coding-system":"Read a coding system from the minibuffer, prompting with string PROMPT.¶If the user enters null input, return second argument DEFAULT-CODING-SYSTEM.¶Ignores case when completing coding systems (all Emacs coding systems¶are lower-case).¶¶(fn PROMPT &amp;optional DEFAULT-CODING-SYSTEM)",
"read-non-nil-coding-system":"Read a coding system from the minibuffer, prompting with string PROMPT.¶¶(fn PROMPT)",
"current-time-string":"Return the current local time, as a human-readable string.¶Programs can use this function to decode a time,¶since the number of columns in each field is fixed¶if the year is in the range 1000-9999.¶The format is ‘Sun Sep 16 01:03:52 1973’.¶However, see also the functions ‘decode-time’ and ‘format-time-string’¶which provide a much more powerful and general facility.¶¶If SPECIFIED-TIME is given, it is a time to format instead of the¶current time.  The argument should have the form (HIGH LOW . IGNORED).¶Thus, you can use times obtained from ‘current-time’ and from¶‘file-attributes’.  SPECIFIED-TIME can also have the form (HIGH . LOW),¶but this is considered obsolete.¶¶The optional ZONE is omitted or nil for Emacs local time, t for¶Universal Time, ‘wall’ for system wall clock time, or a string as in¶the TZ environment variable.¶¶(fn &amp;optional SPECIFIED-TIME ZONE)",
"current-time":"Return the current time, as the number of seconds since 1970-01-01 00:00:00.¶The time is returned as a list of integers (HIGH LOW USEC PSEC).¶HIGH has the most significant bits of the seconds, while LOW has the¶least significant 16 bits.  USEC and PSEC are the microsecond and¶picosecond counts.¶¶(fn)",
"float-time":"Return the current time, as a float number of seconds since the epoch.¶If SPECIFIED-TIME is given, it is the time to convert to float¶instead of the current time.  The argument should have the form¶(HIGH LOW) or (HIGH LOW USEC) or (HIGH LOW USEC PSEC).  Thus,¶you can use times from ‘current-time’ and from ‘file-attributes’.¶SPECIFIED-TIME can also have the form (HIGH . LOW), but this is¶considered obsolete.¶¶WARNING: Since the result is floating point, it may not be exact.¶If precise time stamps are required, use either ‘current-time’,¶or (if you need time as a string) ‘format-time-string’.¶¶(fn &amp;optional SPECIFIED-TIME)",
"seconds-to-time":"Convert SECONDS to a time value.",
"set-default-file-modes":"Set the file permission bits for newly created files.¶The argument MODE should be an integer; only the low 9 bits are used.¶This setting is inherited by subprocesses.¶¶(fn MODE)",
"default-file-modes":"Return the default file protection for created files.¶The value is an integer.¶¶(fn)",
"read-file-modes":"Read file modes in octal or symbolic notation and return its numeric value.¶PROMPT is used as the prompt, default to &quot;File modes (octal or symbolic): &quot;.¶ORIG-FILE is the name of a file on whose mode bits to base returned¶permissions if what user types requests to add, remove, or set permissions¶based on existing mode bits, as in &quot;og+rX-w&quot;.¶¶(fn &amp;optional PROMPT ORIG-FILE)",
"file-modes-symbolic-to-number":"Convert symbolic file modes to numeric file modes.¶MODES is the string to convert, it should match¶&quot;[ugoa]*([+-=][rwxXstugo]*)+,...&quot;.¶See Info node ‘(coreutils)File permissions’ for more information on this¶notation.¶FROM (or 0 if nil) gives the mode bits on which to base permissions if¶MODES request to add, remove, or set permissions based on existing ones,¶as in &quot;og+rX-w&quot;.¶¶(fn MODES &amp;optional FROM)",
"set-file-times":"Set times of file FILENAME to TIMESTAMP.¶Set both access and modification times.¶Return t on success, else nil.¶Use the current time if TIMESTAMP is nil.  TIMESTAMP is in the format of¶‘current-time’.¶¶(fn FILENAME &amp;optional TIMESTAMP)",
"set-file-extended-attributes":"Set extended attributes of file FILENAME to ATTRIBUTES.¶¶ATTRIBUTES must be an alist of file attributes as returned by¶‘file-extended-attributes’.¶Value is t if the function succeeds in setting the attributes.¶¶(fn FILENAME ATTRIBUTES)",
"set-file-selinux-context":"Set SELinux context of file named FILENAME to CONTEXT.¶CONTEXT should be a list (USER ROLE TYPE RANGE), where the list¶elements are strings naming the components of a SELinux context.¶¶Value is t if setting of SELinux context was successful, nil otherwise.¶¶This function does nothing and returns nil if SELinux is disabled,¶or if Emacs was not compiled with SELinux support.¶¶(fn FILENAME CONTEXT)",
"set-file-acl":"Set ACL of file named FILENAME to ACL-STRING.¶ACL-STRING should contain the textual representation of the ACL¶entries in a format suitable for the platform.¶¶Value is t if setting of ACL was successful, nil otherwise.¶¶Setting ACL for local files requires Emacs to be built with ACL¶support.¶¶(fn FILENAME ACL-STRING)",
"current-left-margin":"Return the left margin to use for this line.¶This is the value of the buffer-local variable ‘left-margin’ plus the value¶of the ‘left-margin’ text-property at the start of the line.",
"current-fill-column":"Return the fill-column to use for this line.¶The fill-column to use for a buffer is stored in the variable ‘fill-column’,¶but can be locally modified by the ‘right-margin’ text property, which is¶subtracted from ‘fill-column’.¶¶The fill column to use for a line is the first column at which the column¶number equals or exceeds the local fill-column - right-margin difference.",
"delete-to-left-margin":"Remove left margin indentation from a region.¶This deletes to the column given by ‘current-left-margin’.¶In no case will it delete non-whitespace.¶Args FROM and TO are optional; default is the whole buffer.¶¶(fn &amp;optional FROM TO)",
"indent-to-left-margin":"Indent current line to the column given by ‘current-left-margin’.",
"sort-subr":"General text sorting routine to divide buffer into records and sort them.¶¶We divide the accessible portion of the buffer into disjoint pieces¶called sort records.  A portion of each sort record (perhaps all of¶it) is designated as the sort key.  The records are rearranged in the¶buffer in order by their sort keys.  The records may or may not be¶contiguous.¶¶Usually the records are rearranged in order of ascending sort key.¶If REVERSE is non-nil, they are rearranged in order of descending sort key.¶The variable ‘sort-fold-case’ determines whether alphabetic case affects¶the sort order.¶¶The next four arguments are functions to be called to move point¶across a sort record.  They will be called many times from within sort-subr.¶¶NEXTRECFUN is called with point at the end of the previous record.¶It moves point to the start of the next record.¶It should move point to the end of the buffer if there are no more records.¶The first record is assumed to start at the position of point when sort-subr¶is called.¶¶ENDRECFUN is called with point within the record.¶It should move point to the end of the record.¶¶STARTKEYFUN moves from the start of the record to the start of the key.¶It may return either a non-nil value to be used as the key, or¶else the key is the substring between the values of point after¶STARTKEYFUN and ENDKEYFUN are called.  If STARTKEYFUN is nil, the key¶starts at the beginning of the record.¶¶ENDKEYFUN moves from the start of the sort key to the end of the sort key.¶ENDKEYFUN may be nil if STARTKEYFUN returns a value or if it would be the¶same as ENDRECFUN.¶¶PREDICATE, if non-nil, is the predicate function for comparing¶keys; it is called with two arguments, the keys to compare, and¶should return non-nil if the first key should sort before the¶second key.  If PREDICATE is nil, comparison is done with ‘&lt;’ if¶the keys are numbers, with ‘compare-buffer-substrings’ if the¶keys are cons cells (the car and cdr of each cons cell are taken¶as start and end positions), and with ‘string&lt;’ otherwise.¶¶(fn REVERSE NEXTRECFUN ENDRECFUN &amp;optional STARTKEYFUN ENDKEYFUN PREDICATE)",
"backup-file-name-p":"Return non-nil if FILE is a backup file name (numeric or not).¶This is a separate function so you can redefine it for customization.¶You may need to redefine ‘file-name-sans-versions’ as well.¶¶(fn FILE)",
"make-backup-file-name":"Create the non-numeric backup file name for FILE.¶This calls the function that ‘make-backup-file-name-function’ specifies,¶with a single argument FILE.¶¶(fn FILE)",
"find-backup-file-name":"Find a file name for a backup file FN, and suggestions for deletions.¶Value is a list whose car is the name for the backup file¶and whose cdr is a list of old versions to consider deleting now.¶If the value is nil, don’t make a backup.¶Uses ‘backup-directory-alist’ in the same way as¶‘make-backup-file-name--default-function’ does.¶¶(fn FN)",
"file-newest-backup":"Return most recent backup file for FILENAME or nil if no backups exist.¶¶(fn FILENAME)",
"locate-user-emacs-file":"Return an absolute per-user Emacs-specific file name.¶If NEW-NAME exists in ‘user-emacs-directory’, return it.¶Else if OLD-NAME is non-nil and ~/OLD-NAME exists, return ~/OLD-NAME.¶Else return NEW-NAME in ‘user-emacs-directory’, creating the¶directory if it does not exist.¶¶(fn NEW-NAME &amp;optional OLD-NAME)",
"convert-standard-filename":"Convert a standard file’s name to something suitable for the OS.¶This means to guarantee valid names and perhaps to canonicalize¶certain patterns.¶¶FILENAME should be an absolute file name since the conversion rules¶sometimes vary depending on the position in the file name.  E.g. c:/foo¶is a valid DOS file name, but c:/bar/c:/foo is not.¶¶This function’s standard definition is trivial; it just returns¶the argument.  However, on Windows and DOS, replace invalid¶characters.  On DOS, make sure to obey the 8.3 limitations.¶In the native Windows build, turn Cygwin names into native names,¶and also turn slashes into backslashes if the shell requires it (see¶‘w32-shell-dos-semantics’).¶¶See Info node ‘(elisp)Standard File Names’ for more details.¶¶(fn FILENAME)",
"add-hook":"Add to the value of HOOK the function FUNCTION.¶FUNCTION is not added if already present.¶FUNCTION is added (if necessary) at the beginning of the hook list¶unless the optional argument APPEND is non-nil, in which case¶FUNCTION is added at the end.¶¶The optional fourth argument, LOCAL, if non-nil, says to modify¶the hook’s buffer-local value rather than its global value.¶This makes the hook buffer-local, and it makes t a member of the¶buffer-local value.  That acts as a flag to run the hook¶functions of the global value as well as in the local value.¶¶HOOK should be a symbol, and FUNCTION may be any valid function.  If¶HOOK is void, it is first set to nil.  If HOOK’s value is a single¶function, it is changed to a list of functions.¶¶(fn HOOK FUNCTION &amp;optional APPEND LOCAL)",
"remove-hook":"Remove from the value of HOOK the function FUNCTION.¶HOOK should be a symbol, and FUNCTION may be any valid function.  If¶FUNCTION isn’t the value of HOOK, or, if FUNCTION doesn’t appear in the¶list of hooks to run in HOOK, then nothing is done.  See ‘add-hook’.¶¶The optional third argument, LOCAL, if non-nil, says to modify¶the hook’s buffer-local value rather than its default value.¶¶(fn HOOK FUNCTION &amp;optional LOCAL)",
"error-message-string":"Convert an error value (ERROR-SYMBOL . DATA) to an error message.¶See Info anchor ‘(elisp)Definition of signal’ for some details on how this¶error message is constructed.¶¶(fn OBJ)",
"window-point":"Return current value of point in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶For a nonselected window, this is the value point would have if that¶window were selected.¶¶Note that, when WINDOW is selected, the value returned is the same as¶that returned by ‘point’ for WINDOW’s buffer.  It would be more strictly¶correct to return the top-level value of ‘point’, outside of any¶‘save-excursion’ forms.  But that is hard to define.¶¶(fn &amp;optional WINDOW)",
"set-window-point":"Make point value in WINDOW be at position POS in WINDOW’s buffer.¶WINDOW must be a live window and defaults to the selected one.¶Return POS.¶¶(fn WINDOW POS)",
"quit-restore-window":"Quit WINDOW and deal with its buffer.¶WINDOW must be a live window and defaults to the selected one.¶¶According to information stored in WINDOW’s ‘quit-restore’ window¶parameter either (1) delete WINDOW and its frame, (2) delete¶WINDOW, (3) restore the buffer previously displayed in WINDOW,¶or (4) make WINDOW display some other buffer than the present¶one.  If non-nil, reset ‘quit-restore’ parameter to nil.¶¶Optional second argument BURY-OR-KILL tells how to proceed with¶the buffer of WINDOW.  The following values are handled:¶¶nil means to not handle the buffer in a particular way.  This¶  means that if WINDOW is not deleted by this function, invoking¶  ‘switch-to-prev-buffer’ will usually show the buffer again.¶¶‘append’ means that if WINDOW is not deleted, move its buffer to¶  the end of WINDOW’s previous buffers so it’s less likely that a¶  future invocation of ‘switch-to-prev-buffer’ will switch to it.¶  Also, move the buffer to the end of the frame’s buffer list.¶¶‘bury’ means that if WINDOW is not deleted, remove its buffer¶  from WINDOW’S list of previous buffers.  Also, move the buffer¶  to the end of the frame’s buffer list.  This value provides the¶  most reliable remedy to not have ‘switch-to-prev-buffer’ switch¶  to this buffer again without killing the buffer.¶¶‘kill’ means to kill WINDOW’s buffer.",
"x-parse-geometry":"Parse a display geometry string STRING.¶Returns an alist of the form ((top . TOP), (left . LEFT) ... ).¶The properties returned may include ‘top’, ‘left’, ‘height’, and ‘width’.¶For X, the value of ‘left’ or ‘top’ may be an integer,¶or a list (+ N) meaning N pixels relative to top/left corner,¶or a list (- N) meaning -N pixels relative to bottom/right corner.¶On Nextstep, this just calls ‘ns-parse-geometry’.¶¶(fn STRING)",
"process-list":"Return a list of all processes that are Emacs sub-processes.¶¶(fn)",
"get-process":"Return the process named NAME, or nil if there is none.¶¶(fn NAME)",
"process-command":"Return the command that was executed to start PROCESS.¶This is a list of strings, the first string being the program executed¶and the rest of the strings being the arguments given to it.¶For a network or serial or pipe connection, this is nil (process is running)¶or t (process is stopped).¶¶(fn PROCESS)",
"process-contact":"Return the contact info of PROCESS; t for a real child.¶For a network or serial or pipe connection, the value depends on the¶optional KEY arg.  If KEY is nil, value is a cons cell of the form¶(HOST SERVICE) for a network connection or (PORT SPEED) for a serial¶connection; it is t for a pipe connection.  If KEY is t, the complete¶contact information for the connection is returned, else the specific¶value for the keyword KEY is returned.  See ‘make-network-process’,¶‘make-serial-process’, or ‘make-pipe-process’ for the list of keywords.¶¶(fn PROCESS &amp;optional KEY)",
"process-id":"Return the process id of PROCESS.¶This is the pid of the external process which PROCESS uses or talks to.¶For a network, serial, and pipe connections, this value is nil.¶¶(fn PROCESS)",
"process-name":"Return the name of PROCESS, as a string.¶This is the name of the program invoked in PROCESS,¶possibly modified to make it unique among process names.¶¶(fn PROCESS)",
"process-status":"Return the status of PROCESS.¶The returned value is one of the following symbols:¶run  -- for a process that is running.¶stop -- for a process stopped but continuable.¶exit -- for a process that has exited.¶signal -- for a process that has got a fatal signal.¶open -- for a network stream connection that is open.¶listen -- for a network stream server that is listening.¶closed -- for a network stream connection that is closed.¶connect -- when waiting for a non-blocking connection to complete.¶failed -- when a non-blocking connection has failed.¶nil -- if arg is a process name and no such process exists.¶PROCESS may be a process, a buffer, the name of a process, or¶nil, indicating the current buffer’s process.¶¶(fn PROCESS)",
"process-live-p":"Returns non-nil if PROCESS is alive.¶A process is considered alive if its status is ‘run’, ‘open’,¶‘listen’, ‘connect’ or ‘stop’.  Value is nil if PROCESS is not a¶process.¶¶(fn PROCESS)",
"process-type":"Return the connection type of PROCESS.¶The value is either the symbol ‘real’, ‘network’, ‘serial’, or ‘pipe’.¶PROCESS may be a process, a buffer, the name of a process or buffer, or¶nil, indicating the current buffer’s process.¶¶(fn PROCESS)",
"process-exit-status":"Return the exit status of PROCESS or the signal number that killed it.¶If PROCESS has not yet exited or died, return 0.¶¶(fn PROCESS)",
"process-tty-name":"Return the name of the terminal PROCESS uses, or nil if none.¶This is the terminal that the process itself reads and writes on,¶not the name of the pty that Emacs uses to talk with that terminal.¶¶(fn PROCESS)",
"process-coding-system":"Return a cons of coding systems for decoding and encoding of PROCESS.¶¶(fn PROCESS)",
"set-process-coding-system":"Set coding systems of PROCESS to DECODING and ENCODING.¶DECODING will be used to decode subprocess output and ENCODING to¶encode subprocess input.¶¶(fn PROCESS &amp;optional DECODING ENCODING)",
"process-get":"Return the value of PROCESS’ PROPNAME property.¶This is the last value stored with ‘(process-put PROCESS PROPNAME VALUE)’.¶¶(fn PROCESS PROPNAME)",
"process-put":"Change PROCESS’ PROPNAME property to VALUE.¶It can be retrieved with ‘(process-get PROCESS PROPNAME)’.¶¶(fn PROCESS PROPNAME VALUE)",
"process-plist":"Return the plist of PROCESS.¶¶(fn PROCESS)",
"set-process-plist":"Replace the plist of PROCESS with PLIST.  Returns PLIST.¶¶(fn PROCESS PLIST)",
"keyboard-translate":"Translate character FROM to TO on the current terminal.¶This function creates a ‘keyboard-translate-table’ if necessary¶and then modifies one entry in it.¶¶(fn FROM TO)",
"execute-kbd-macro":"Execute MACRO as string of editor command characters.¶MACRO can also be a vector of keyboard events.  If MACRO is a symbol,¶its function definition is used.¶COUNT is a repeat count, or nil for once, or 0 for infinite loop.¶¶Optional third arg LOOPFUNC may be a function that is called prior to¶each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.¶¶(fn MACRO &amp;optional COUNT LOOPFUNC)",
"date-to-time":"Parse a string DATE that represents a date-time and return a time value.¶If DATE lacks timezone information, GMT is assumed.",
"format-time-string":"Use FORMAT-STRING to format the time TIME, or now if omitted.¶TIME is specified as (HIGH LOW USEC PSEC), as returned by¶‘current-time’ or ‘file-attributes’.  The obsolete form (HIGH . LOW)¶is also still accepted.  The optional ZONE is omitted or nil for Emacs¶local time, t for Universal Time, ‘wall’ for system wall clock time,¶or a string as in the TZ environment variable.¶¶The value is a copy of FORMAT-STRING, but with certain constructs replaced¶by text that describes the specified date and time in TIME:¶¶%Y is the year, %y within the century, %C the century.¶%G is the year corresponding to the ISO week, %g within the century.¶%m is the numeric month.¶%b and %h are the locale’s abbreviated month name, %B the full name.¶ (%h is not supported on MS-Windows.)¶%d is the day of the month, zero-padded, %e is blank-padded.¶%u is the numeric day of week from 1 (Monday) to 7, %w from 0 (Sunday) to 6.¶%a is the locale’s abbreviated name of the day of week, %A the full name.¶%U is the week number starting on Sunday, %W starting on Monday,¶ %V according to ISO 8601.¶%j is the day of the year.¶¶%H is the hour on a 24-hour clock, %I is on a 12-hour clock, %k is like %H¶ only blank-padded, %l is like %I blank-padded.¶%p is the locale’s equivalent of either AM or PM.¶%M is the minute.¶%S is the second.¶%N is the nanosecond, %6N the microsecond, %3N the millisecond, etc.¶%Z is the time zone name, %z is the numeric form.¶%s is the number of seconds since 1970-01-01 00:00:00 +0000.¶¶%c is the locale’s date and time format.¶%x is the locale’s &quot;preferred&quot; date format.¶%D is like &quot;%m/%d/%y&quot;.¶%F is the ISO 8601 date format (like &quot;%Y-%m-%d&quot;).¶¶%R is like &quot;%H:%M&quot;, %T is like &quot;%H:%M:%S&quot;, %r is like &quot;%I:%M:%S %p&quot;.¶%X is the locale’s &quot;preferred&quot; time format.¶¶Finally, %n is a newline, %t is a tab, %% is a literal %.¶¶Certain flags and modifiers are available with some format controls.¶The flags are ‘_’, ‘-’, ‘^’ and ‘#’.  For certain characters X,¶%_X is like %X, but padded with blanks; %-X is like %X,¶but without padding.  %^X is like %X, but with all textual¶characters up-cased; %#X is like %X, but with letter-case of¶all textual characters reversed.¶%NX (where N stands for an integer) is like %X,¶but takes up at least N (a number) positions.¶The modifiers are ‘E’ and ‘O’.  For certain characters X,¶%EX is a locale’s alternative version of %X;¶%OX is like %X, but uses the locale’s number symbols.¶¶For example, to produce full ISO 8601 format, use &quot;%FT%T%z&quot;.¶¶(fn FORMAT-STRING &amp;optional TIME ZONE)",
"format-seconds":"Use format control STRING to format the number SECONDS.¶The valid format specifiers are:¶%y is the number of (365-day) years.¶%d is the number of days.¶%h is the number of hours.¶%m is the number of minutes.¶%s is the number of seconds.¶%z is a non-printing control flag (see below).¶%% is a literal &quot;%&quot;.¶¶Upper-case specifiers are followed by the unit-name (e.g. &quot;years&quot;).¶Lower-case specifiers return only the unit.¶¶&quot;%&quot; may be followed by a number specifying a width, with an¶optional leading &quot;.&quot; for zero-padding.  For example, &quot;%.3Y&quot; will¶return something of the form &quot;001 year&quot;.¶¶The &quot;%z&quot; specifier does not print anything.  When it is used, specifiers¶must be given in order of decreasing size.  To the left of &quot;%z&quot;, nothing¶is output until the first non-zero unit is encountered.¶¶This function does not work for SECONDS greater than ‘most-positive-fixnum’.",
"make-ring":"Make a ring that can contain SIZE elements.",
"ring-p":"Return t if X is a ring; nil otherwise.",
"ring-size":"Return the size of RING, the maximum number of elements it can contain.",
"ring-length":"Return the number of elements in the RING.",
"ring-elements":"Return a list of the elements of RING, in order, newest first.",
"ring-copy":"Return a copy of RING.",
"ring-empty-p":"Return t if RING is empty; nil otherwise.",
"ring-ref":"Return RING’s INDEX element.¶INDEX = 0 is the most recently inserted; higher indices¶correspond to older elements.¶INDEX need not be &lt;= the ring length; the appropriate modulo operation¶will be performed.",
"ring-insert":"Insert onto ring RING the item ITEM, as the newest (last) item.¶If the ring is full, dump the oldest item to make room.",
"ring-remove":"Remove an item from the RING.  Return the removed item.¶If optional INDEX is nil, remove the oldest item.  If it’s¶numeric, remove the element indexed.",
"ring-insert-at-beginning":"Add to RING the item ITEM, at the front, as the oldest item.",
"set-window-combination-limit":"Set combination limit of window WINDOW to LIMIT; return LIMIT.¶WINDOW must be a valid window used in horizontal or vertical combination.¶If LIMIT is nil, child windows of WINDOW can be recombined with WINDOW’s¶siblings.  LIMIT t means that child windows of WINDOW are never¶(re-)combined with WINDOW’s siblings.  Other values are reserved for¶future use.¶¶(fn WINDOW LIMIT)",
"window-combination-limit":"Return combination limit of window WINDOW.¶WINDOW must be a valid window used in horizontal or vertical combination.¶If the return value is nil, child windows of WINDOW can be recombined with¶WINDOW’s siblings.  A return value of t means that child windows of¶WINDOW are never (re-)combined with WINDOW’s siblings.¶¶(fn WINDOW)",
"regexp-quote":"Return a regexp string which matches exactly STRING and nothing else.¶¶(fn STRING)",
"regexp-opt":"Return a regexp to match a string in the list STRINGS.¶Each string should be unique in STRINGS and should not contain¶any regexps, quoted or not.  Optional PAREN specifies how the¶returned regexp is surrounded by grouping constructs.¶¶The optional argument PAREN can be any of the following:¶¶a string¶    the resulting regexp is preceded by PAREN and followed by¶    ⧷), e.g.  use &quot;⧷⧷(?1:&quot; to produce an explicitly numbered¶    group.¶¶‘words’¶    the resulting regexp is surrounded by ⧷&lt;⧷( and ⧷)⧷&gt;.¶¶‘symbols’¶    the resulting regexp is surrounded by ⧷_&lt;⧷( and ⧷)⧷_&gt;.¶¶non-nil¶    the resulting regexp is surrounded by ⧷( and ⧷).¶¶nil¶    the resulting regexp is surrounded by ⧷(?: and ⧷), if it is¶    necessary to ensure that a postfix operator appended to it will¶    apply to the whole expression.¶¶The resulting regexp is equivalent to but usually more efficient¶than that of a simplified version:¶¶ (defun simplified-regexp-opt (strings &amp;optional paren)¶   (let ((parens¶          (cond ((stringp paren)       (cons paren &quot;⧷⧷)&quot;))¶                ((eq paren ’words)    ’(&quot;⧷⧷&lt;⧷⧷(&quot; . &quot;⧷⧷)⧷⧷&gt;&quot;))¶                ((eq paren ’symbols) ’(&quot;⧷⧷_&lt;⧷⧷(&quot; . &quot;⧷⧷)⧷⧷_&gt;&quot;))¶                ((null paren)          ’(&quot;⧷⧷(?:&quot; . &quot;⧷⧷)&quot;))¶                (t                       ’(&quot;⧷⧷(&quot; . &quot;⧷⧷)&quot;)))))¶     (concat (car paren)¶             (mapconcat ’regexp-quote strings &quot;⧷⧷|&quot;)¶             (cdr paren))))",
"regexp-opt-depth":"Return the depth of REGEXP.¶This means the number of non-shy regexp grouping constructs¶(parenthesized expressions) in REGEXP.",
"regexp-opt-charset":"Return a regexp to match a character in CHARS.¶CHARS should be a list of characters.",
"provide":"Announce that FEATURE is a feature of the current Emacs.¶The optional argument SUBFEATURES should be a list of symbols listing¶particular subfeatures supported in this version of FEATURE.¶¶(fn FEATURE &amp;optional SUBFEATURES)",
"require":"If feature FEATURE is not loaded, load it from FILENAME.¶If FEATURE is not a member of the list ‘features’, then the feature is¶not loaded; so load the file FILENAME.¶¶If FILENAME is omitted, the printname of FEATURE is used as the file¶name, and ‘load’ will try to load this name appended with the suffix¶‘.elc’, ‘.el’, or the system-dependent suffix for dynamic module¶files, in that order.  The name without appended suffix will not be¶used.  See ‘get-load-suffixes’ for the complete list of suffixes.¶¶The directories in ‘load-path’ are searched when trying to find the¶file name.¶¶If the optional third argument NOERROR is non-nil, then return nil if¶the file is not found instead of signaling an error.  Normally the¶return value is FEATURE.¶¶The normal messages at start and end of loading FILENAME are¶suppressed.¶¶(fn FEATURE &amp;optional FILENAME NOERROR)",
"featurep":"Return t if FEATURE is present in this Emacs.¶¶Use this to conditionalize execution of lisp code based on the¶presence or absence of Emacs or environment extensions.¶Use ‘provide’ to declare that a feature is available.  This function¶looks at the value of the variable ‘features’.  The optional argument¶SUBFEATURE can be used to check a specific subfeature of FEATURE.¶¶(fn FEATURE &amp;optional SUBFEATURE)",
"backup-buffer":"Make a backup of the disk file visited by the current buffer, if appropriate.¶This is normally done before saving the buffer the first time.¶¶A backup may be done by renaming or by copying; see documentation of¶variable ‘make-backup-files’.  If it’s done by renaming, then the file is¶no longer accessible under its old name.¶¶The value is non-nil after a backup was made by renaming.¶It has the form (MODES EXTENDED-ATTRIBUTES BACKUPNAME).¶MODES is the result of ‘file-modes’ on the original¶file; this means that the caller, after saving the buffer, should change¶the modes of the new file to agree with the old modes.¶EXTENDED-ATTRIBUTES is the result of ‘file-extended-attributes’¶on the original file; this means that the caller, after saving¶the buffer, should change the extended attributes of the new file¶to agree with the old attributes.¶BACKUPNAME is the backup file name, which is the old file renamed.",
"event-modifiers":"Return a list of symbols representing the modifier keys in event EVENT.¶The elements of the list may include ‘meta’, ‘control’,¶‘shift’, ‘hyper’, ‘super’, ‘alt’, ‘click’, ‘double’, ‘triple’, ‘drag’,¶and ‘down’.¶EVENT may be an event or an event type.  If EVENT is a symbol¶that has never been used in an event that has been read as input¶in the current Emacs session, then this function may fail to include¶the ‘click’ modifier.¶¶(fn EVENT)",
"event-basic-type":"Return the basic type of the given event (all modifiers removed).¶The value is a printing character (not upper case) or a symbol.¶EVENT may be an event or an event type.  If EVENT is a symbol¶that has never been used in an event that has been read as input¶in the current Emacs session, then this function may return nil.¶¶(fn EVENT)",
"mouse-movement-p":"Return non-nil if OBJECT is a mouse movement event.¶¶(fn OBJECT)",
"event-convert-list":"Convert the event description list EVENT-DESC to an event type.¶EVENT-DESC should contain one base event type (a character or symbol)¶and zero or more modifier names (control, meta, hyper, super, shift, alt,¶drag, down, double or triple).  The base must be last.¶The return value is an event type (a character or symbol) which¶has the same base event type and all the specified modifiers.¶¶(fn EVENT-DESC)",
"read-key-sequence":"Read a sequence of keystrokes and return as a string or vector.¶The sequence is sufficient to specify a non-prefix command in the¶current local and global maps.¶¶First arg PROMPT is a prompt string.  If nil, do not prompt specially.¶Second (optional) arg CONTINUE-ECHO, if non-nil, means this key echos¶as a continuation of the previous key.¶¶The third (optional) arg DONT-DOWNCASE-LAST, if non-nil, means do not¶convert the last event to lower case.  (Normally any upper case event¶is converted to lower case if the original event is undefined and the lower¶case equivalent is defined.)  A non-nil value is appropriate for reading¶a key sequence to be defined.¶¶A C-g typed while in this function is treated like any other character,¶and ‘quit-flag’ is not set.¶¶If the key sequence starts with a mouse click, then the sequence is read¶using the keymaps of the buffer of the window clicked in, not the buffer¶of the selected window as normal.¶¶‘read-key-sequence’ drops unbound button-down events, since you normally¶only care about the click or drag events which follow them.  If a drag¶or multi-click event is unbound, but the corresponding click event would¶be bound, ‘read-key-sequence’ turns the event into a click event at the¶drag’s starting position.  This means that you don’t have to distinguish¶between click and drag, double, or triple events unless you want to.¶¶‘read-key-sequence’ prefixes mouse events on mode lines, the vertical¶lines separating windows, and scroll bars with imaginary keys¶‘mode-line’, ‘vertical-line’, and ‘vertical-scroll-bar’.¶¶Optional fourth argument CAN-RETURN-SWITCH-FRAME non-nil means that this¶function will process a switch-frame event if the user switches frames¶before typing anything.  If the user switches frames in the middle of a¶key sequence, or at the start of the sequence but CAN-RETURN-SWITCH-FRAME¶is nil, then the event will be put off until after the current key sequence.¶¶‘read-key-sequence’ checks ‘function-key-map’ for function key¶sequences, where they wouldn’t conflict with ordinary bindings.  See¶‘function-key-map’ for more details.¶¶The optional fifth argument CMD-LOOP, if non-nil, means¶that this key sequence is being read by something that will¶read commands one after another.  It should be nil if the caller¶will read just one key sequence.¶¶(fn PROMPT &amp;optional CONTINUE-ECHO DONT-DOWNCASE-LAST CAN-RETURN-SWITCH-FRAME CMD-LOOP)",
"read-key-sequence-vector":"Like ‘read-key-sequence’ but always return a vector.¶¶(fn PROMPT &amp;optional CONTINUE-ECHO DONT-DOWNCASE-LAST CAN-RETURN-SWITCH-FRAME CMD-LOOP)",
"file-truename":"Return the truename of FILENAME.¶If FILENAME is not absolute, first expands it against ‘default-directory’.¶The truename of a file name is found by chasing symbolic links¶both at the level of the file and at the level of the directories¶containing it, until no links are left at any level.¶¶(fn FILENAME)",
"file-chase-links":"Chase links in FILENAME until a name that is not a link.¶Unlike ‘file-truename’, this does not check whether a parent¶directory name is a symbolic link.¶If the optional argument LIMIT is a number,¶it means chase no more than that many links and then stop.¶¶(fn FILENAME &amp;optional LIMIT)",
"file-equal-p":"Return non-nil if files FILE1 and FILE2 name the same file.¶If FILE1 or FILE2 does not exist, the return value is unspecified.¶¶(fn FILE1 FILE2)",
"file-in-directory-p":"Return non-nil if FILE is in DIR or a subdirectory of DIR.¶A directory is considered to be &quot;in&quot; itself.¶Return nil if DIR is not an existing directory.¶¶(fn FILE DIR)",
"eval":"Evaluate FORM and return its value.¶If LEXICAL is t, evaluate using lexical scoping.¶LEXICAL can also be an actual lexical environment, in the form of an¶alist mapping symbols to their value.¶¶(fn FORM &amp;optional LEXICAL)",
"frame-parameter":"Return FRAME’s value for parameter PARAMETER.¶If FRAME is nil, describe the currently selected frame.¶¶(fn FRAME PARAMETER)",
"frame-parameters":"Return the parameters-alist of frame FRAME.¶It is a list of elements of the form (PARM . VALUE), where PARM is a symbol.¶The meaningful PARMs depend on the kind of frame.¶If FRAME is omitted or nil, return information on the currently selected frame.¶¶(fn &amp;optional FRAME)",
"modify-frame-parameters":"Modify FRAME according to new values of its parameters in ALIST.¶If FRAME is nil, it defaults to the selected frame.¶ALIST is an alist of parameters to change and their new values.¶Each element of ALIST has the form (PARM . VALUE), where PARM is a symbol.¶Which PARMs are meaningful depends on the kind of frame.¶The meaningful parameters are acted upon, i.e. the frame is changed¶according to their new values, and are also stored in the frame’s¶parameter list so that ‘frame-parameters’ will return them.¶PARMs that are not meaningful are still stored in the frame’s parameter¶list, but are otherwise ignored.¶¶The value of frame parameter FOO can also be accessed¶as a frame-local binding for the variable FOO, if you have¶enabled such bindings for that variable with ‘make-variable-frame-local’.¶Note that this functionality is obsolete as of Emacs 22.2, and its¶use is not recommended.  Explicitly check for a frame-parameter instead.¶¶(fn FRAME ALIST)",
"set-frame-parameter":"Set frame parameter PARAMETER to VALUE on FRAME.¶If FRAME is nil, it defaults to the selected frame.¶See ‘modify-frame-parameters’.¶¶(fn FRAME PARAMETER VALUE)",
"modify-all-frames-parameters":"Modify all current and future frames’ parameters according to ALIST.¶This changes ‘default-frame-alist’ and possibly ‘initial-frame-alist’.¶Furthermore, this function removes all parameters in ALIST from¶‘window-system-default-frame-alist’.¶See help of ‘modify-frame-parameters’ for more information.¶¶(fn ALIST)",
"process-datagram-address":"Get the current datagram address associated with PROCESS.¶¶(fn PROCESS)",
"set-process-datagram-address":"Set the datagram address for PROCESS to ADDRESS.¶Returns nil upon error setting address, ADDRESS otherwise.¶¶(fn PROCESS ADDRESS)",
"current-window-configuration":"Return an object representing the current window configuration of FRAME.¶If FRAME is nil or omitted, use the selected frame.¶This describes the number of windows, their sizes and current buffers,¶and for each displayed buffer, where display starts, and the position of¶point.  An exception is made for point in the current buffer:¶its value is -not- saved.¶This also records the currently selected frame, and FRAME’s focus¶redirection (see ‘redirect-frame-focus’).  The variable¶‘window-persistent-parameters’ specifies which window parameters are¶saved by this function.¶¶(fn &amp;optional FRAME)",
"set-window-configuration":"Set the configuration of windows and buffers as specified by CONFIGURATION.¶CONFIGURATION must be a value previously returned¶by ‘current-window-configuration’ (which see).¶If CONFIGURATION was made from a frame that is now deleted,¶only frame-independent values can be restored.  In this case,¶the return value is nil.  Otherwise the value is t.¶¶(fn CONFIGURATION)",
"window-configuration-p":"Return t if OBJECT is a window-configuration object.¶¶(fn OBJECT)",
"compare-window-configurations":"Compare two window configurations as regards the structure of windows.¶This function ignores details such as the values of point¶and scrolling positions.¶¶(fn X Y)",
"window-configuration-frame":"Return the frame that CONFIG, a window-configuration object, is about.¶¶(fn CONFIG)",
"window-state-get":"Return state of WINDOW as a Lisp object.¶WINDOW can be any window and defaults to the root window of the¶selected frame.¶¶Optional argument WRITABLE non-nil means do not use markers for¶sampling ‘window-point’ and ‘window-start’.  Together, WRITABLE¶and the variable ‘window-persistent-parameters’ specify which¶window parameters are saved by this function.  WRITABLE should be¶non-nil when the return value shall be written to a file and read¶back in another session.  Otherwise, an application may run into¶an ‘invalid-read-syntax’ error while attempting to read back the¶value from file.¶¶The return value can be used as argument for ‘window-state-put’¶to put the state recorded here into an arbitrary window.  The¶value can be also stored on disk and read back in a new session.",
"window-state-put":"Put window state STATE into WINDOW.¶STATE should be the state of a window returned by an earlier¶invocation of ‘window-state-get’.  Optional argument WINDOW must¶specify a valid window and defaults to the selected one.  If¶WINDOW is not live, replace WINDOW by a live one before putting¶STATE into it.¶¶Optional argument IGNORE non-nil means ignore minimum window¶sizes and fixed size restrictions.  IGNORE equal ‘safe’ means¶windows can get as small as ‘window-safe-min-height’ and¶‘window-safe-min-width’.",
"charset-after":"Return charset of a character in the current buffer at position POS.¶If POS is nil, it defaults to the current point.¶If POS is out of range, the value is nil.¶¶(fn &amp;optional POS)",
"find-charset-region":"Return a list of charsets in the region between BEG and END.¶BEG and END are buffer positions.¶Optional arg TABLE if non-nil is a translation table to look up.¶¶If the current buffer is unibyte, the returned list may contain¶only ‘ascii’, ‘eight-bit-control’, and ‘eight-bit-graphic’.¶¶(fn BEG END &amp;optional TABLE)",
"find-charset-string":"Return a list of charsets in STR.¶Optional arg TABLE if non-nil is a translation table to look up.¶¶If STR is unibyte, the returned list may contain¶only ‘ascii’, ‘eight-bit-control’, and ‘eight-bit-graphic’.¶¶(fn STR &amp;optional TABLE)",
"abbrev-table-put":"Set the PROP property of abbrev table TABLE to VAL.¶¶(fn TABLE PROP VAL)",
"abbrev-table-get":"Get the PROP property of abbrev table TABLE.¶¶(fn TABLE PROP)",
"coding-system-list":"Return a list of all existing non-subsidiary coding systems.¶If optional arg BASE-ONLY is non-nil, only base coding systems are¶listed.  The value doesn’t include subsidiary coding systems which are¶made from bases and aliases automatically for various end-of-line¶formats (e.g. iso-latin-1-unix, koi8-r-dos).",
"coding-system-p":"Return t if OBJECT is nil or a coding-system.¶See the documentation of ‘define-coding-system’ for information¶about coding-system objects.¶¶(fn OBJECT)",
"check-coding-system":"Check validity of CODING-SYSTEM.¶If valid, return CODING-SYSTEM, else signal a ‘coding-system-error’ error.¶It is valid if it is nil or a symbol defined as a coding system by the¶function ‘define-coding-system’.¶¶(fn CODING-SYSTEM)",
"coding-system-eol-type":"Return eol-type of CODING-SYSTEM.¶An eol-type is an integer 0, 1, 2, or a vector of coding systems.¶¶Integer values 0, 1, and 2 indicate a format of end-of-line; LF, CRLF,¶and CR respectively.¶¶A vector value indicates that a format of end-of-line should be¶detected automatically.  Nth element of the vector is the subsidiary¶coding system whose eol-type is N.¶¶(fn CODING-SYSTEM)",
"coding-system-change-eol-conversion":"Return a coding system which differs from CODING-SYSTEM in EOL conversion.¶The returned coding system converts end-of-line by EOL-TYPE¶but text as the same way as CODING-SYSTEM.¶EOL-TYPE should be ‘unix’, ‘dos’, ‘mac’, or nil.¶If EOL-TYPE is nil, the returned coding system detects¶how end-of-line is formatted automatically while decoding.¶¶EOL-TYPE can be specified by an integer 0, 1, or 2.¶They means ‘unix’, ‘dos’, and ‘mac’ respectively.¶¶(fn CODING-SYSTEM EOL-TYPE)",
"coding-system-change-text-conversion":"Return a coding system which differs from CODING-SYSTEM in text conversion.¶The returned coding system converts text by CODING¶but end-of-line as the same way as CODING-SYSTEM.¶If CODING is nil, the returned coding system detects¶how text is formatted automatically while decoding.¶¶(fn CODING-SYSTEM CODING)",
"find-coding-systems-region":"Return a list of proper coding systems to encode a text between FROM and TO.¶¶If FROM is a string, find coding systems in that instead of the buffer.¶All coding systems in the list can safely encode any multibyte characters¶in the text.¶¶If the text contains no multibyte characters, return a list of a single¶element ‘undecided’.¶¶(fn FROM TO)",
"find-coding-systems-string":"Return a list of proper coding systems to encode STRING.¶All coding systems in the list can safely encode any multibyte characters¶in STRING.¶¶If STRING contains no multibyte characters, return a list of a single¶element ‘undecided’.¶¶(fn STRING)",
"find-coding-systems-for-charsets":"Return a list of proper coding systems to encode characters of CHARSETS.¶CHARSETS is a list of character sets.¶¶This only finds coding systems of type ‘charset’, whose¶‘:charset-list’ property includes all of CHARSETS (plus ‘ascii’ for¶ASCII-compatible coding systems).  It was used in older versions of¶Emacs, but is unlikely to be what you really want now.¶¶(fn CHARSETS)",
"check-coding-systems-region":"Check if the region is encodable by coding systems.¶¶START and END are buffer positions specifying the region.¶CODING-SYSTEM-LIST is a list of coding systems to check.¶¶The value is an alist ((CODING-SYSTEM POS0 POS1 ...) ...), where¶CODING-SYSTEM is a member of CODING-SYSTEM-LIST and can’t encode the¶whole region, POS0, POS1, ... are buffer positions where non-encodable¶characters are found.¶¶If all coding systems in CODING-SYSTEM-LIST can encode the region, the¶value is nil.¶¶START may be a string.  In that case, check if the string is¶encodable, and the value contains indices to the string instead of¶buffer positions.  END is ignored.¶¶If the current buffer (or START if it is a string) is unibyte, the value¶is nil.¶¶(fn START END CODING-SYSTEM-LIST)",
"detect-coding-region":"Detect coding system of the text in the region between START and END.¶Return a list of possible coding systems ordered by priority.¶The coding systems to try and their priorities follows what¶the function ‘coding-system-priority-list’ (which see) returns.¶¶If only ASCII characters are found (except for such ISO-2022 control¶characters as ESC), it returns a list of single element ‘undecided’¶or its subsidiary coding system according to a detected end-of-line¶format.¶¶If optional argument HIGHEST is non-nil, return the coding system of¶highest priority.¶¶(fn START END &amp;optional HIGHEST)",
"detect-coding-string":"Detect coding system of the text in STRING.¶Return a list of possible coding systems ordered by priority.¶The coding systems to try and their priorities follows what¶the function ‘coding-system-priority-list’ (which see) returns.¶¶If only ASCII characters are found (except for such ISO-2022 control¶characters as ESC), it returns a list of single element ‘undecided’¶or its subsidiary coding system according to a detected end-of-line¶format.¶¶If optional argument HIGHEST is non-nil, return the coding system of¶highest priority.¶¶(fn STRING &amp;optional HIGHEST)",
"coding-system-charset-list":"Return list of charsets supported by CODING-SYSTEM.¶If CODING-SYSTEM supports all ISO-2022 charsets, return ‘iso-2022’.¶If CODING-SYSTEM supports all emacs-mule charsets, return ‘emacs-mule’.",
"locate-file":"Search for FILENAME through PATH.¶If found, return the absolute file name of FILENAME; otherwise¶return nil.¶PATH should be a list of directories to look in, like the lists in¶‘exec-path’ or ‘load-path’.¶If SUFFIXES is non-nil, it should be a list of suffixes to append to¶file name when searching.  If SUFFIXES is nil, it is equivalent to (&quot;&quot;).¶Use (&quot;/&quot;) to disable PATH search, but still try the suffixes in SUFFIXES.¶If non-nil, PREDICATE is used instead of ‘file-readable-p’.¶¶This function will normally skip directories, so if you want it to find¶directories, make sure the PREDICATE function returns ‘dir-ok’ for them.¶¶PREDICATE can also be an integer to pass to the ‘access’ system call,¶in which case file-name handlers are ignored.  This usage is deprecated.¶For compatibility, PREDICATE can also be one of the symbols¶‘executable’, ‘readable’, ‘writable’, or ‘exists’, or a list of¶one or more of those symbols.¶¶(fn FILENAME PATH &amp;optional SUFFIXES PREDICATE)",
"executable-find":"Search for COMMAND in ‘exec-path’ and return the absolute file name.¶Return nil if COMMAND is not found anywhere in ‘exec-path’.¶¶(fn COMMAND)",
"symbol-name":"Return SYMBOL’s name, a string.¶¶(fn SYMBOL)",
"make-symbol":"Return a newly allocated uninterned symbol whose name is NAME.¶Its value is void, and its function definition and property list are nil.¶¶(fn NAME)",
"intern":"Return the canonical symbol whose name is STRING.¶If there is none, one is created by this function and returned.¶A second optional argument specifies the obarray to use;¶it defaults to the value of ‘obarray’.¶¶(fn STRING &amp;optional OBARRAY)",
"intern-soft":"Return the canonical symbol named NAME, or nil if none exists.¶NAME may be a string or a symbol.  If it is a symbol, that exact¶symbol is searched for.¶A second optional argument specifies the obarray to use;¶it defaults to the value of ‘obarray’.¶¶(fn NAME &amp;optional OBARRAY)",
"mapatoms":"Call FUNCTION on every symbol in OBARRAY.¶OBARRAY defaults to the value of ‘obarray’.¶¶(fn FUNCTION &amp;optional OBARRAY)",
"unintern":"Delete the symbol named NAME, if any, from OBARRAY.¶The value is t if a symbol was found and deleted, nil otherwise.¶NAME may be a string or a symbol.  If it is a symbol, that symbol¶is deleted, if it belongs to OBARRAY--no other symbol is deleted.¶OBARRAY, if nil, defaults to the value of the variable ‘obarray’.¶¶(fn NAME OBARRAY)",
"current-column":"Return the horizontal position of point.  Beginning of line is column 0.¶This is calculated by adding together the widths of all the displayed¶representations of the character between the start of the previous line¶and point (e.g., control characters will have a width of 2 or 4, tabs¶will have a variable width).¶Ignores finite width of frame, which means that this function may return¶values greater than (frame-width).¶Whether the line is visible (if ‘selective-display’ is t) has no effect;¶however, ^M is treated as end of line when ‘selective-display’ is t.¶Text that has an invisible property is considered as having width 0, unless¶‘buffer-invisibility-spec’ specifies that it is replaced by an ellipsis.¶¶(fn)",
"special-variable-p":"Return non-nil if SYMBOL’s global binding has been declared special.¶A special variable is one that will be bound dynamically, even in a¶context where binding is lexical by default.¶¶(fn SYMBOL)",
"accessible-keymaps":"Find all keymaps accessible via prefix characters from KEYMAP.¶Returns a list of elements of the form (KEYS . MAP), where the sequence¶KEYS starting from KEYMAP gets you to MAP.  These elements are ordered¶so that the KEYS increase in length.  The first element is ([] . KEYMAP).¶An optional argument PREFIX, if non-nil, should be a key sequence;¶then the value includes only maps for prefixes that start with PREFIX.¶¶(fn KEYMAP &amp;optional PREFIX)",
"map-keymap":"Call FUNCTION once for each event binding in KEYMAP.¶FUNCTION is called with two arguments: the event that is bound, and¶the definition it is bound to.  The event may be a character range.¶¶If KEYMAP has a parent, the parent’s bindings are included as well.¶This works recursively: if the parent has itself a parent, then the¶grandparent’s bindings are also included and so on.¶¶(fn FUNCTION KEYMAP)",
"where-is-internal":"Return list of keys that invoke DEFINITION.¶If KEYMAP is a keymap, search only KEYMAP and the global keymap.¶If KEYMAP is nil, search all the currently active keymaps, except¶ for ‘overriding-local-map’ (which is ignored).¶If KEYMAP is a list of keymaps, search only those keymaps.¶¶If optional 3rd arg FIRSTONLY is non-nil, return the first key sequence found,¶rather than a list of all possible key sequences.¶If FIRSTONLY is the symbol ‘non-ascii’, return the first binding found,¶no matter what it is.¶If FIRSTONLY has another non-nil value, prefer bindings¶that use the modifier key specified in ‘where-is-preferred-modifier’¶(or their meta variants) and entirely reject menu bindings.¶¶If optional 4th arg NOINDIRECT is non-nil, don’t extract the commands inside¶menu-items.  This makes it possible to search for a menu-item itself.¶¶The optional 5th arg NO-REMAP alters how command remapping is handled:¶¶- If another command OTHER-COMMAND is remapped to DEFINITION, normally¶  search for the bindings of OTHER-COMMAND and include them in the¶  returned list.  But if NO-REMAP is non-nil, include the vector¶  [remap OTHER-COMMAND] in the returned list instead, without¶  searching for those other bindings.¶¶- If DEFINITION is remapped to OTHER-COMMAND, normally return the¶  bindings for OTHER-COMMAND.  But if NO-REMAP is non-nil, return the¶  bindings for DEFINITION instead, ignoring its remapping.¶¶(fn DEFINITION &amp;optional KEYMAP FIRSTONLY NOINDIRECT NO-REMAP)",
"window-display-table":"Return the display-table that WINDOW is using.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"set-window-display-table":"Set WINDOW’s display-table to TABLE.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn WINDOW TABLE)",
"redisplay":"Perform redisplay.¶Optional arg FORCE, if non-nil, prevents redisplay from being¶preempted by arriving input, even if ‘redisplay-dont-pause’ is nil.¶If ‘redisplay-dont-pause’ is non-nil (the default), redisplay is never¶preempted by arriving input, so FORCE does nothing.¶¶Return t if redisplay was performed, nil if redisplay was preempted¶immediately by pending input.¶¶(fn &amp;optional FORCE)",
"force-window-update":"Force all windows to be updated on next redisplay.¶If optional arg OBJECT is a window, force redisplay of that window only.¶If OBJECT is a buffer or buffer name, force redisplay of all windows¶displaying that buffer.¶¶(fn &amp;optional OBJECT)",
"window-start":"Return position at which display currently starts in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶This is updated by redisplay or by calling ‘set-window-start’.¶¶(fn &amp;optional WINDOW)",
"window-group-start":"Return position at which display currently starts in the group of¶windows containing WINDOW.  When a grouping mode (such as Follow Mode)¶is not active, this function is identical to ‘window-start’.¶¶WINDOW must be a live window and defaults to the selected one.¶This is updated by redisplay or by calling ‘set-window*-start’.",
"window-end":"Return position at which display currently ends in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶This is updated by redisplay, when it runs to completion.¶Simply changing the buffer text or setting ‘window-start’¶does not update this value.¶Return nil if there is no recorded value.  (This can happen if the¶last redisplay of WINDOW was preempted, and did not finish.)¶If UPDATE is non-nil, compute the up-to-date position¶if it isn’t already recorded.¶¶(fn &amp;optional WINDOW UPDATE)",
"window-group-end":"Return position at which display currently ends in the group of¶windows containing WINDOW.  When a grouping mode (such as Follow Mode)¶is not active, this function is identical to ‘window-end’.¶¶WINDOW must be a live window and defaults to the selected one.¶This is updated by redisplay, when it runs to completion.¶Simply changing the buffer text or setting ‘window-group-start’¶does not update this value.¶Return nil if there is no recorded value.  (This can happen if the¶last redisplay of WINDOW was preempted, and did not finish.)¶If UPDATE is non-nil, compute the up-to-date position¶if it isn’t already recorded.",
"set-window-start":"Make display in WINDOW start at position POS in WINDOW’s buffer.¶WINDOW must be a live window and defaults to the selected one.  Return¶POS.  Optional third arg NOFORCE non-nil inhibits next redisplay from¶overriding motion of point in order to display at this exact start.¶¶(fn WINDOW POS &amp;optional NOFORCE)",
"set-window-group-start":"Make display in the group of windows containing WINDOW start at¶position POS in WINDOW’s buffer.  When a grouping mode (such as Follow¶Mode) is not active, this function is identical to ‘set-window-start’.¶¶WINDOW must be a live window and defaults to the selected one.  Return¶POS.  Optional third arg NOFORCE non-nil inhibits next redisplay from¶overriding motion of point in order to display at this exact start.",
"pos-visible-in-window-p":"Return non-nil if position POS is currently on the frame in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Return nil if that position is scrolled vertically out of view.  If a¶character is only partially visible, nil is returned, unless the¶optional argument PARTIALLY is non-nil.  If POS is only out of view¶because of horizontal scrolling, return non-nil.  If POS is t, it¶specifies either the first position displayed on the last visible¶screen line in WINDOW, or the end-of-buffer position, whichever comes¶first.  POS defaults to point in WINDOW; WINDOW defaults to the¶selected window.¶¶If POS is visible, return t if PARTIALLY is nil; if PARTIALLY is non-nil,¶the return value is a list of 2 or 6 elements (X Y [RTOP RBOT ROWH VPOS]),¶where X and Y are the pixel coordinates relative to the top left corner¶of the window.  The remaining elements are omitted if the character after¶POS is fully visible; otherwise, RTOP and RBOT are the number of pixels¶off-window at the top and bottom of the screen line (&quot;row&quot;) containing¶POS, ROWH is the visible height of that row, and VPOS is the row number¶(zero-based).¶¶(fn &amp;optional POS WINDOW PARTIALLY)",
"pos-visible-in-window-group-p":"Return non-nil if position POS is currently on the frame in the¶window group containing WINDOW.  When a grouping mode (such as Follow¶Mode) is not active, this function is identical to¶‘pos-visible-in-window-p’.¶¶WINDOW must be a live window and defaults to the selected one.¶¶Return nil if that position is scrolled vertically out of view.  If a¶character is only partially visible, nil is returned, unless the¶optional argument PARTIALLY is non-nil.  If POS is only out of view¶because of horizontal scrolling, return non-nil.  If POS is t, it¶specifies the position of the last visible glyph in the window group.¶POS defaults to point in WINDOW; WINDOW defaults to the selected¶window.¶¶If POS is visible, return t if PARTIALLY is nil; if PARTIALLY is non-nil,¶the return value is a list of 2 or 6 elements (X Y [RTOP RBOT ROWH VPOS]),¶where X and Y are the pixel coordinates relative to the top left corner¶of the window.  The remaining elements are omitted if the character after¶POS is fully visible; otherwise, RTOP and RBOT are the number of pixels¶off-window at the top and bottom of the screen line (&quot;row&quot;) containing¶POS, ROWH is the visible height of that row, and VPOS is the row number¶(zero-based).",
"window-line-height":"Return height in pixels of text line LINE in window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Return height of current line if LINE is omitted or nil.  Return height of¶header or mode line if LINE is ‘header-line’ or ‘mode-line’.¶Otherwise, LINE is a text line number starting from 0.  A negative number¶counts from the end of the window.¶¶Value is a list (HEIGHT VPOS YPOS OFFBOT), where HEIGHT is the height¶in pixels of the visible part of the line, VPOS and YPOS are the¶vertical position in lines and pixels of the line, relative to the top¶of the first text line, and OFFBOT is the number of off-window pixels at¶the bottom of the text line.  If there are off-window pixels at the top¶of the (first) text line, YPOS is negative.¶¶Return nil if window display is not up-to-date.  In that case, use¶‘pos-visible-in-window-p’ to obtain the information.¶¶(fn &amp;optional LINE WINDOW)",
"fringe-bitmaps-at-pos":"Return fringe bitmaps of row containing position POS in window WINDOW.¶If WINDOW is nil, use selected window.  If POS is nil, use value of point¶in that window.  Return value is a list (LEFT RIGHT OV), where LEFT¶is the symbol for the bitmap in the left fringe (or nil if no bitmap),¶RIGHT is similar for the right fringe, and OV is non-nil if there is an¶overlay arrow in the left fringe.¶Return nil if POS is not visible in WINDOW.¶¶(fn &amp;optional POS WINDOW)",
"buffer-name":"Return the name of BUFFER, as a string.¶BUFFER defaults to the current buffer.¶Return nil if BUFFER has been killed.¶¶(fn &amp;optional BUFFER)",
"get-buffer":"Return the buffer named BUFFER-OR-NAME.¶BUFFER-OR-NAME must be either a string or a buffer.  If BUFFER-OR-NAME¶is a string and there is no buffer with that name, return nil.  If¶BUFFER-OR-NAME is a buffer, return it as given.¶¶(fn BUFFER-OR-NAME)",
"generate-new-buffer-name":"Return a string that is the name of no existing buffer based on NAME.¶If there is no live buffer named NAME, then return NAME.¶Otherwise modify name by appending ‘&lt;NUMBER&gt;’, incrementing NUMBER¶(starting at 2) until an unused name is found, and then return that name.¶Optional second argument IGNORE specifies a name that is okay to use (if¶it is in the sequence to be tried) even if a buffer with that name exists.¶¶If NAME begins with a space (i.e., a buffer that is not normally¶visible to users), then if buffer NAME already exists a random number¶is first appended to NAME, to speed up finding a non-existent buffer.¶¶(fn NAME &amp;optional IGNORE)",
"jit-lock-register":"Register FUN as a fontification function to be called in this buffer.¶FUN will be called with two arguments START and END indicating the region¶that needs to be (re)fontified.¶If non-nil, CONTEXTUAL means that a contextual fontification would be useful.¶¶(fn FUN &amp;optional CONTEXTUAL)",
"jit-lock-unregister":"Unregister FUN as a fontification function.¶Only applies to the current buffer.¶¶(fn FUN)",
"file-notify-add-watch":"Add a watch for filesystem events pertaining to FILE.¶This arranges for filesystem events pertaining to FILE to be reported¶to Emacs.  Use ‘file-notify-rm-watch’ to cancel the watch.¶¶The returned value is a descriptor for the added watch.  If the¶file cannot be watched for some reason, this function signals a¶‘file-notify-error’ error.¶¶FLAGS is a list of conditions to set what will be watched for.  It can¶include the following symbols:¶¶  ‘change’           -- watch for file changes¶  ‘attribute-change’ -- watch for file attributes changes, like¶                        permissions or modification time¶¶If FILE is a directory, ‘change’ watches for file creation or¶deletion in that directory.  This does not work recursively.¶¶When any event happens, Emacs will call the CALLBACK function passing¶it a single argument EVENT, which is of the form¶¶  (DESCRIPTOR ACTION FILE [FILE1])¶¶DESCRIPTOR is the same object as the one returned by this function.¶ACTION is the description of the event.  It could be any one of the¶following:¶¶  ‘created’           -- FILE was created¶  ‘deleted’           -- FILE was deleted¶  ‘changed’           -- FILE has changed¶  ‘renamed’           -- FILE has been renamed to FILE1¶  ‘attribute-changed’ -- a FILE attribute was changed¶  ‘stopped’           -- watching FILE has been stopped¶¶FILE is the name of the file whose event is being reported.¶¶(fn FILE FLAGS CALLBACK)",
"file-notify-rm-watch":"Remove an existing watch specified by its DESCRIPTOR.¶DESCRIPTOR should be an object returned by ‘file-notify-add-watch’.¶¶(fn DESCRIPTOR)",
"file-notify-valid-p":"Check a watch specified by its DESCRIPTOR.¶DESCRIPTOR should be an object returned by ‘file-notify-add-watch’.¶¶(fn DESCRIPTOR)",
"local-variable-p":"Non-nil if VARIABLE has a local binding in buffer BUFFER.¶BUFFER defaults to the current buffer.¶¶(fn VARIABLE &amp;optional BUFFER)",
"local-variable-if-set-p":"Non-nil if VARIABLE is local in buffer BUFFER when set there.¶BUFFER defaults to the current buffer.¶¶More precisely, return non-nil if either VARIABLE already has a local¶value in BUFFER, or if VARIABLE is automatically buffer-local (see¶‘make-variable-buffer-local’).¶¶(fn VARIABLE &amp;optional BUFFER)",
"buffer-local-value":"Return the value of VARIABLE in BUFFER.¶If VARIABLE does not have a buffer-local binding in BUFFER, the value¶is the default binding of the variable.¶¶(fn VARIABLE BUFFER)",
"buffer-local-variables":"Return an alist of variables that are buffer-local in BUFFER.¶Most elements look like (SYMBOL . VALUE), describing one variable.¶For a symbol that is locally unbound, just the symbol appears in the value.¶Note that storing new VALUEs in these elements doesn’t change the variables.¶No argument or nil as argument means use current buffer as BUFFER.¶¶(fn &amp;optional BUFFER)",
"kill-all-local-variables":"Switch to Fundamental mode by killing current buffer’s local variables.¶Most local variable bindings are eliminated so that the default values¶become effective once more.  Also, the syntax table is set from¶‘standard-syntax-table’, the local keymap is set to nil,¶and the abbrev table from ‘fundamental-mode-abbrev-table’.¶This function also forces redisplay of the mode line.¶¶Every function to select a new major mode starts by¶calling this function.¶¶As a special exception, local variables whose names have¶a non-nil ‘permanent-local’ property are not eliminated by this function.¶¶The first thing this function does is run¶the normal hook ‘change-major-mode-hook’.¶¶(fn)",
"eventp":"True if the argument is an event object.¶¶(fn OBJ)",
"skip-chars-forward":"Move point forward, stopping before a char not in STRING, or at pos LIM.¶STRING is like the inside of a ‘[...]’ in a regular expression¶except that ‘]’ is never special and ‘⧷’ quotes ‘^’, ‘-’ or ‘⧷’¶ (but not at the end of a range; quoting is never needed there).¶Thus, with arg &quot;a-zA-Z&quot;, this skips letters stopping before first nonletter.¶With arg &quot;^a-zA-Z&quot;, skips nonletters stopping before first letter.¶Char classes, e.g. ‘[:alpha:]’, are supported.¶¶Returns the distance traveled, either zero or positive.¶¶(fn STRING &amp;optional LIM)",
"skip-chars-backward":"Move point backward, stopping after a char not in STRING, or at pos LIM.¶See ‘skip-chars-forward’ for details.¶Returns the distance traveled, either zero or negative.¶¶(fn STRING &amp;optional LIM)",
"window-parameter":"Return WINDOW’s value for PARAMETER.¶WINDOW can be any window and defaults to the selected one.¶¶(fn WINDOW PARAMETER)",
"window-parameters":"Return the parameters of WINDOW and their values.¶WINDOW must be a valid window and defaults to the selected one.  The¶return value is a list of elements of the form (PARAMETER . VALUE).¶¶(fn &amp;optional WINDOW)",
"set-window-parameter":"Set WINDOW’s value of PARAMETER to VALUE.¶WINDOW can be any window and defaults to the selected one.¶Return VALUE.¶¶(fn WINDOW PARAMETER VALUE)",
"recent-keys":"Return vector of last few events, not counting those from keyboard macros.¶If INCLUDE-CMDS is non-nil, include the commands that were run,¶represented as events of the form (nil . COMMAND).¶¶(fn &amp;optional INCLUDE-CMDS)",
"terminal-parameters":"Return the parameter-alist of terminal TERMINAL.¶The value is a list of elements of the form (PARM . VALUE), where PARM¶is a symbol.¶¶TERMINAL can be a terminal object, a frame, or nil (meaning the¶selected frame’s terminal).¶¶(fn &amp;optional TERMINAL)",
"terminal-parameter":"Return TERMINAL’s value for parameter PARAMETER.¶TERMINAL can be a terminal object, a frame, or nil (meaning the¶selected frame’s terminal).¶¶(fn TERMINAL PARAMETER)",
"set-terminal-parameter":"Set TERMINAL’s value for parameter PARAMETER to VALUE.¶Return the previous value of PARAMETER.¶¶TERMINAL can be a terminal object, a frame or nil (meaning the¶selected frame’s terminal).¶¶(fn TERMINAL PARAMETER VALUE)",
"memq":"Return non-nil if ELT is an element of LIST.  Comparison done with ‘eq’.¶The value is actually the tail of LIST whose car is ELT.¶¶(fn ELT LIST)",
"delq":"Delete members of LIST which are ‘eq’ to ELT, and return the result.¶More precisely, this function skips any members ‘eq’ to ELT at the¶front of LIST, then removes members ‘eq’ to ELT from the remaining¶sublist by modifying its list structure, then returns the resulting¶list.¶¶Write ‘(setq foo (delq element foo))’ to be sure of correctly changing¶the value of a list ‘foo’.  See also ‘remq’, which does not modify the¶argument.¶¶(fn ELT LIST)",
"remq":"Return LIST with all occurrences of ELT removed.¶The comparison is done with ‘eq’.  Contrary to ‘delq’, this does not use¶side-effects, and the argument LIST is not modified.¶¶(fn ELT LIST)",
"memql":"Return non-nil if ELT is an element of LIST.  Comparison done with ‘eql’.¶The value is actually the tail of LIST whose car is ELT.¶¶(fn ELT LIST)",
"member":"Return non-nil if ELT is an element of LIST.  Comparison done with ‘equal’.¶The value is actually the tail of LIST whose car is ELT.¶¶(fn ELT LIST)",
"delete":"Delete members of SEQ which are ‘equal’ to ELT, and return the result.¶SEQ must be a sequence (i.e. a list, a vector, or a string).¶The return value is a sequence of the same type.¶¶If SEQ is a list, this behaves like ‘delq’, except that it compares¶with ‘equal’ instead of ‘eq’.  In particular, it may remove elements¶by altering the list structure.¶¶If SEQ is not a list, deletion is never performed destructively;¶instead this function creates and returns a new vector or string.¶¶Write ‘(setq foo (delete element foo))’ to be sure of correctly¶changing the value of a sequence ‘foo’.¶¶(fn ELT SEQ)",
"remove":"Return a copy of SEQ with all occurrences of ELT removed.¶SEQ must be a list, vector, or string.  The comparison is done with ‘equal’.¶¶(fn ELT SEQ)",
"member-ignore-case":"Like ‘member’, but ignore differences in case and text representation.¶ELT must be a string.  Upper-case and lower-case letters are treated as equal.¶Unibyte strings are converted to multibyte for comparison.¶Non-strings in LIST are ignored.¶¶(fn ELT LIST)",
"delete-dups":"Destructively remove ‘equal’ duplicates from LIST.¶Store the result in LIST and return it.  LIST must be a proper list.¶Of several ‘equal’ occurrences of an element in LIST, the first¶one is kept.¶¶(fn LIST)",
"parse-partial-sexp":"Parse Lisp syntax starting at FROM until TO; return status of parse at TO.¶Parsing stops at TO or when certain criteria are met;¶ point is set to where parsing stops.¶If fifth arg OLDSTATE is omitted or nil,¶ parsing assumes that FROM is the beginning of a function.¶Value is a list of elements describing final state of parsing:¶ 0. depth in parens.¶ 1. character address of start of innermost containing list; nil if none.¶ 2. character address of start of last complete sexp terminated.¶ 3. non-nil if inside a string.¶    (it is the character that will terminate the string,¶     or t if the string should be terminated by a generic string delimiter.)¶ 4. nil if outside a comment, t if inside a non-nestable comment,¶    else an integer (the current comment nesting).¶ 5. t if following a quote character.¶ 6. the minimum paren-depth encountered during this scan.¶ 7. style of comment, if any.¶ 8. character address of start of comment or string; nil if not in one.¶ 9. Intermediate data for continuation of parsing (subject to change).¶If third arg TARGETDEPTH is non-nil, parsing stops if the depth¶in parentheses becomes equal to TARGETDEPTH.¶Fourth arg STOPBEFORE non-nil means stop when come to¶ any character that starts a sexp.¶Fifth arg OLDSTATE is a list like what this function returns.¶ It is used to initialize the state of the parse.  Elements number 1, 2, 6¶ are ignored.¶Sixth arg COMMENTSTOP non-nil means stop at the start of a comment.¶ If it is symbol ‘syntax-table’, stop after the start of a comment or a¶ string, or after end of a comment or a string.¶¶(fn FROM TO &amp;optional TARGETDEPTH STOPBEFORE OLDSTATE COMMENTSTOP)",
"get-buffer-create":"Return the buffer specified by BUFFER-OR-NAME, creating a new one if needed.¶If BUFFER-OR-NAME is a string and a live buffer with that name exists,¶return that buffer.  If no such buffer exists, create a new buffer with¶that name and return it.  If BUFFER-OR-NAME starts with a space, the new¶buffer does not keep undo information.¶¶If BUFFER-OR-NAME is a buffer instead of a string, return it as given,¶even if it is dead.  The return value is never nil.¶¶(fn BUFFER-OR-NAME)",
"generate-new-buffer":"Create and return a buffer with a name based on NAME.¶Choose the buffer’s name using ‘generate-new-buffer-name’.¶¶(fn NAME)",
"current-global-map":"Return the current global keymap.¶¶(fn)",
"current-local-map":"Return current buffer’s local keymap, or nil if it has none.¶Normally the local keymap is set by the major mode with ‘use-local-map’.¶¶(fn)",
"current-minor-mode-maps":"Return a list of keymaps for the minor modes of the current buffer.¶¶(fn)",
"use-global-map":"Select KEYMAP as the global keymap.¶¶(fn KEYMAP)",
"use-local-map":"Select KEYMAP as the local keymap.¶If KEYMAP is nil, that means no local keymap.¶¶(fn KEYMAP)",
"set-transient-map":"Set MAP as a temporary keymap taking precedence over other keymaps.¶Normally, MAP is used only once, to look up the very next key.¶However, if the optional argument KEEP-PRED is t, MAP stays¶active if a key from MAP is used.  KEEP-PRED can also be a¶function of no arguments: it is called from ‘pre-command-hook’ and¶if it returns non-nil, then MAP stays active.¶¶Optional arg ON-EXIT, if non-nil, specifies a function that is¶called, with no arguments, after MAP is deactivated.¶¶This uses ‘overriding-terminal-local-map’ which takes precedence over all other¶keymaps.  As usual, if no match for a key is found in MAP, the normal key¶lookup sequence then continues.¶¶This returns an &quot;exit function&quot;, which can be called with no argument¶to deactivate this transient map, regardless of KEEP-PRED.¶¶(fn MAP &amp;optional KEEP-PRED ON-EXIT)",
"accept-process-output":"Allow any pending output from subprocesses to be read by Emacs.¶It is given to their filter functions.¶Optional argument PROCESS means do not return until output has been¶received from PROCESS.¶¶Optional second argument SECONDS and third argument MILLISEC¶specify a timeout; return after that much time even if there is¶no subprocess output.  If SECONDS is a floating point number,¶it specifies a fractional number of seconds to wait.¶The MILLISEC argument is obsolete and should be avoided.¶¶If optional fourth argument JUST-THIS-ONE is non-nil, accept output¶from PROCESS only, suspending reading output from other processes.¶If JUST-THIS-ONE is an integer, don’t run any timers either.¶Return non-nil if we received any output from PROCESS (or, if PROCESS¶is nil, from any process) before the timeout expired.¶¶(fn &amp;optional PROCESS SECONDS MILLISEC JUST-THIS-ONE)",
"skip-syntax-forward":"Move point forward across chars in specified syntax classes.¶SYNTAX is a string of syntax code characters.¶Stop before a char whose syntax is not in SYNTAX, or at position LIM.¶If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.¶This function returns the distance traveled, either zero or positive.¶¶(fn SYNTAX &amp;optional LIM)",
"skip-syntax-backward":"Move point backward across chars in specified syntax classes.¶SYNTAX is a string of syntax code characters.¶Stop on reaching a char whose syntax is not in SYNTAX, or at position LIM.¶If SYNTAX starts with ^, skip characters whose syntax is NOT in SYNTAX.¶This function returns either zero or a negative number, and the absolute value¶of this is the distance traveled.¶¶(fn SYNTAX &amp;optional LIM)",
"backward-prefix-chars":"Move point backward over any number of chars with prefix syntax.¶This includes chars with expression prefix syntax class (') and those with¶the prefix syntax flag (p).¶¶(fn)",
"vertical-motion":"Move point to start of the screen line LINES lines down.¶If LINES is negative, this means moving up.¶¶This function is an ordinary cursor motion function¶which calculates the new position based on how text would be displayed.¶The new position may be the start of a line,¶or just the start of a continuation line.¶The function returns number of screen lines moved over;¶that usually equals LINES, but may be closer to zero¶if beginning or end of buffer was reached.¶¶The optional second argument WINDOW specifies the window to use for¶parameters such as width, horizontal scrolling, and so on.¶The default is to use the selected window’s parameters.¶¶LINES can optionally take the form (COLS . LINES), in which case the¶motion will not stop at the start of a screen line but COLS column¶from the visual start of the line (if such exists on that line, that¶is).  If the line is scrolled horizontally, COLS is interpreted¶visually, i.e., as addition to the columns of text beyond the left¶edge of the window.¶¶The optional third argument CUR-COL specifies the horizontal¶window-relative coordinate of point, in units of frame’s canonical¶character width, where the function is invoked.  If this argument is¶omitted or nil, the function will determine the point coordinate by¶going back to the beginning of the line.¶¶‘vertical-motion’ always uses the current buffer,¶regardless of which buffer is displayed in WINDOW.¶This is consistent with other cursor motion functions¶and makes it possible to use ‘vertical-motion’ in any buffer,¶whether or not it is currently displayed in some window.¶¶(fn LINES &amp;optional WINDOW CUR-COL)",
"count-screen-lines":"Return the number of screen lines in the region.¶The number of screen lines may be different from the number of actual lines,¶due to line breaking, display table, etc.¶¶Optional arguments BEG and END default to ‘point-min’ and ‘point-max’¶respectively.¶¶If region ends with a newline, ignore it unless optional third argument¶COUNT-FINAL-NEWLINE is non-nil.¶¶The optional fourth argument WINDOW specifies the window used for obtaining¶parameters such as width, horizontal scrolling, and so on.  The default is¶to use the selected window’s parameters.¶¶Like ‘vertical-motion’, ‘count-screen-lines’ always uses the current buffer,¶regardless of which buffer is displayed in WINDOW.  This makes possible to use¶‘count-screen-lines’ in any buffer, whether or not it is currently displayed¶in some window.",
"move-to-window-group-line":"Position point relative to the the current group of windows.¶When a grouping mode (such as Follow Mode) is not active, this¶function is identical to ‘move-to-window-line’.¶¶ARG nil means position point at center of the window group.¶Else, ARG specifies the vertical position within the window¶group; zero means top of first window in the group, negative¶means relative to the bottom of the last window in the group.",
"compute-motion":"Scan through the current buffer, calculating screen position.¶Scan the current buffer forward from offset FROM,¶assuming it is at position FROMPOS--a cons of the form (HPOS . VPOS)--¶to position TO or position TOPOS--another cons of the form (HPOS . VPOS)--¶and return the ending buffer position and screen location.¶¶If TOPOS is nil, the actual width and height of the window’s¶text area are used.¶¶There are three additional arguments:¶¶WIDTH is the number of columns available to display text;¶this affects handling of continuation lines.  A value of nil¶corresponds to the actual number of available text columns.¶¶OFFSETS is either nil or a cons cell (HSCROLL . TAB-OFFSET).¶HSCROLL is the number of columns not being displayed at the left¶margin; this is usually taken from a window’s hscroll member.¶TAB-OFFSET is the number of columns of the first tab that aren’t¶being displayed, perhaps because the line was continued within it.¶If OFFSETS is nil, HSCROLL and TAB-OFFSET are assumed to be zero.¶¶WINDOW is the window to operate on.  It is used to choose the display table;¶if it is showing the current buffer, it is used also for¶deciding which overlay properties apply.¶Note that ‘compute-motion’ always operates on the current buffer.¶¶The value is a list of five elements:¶  (POS HPOS VPOS PREVHPOS CONTIN)¶POS is the buffer position where the scan stopped.¶VPOS is the vertical position where the scan stopped.¶HPOS is the horizontal position where the scan stopped.¶¶PREVHPOS is the horizontal position one character back from POS.¶CONTIN is t if a line was continued after (or within) the previous character.¶¶For example, to find the buffer position of column COL of line LINE¶of a certain window, pass the window’s starting location as FROM¶and the window’s upper-left coordinates as FROMPOS.¶Pass the buffer’s (point-max) as TO, to limit the scan to the end of the¶visible section of the buffer, and pass LINE and COL as TOPOS.¶¶(fn FROM FROMPOS TO TOPOS WIDTH OFFSETS WINDOW)",
"file-exists-p":"Return t if file FILENAME exists (whether or not you can read it.)¶See also ‘file-readable-p’ and ‘file-attributes’.¶This returns nil for a symlink to a nonexistent file.¶Use ‘file-symlink-p’ to test for such links.¶¶(fn FILENAME)",
"file-readable-p":"Return t if file FILENAME exists and you can read it.¶See also ‘file-exists-p’ and ‘file-attributes’.¶¶(fn FILENAME)",
"file-executable-p":"Return t if FILENAME can be executed by you.¶For a directory, this means you can access files in that directory.¶(It is generally better to use ‘file-accessible-directory-p’ for that¶purpose, though.)¶¶(fn FILENAME)",
"file-writable-p":"Return t if file FILENAME can be written or created by you.¶¶(fn FILENAME)",
"file-accessible-directory-p":"Return t if FILENAME names a directory you can open.¶For the value to be t, FILENAME must specify the name of a directory¶as a file, and the directory must allow you to open files in it.  In¶order to use a directory as a buffer’s current directory, this¶predicate must return true.  A directory name spec may be given¶instead; then the value is t if the directory so specified exists and¶really is a readable and searchable directory.¶¶(fn FILENAME)",
"access-file":"Access file FILENAME, and get an error if that does not work.¶The second argument STRING is used in the error message.¶If there is no error, returns nil.¶¶(fn FILENAME STRING)",
"file-ownership-preserved-p":"Return t if deleting FILE and rewriting it would preserve the owner.¶Return nil if FILE does not exist, or if deleting and recreating it¶might not preserve the owner.  If GROUP is non-nil, check whether¶the group would be preserved too.¶¶(fn FILE &amp;optional GROUP)",
"file-modes":"Return mode bits of file named FILENAME, as an integer.¶Return nil, if file does not exist or is not accessible.¶¶(fn FILENAME)",
"open-network-stream":"Open a TCP connection to HOST, optionally with encryption.¶Normally, return a network process object; with a non-nil¶:return-list parameter, return a list instead (see below).¶Input and output work as for subprocesses; ‘delete-process’¶closes it.¶¶NAME is the name for the process.  It is modified if necessary to¶ make it unique.¶BUFFER is a buffer or buffer name to associate with the process.¶ Process output goes at end of that buffer.  BUFFER may be nil,¶ meaning that the process is not associated with any buffer.¶HOST is the name or IP address of the host to connect to.¶SERVICE is the name of the service desired, or an integer specifying¶ a port number to connect to.¶¶The remaining PARAMETERS should be a sequence of keywords and¶values:¶¶:type specifies the connection type, one of the following:¶  nil or ‘network’¶             -- Begin with an ordinary network connection, and if¶                the parameters :success and :capability-command¶                are also supplied, try to upgrade to an encrypted¶                connection via STARTTLS.  Even if that¶                fails (e.g. if HOST does not support TLS), retain¶                an unencrypted connection.¶  ‘plain’    -- An ordinary, unencrypted network connection.¶  ‘starttls’ -- Begin with an ordinary connection, and try¶                upgrading via STARTTLS.  If that fails for any¶                reason, drop the connection; in that case the¶                returned object is a killed process.¶  ‘tls’      -- A TLS connection.¶  ‘ssl’      -- Equivalent to ‘tls’.¶  ‘shell’    -- A shell connection.¶¶:return-list specifies this function’s return value.¶  If omitted or nil, return a process object.  A non-nil means to¶  return (PROC . PROPS), where PROC is a process object and PROPS¶  is a plist of connection properties, with these keywords:¶   :greeting -- the greeting returned by HOST (a string), or nil.¶   :capabilities -- a string representing HOST’s capabilities,¶                    or nil if none could be found.¶   :type -- the resulting connection type; ‘plain’ (unencrypted)¶            or ‘tls’ (TLS-encrypted).¶¶:end-of-command specifies a regexp matching the end of a command.¶¶:end-of-capability specifies a regexp matching the end of the¶  response to the command specified for :capability-command.¶  It defaults to the regexp specified for :end-of-command.¶¶:success specifies a regexp matching a message indicating a¶  successful STARTTLS negotiation.  For instance, the default¶  should be &quot;^3&quot; for an NNTP connection.¶¶:capability-command specifies a command used to query the HOST¶  for its capabilities.  For instance, for IMAP this should be¶  &quot;1 CAPABILITY⧷r⧷n&quot;.¶¶:starttls-function specifies a function for handling STARTTLS.¶  This function should take one parameter, the response to the¶  capability command, and should return the command to switch on¶  STARTTLS if the server supports STARTTLS, and nil otherwise.¶¶:always-query-capabilities says whether to query the server for¶  capabilities, even if we’re doing a ‘plain’ network connection.¶¶:client-certificate should either be a list where the first¶  element is the certificate key file name, and the second¶  element is the certificate file name itself, or t, which¶  means that ‘auth-source’ will be queried for the key and the¶  certificate.  This parameter will only be used when doing TLS¶  or STARTTLS connections.¶¶:use-starttls-if-possible is a boolean that says to do opportunistic¶STARTTLS upgrades even if Emacs doesn’t have built-in TLS functionality.¶¶:warn-unless-encrypted is a boolean which, if :return-list is¶non-nil, is used warn the user if the connection isn’t encrypted.¶¶:nogreeting is a boolean that can be used to inhibit waiting for¶a greeting from the server.¶¶:nowait is a boolean that says the connection should be made¶asynchronously, if possible.¶¶(fn NAME BUFFER HOST SERVICE &amp;rest PARAMETERS)",
"undo-boundary":"Mark a boundary between units of undo.¶An undo command will stop at this point,¶but another undo command will undo to the previous boundary.¶¶(fn)",
"undo-auto-amalgamate":"Amalgamate undo if necessary.¶This function can be called before an amalgamating command.  It¶removes the previous ‘undo-boundary’ if a series of such calls¶have been made.  By default ‘self-insert-command’ and¶‘delete-char’ are the only amalgamating commands, although this¶function could be called by any command wishing to have this¶behavior.",
"primitive-undo":"Undo N records from the front of the list LIST.¶Return what remains of the list.¶¶(fn N LIST)",
"keyboard-coding-system":"Return coding system specified for decoding keyboard input.¶¶(fn &amp;optional TERMINAL)",
"terminal-coding-system":"Return coding system specified for terminal output on the given terminal.¶TERMINAL may be a terminal object, a frame, or nil for the selected¶frame’s terminal device.¶¶(fn &amp;optional TERMINAL)",
"symbolp":"Return t if OBJECT is a symbol.¶¶(fn OBJECT)",
"booleanp":"Return t if OBJECT is one of the two canonical boolean values: t or nil.¶Otherwise, return nil.¶¶(fn OBJECT)",
"functionp":"Non-nil if OBJECT is a function.¶¶(fn OBJECT)",
"subrp":"Return t if OBJECT is a built-in function.¶¶(fn OBJECT)",
"byte-code-function-p":"Return t if OBJECT is a byte-compiled function object.¶¶(fn OBJECT)",
"subr-arity":"Return minimum and maximum number of args allowed for SUBR.¶SUBR must be a built-in function.¶The returned value is a pair (MIN . MAX).  MIN is the minimum number¶of args.  MAX is the maximum number or the symbol ‘many’, for a¶function with ‘&amp;rest’ args, or ‘unevalled’ for a special form.¶¶(fn SUBR)",
"char-width":"Return width of CHAR when displayed in the current buffer.¶The width is measured by how many columns it occupies on the screen.¶Tab is taken to occupy ‘tab-width’ columns.¶¶(fn CHAR)",
"string-width":"Return width of STRING when displayed in the current buffer.¶Width is measured by how many columns it occupies on the screen.¶When calculating width of a multibyte character in STRING,¶only the base leading-code is considered; the validity of¶the following bytes is not checked.  Tabs in STRING are always¶taken to occupy ‘tab-width’ columns.¶¶(fn STRING)",
"truncate-string-to-width":"Truncate string STR to end at column END-COLUMN.¶The optional 3rd arg START-COLUMN, if non-nil, specifies the starting¶column; that means to return the characters occupying columns¶START-COLUMN ... END-COLUMN of STR.  Both END-COLUMN and START-COLUMN¶are specified in terms of character display width in the current¶buffer; see also ‘char-width’.¶¶The optional 4th arg PADDING, if non-nil, specifies a padding¶character (which should have a display width of 1) to add at the end¶of the result if STR doesn’t reach column END-COLUMN, or if END-COLUMN¶comes in the middle of a character in STR.  PADDING is also added at¶the beginning of the result if column START-COLUMN appears in the¶middle of a character in STR.¶¶If PADDING is nil, no padding is added in these cases, so¶the resulting string may be narrower than END-COLUMN.¶¶If ELLIPSIS is non-nil, it should be a string which will replace the¶end of STR (including any padding) if it extends beyond END-COLUMN,¶unless the display width of STR is equal to or less than the display¶width of ELLIPSIS.  If it is non-nil and not a string, then ELLIPSIS¶defaults to ‘truncate-string-ellipsis’.¶¶(fn STR END-COLUMN &amp;optional START-COLUMN PADDING ELLIPSIS)",
"window-text-pixel-size":"Return the size of the text of WINDOW’s buffer in pixels.¶WINDOW must be a live window and defaults to the selected one.  The¶return value is a cons of the maximum pixel-width of any text line and¶the maximum pixel-height of all text lines.¶¶The optional argument FROM, if non-nil, specifies the first text¶position and defaults to the minimum accessible position of the buffer.¶If FROM is t, use the minimum accessible position that is not a newline¶character.  TO, if non-nil, specifies the last text position and¶defaults to the maximum accessible position of the buffer.  If TO is t,¶use the maximum accessible position that is not a newline character.¶¶The optional argument X-LIMIT, if non-nil, specifies the maximum text¶width that can be returned.  X-LIMIT nil or omitted, means to use the¶pixel-width of WINDOW’s body; use this if you do not intend to change¶the width of WINDOW.  Use the maximum width WINDOW may assume if you¶intend to change WINDOW’s width.  In any case, text whose x-coordinate¶is beyond X-LIMIT is ignored.  Since calculating the width of long lines¶can take some time, it’s always a good idea to make this argument as¶small as possible; in particular, if the buffer contains long lines that¶shall be truncated anyway.¶¶The optional argument Y-LIMIT, if non-nil, specifies the maximum text¶height that can be returned.  Text lines whose y-coordinate is beyond¶Y-LIMIT are ignored.  Since calculating the text height of a large¶buffer can take some time, it makes sense to specify this argument if¶the size of the buffer is unknown.¶¶Optional argument MODE-AND-HEADER-LINE nil or omitted means do not¶include the height of the mode- or header-line of WINDOW in the return¶value.  If it is either the symbol ‘mode-line’ or ‘header-line’, include¶only the height of that line, if present, in the return value.  If t,¶include the height of both, if present, in the return value.¶¶(fn &amp;optional WINDOW FROM TO X-LIMIT Y-LIMIT MODE-AND-HEADER-LINE)",
"documentation-property":"Return the documentation string that is SYMBOL’s PROP property.¶Third argument RAW omitted or nil means pass the result through¶‘substitute-command-keys’ if it is a string.¶¶This differs from ‘get’ in that it can refer to strings stored in the¶‘etc/DOC’ file; and that it evaluates documentation properties that¶aren’t strings.¶¶(fn SYMBOL PROP &amp;optional RAW)",
"documentation":"Return the documentation string of FUNCTION.¶Unless a non-nil second argument RAW is given, the¶string is passed through ‘substitute-command-keys’.¶¶(fn FUNCTION &amp;optional RAW)",
"face-documentation":"Get the documentation string for FACE.¶If FACE is a face-alias, get the documentation for the target face.",
"Snarf-documentation":"Used during Emacs initialization to scan the ‘etc/DOC...’ file.¶This searches the ‘etc/DOC...’ file for doc strings and¶records them in function and variable definitions.¶The function takes one argument, FILENAME, a string;¶it specifies the file name (without a directory) of the DOC file.¶That file is found in ‘../etc’ now; later, when the dumped Emacs is run,¶the same file name is found in the ‘doc-directory’.¶¶(fn FILENAME)",
"match-string":"Return string of text matched by last search.¶NUM specifies which parenthesized expression in the last regexp.¶ Value is nil if NUMth pair didn’t match, or there were less than NUM pairs.¶Zero means the entire text matched by the whole regexp or whole string.¶STRING should be given if the last search was by ‘string-match’ on STRING.¶If STRING is nil, the current buffer should be the same buffer¶the search/match was performed in.¶¶(fn NUM &amp;optional STRING)",
"match-string-no-properties":"Return string of text matched by last search, without text properties.¶NUM specifies which parenthesized expression in the last regexp.¶ Value is nil if NUMth pair didn’t match, or there were less than NUM pairs.¶Zero means the entire text matched by the whole regexp or whole string.¶STRING should be given if the last search was by ‘string-match’ on STRING.¶If STRING is nil, the current buffer should be the same buffer¶the search/match was performed in.¶¶(fn NUM &amp;optional STRING)",
"match-beginning":"Return position of start of text matched by last search.¶SUBEXP, a number, specifies which parenthesized expression in the last¶  regexp.¶Value is nil if SUBEXPth pair didn’t match, or there were less than¶  SUBEXP pairs.¶Zero means the entire text matched by the whole regexp or whole string.¶¶Return value is undefined if the last search failed.¶¶(fn SUBEXP)",
"match-end":"Return position of end of text matched by last search.¶SUBEXP, a number, specifies which parenthesized expression in the last¶  regexp.¶Value is nil if SUBEXPth pair didn’t match, or there were less than¶  SUBEXP pairs.¶Zero means the entire text matched by the whole regexp or whole string.¶¶Return value is undefined if the last search failed.¶¶(fn SUBEXP)",
"coding-system-priority-list":"Return a list of coding systems ordered by their priorities.¶The list contains a subset of coding systems; i.e. coding systems¶assigned to each coding category (see ‘coding-category-list’).¶¶HIGHESTP non-nil means just return the highest priority one.¶¶(fn &amp;optional HIGHESTP)",
"set-coding-system-priority":"Assign higher priority to the coding systems given as arguments.¶If multiple coding systems belong to the same category,¶all but the first one are ignored.¶¶(fn &amp;rest coding-systems)",
"x-popup-menu":"Pop up a deck-of-cards menu and return user’s selection.¶POSITION is a position specification.  This is either a mouse button event¶or a list ((XOFFSET YOFFSET) WINDOW)¶where XOFFSET and YOFFSET are positions in pixels from the top left¶corner of WINDOW.  (WINDOW may be a window or a frame object.)¶This controls the position of the top left of the menu as a whole.¶If POSITION is t, it means to use the current mouse position.¶¶MENU is a specifier for a menu.  For the simplest case, MENU is a keymap.¶The menu items come from key bindings that have a menu string as well as¶a definition; actually, the &quot;definition&quot; in such a key binding looks like¶(STRING . REAL-DEFINITION).  To give the menu a title, put a string into¶the keymap as a top-level element.¶¶If REAL-DEFINITION is nil, that puts a nonselectable string in the menu.¶Otherwise, REAL-DEFINITION should be a valid key binding definition.¶¶You can also use a list of keymaps as MENU.¶  Then each keymap makes a separate pane.¶¶When MENU is a keymap or a list of keymaps, the return value is the¶list of events corresponding to the user’s choice. Note that¶‘x-popup-menu’ does not actually execute the command bound to that¶sequence of events.¶¶Alternatively, you can specify a menu of multiple panes¶  with a list of the form (TITLE PANE1 PANE2...),¶where each pane is a list of form (TITLE ITEM1 ITEM2...).¶Each ITEM is normally a cons cell (STRING . VALUE);¶but a string can appear as an item--that makes a nonselectable line¶in the menu.¶With this form of menu, the return value is VALUE from the chosen item.¶¶If POSITION is nil, don’t display the menu at all, just precalculate the¶cached information about equivalent key sequences.¶¶If the user gets rid of the menu without making a valid choice, for¶instance by clicking the mouse away from a valid choice or by typing¶keyboard input, then this normally results in a quit and¶‘x-popup-menu’ does not return.  But if POSITION is a mouse button¶event (indicating that the user invoked the menu with the mouse) then¶no quit occurs and ‘x-popup-menu’ returns nil.¶¶(fn POSITION MENU)",
"-":"Negate number or subtract numbers or markers and return the result.¶With one arg, negates it.  With more than one arg,¶subtracts all but the first from the first.¶¶(fn &amp;optional NUMBER-OR-MARKER &amp;rest MORE-NUMBERS-OR-MARKERS)",
"mod":"Return X modulo Y.¶The result falls between zero (inclusive) and Y (exclusive).¶Both X and Y must be numbers or markers.¶¶(fn X Y)",
"symbol-file":"Return the name of the file that defined SYMBOL.¶The value is normally an absolute file name.  It can also be nil,¶if the definition is not associated with any file.  If SYMBOL¶specifies an autoloaded function, the value can be a relative¶file name without extension.¶¶If TYPE is nil, then any kind of definition is acceptable.  If¶TYPE is ‘defun’, ‘defvar’, or ‘defface’, that specifies function¶definition, variable definition, or face definition only.¶¶(fn SYMBOL &amp;optional TYPE)",
"command-line":"A subroutine of ‘normal-top-level’.¶Amongst another things, it parses the command-line arguments.",
"get-load-suffixes":"Return the suffixes that ‘load’ should try if a suffix is required.¶This uses the variables ‘load-suffixes’ and ‘load-file-rep-suffixes’.¶¶(fn)",
"defalias":"Set SYMBOL’s function definition to DEFINITION.¶Associates the function with the current load file, if any.¶The optional third argument DOCSTRING specifies the documentation string¶for SYMBOL; if it is omitted or nil, SYMBOL uses the documentation string¶determined by DEFINITION.¶¶Internally, this normally uses ‘fset’, but if SYMBOL has a¶‘defalias-fset-function’ property, the associated value is used instead.¶¶The return value is undefined.¶¶(fn SYMBOL DEFINITION &amp;optional DOCSTRING)",
"define-button-type":"Define a ‘button type’ called NAME (a symbol).¶The remaining arguments form a sequence of PROPERTY VALUE pairs,¶specifying properties to use as defaults for buttons with this type¶(a button’s type may be set by giving it a ‘type’ property when¶creating the button, using the :type keyword argument).¶¶In addition, the keyword argument :supertype may be used to specify a¶button-type from which NAME inherits its default property values¶(however, the inheritance happens only when NAME is defined; subsequent¶changes to a supertype are not reflected in its subtypes).",
"custom-set-variables":"Install user customizations of variable values specified in ARGS.¶These settings are registered as theme ‘user’.¶The arguments should each be a list of the form:¶¶  (SYMBOL EXP [NOW [REQUEST [COMMENT]]])¶¶This stores EXP (without evaluating it) as the saved value for SYMBOL.¶If NOW is present and non-nil, then also evaluate EXP and set¶the default value for the SYMBOL to the value of EXP.¶¶REQUEST is a list of features we must require in order to¶handle SYMBOL properly.¶COMMENT is a comment string about SYMBOL.",
"custom-set-faces":"Apply a list of face specs for user customizations.¶This works by calling ‘custom-theme-set-faces’ for the ‘user’¶theme, a special theme referring to settings made via Customize.¶The arguments should be a list where each entry has the form:¶¶  (FACE SPEC [NOW [COMMENT]])¶¶See the documentation of ‘custom-theme-set-faces’ for details.",
"interactive-form":"Return the interactive form of CMD or nil if none.¶If CMD is not a command, the return value is nil.¶Value, if non-nil, is a list (interactive SPEC).¶¶(fn CMD)",
"encode-coding-string":"Encode STRING to CODING-SYSTEM, and return the result.¶¶Optional third arg NOCOPY non-nil means it is OK to return STRING¶itself if the encoding operation is trivial.¶¶Optional fourth arg BUFFER non-nil means that the encoded text is¶inserted in that buffer after point (point does not move).  In this¶case, the return value is the length of the encoded text.¶¶This function sets ‘last-coding-system-used’ to the precise coding system¶used (which may be different from CODING-SYSTEM if CODING-SYSTEM is¶not fully specified.)¶¶(fn STRING CODING-SYSTEM &amp;optional NOCOPY BUFFER)",
"decode-coding-string":"Decode STRING which is encoded in CODING-SYSTEM, and return the result.¶¶Optional third arg NOCOPY non-nil means it is OK to return STRING itself¶if the decoding operation is trivial.¶¶Optional fourth arg BUFFER non-nil means that the decoded text is¶inserted in that buffer after point (point does not move).  In this¶case, the return value is the length of the decoded text.¶¶This function sets ‘last-coding-system-used’ to the precise coding system¶used (which may be different from CODING-SYSTEM if CODING-SYSTEM is¶not fully specified.)¶¶(fn STRING CODING-SYSTEM &amp;optional NOCOPY BUFFER)",
"decode-coding-inserted-region":"Decode the region between FROM and TO as if it is read from file FILENAME.¶The idea is that the text between FROM and TO was just inserted somehow.¶Optional arguments VISIT, BEG, END, and REPLACE are the same as those¶of the function ‘insert-file-contents’.¶Part of the job of this function is setting ‘buffer-undo-list’ appropriately.",
"make-hash-table":"Create and return a new hash table.¶¶Arguments are specified as keyword/argument pairs.  The following¶arguments are defined:¶¶:test TEST -- TEST must be a symbol that specifies how to compare¶keys.  Default is ‘eql’.  Predefined are the tests ‘eq’, ‘eql’, and¶‘equal’.  User-supplied test and hash functions can be specified via¶‘define-hash-table-test’.¶¶:size SIZE -- A hint as to how many elements will be put in the table.¶Default is 65.¶¶:rehash-size REHASH-SIZE - Indicates how to expand the table when it¶fills up.  If REHASH-SIZE is an integer, increase the size by that¶amount.  If it is a float, it must be &gt; 1.0, and the new size is the¶old size multiplied by that factor.  Default is 1.5.¶¶:rehash-threshold THRESHOLD -- THRESHOLD must a float &gt; 0, and &lt;= 1.0.¶Resize the hash table when the ratio (number of entries / table size)¶is greater than or equal to THRESHOLD.  Default is 0.8.¶¶:weakness WEAK -- WEAK must be one of nil, t, ‘key’, ‘value’,¶‘key-or-value’, or ‘key-and-value’.  If WEAK is not nil, the table¶returned is a weak table.  Key/value pairs are removed from a weak¶hash table when there are no non-weak references pointing to their¶key, value, one of key or value, or both key and value, depending on¶WEAK.  WEAK t is equivalent to ‘key-and-value’.  Default value of WEAK¶is nil.¶¶(fn &amp;rest KEYWORD-ARGS)",
"secure-hash":"Return the secure hash of OBJECT, a buffer or string.¶ALGORITHM is a symbol specifying the hash to use:¶md5, sha1, sha224, sha256, sha384 or sha512.¶¶The two optional arguments START and END are positions specifying for¶which part of OBJECT to compute the hash.  If nil or omitted, uses the¶whole OBJECT.¶¶If BINARY is non-nil, returns a string in binary form.¶¶(fn ALGORITHM OBJECT &amp;optional START END BINARY)",
"frame-geometry":"Return geometric attributes of FRAME.¶FRAME must be a live frame and defaults to the selected one.  The return¶value is an association list of the attributes listed below.  All height¶and width values are in pixels.¶¶‘outer-position’ is a cons of the outer left and top edges of FRAME¶  relative to the origin - the position (0, 0) - of FRAME’s display.¶¶‘outer-size’ is a cons of the outer width and height of FRAME.  The¶  outer size includes the title bar and the external borders as well as¶  any menu and/or tool bar of frame.¶¶‘external-border-size’ is a cons of the horizontal and vertical width of¶  FRAME’s external borders as supplied by the window manager.¶¶‘title-bar-size’ is a cons of the width and height of the title bar of¶  FRAME as supplied by the window manager.  If both of them are zero,¶  FRAME has no title bar.  If only the width is zero, Emacs was not¶  able to retrieve the width information.¶¶‘menu-bar-external’, if non-nil, means the menu bar is external (never¶  included in the inner edges of FRAME).¶¶‘menu-bar-size’ is a cons of the width and height of the menu bar of¶  FRAME.¶¶‘tool-bar-external’, if non-nil, means the tool bar is external (never¶  included in the inner edges of FRAME).¶¶‘tool-bar-position’ tells on which side the tool bar on FRAME is and can¶  be one of ‘left’, ‘top’, ‘right’ or ‘bottom’.  If this is nil, FRAME¶  has no tool bar.¶¶‘tool-bar-size’ is a cons of the width and height of the tool bar of¶  FRAME.¶¶‘internal-border-width’ is the width of the internal border of¶  FRAME.¶¶(fn &amp;optional FRAME)",
"frame-edges":"Return coordinates of FRAME’s edges.¶FRAME must be a live frame and defaults to the selected one.  The¶list returned has the form (LEFT TOP RIGHT BOTTOM) where all¶values are in pixels relative to the origin - the position (0, 0)¶- of FRAME’s display.  For terminal frames all values are¶relative to LEFT and TOP which are both zero.¶¶Optional argument TYPE specifies the type of the edges.  TYPE¶‘outer-edges’ means to return the outer edges of FRAME.  TYPE¶‘native-edges’ (or nil) means to return the native edges of¶FRAME.  TYPE ‘inner-edges’ means to return the inner edges of¶FRAME.¶¶(fn &amp;optional FRAME TYPE)",
"buffer-narrowed-p":"Return non-nil if the current buffer is narrowed.",
"locale-info":"Access locale data ITEM for the current C locale, if available.¶ITEM should be one of the following:¶¶‘codeset’, returning the character set as a string (locale item CODESET);¶¶‘days’, returning a 7-element vector of day names (locale items DAY_n);¶¶‘months’, returning a 12-element vector of month names (locale items MON_n);¶¶‘paper’, returning a list (WIDTH HEIGHT) for the default paper size,¶  both measured in millimeters (locale items PAPER_WIDTH, PAPER_HEIGHT).¶¶If the system can’t provide such information through a call to¶‘nl_langinfo’, or if ITEM isn’t from the list above, return nil.¶¶See also Info node ‘(libc)Locales’.¶¶The data read from the system are decoded using ‘locale-coding-system’.¶¶(fn ITEM)",
"keymap-prompt":"Return the prompt-string of a keymap MAP.¶If non-nil, the prompt is shown in the echo-area¶when reading a key-sequence to be looked-up in this keymap.¶¶(fn MAP)",
"set-window-margins":"Set width of marginal areas of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Second arg LEFT-WIDTH specifies the number of character cells to¶reserve for the left marginal area.  Optional third arg RIGHT-WIDTH¶does the same for the right marginal area.  A nil width parameter¶means no margin.¶¶Return t if any margin was actually changed and nil otherwise.¶¶(fn WINDOW LEFT-WIDTH &amp;optional RIGHT-WIDTH)",
"window-margins":"Get width of marginal areas of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Value is a cons of the form (LEFT-WIDTH . RIGHT-WIDTH).¶If a marginal area does not exist, its width will be returned¶as nil.¶¶(fn &amp;optional WINDOW)",
"try-completion":"Return common substring of all completions of STRING in COLLECTION.¶Test each possible completion specified by COLLECTION¶to see if it begins with STRING.  The possible completions may be¶strings or symbols.  Symbols are converted to strings before testing,¶see ‘symbol-name’.¶All that match STRING are compared together; the longest initial sequence¶common to all these matches is the return value.¶If there is no match at all, the return value is nil.¶For a unique match which is exact, the return value is t.¶¶If COLLECTION is an alist, the keys (cars of elements) are the¶possible completions.  If an element is not a cons cell, then the¶element itself is the possible completion.¶If COLLECTION is a hash-table, all the keys that are strings or symbols¶are the possible completions.¶If COLLECTION is an obarray, the names of all symbols in the obarray¶are the possible completions.¶¶COLLECTION can also be a function to do the completion itself.¶It receives three arguments: the values STRING, PREDICATE and nil.¶Whatever it returns becomes the value of ‘try-completion’.¶¶If optional third argument PREDICATE is non-nil,¶it is used to test each possible match.¶The match is a candidate only if PREDICATE returns non-nil.¶The argument given to PREDICATE is the alist element¶or the symbol from the obarray.  If COLLECTION is a hash-table,¶predicate is called with two arguments: the key and the value.¶Additionally to this predicate, ‘completion-regexp-list’¶is used to further constrain the set of candidates.¶¶(fn STRING COLLECTION &amp;optional PREDICATE)",
"all-completions":"Search for partial matches to STRING in COLLECTION.¶Test each of the possible completions specified by COLLECTION¶to see if it begins with STRING.  The possible completions may be¶strings or symbols.  Symbols are converted to strings before testing,¶see ‘symbol-name’.¶The value is a list of all the possible completions that match STRING.¶¶If COLLECTION is an alist, the keys (cars of elements) are the¶possible completions.  If an element is not a cons cell, then the¶element itself is the possible completion.¶If COLLECTION is a hash-table, all the keys that are strings or symbols¶are the possible completions.¶If COLLECTION is an obarray, the names of all symbols in the obarray¶are the possible completions.¶¶COLLECTION can also be a function to do the completion itself.¶It receives three arguments: the values STRING, PREDICATE and t.¶Whatever it returns becomes the value of ‘all-completions’.¶¶If optional third argument PREDICATE is non-nil,¶it is used to test each possible match.¶The match is a candidate only if PREDICATE returns non-nil.¶The argument given to PREDICATE is the alist element¶or the symbol from the obarray.  If COLLECTION is a hash-table,¶predicate is called with two arguments: the key and the value.¶Additionally to this predicate, ‘completion-regexp-list’¶is used to further constrain the set of candidates.¶¶An obsolete optional fourth argument HIDE-SPACES is still accepted for¶backward compatibility.  If non-nil, strings in COLLECTION that start¶with a space are ignored unless STRING itself starts with a space.¶¶(fn STRING COLLECTION &amp;optional PREDICATE HIDE-SPACES)",
"test-completion":"Return non-nil if STRING is a valid completion.¶Takes the same arguments as ‘all-completions’ and ‘try-completion’.¶If COLLECTION is a function, it is called with three arguments:¶the values STRING, PREDICATE and ‘lambda’.¶¶(fn STRING COLLECTION &amp;optional PREDICATE)",
"completion-boundaries":"Return the boundaries of text on which COLLECTION will operate.¶STRING is the string on which completion will be performed.¶SUFFIX is the string after point.¶If COLLECTION is a function, it is called with 3 arguments: STRING,¶PRED, and a cons cell of the form (boundaries . SUFFIX).¶¶The result is of the form (START . END) where START is the position¶in STRING of the beginning of the completion field and END is the position¶in SUFFIX of the end of the completion field.¶E.g. for simple completion tables, the result is always (0 . (length SUFFIX))¶and for file names the result is the positions delimited by¶the closest directory separators.¶¶(fn STRING COLLECTION PRED SUFFIX)",
"add-to-invisibility-spec":"Add ELEMENT to ‘buffer-invisibility-spec’.¶See documentation for ‘buffer-invisibility-spec’ for the kind of elements¶that can be added.¶¶(fn ELEMENT)",
"remove-from-invisibility-spec":"Remove ELEMENT from ‘buffer-invisibility-spec’.¶¶(fn ELEMENT)",
"invisible-p":"Non-nil if the property makes the text invisible.¶POS-OR-PROP can be a marker or number, in which case it is taken to be¶a position in the current buffer and the value of the ‘invisible’ property¶is checked; or it can be some other value, which is then presumed to be the¶value of the ‘invisible’ property of the text of interest.¶The non-nil value returned can be t for truly invisible text or something¶else if the text is replaced by an ellipsis.¶¶(fn POS-OR-PROP)",
"char-after":"Return character in current buffer at position POS.¶POS is an integer or a marker and defaults to point.¶If POS is out of range, the value is nil.¶¶(fn &amp;optional POS)",
"char-before":"Return character in current buffer preceding position POS.¶POS is an integer or a marker and defaults to point.¶If POS is out of range, the value is nil.¶¶(fn &amp;optional POS)",
"following-char":"Return the character following point, as a number.¶At the end of the buffer or accessible region, return 0.¶¶(fn)",
"preceding-char":"Return the character preceding point, as a number.¶At the beginning of the buffer or accessible region, return 0.¶¶(fn)",
"bobp":"Return t if point is at the beginning of the buffer.¶If the buffer is narrowed, this means the beginning of the narrowed part.¶¶(fn)",
"eobp":"Return t if point is at the end of the buffer.¶If the buffer is narrowed, this means the end of the narrowed part.¶¶(fn)",
"bolp":"Return t if point is at the beginning of a line.¶¶(fn)",
"eolp":"Return t if point is at the end of a line.¶‘End of a line’ includes point being at the end of the buffer.¶¶(fn)",
"coding-system-get":"Extract a value from CODING-SYSTEM’s property list for property PROP.¶For compatibility with Emacs 20/21, this accepts old-style symbols¶like ‘mime-charset’ as well as the current style like ‘:mime-charset’.",
"coding-system-aliases":"Return the list of aliases of CODING-SYSTEM.¶¶(fn CODING-SYSTEM)",
"defvaralias":"Make NEW-ALIAS a variable alias for symbol BASE-VARIABLE.¶Aliased variables always have the same value; setting one sets the other.¶Third arg DOCSTRING, if non-nil, is documentation for NEW-ALIAS.  If it is¶omitted or nil, NEW-ALIAS gets the documentation string of BASE-VARIABLE,¶or of the variable at the end of the chain of aliases, if BASE-VARIABLE is¶itself an alias.  If NEW-ALIAS is bound, and BASE-VARIABLE is not,¶then the value of BASE-VARIABLE is set to that of NEW-ALIAS.¶The return value is BASE-VARIABLE.¶¶(fn NEW-ALIAS BASE-VARIABLE &amp;optional DOCSTRING)",
"make-obsolete-variable":"Make the byte-compiler warn that OBSOLETE-NAME is obsolete.¶The warning will say that CURRENT-NAME should be used instead.¶If CURRENT-NAME is a string, that is the ‘use instead’ message.¶WHEN should be a string indicating when the variable¶was first made obsolete, for example a date or a release number.¶ACCESS-TYPE if non-nil should specify the kind of access that will trigger¶  obsolescence warnings; it can be either ‘get’ or ‘set’.¶¶(fn OBSOLETE-NAME CURRENT-NAME &amp;optional WHEN ACCESS-TYPE)",
"indirect-variable":"Return the variable at the end of OBJECT’s variable chain.¶If OBJECT is a symbol, follow its variable indirections (if any), and¶return the variable at the end of the chain of aliases.  See Info node¶‘(elisp)Variable Aliases’.¶¶If OBJECT is not a symbol, just return it.  If there is a loop in the¶chain of aliases, signal a ‘cyclic-variable-indirection’ error.¶¶(fn OBJECT)",
"read-file-name":"Read file name, prompting with PROMPT and completing in directory DIR.¶The return value is not expanded---you must call ‘expand-file-name’ yourself.¶¶DIR is the directory to use for completing relative file names.¶It should be an absolute directory name, or nil (which means the¶current buffer’s value of ‘default-directory’).¶¶DEFAULT-FILENAME specifies the default file name to return if the¶user exits the minibuffer with the same non-empty string inserted¶by this function.  If DEFAULT-FILENAME is a string, that serves¶as the default.  If DEFAULT-FILENAME is a list of strings, the¶first string is the default.  If DEFAULT-FILENAME is omitted or¶nil, then if INITIAL is non-nil, the default is DIR combined with¶INITIAL; otherwise, if the current buffer is visiting a file,¶that file serves as the default; otherwise, the default is simply¶the string inserted into the minibuffer.¶¶If the user exits with an empty minibuffer, return an empty¶string.  (This happens only if the user erases the pre-inserted¶contents, or if ‘insert-default-directory’ is nil.)¶¶Fourth arg MUSTMATCH can take the following values:¶- nil means that the user can exit with any input.¶- t means that the user is not allowed to exit unless¶  the input is (or completes to) an existing file.¶- ‘confirm’ means that the user can exit with any input, but she needs¶  to confirm her choice if the input is not an existing file.¶- ‘confirm-after-completion’ means that the user can exit with any¶  input, but she needs to confirm her choice if she called¶  ‘minibuffer-complete’ right before ‘minibuffer-complete-and-exit’¶  and the input is not an existing file.¶- anything else behaves like t except that typing RET does not exit if it¶  does non-null completion.¶¶Fifth arg INITIAL specifies text to start with.¶¶Sixth arg PREDICATE, if non-nil, should be a function of one¶argument; then a file name is considered an acceptable completion¶alternative only if PREDICATE returns non-nil with the file name¶as its argument.¶¶If this command was invoked with the mouse, use a graphical file¶dialog if ‘use-dialog-box’ is non-nil, and the window system or X¶toolkit in use provides a file dialog box, and DIR is not a¶remote file.  For graphical file dialogs, any of the special values¶of MUSTMATCH ‘confirm’ and ‘confirm-after-completion’ are¶treated as equivalent to nil.  Some graphical file dialogs respect¶a MUSTMATCH value of t, and some do not (or it only has a cosmetic¶effect, and does not actually prevent the user from entering a¶non-existent file).¶¶See also ‘read-file-name-completion-ignore-case’¶and ‘read-file-name-function’.¶¶(fn PROMPT &amp;optional DIR DEFAULT-FILENAME MUSTMATCH INITIAL PREDICATE)",
"read-directory-name":"Read directory name, prompting with PROMPT and completing in directory DIR.¶Value is not expanded---you must call ‘expand-file-name’ yourself.¶Default name to DEFAULT-DIRNAME if user exits with the same¶non-empty string that was inserted by this function.¶ (If DEFAULT-DIRNAME is omitted, DIR combined with INITIAL is used,¶  or just DIR if INITIAL is nil.)¶If the user exits with an empty minibuffer, this function returns¶an empty string.  (This can only happen if the user erased the¶pre-inserted contents or if ‘insert-default-directory’ is nil.)¶Fourth arg MUSTMATCH non-nil means require existing directory’s name.¶ Non-nil and non-t means also require confirmation after completion.¶Fifth arg INITIAL specifies text to start with.¶DIR should be an absolute directory name.  It defaults to¶the value of ‘default-directory’.¶¶(fn PROMPT &amp;optional DIR DEFAULT-DIRNAME MUSTMATCH INITIAL)",
"read-shell-command":"Read a shell command from the minibuffer.¶The arguments are the same as the ones of ‘read-from-minibuffer’,¶except READ and KEYMAP are missing and HIST defaults¶to ‘shell-command-history’.¶¶(fn PROMPT &amp;optional INITIAL-CONTENTS HIST &amp;rest ARGS)",
"select-window":"Select WINDOW which must be a live window.¶Also make WINDOW’s frame the selected frame and WINDOW that frame’s¶selected window.  In addition, make WINDOW’s buffer current and set its¶buffer’s value of ‘point’ to the value of WINDOW’s ‘window-point’.¶Return WINDOW.¶¶Optional second arg NORECORD non-nil means do not put this buffer at the¶front of the buffer list and do not make this window the most recently¶selected one.¶¶Run ‘buffer-list-update-hook’ unless NORECORD is non-nil.  Note that¶applications and internal routines often select a window temporarily for¶various purposes; mostly, to simplify coding.  As a rule, such¶selections should be not recorded and therefore will not pollute¶‘buffer-list-update-hook’.  Selections that &quot;really count&quot; are those¶causing a visible change in the next redisplay of WINDOW’s frame and¶should be always recorded.  So if you think of running a function each¶time a window gets selected put it on ‘buffer-list-update-hook’.¶¶Also note that the main editor command loop sets the current buffer to¶the buffer of the selected window before each command.¶¶(fn WINDOW &amp;optional NORECORD)",
"frame-selected-window":"Return the selected window of FRAME-OR-WINDOW.¶If omitted, FRAME-OR-WINDOW defaults to the currently selected frame.¶Else if FRAME-OR-WINDOW denotes a valid window, return the selected¶window of that window’s frame.  If FRAME-OR-WINDOW denotes a live frame,¶return the selected window of that frame.¶¶(fn &amp;optional FRAME-OR-WINDOW)",
"set-frame-selected-window":"Set selected window of FRAME to WINDOW.¶FRAME must be a live frame and defaults to the selected one.  If FRAME¶is the selected frame, this makes WINDOW the selected window.  Optional¶argument NORECORD non-nil means to neither change the order of recently¶selected windows nor the buffer list.  WINDOW must denote a live window.¶Return WINDOW.¶¶(fn FRAME WINDOW &amp;optional NORECORD)",
"window-use-time":"Return the use time of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶The window with the highest use time is the most recently selected¶one.  The window with the lowest use time is the least recently¶selected one.¶¶(fn &amp;optional WINDOW)",
"make-glyph-code":"Return a glyph code representing char CHAR with face FACE.",
"glyph-char":"Return the character of glyph code GLYPH.",
"glyph-face":"Return the face of glyph code GLYPH, or nil if glyph has default face.",
"command-remapping":"Return the remapping for command COMMAND.¶Returns nil if COMMAND is not remapped (or not a symbol).¶¶If the optional argument POSITION is non-nil, it specifies a mouse¶position as returned by ‘event-start’ and ‘event-end’, and the¶remapping occurs in the keymaps associated with it.  It can also be a¶number or marker, in which case the keymap properties at the specified¶buffer position instead of point are used.  The KEYMAPS argument is¶ignored if POSITION is non-nil.¶¶If the optional argument KEYMAPS is non-nil, it should be a list of¶keymaps to search for command remapping.  Otherwise, search for the¶remapping in all currently active keymaps.¶¶(fn COMMAND &amp;optional POSITION KEYMAPS)",
"help-buffer":"Return the name of a buffer for inserting help.¶If ‘help-xref-following’ is non-nil, this is the name of the¶current buffer.  Signal an error if this buffer is not derived¶from ‘help-mode’.¶Otherwise, return &quot;*Help*&quot;, creating a buffer with that name if¶it does not already exist.",
"help-setup-xref":"Invoked from commands using the &quot;*Help*&quot; buffer to install some xref info.¶¶ITEM is a (FUNCTION . ARGS) pair appropriate for recreating the help¶buffer after following a reference.  INTERACTIVE-P is non-nil if the¶calling command was invoked interactively.  In this case the stack of¶items for help buffer &quot;back&quot; buttons is cleared.¶¶This should be called very early, before the output buffer is cleared,¶because we want to record the &quot;previous&quot; position of point so we can¶restore it properly when going back.",
"downcase":"Convert argument to lower case and return that.¶The argument may be a character or string.  The result has the same type.¶The argument object is not altered--the value is a copy.¶¶(fn OBJ)",
"upcase":"Convert argument to upper case and return that.¶The argument may be a character or string.  The result has the same type.¶The argument object is not altered--the value is a copy.¶See also ‘capitalize’, ‘downcase’ and ‘upcase-initials’.¶¶(fn OBJ)",
"capitalize":"Convert argument to capitalized form and return that.¶This means that each word’s first character is upper case¶and the rest is lower case.¶The argument may be a character or string.  The result has the same type.¶The argument object is not altered--the value is a copy.¶¶(fn OBJ)",
"upcase-initials":"Convert the initial of each word in the argument to upper case.¶Do not change the other letters of each word.¶The argument may be a character or string.  The result has the same type.¶The argument object is not altered--the value is a copy.¶¶(fn OBJ)",
"redraw-frame":"Clear frame FRAME and output again what is supposed to appear on it.¶If FRAME is omitted or nil, the selected frame is used.¶¶(fn &amp;optional FRAME)",
"characterp":"Return non-nil if OBJECT is a character.¶In Emacs Lisp, characters are represented by character codes, which¶are non-negative integers.  The function ‘max-char’ returns the¶maximum character code.¶¶(fn OBJECT)",
"max-char":"Return the character of the maximum code.¶¶(fn)",
"get-byte":"Return a byte value of a character at point.¶Optional 1st arg POSITION, if non-nil, is a position of a character to get¶a byte value.¶Optional 2nd arg STRING, if non-nil, is a string of which first¶character is a target to get a byte value.  In this case, POSITION, if¶non-nil, is an index of a target character in the string.¶¶If the current buffer (or STRING) is multibyte, and the target¶character is not ASCII nor 8-bit character, an error is signaled.¶¶(fn &amp;optional POSITION STRING)",
"float":"Return the floating point number equal to ARG.¶¶(fn ARG)",
"truncate":"Truncate a floating point number to an int.¶Rounds ARG toward zero.¶With optional DIVISOR, truncate ARG/DIVISOR.¶¶(fn ARG &amp;optional DIVISOR)",
"floor":"Return the largest integer no greater than ARG.¶This rounds the value towards -inf.¶With optional DIVISOR, return the largest integer no greater than ARG/DIVISOR.¶¶(fn ARG &amp;optional DIVISOR)",
"ceiling":"Return the smallest integer no less than ARG.¶This rounds the value towards +inf.¶With optional DIVISOR, return the smallest integer no less than ARG/DIVISOR.¶¶(fn ARG &amp;optional DIVISOR)",
"round":"Return the nearest integer to ARG.¶With optional DIVISOR, return the nearest integer to ARG/DIVISOR.¶¶Rounding a value equidistant between two integers may choose the¶integer closer to zero, or it may prefer an even integer, depending on¶your machine.  For example, (round 2.5) can return 3 on some¶systems, but 2 on others.¶¶(fn ARG &amp;optional DIVISOR)",
"window-vscroll":"Return the amount by which WINDOW is scrolled vertically.¶If WINDOW is omitted or nil, it defaults to the selected window.¶Normally, value is a multiple of the canonical character height of WINDOW;¶optional second arg PIXELS-P means value is measured in pixels.¶¶(fn &amp;optional WINDOW PIXELS-P)",
"set-window-vscroll":"Set amount by which WINDOW should be scrolled vertically to VSCROLL.¶WINDOW nil means use the selected window.  Normally, VSCROLL is a¶non-negative multiple of the canonical character height of WINDOW;¶optional third arg PIXELS-P non-nil means that VSCROLL is in pixels.¶If PIXELS-P is nil, VSCROLL may have to be rounded so that it¶corresponds to an integral number of pixels.  The return value is the¶result of this rounding.¶If PIXELS-P is non-nil, the return value is VSCROLL.¶¶(fn WINDOW VSCROLL &amp;optional PIXELS-P)",
"selected-frame":"Return the frame that is now selected.¶¶(fn)",
"select-frame-set-input-focus":"Select FRAME, raise it, and set input focus, if possible.¶If ‘mouse-autoselect-window’ is non-nil, also move mouse pointer¶to FRAME’s selected window.  Otherwise, if ‘focus-follows-mouse’¶is non-nil, move mouse cursor to FRAME.¶¶Optional argument NORECORD means to neither change the order of¶recently selected windows nor the buffer list.¶¶(fn FRAME &amp;optional NORECORD)",
"redirect-frame-focus":"Arrange for keystrokes typed at FRAME to be sent to FOCUS-FRAME.¶In other words, switch-frame events caused by events in FRAME will¶request a switch to FOCUS-FRAME, and ‘last-event-frame’ will be¶FOCUS-FRAME after reading an event typed at FRAME.¶¶If FOCUS-FRAME is nil, any existing redirection is canceled, and the¶frame again receives its own keystrokes.¶¶Focus redirection is useful for temporarily redirecting keystrokes to¶a surrogate minibuffer frame when a frame doesn’t have its own¶minibuffer window.¶¶A frame’s focus redirection can be changed by ‘select-frame’.  If frame¶FOO is selected, and then a different frame BAR is selected, any¶frames redirecting their focus to FOO are shifted to redirect their¶focus to BAR.  This allows focus redirection to work properly when the¶user switches from one frame to another using ‘select-window’.¶¶This means that a frame whose focus is redirected to itself is treated¶differently from a frame whose focus is redirected to nil; the former¶is affected by ‘select-frame’, while the latter is not.¶¶The redirection lasts until ‘redirect-frame-focus’ is called to change it.¶¶(fn FRAME &amp;optional FOCUS-FRAME)",
"image-multi-frame-p":"Return non-nil if IMAGE contains more than one frame.¶The actual return value is a cons (NIMAGES . DELAY), where NIMAGES is¶the number of frames (or sub-images) in the image and DELAY is the delay¶in seconds that the image specifies between each frame.  DELAY may be nil,¶in which case you might want to use ‘image-default-frame-delay’.",
"image-current-frame":"The current frame number of IMAGE, indexed from 0.",
"image-show-frame":"Show frame N of IMAGE.¶Frames are indexed from 0.  Optional argument NOCHECK non-nil means¶do not check N is within the range of frames present in the image.",
"image-animate":"Start animating IMAGE.¶Animation occurs by destructively altering the IMAGE spec list.¶¶With optional INDEX, begin animating from that animation frame.¶LIMIT specifies how long to animate the image.  If omitted or¶nil, play the animation until the end.  If t, loop forever.  If a¶number, play until that number of seconds has elapsed.",
"image-animate-timer":"Return the animation timer for image IMAGE.",
"replace-regexp-in-string":"Replace all matches for REGEXP with REP in STRING.¶¶Return a new string containing the replacements.¶¶Optional arguments FIXEDCASE, LITERAL and SUBEXP are like the¶arguments with the same names of function ‘replace-match’.  If START¶is non-nil, start replacements at that index in STRING.¶¶REP is either a string used as the NEWTEXT arg of ‘replace-match’ or a¶function.  If it is a function, it is called with the actual text of each¶match, and its value is used as the replacement text.  When REP is called,¶the match data are the result of matching REGEXP against a substring¶of STRING, the same substring that is the actual text of the match which¶is passed to REP as its argument.¶¶To replace only the first match (if any), make REGEXP match up to ⧷'¶and replace a sub-expression, e.g.¶  (replace-regexp-in-string &quot;⧷⧷(foo⧷⧷).*⧷⧷'&quot; &quot;bar&quot; &quot; foo foo&quot; nil nil 1)¶    =&gt; &quot; bar foo&quot;¶¶(fn REGEXP REP STRING &amp;optional FIXEDCASE LITERAL SUBEXP START)",
"perform-replace":"Subroutine of ‘query-replace’.  Its complexity handles interactive queries.¶Don’t use this in your own program unless you want to query and set the mark¶just as ‘query-replace’ does.  Instead, write a simple loop like this:¶¶  (while (re-search-forward &quot;foo[ ⧷t]+bar&quot; nil t)¶    (replace-match &quot;foobar&quot; nil nil))¶¶which will run faster and probably do exactly what you want.  Please¶see the documentation of ‘replace-match’ to find out how to simulate¶‘case-replace’.¶¶This function returns nil if and only if there were no matches to¶make, or the user didn’t cancel the call.¶¶REPLACEMENTS is either a string, a list of strings, or a cons cell¶containing a function and its first argument.  The function is¶called to generate each replacement like this:¶  (funcall (car replacements) (cdr replacements) replace-count)¶It must return a string.",
"current-idle-time":"Return the current length of Emacs idleness, or nil.¶The value when Emacs is idle is a list of four integers (HIGH LOW USEC PSEC)¶in the same style as (current-time).¶¶The value when Emacs is not idle is nil.¶¶PSEC is a multiple of the system clock resolution.¶¶(fn)",
"subst-char-in-region":"From START to END, replace FROMCHAR with TOCHAR each time it occurs.¶If optional arg NOUNDO is non-nil, don’t record this change for undo¶and don’t mark the buffer as really changed.¶Both characters must have the same length of multi-byte form.¶¶(fn START END FROMCHAR TOCHAR &amp;optional NOUNDO)",
"derived-mode-p":"Non-nil if the current major mode is derived from one of MODES.¶Uses the ‘derived-mode-parent’ property of the symbol to trace backwards.¶¶(fn &amp;rest MODES)",
"dom-node":"Return a DOM node with TAG and ATTRIBUTES.",
"face-attribute":"Return the value of FACE’s ATTRIBUTE on FRAME.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶¶If INHERIT is nil, only attributes directly defined by FACE are considered,¶  so the return value may be ‘unspecified’, or a relative value.¶If INHERIT is non-nil, FACE’s definition of ATTRIBUTE is merged with the¶  faces specified by its ‘:inherit’ attribute; however the return value¶  may still be ‘unspecified’ or relative.¶If INHERIT is a face or a list of faces, then the result is further merged¶  with that face (or faces), until it becomes specified and absolute.¶¶To ensure that the return value is always specified and absolute, use a¶value of ‘default’ for INHERIT; this will resolve any unspecified or¶relative values by merging with the ‘default’ face (which is always¶completely specified).",
"face-attribute-relative-p":"Check whether a face attribute value is relative.¶Specifically, this function returns t if the attribute ATTRIBUTE¶with the value VALUE is relative.¶¶A relative value is one that doesn’t entirely override whatever is¶inherited from another face.  For most possible attributes,¶the only relative value that users see is ‘unspecified’.¶However, for :height, floating point values are also relative.¶¶(fn ATTRIBUTE VALUE)",
"face-all-attributes":"Return an alist stating the attributes of FACE.¶Each element of the result has the form (ATTR-NAME . ATTR-VALUE).¶If FRAME is omitted or nil the value describes the default attributes,¶but if you specify FRAME, the value describes the attributes¶of FACE on FRAME.",
"merge-face-attribute":"Return face ATTRIBUTE VALUE1 merged with VALUE2.¶If VALUE1 or VALUE2 are absolute (see ‘face-attribute-relative-p’), then¶the result will be absolute, otherwise it will be relative.¶¶(fn ATTRIBUTE VALUE1 VALUE2)",
"set-face-attribute":"Set attributes of FACE on FRAME from ARGS.¶This function overrides the face attributes specified by FACE’s¶face spec.  It is mostly intended for internal use only.¶¶If FRAME is nil, set the attributes for all existing frames, as¶well as the default for new frames.  If FRAME is t, change the¶default for new frames only.¶¶ARGS must come in pairs ATTRIBUTE VALUE.  ATTRIBUTE must be a¶valid face attribute name.  All attributes can be set to¶‘unspecified’; this fact is not further mentioned below.¶¶The following attributes are recognized:¶¶‘:family’¶¶VALUE must be a string specifying the font family¶(e.g. &quot;Monospace&quot;) or a fontset.¶¶‘:foundry’¶¶VALUE must be a string specifying the font foundry,¶e.g., &quot;adobe&quot;.  If a font foundry is specified, wild-cards ‘*’¶and ‘?’ are allowed.¶¶‘:width’¶¶VALUE specifies the relative proportionate width of the font to use.¶It must be one of the symbols ‘ultra-condensed’, ‘extra-condensed’,¶‘condensed’, ‘semi-condensed’, ‘normal’, ‘semi-expanded’, ‘expanded’,¶‘extra-expanded’, or ‘ultra-expanded’.¶¶‘:height’¶¶VALUE specifies the relative or absolute height of the font.  An¶absolute height is an integer, and specifies font height in units¶of 1/10 pt.  A relative height is either a floating point number,¶which specifies a scaling factor for the underlying face height;¶or a function that takes a single argument (the underlying face¶height) and returns the new height.  Note that for the ‘default’¶face, you must specify an absolute height (since there is nothing¶for it to be relative to).¶¶‘:weight’¶¶VALUE specifies the weight of the font to use.  It must be one of the¶symbols ‘ultra-bold’, ‘extra-bold’, ‘bold’, ‘semi-bold’, ‘normal’,¶‘semi-light’, ‘light’, ‘extra-light’, ‘ultra-light’.¶¶‘:slant’¶¶VALUE specifies the slant of the font to use.  It must be one of the¶symbols ‘italic’, ‘oblique’, ‘normal’, ‘reverse-italic’, or¶‘reverse-oblique’.¶¶‘:foreground’, ‘:background’¶¶VALUE must be a color name, a string.¶¶‘:underline’¶¶VALUE specifies whether characters in FACE should be underlined.¶If VALUE is t, underline with foreground color of the face.¶If VALUE is a string, underline with that color.¶If VALUE is nil, explicitly don’t underline.¶¶Otherwise, VALUE must be a property list of the form:¶¶‘(:color COLOR :style STYLE)’.¶¶COLOR can be a either a color name string or ‘foreground-color’.¶STYLE can be either ‘line’ or ‘wave’.¶If a keyword/value pair is missing from the property list, a¶default value will be used for the value.¶The default value of COLOR is the foreground color of the face.¶The default value of STYLE is ‘line’.¶¶‘:overline’¶¶VALUE specifies whether characters in FACE should be overlined.  If¶VALUE is t, overline with foreground color of the face.  If VALUE is a¶string, overline with that color.  If VALUE is nil, explicitly don’t¶overline.¶¶‘:strike-through’¶¶VALUE specifies whether characters in FACE should be drawn with a line¶striking through them.  If VALUE is t, use the foreground color of the¶face.  If VALUE is a string, strike-through with that color.  If VALUE¶is nil, explicitly don’t strike through.¶¶‘:box’¶¶VALUE specifies whether characters in FACE should have a box drawn¶around them.  If VALUE is nil, explicitly don’t draw boxes.  If¶VALUE is t, draw a box with lines of width 1 in the foreground color¶of the face.  If VALUE is a string, the string must be a color name,¶and the box is drawn in that color with a line width of 1.  Otherwise,¶VALUE must be a property list of the form ‘(:line-width WIDTH¶:color COLOR :style STYLE)’.  If a keyword/value pair is missing from¶the property list, a default value will be used for the value, as¶specified below.  WIDTH specifies the width of the lines to draw; it¶defaults to 1.  If WIDTH is negative, the absolute value is the width¶of the lines, and draw top/bottom lines inside the characters area,¶not around it.  COLOR is the name of the color to draw in, default is¶the foreground color of the face for simple boxes, and the background¶color of the face for 3D boxes.  STYLE specifies whether a 3D box¶should be draw.  If STYLE is ‘released-button’, draw a box looking¶like a released 3D button.  If STYLE is ‘pressed-button’ draw a box¶that appears like a pressed button.  If STYLE is nil, the default if¶the property list doesn’t contain a style specification, draw a 2D¶box.¶¶‘:inverse-video’¶¶VALUE specifies whether characters in FACE should be displayed in¶inverse video.  VALUE must be one of t or nil.¶¶‘:stipple’¶¶If VALUE is a string, it must be the name of a file of pixmap data.¶The directories listed in the ‘x-bitmap-file-path’ variable are¶searched.  Alternatively, VALUE may be a list of the form (WIDTH¶HEIGHT DATA) where WIDTH and HEIGHT are the size in pixels, and DATA¶is a string containing the raw bits of the bitmap.  VALUE nil means¶explicitly don’t use a stipple pattern.¶¶For convenience, attributes ‘:family’, ‘:foundry’, ‘:width’,¶‘:height’, ‘:weight’, and ‘:slant’ may also be set in one step¶from an X font name:¶¶‘:font’¶¶Set font-related face attributes from VALUE.  VALUE must be a¶valid font name or font object.  Setting this attribute will also¶set the ‘:family’, ‘:foundry’, ‘:width’, ‘:height’, ‘:weight’,¶and ‘:slant’ attributes.¶¶‘:inherit’¶¶VALUE is the name of a face from which to inherit attributes, or¶a list of face names.  Attributes from inherited faces are merged¶into the face like an underlying face would be, with higher¶priority than underlying faces.¶¶For backward compatibility, the keywords ‘:bold’ and ‘:italic’¶can be used to specify weight and slant respectively.  This usage¶is considered obsolete.  For these two keywords, the VALUE must¶be either t or nil.  A value of t for ‘:bold’ is equivalent to¶setting ‘:weight’ to ‘bold’, and a value of t for ‘:italic’ is¶equivalent to setting ‘:slant’ to ‘italic’.  But if ‘:weight’ is¶specified in the face spec, ‘:bold’ is ignored, and if ‘:slant’¶is specified, ‘:italic’ is ignored.",
"set-face-bold":"Specify whether face FACE is bold.¶BOLD-P non-nil means FACE should explicitly display bold.¶BOLD-P nil means FACE should explicitly display non-bold.¶FRAME nil or not specified means change face on all frames.¶Use ‘set-face-attribute’ or ‘modify-face’ for finer control.",
"set-face-italic":"Specify whether face FACE is italic.¶ITALIC-P non-nil means FACE should explicitly display italic.¶ITALIC-P nil means FACE should explicitly display non-italic.¶FRAME nil or not specified means change face on all frames.¶Use ‘set-face-attribute’ or ‘modify-face’ for finer control.",
"set-face-underline":"Specify whether face FACE is underlined.¶UNDERLINE nil means FACE explicitly doesn’t underline.¶UNDERLINE t means FACE underlines with its foreground color.¶If UNDERLINE is a string, underline with that color.¶¶UNDERLINE may also be a list of the form (:color COLOR :style STYLE),¶where COLOR is a string or ‘foreground-color’, and STYLE is either¶‘line’ or ‘wave’.  :color may be omitted, which means to use the¶foreground color.  :style may be omitted, which means to use a line.¶¶FRAME nil or not specified means change face on all frames.¶Use ‘set-face-attribute’ to &quot;unspecify&quot; underlining.",
"set-face-inverse-video":"Specify whether face FACE is in inverse video.¶INVERSE-VIDEO-P non-nil means FACE displays explicitly in inverse video.¶INVERSE-VIDEO-P nil means FACE explicitly is not in inverse video.¶FRAME nil or not specified means change face on all frames.¶Use ‘set-face-attribute’ to &quot;unspecify&quot; the inverse video attribute.",
"face-font":"Return the font name of face FACE, or nil if it is unspecified.¶The font name is, by default, for ASCII characters.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶  The font default for a face is either nil, or a list¶  of the form (bold), (italic) or (bold italic).¶If FRAME is omitted or nil, use the selected frame.  And, in this case,¶if the optional third argument CHARACTER is given,¶return the font name used for CHARACTER.¶¶(fn FACE &amp;optional FRAME CHARACTER)",
"face-foreground":"Return the foreground color name of FACE, or nil if unspecified.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶¶If INHERIT is nil, only a foreground color directly defined by FACE is¶  considered, so the return value may be nil.¶If INHERIT is t, and FACE doesn’t define a foreground color, then any¶  foreground color that FACE inherits through its ‘:inherit’ attribute¶  is considered as well; however the return value may still be nil.¶If INHERIT is a face or a list of faces, then it is used to try to¶  resolve an unspecified foreground color.¶¶To ensure that a valid color is always returned, use a value of¶‘default’ for INHERIT; this will resolve any unspecified values by¶merging with the ‘default’ face (which is always completely specified).",
"face-background":"Return the background color name of FACE, or nil if unspecified.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶¶If INHERIT is nil, only a background color directly defined by FACE is¶  considered, so the return value may be nil.¶If INHERIT is t, and FACE doesn’t define a background color, then any¶  background color that FACE inherits through its ‘:inherit’ attribute¶  is considered as well; however the return value may still be nil.¶If INHERIT is a face or a list of faces, then it is used to try to¶  resolve an unspecified background color.¶¶To ensure that a valid color is always returned, use a value of¶‘default’ for INHERIT; this will resolve any unspecified values by¶merging with the ‘default’ face (which is always completely specified).",
"face-stipple":"Return the stipple pixmap name of FACE, or nil if unspecified.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶¶If INHERIT is nil, only a stipple directly defined by FACE is¶  considered, so the return value may be nil.¶If INHERIT is t, and FACE doesn’t define a stipple, then any stipple¶  that FACE inherits through its ‘:inherit’ attribute is considered as¶  well; however the return value may still be nil.¶If INHERIT is a face or a list of faces, then it is used to try to¶  resolve an unspecified stipple.¶¶To ensure that a valid stipple or nil is always returned, use a value of¶‘default’ for INHERIT; this will resolve any unspecified values by merging¶with the ‘default’ face (which is always completely specified).",
"face-bold-p":"Return non-nil if the font of FACE is bold on FRAME.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶Optional argument INHERIT is passed to ‘face-attribute’.¶Use ‘face-attribute’ for finer control.",
"face-italic-p":"Return non-nil if the font of FACE is italic on FRAME.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶Optional argument INHERIT is passed to ‘face-attribute’.¶Use ‘face-attribute’ for finer control.",
"face-underline-p":"Return non-nil if FACE specifies a non-nil underlining.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶Optional argument INHERIT is passed to ‘face-attribute’.",
"face-inverse-video-p":"Return non-nil if FACE specifies a non-nil inverse-video.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.¶Optional argument INHERIT is passed to ‘face-attribute’.",
"file-name-all-completions":"Return a list of all completions of file name FILE in directory DIRECTORY.¶These are all file names in directory DIRECTORY which begin with FILE.¶¶This function ignores some of the possible completions as determined¶by ‘completion-regexp-list’, which see.  ‘completion-regexp-list’¶is matched against file and directory names relative to DIRECTORY.¶¶(fn FILE DIRECTORY)",
"file-name-completion":"Complete file name FILE in directory DIRECTORY.¶Returns the longest string¶common to all file names in DIRECTORY that start with FILE.¶If there is only one and FILE matches it exactly, returns t.¶Returns nil if DIRECTORY contains no name starting with FILE.¶¶If PREDICATE is non-nil, call PREDICATE with each possible¶completion (in absolute form) and ignore it if PREDICATE returns nil.¶¶This function ignores some of the possible completions as determined¶by the variables ‘completion-regexp-list’ and¶‘completion-ignored-extensions’, which see.  ‘completion-regexp-list’¶is matched against file and directory names relative to DIRECTORY.¶¶(fn FILE DIRECTORY &amp;optional PREDICATE)",
"make-string":"Return a newly created string of length LENGTH, with INIT in each element.¶LENGTH must be an integer.¶INIT must be an integer that represents a character.¶¶(fn LENGTH INIT)",
"string":"Concatenate all the argument characters and make the result a string.¶¶(fn &amp;rest CHARACTERS)",
"substring":"Return a new string whose contents are a substring of STRING.¶The returned string consists of the characters between index FROM¶(inclusive) and index TO (exclusive) of STRING.  FROM and TO are¶zero-indexed: 0 means the first character of STRING.  Negative values¶are counted from the end of STRING.  If TO is nil, the substring runs¶to the end of STRING.¶¶The STRING argument may also be a vector.  In that case, the return¶value is a new vector that contains the elements between index FROM¶(inclusive) and index TO (exclusive) of that vector argument.¶¶With one argument, just copy STRING (with properties, if any).¶¶(fn STRING &amp;optional FROM TO)",
"substring-no-properties":"Return a substring of STRING, without text properties.¶It starts at index FROM and ends before TO.¶TO may be nil or omitted; then the substring runs to the end of STRING.¶If FROM is nil or omitted, the substring starts at the beginning of STRING.¶If FROM or TO is negative, it counts from the end.¶¶With one argument, just copy STRING without its properties.¶¶(fn STRING &amp;optional FROM TO)",
"concat":"Concatenate all the arguments and make the result a string.¶The result is a string whose elements are the elements of all the arguments.¶Each argument may be a string or a list or vector of characters (integers).¶¶(fn &amp;rest SEQUENCES)",
"split-string":"Split STRING into substrings bounded by matches for SEPARATORS.¶¶The beginning and end of STRING, and each match for SEPARATORS, are¶splitting points.  The substrings matching SEPARATORS are removed, and¶the substrings between the splitting points are collected as a list,¶which is returned.¶¶If SEPARATORS is non-nil, it should be a regular expression matching text¶which separates, but is not part of, the substrings.  If nil it defaults to¶‘split-string-default-separators’, normally &quot;[ ⧷f⧷t⧷n⧷r⧷v]+&quot;, and¶OMIT-NULLS is forced to t.¶¶If OMIT-NULLS is t, zero-length substrings are omitted from the list (so¶that for the default value of SEPARATORS leading and trailing whitespace¶are effectively trimmed).  If nil, all zero-length substrings are retained,¶which correctly parses CSV format, for example.¶¶If TRIM is non-nil, it should be a regular expression to match¶text to trim from the beginning and end of each substring.  If trimming¶makes the substring empty, it is treated as null.¶¶If you want to trim whitespace from the substrings, the reliably correct¶way is using TRIM.  Making SEPARATORS match that whitespace gives incorrect¶results when there is whitespace at the start or end of STRING.  If you¶see such calls to ‘split-string’, please fix them.¶¶Note that the effect of ‘(split-string STRING)’ is the same as¶‘(split-string STRING split-string-default-separators t)’.  In the rare¶case that you wish to retain zero-length substrings when splitting on¶whitespace, use ‘(split-string STRING split-string-default-separators)’.¶¶Modifies the match data; use ‘save-match-data’ if necessary.¶¶(fn STRING &amp;optional SEPARATORS OMIT-NULLS TRIM)",
"window-buffer":"Return the buffer displayed in window WINDOW.¶If WINDOW is omitted or nil, it defaults to the selected window.¶Return nil for an internal window or a deleted window.¶¶(fn &amp;optional WINDOW)",
"set-window-buffer":"Make WINDOW display BUFFER-OR-NAME.¶WINDOW must be a live window and defaults to the selected one.¶BUFFER-OR-NAME must be a buffer or the name of an existing buffer.¶¶Optional third argument KEEP-MARGINS non-nil means that WINDOW’s current¶display margins, fringe widths, and scroll bar settings are preserved;¶the default is to reset these from the local settings for BUFFER-OR-NAME¶or the frame defaults.  Return nil.¶¶This function throws an error when WINDOW is strongly dedicated to its¶buffer (that is ‘window-dedicated-p’ returns t for WINDOW) and does not¶already display BUFFER-OR-NAME.¶¶This function runs ‘window-scroll-functions’ before running¶‘window-configuration-change-hook’.¶¶(fn WINDOW BUFFER-OR-NAME &amp;optional KEEP-MARGINS)",
"get-buffer-window":"Return a window currently displaying BUFFER-OR-NAME, or nil if none.¶BUFFER-OR-NAME may be a buffer or a buffer name and defaults to¶the current buffer.¶¶The optional argument ALL-FRAMES specifies the frames to consider:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames.¶¶- 0 (the number zero) means consider all windows on all visible¶    and iconified frames.¶¶- A frame means consider all windows on that frame only.¶¶Any other value of ALL-FRAMES means consider all windows on the¶selected frame and no others.¶¶(fn &amp;optional BUFFER-OR-NAME ALL-FRAMES)",
"get-buffer-window-list":"Return list of all windows displaying BUFFER-OR-NAME, or nil if none.¶BUFFER-OR-NAME may be a buffer or the name of an existing buffer¶and defaults to the current buffer.  If the selected window displays¶BUFFER-OR-NAME, it will be the first in the resulting list.¶¶MINIBUF t means include the minibuffer window even if the¶minibuffer is not active.  MINIBUF nil or omitted means include¶the minibuffer window only if the minibuffer is active.  Any¶other value means do not include the minibuffer window even if¶the minibuffer is active.¶¶ALL-FRAMES nil or omitted means consider all windows on the¶selected frame, plus the minibuffer window if specified by the¶MINIBUF argument.  If the minibuffer counts, consider all windows¶on all frames that share that minibuffer too.  The following¶non-nil values of ALL-FRAMES have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on the selected frame¶and no others.",
"process-query-on-exit-flag":"Return the current value of query-on-exit flag for PROCESS.¶¶(fn PROCESS)",
"set-process-query-on-exit-flag":"Specify if query is needed for PROCESS when Emacs is exited.¶If the second argument FLAG is non-nil, Emacs will query the user before¶exiting or killing a buffer if PROCESS is running.  This function¶returns FLAG.¶¶(fn PROCESS FLAG)",
"process-send-string":"Send PROCESS the contents of STRING as input.¶PROCESS may be a process, a buffer, the name of a process or buffer, or¶nil, indicating the current buffer’s process.¶If STRING is more than 500 characters long,¶it is sent in several bunches.  This may happen even for shorter strings.¶Output from processes can arrive in between bunches.¶¶(fn PROCESS STRING)",
"process-send-region":"Send current contents of region as input to PROCESS.¶PROCESS may be a process, a buffer, the name of a process or buffer, or¶nil, indicating the current buffer’s process.¶Called from program, takes three arguments, PROCESS, START and END.¶If the region is more than 500 characters long,¶it is sent in several bunches.  This may happen even for shorter regions.¶Output from processes can arrive in between bunches.¶¶(fn PROCESS START END)",
"process-send-eof":"Make PROCESS see end-of-file in its input.¶EOF comes after any text already sent to it.¶PROCESS may be a process, a buffer, the name of a process or buffer, or¶nil, indicating the current buffer’s process.¶If PROCESS is a network connection, or is a process communicating¶through a pipe (as opposed to a pty), then you cannot send any more¶text to PROCESS after you call this function.¶If PROCESS is a serial process, wait until all output written to the¶process has been transmitted to the serial port.¶¶(fn &amp;optional PROCESS)",
"process-running-child-p":"Return non-nil if PROCESS has given the terminal to a¶child.  If the operating system does not make it possible to find out,¶return t.  If we can find out, return the numeric ID of the foreground¶process group.¶¶(fn &amp;optional PROCESS)",
"frame-position":"Return top left corner of FRAME in pixels.¶FRAME must be a live frame and defaults to the selected one.  The return¶value is a cons (x, y) of the coordinates of the top left corner of¶FRAME’s outer frame, in pixels relative to an origin (0, 0) of FRAME’s¶display.¶¶(fn &amp;optional FRAME)",
"set-frame-position":"Set position of FRAME to (X, Y).¶FRAME must be a live frame and defaults to the selected one.  X and Y,¶if positive, specify the coordinate of the left and top edge of FRAME’s¶outer frame in pixels relative to an origin (0, 0) of FRAME’s display.¶If any of X or Y is negative, it specifies the coordinates of the right¶or bottom edge of the outer frame of FRAME relative to the right or¶bottom edge of FRAME’s display.¶¶(fn FRAME X Y)",
"frame-pixel-height":"Return a FRAME’s height in pixels.¶If FRAME is omitted or nil, the selected frame is used.  The exact value¶of the result depends on the window-system and toolkit in use:¶¶In the Gtk+ version of Emacs, it includes only any window (including¶the minibuffer or echo area), mode line, and header line.  It does not¶include the tool bar or menu bar.¶¶With other graphical versions, it also includes the tool bar and the¶menu bar.¶¶For a text terminal, it includes the menu bar.  In this case, the¶result is really in characters rather than pixels (i.e., is identical¶to ‘frame-height’).¶¶(fn &amp;optional FRAME)",
"frame-pixel-width":"Return FRAME’s width in pixels.¶For a terminal frame, the result really gives the width in characters.¶If FRAME is omitted or nil, the selected frame is used.¶¶(fn &amp;optional FRAME)",
"frame-text-height":"Return text area height of FRAME in pixels.¶¶(fn &amp;optional FRAME)",
"frame-text-width":"Return text area width of FRAME in pixels.¶¶(fn &amp;optional FRAME)",
"frame-height":"Return number of lines available for display on FRAME.¶If FRAME is omitted, describe the currently selected frame.¶Exactly what is included in the return value depends on the¶window-system and toolkit in use - see ‘frame-pixel-height’ for¶more details.  The lines are in units of the default font height.¶¶The result is roughly related to the frame pixel height via¶height in pixels = height in lines * ‘frame-char-height’.¶However, this is only approximate, and is complicated e.g. by the¶fact that individual window lines and menu bar lines can have¶differing font heights.¶¶(fn &amp;optional FRAME)",
"frame-width":"Return number of columns available for display on FRAME.¶If FRAME is omitted, describe the currently selected frame.¶¶(fn &amp;optional FRAME)",
"set-frame-size":"Set text size of FRAME to WIDTH by HEIGHT, measured in characters.¶Optional argument PIXELWISE non-nil means to measure in pixels.  Note:¶When ‘frame-resize-pixelwise’ is nil, some window managers may refuse to¶honor a WIDTH that is not an integer multiple of the default frame font¶width or a HEIGHT that is not an integer multiple of the default frame¶font height.¶¶(fn FRAME WIDTH HEIGHT &amp;optional PIXELWISE)",
"set-frame-height":"Set text height of frame FRAME to HEIGHT lines.¶Optional third arg PRETEND non-nil means that redisplay should use¶HEIGHT lines but that the idea of the actual height of the frame should¶not be changed.¶¶Optional fourth argument PIXELWISE non-nil means that FRAME should be¶HEIGHT pixels high.  Note: When ‘frame-resize-pixelwise’ is nil, some¶window managers may refuse to honor a HEIGHT that is not an integer¶multiple of the default frame font height.¶¶(fn FRAME HEIGHT &amp;optional PRETEND PIXELWISE)",
"set-frame-width":"Set text width of frame FRAME to WIDTH columns.¶Optional third arg PRETEND non-nil means that redisplay should use WIDTH¶columns but that the idea of the actual width of the frame should not¶be changed.¶¶Optional fourth argument PIXELWISE non-nil means that FRAME should be¶WIDTH pixels wide.  Note: When ‘frame-resize-pixelwise’ is nil, some¶window managers may refuse to honor a WIDTH that is not an integer¶multiple of the default frame font width.¶¶(fn FRAME WIDTH &amp;optional PRETEND PIXELWISE)",
"recursion-depth":"Return the current depth in recursive edits.¶¶(fn)",
"buffer-substring":"Return the contents of part of the current buffer as a string.¶The two arguments START and END are character positions;¶they can be in either order.¶The string returned is multibyte if the buffer is multibyte.¶¶This function copies the text properties of that part of the buffer¶into the result string; if you don’t want the text properties,¶use ‘buffer-substring-no-properties’ instead.¶¶(fn START END)",
"buffer-substring-no-properties":"Return the characters of part of the buffer, without the text properties.¶The two arguments START and END are character positions;¶they can be in either order.¶¶(fn START END)",
"buffer-string":"Return the contents of the current buffer as a string.¶If narrowing is in effect, this function returns only the visible part¶of the buffer.¶¶(fn)",
"filter-buffer-substring":"Return the buffer substring between BEG and END, after filtering.¶If DELETE is non-nil, delete the text between BEG and END from the buffer.¶¶This calls the function that ‘filter-buffer-substring-function’ specifies¶(passing the same three arguments that it received) to do the work,¶and returns whatever it does.  The default function does no filtering,¶unless a hook has been set.¶¶Use ‘filter-buffer-substring’ instead of ‘buffer-substring’,¶‘buffer-substring-no-properties’, or ‘delete-and-extract-region’ when¶you want to allow filtering to take place.  For example, major or minor¶modes can use ‘filter-buffer-substring-function’ to extract characters¶that are special to a buffer, and should not be copied into other buffers.¶¶(fn BEG END &amp;optional DELETE)",
"current-word":"Return the symbol or word that point is on (or a nearby one) as a string.¶The return value includes no text properties.¶If optional arg STRICT is non-nil, return nil unless point is within¶or adjacent to a symbol or word.  In all cases the value can be nil¶if there is no word nearby.¶The function, belying its name, normally finds a symbol.¶If optional arg REALLY-WORD is non-nil, it finds just a word.¶¶(fn &amp;optional STRICT REALLY-WORD)",
"thing-at-point":"Return the THING at point.¶THING should be a symbol specifying a type of syntactic entity.¶Possibilities include ‘symbol’, ‘list’, ‘sexp’, ‘defun’,¶‘filename’, ‘url’, ‘email’, ‘word’, ‘sentence’, ‘whitespace’,¶‘line’, ‘number’, and ‘page’.¶¶When the optional argument NO-PROPERTIES is non-nil,¶strip text properties from the return value.¶¶See the file ‘thingatpt.el’ for documentation on how to define¶a symbol as a valid THING.¶¶(fn THING &amp;optional NO-PROPERTIES)",
"bufferp":"Return t if OBJECT is an editor buffer.¶¶(fn OBJECT)",
"random":"Return a pseudo-random number.¶All integers representable in Lisp, i.e. between ‘most-negative-fixnum’¶and ‘most-positive-fixnum’, inclusive, are equally likely.¶¶With positive integer LIMIT, return random number in interval [0,LIMIT).¶With argument t, set the random number seed from the system’s entropy¶pool if available, otherwise from less-random volatile data such as the time.¶With a string argument, set the seed based on the string’s contents.¶Other values of LIMIT are ignored.¶¶See Info node ‘(elisp)Random Numbers’ for more details.¶¶(fn &amp;optional LIMIT)",
"processp":"Return t if OBJECT is a process.¶¶(fn OBJECT)",
"case-table-p":"Return t if OBJECT is a case table.¶See ‘set-case-table’ for more information on these data structures.¶¶(fn OBJECT)",
"set-standard-case-table":"Select a new standard case table for new buffers.¶See ‘set-case-table’ for more info on case tables.¶¶(fn TABLE)",
"standard-case-table":"Return the standard case table.¶This is the one used for new buffers.¶¶(fn)",
"current-case-table":"Return the case table of the current buffer.¶¶(fn)",
"set-case-table":"Select a new case table for the current buffer.¶A case table is a char-table which maps characters¶to their lower-case equivalents.  It also has three &quot;extra&quot; slots¶which may be additional char-tables or nil.¶These slots are called UPCASE, CANONICALIZE and EQUIVALENCES.¶UPCASE maps each non-upper-case character to its upper-case equivalent.¶ (The value in UPCASE for an upper-case character is never used.)¶ If lower and upper case characters are in 1-1 correspondence,¶ you may use nil and the upcase table will be deduced from DOWNCASE.¶CANONICALIZE maps each character to a canonical equivalent;¶ any two characters that are related by case-conversion have the same¶ canonical equivalent character; it may be nil, in which case it is¶ deduced from DOWNCASE and UPCASE.¶EQUIVALENCES is a map that cyclically permutes each equivalence class¶ (of characters with the same canonical equivalent); it may be nil,¶ in which case it is deduced from CANONICALIZE.¶¶(fn TABLE)",
"set-case-syntax-pair":"Make characters UC and LC a pair of inter-case-converting letters.¶This sets the entries for characters UC and LC in TABLE, which is a string¶that will be used as the downcase part of a case table.¶It also modifies ‘standard-syntax-table’ to give them the syntax of¶word constituents.¶¶(fn UC LC TABLE)",
"set-case-syntax-delims":"Make characters L and R a matching pair of non-case-converting delimiters.¶This sets the entries for L and R in TABLE, which is a string¶that will be used as the downcase part of a case table.¶It also modifies ‘standard-syntax-table’ to¶indicate left and right delimiters.¶¶(fn L R TABLE)",
"set-case-syntax":"Make character C case-invariant with syntax SYNTAX.¶This sets the entry for character C in TABLE, which is a string¶that will be used as the downcase part of a case table.¶It also modifies ‘standard-syntax-table’.¶SYNTAX should be &quot; &quot;, &quot;w&quot;, &quot;.&quot; or &quot;_&quot;.¶¶(fn C SYNTAX TABLE)",
"window-prev-buffers":"Return buffers previously shown in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶The return value is a list of elements (BUFFER WINDOW-START POS),¶where BUFFER is a buffer, WINDOW-START is the start position of the¶window for that buffer, and POS is a window-specific point value.¶¶(fn &amp;optional WINDOW)",
"set-window-prev-buffers":"Set WINDOW’s previous buffers to PREV-BUFFERS.¶WINDOW must be a live window and defaults to the selected one.¶¶PREV-BUFFERS should be a list of elements (BUFFER WINDOW-START POS),¶where BUFFER is a buffer, WINDOW-START is the start position of the¶window for that buffer, and POS is a window-specific point value.¶¶(fn WINDOW PREV-BUFFERS)",
"window-next-buffers":"Return list of buffers recently re-shown in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"set-window-next-buffers":"Set WINDOW’s next buffers to NEXT-BUFFERS.¶WINDOW must be a live window and defaults to the selected one.¶NEXT-BUFFERS should be a list of buffers.¶¶(fn WINDOW NEXT-BUFFERS)",
"read-passwd":"Read a password, prompting with PROMPT, and return it.¶If optional CONFIRM is non-nil, read the password twice to make sure.¶Optional DEFAULT is a default password to use instead of empty input.¶¶This function echoes ‘.’ for each character that the user types.¶You could let-bind ‘read-hide-char’ to another hiding character, though.¶¶Once the caller uses the password, it can erase the password¶by doing (clear-string STRING).¶¶(fn PROMPT &amp;optional CONFIRM DEFAULT)",
"frame-list":"Return a list of all live frames.¶¶(fn)",
"visible-frame-list":"Return a list of all frames now &quot;visible&quot; (being updated).¶¶(fn)",
"next-frame":"Return the next frame in the frame list after FRAME.¶It considers only frames on the same terminal as FRAME.¶By default, skip minibuffer-only frames.¶If omitted, FRAME defaults to the selected frame.¶If optional argument MINIFRAME is nil, exclude minibuffer-only frames.¶If MINIFRAME is a window, include only its own frame¶and any frame now using that window as the minibuffer.¶If MINIFRAME is ‘visible’, include all visible frames.¶If MINIFRAME is 0, include all visible and iconified frames.¶Otherwise, include all frames.¶¶(fn &amp;optional FRAME MINIFRAME)",
"previous-frame":"Return the previous frame in the frame list before FRAME.¶It considers only frames on the same terminal as FRAME.¶By default, skip minibuffer-only frames.¶If omitted, FRAME defaults to the selected frame.¶If optional argument MINIFRAME is nil, exclude minibuffer-only frames.¶If MINIFRAME is a window, include only its own frame¶and any frame now using that window as the minibuffer.¶If MINIFRAME is ‘visible’, include all visible frames.¶If MINIFRAME is 0, include all visible and iconified frames.¶Otherwise, include all frames.¶¶(fn &amp;optional FRAME MINIFRAME)",
"face-list":"Return a list of all defined faces.",
"face-id":"Return the internal ID of face with name FACE.¶If FACE is a face-alias, return the ID of the target face.¶The optional argument FRAME is ignored, since the internal face ID¶of a face name is the same for all frames.",
"face-equal":"Non-nil if faces FACE1 and FACE2 are equal.¶Faces are considered equal if all their attributes are equal.¶If the optional argument FRAME is given, report on FACE1 and FACE2 in that frame.¶If FRAME is t, report on the defaults for FACE1 and FACE2 (for new frames).¶If FRAME is omitted or nil, use the selected frame.",
"face-differs-from-default-p":"Return non-nil if FACE displays differently from the default face.¶If the optional argument FRAME is given, report on face FACE in that frame.¶If FRAME is t, report on the defaults for face FACE (for new frames).¶If FRAME is omitted or nil, use the selected frame.",
"file-symlink-p":"Return non-nil if file FILENAME is the name of a symbolic link.¶The value is the link target, as a string.¶Otherwise it returns nil.¶¶This function does not check whether the link target exists.¶¶(fn FILENAME)",
"file-directory-p":"Return t if FILENAME names an existing directory.¶Symbolic links to directories count as directories.¶See ‘file-symlink-p’ to distinguish symlinks.¶¶(fn FILENAME)",
"file-regular-p":"Return t if FILENAME names a regular file.¶This is the sort of file that holds an ordinary stream of data bytes.¶Symbolic links to regular files count as regular files.¶See ‘file-symlink-p’ to distinguish symlinks.¶¶(fn FILENAME)",
"find-file-noselect":"Read file FILENAME into a buffer and return the buffer.¶If a buffer exists visiting FILENAME, return that one, but¶verify that the file has not changed since visited or saved.¶The buffer is not selected, just returned to the caller.¶Optional second arg NOWARN non-nil means suppress any warning messages.¶Optional third arg RAWFILE non-nil means the file is read literally.¶Optional fourth arg WILDCARDS non-nil means do wildcard processing¶and visit all the matching files.  When wildcards are actually¶used and expanded, return a list of buffers that are visiting¶the various files.¶¶(fn FILENAME &amp;optional NOWARN RAWFILE WILDCARDS)",
"event-click-count":"Return the multi-click count of EVENT, a click or drag event.¶The return value is a positive integer.¶¶(fn EVENT)",
"fontp":"Return t if OBJECT is a font-spec, font-entity, or font-object.¶Return nil otherwise.¶Optional 2nd argument EXTRA-TYPE, if non-nil, specifies to check¶which kind of font it is.  It must be one of ‘font-spec’, ‘font-entity’,¶‘font-object’.¶¶(fn OBJECT &amp;optional EXTRA-TYPE)",
"font-at":"Return a font-object for displaying a character at POSITION.¶Optional second arg WINDOW, if non-nil, is a window displaying¶the current buffer.  It defaults to the currently selected window.¶Optional third arg STRING, if non-nil, is a string containing the target¶character at index specified by POSITION.¶¶(fn POSITION &amp;optional WINDOW STRING)",
"font-spec":"Return a newly created font-spec with arguments as properties.¶¶ARGS must come in pairs KEY VALUE of font properties.  KEY must be a¶valid font property name listed below:¶¶‘:family’, ‘:weight’, ‘:slant’, ‘:width’¶¶They are the same as face attributes of the same name.  See¶‘set-face-attribute’.¶¶‘:foundry’¶¶VALUE must be a string or a symbol specifying the font foundry, e.g. ‘misc’.¶¶‘:adstyle’¶¶VALUE must be a string or a symbol specifying the additional¶typographic style information of a font, e.g. ‘sans’.¶¶‘:registry’¶¶VALUE must be a string or a symbol specifying the charset registry and¶encoding of a font, e.g. ‘iso8859-1’.¶¶‘:size’¶¶VALUE must be a non-negative integer or a floating point number¶specifying the font size.  It specifies the font size in pixels (if¶VALUE is an integer), or in points (if VALUE is a float).¶¶‘:name’¶¶VALUE must be a string of XLFD-style or fontconfig-style font name.¶¶‘:script’¶¶VALUE must be a symbol representing a script that the font must¶support.  It may be a symbol representing a subgroup of a script¶listed in the variable ‘script-representative-chars’.¶¶‘:lang’¶¶VALUE must be a symbol whose name is a two-letter ISO-639 language¶name, e.g. ‘ja’.  The value is matched against the &quot;Additional Style&quot;¶field of the XLFD spec of a font, if it’s non-empty, on X, and¶against the codepages supported by the font on w32.¶¶‘:otf’¶¶VALUE must be a list (SCRIPT-TAG LANGSYS-TAG GSUB [ GPOS ]) to specify¶required OpenType features.¶¶  SCRIPT-TAG: OpenType script tag symbol (e.g. ‘deva’).¶  LANGSYS-TAG: OpenType language system tag symbol,¶     or nil for the default language system.¶  GSUB: List of OpenType GSUB feature tag symbols, or nil if none required.¶  GPOS: List of OpenType GPOS feature tag symbols, or nil if none required.¶¶GSUB and GPOS may contain nil elements.  In such a case, the font¶must not have any of the remaining elements.¶¶For instance, if the VALUE is ‘(thai nil nil (mark))’, the font must¶be an OpenType font whose GPOS table of ‘thai’ script’s default¶language system must contain ‘mark’ feature.¶¶(fn ARGS...)",
"font-put":"Set one property of FONT: give property KEY value VAL.¶FONT is a font-spec, a font-entity, or a font-object.¶¶If FONT is a font-spec, KEY can be any symbol.  But if KEY is the one¶accepted by the function ‘font-spec’ (which see), VAL must be what¶allowed in ‘font-spec’.¶¶If FONT is a font-entity or a font-object, KEY must not be the one¶accepted by ‘font-spec’.¶¶(fn FONT PROP VAL)",
"find-font":"Return a font-entity matching with FONT-SPEC on the current frame.¶Optional 2nd argument FRAME, if non-nil, specifies the target frame.¶¶(fn FONT-SPEC &amp;optional FRAME)",
"list-fonts":"List available fonts matching FONT-SPEC on the current frame.¶Optional 2nd argument FRAME specifies the target frame.¶Optional 3rd argument NUM, if non-nil, limits the number of returned fonts.¶Optional 4th argument PREFER, if non-nil, is a font-spec to¶control the order of the returned list.  Fonts are sorted by¶how close they are to PREFER.¶¶(fn FONT-SPEC &amp;optional FRAME NUM PREFER)",
"font-get":"Return the value of FONT’s property KEY.¶FONT is a font-spec, a font-entity, or a font-object.¶KEY is any symbol, but these are reserved for specific meanings:¶  :family, :weight, :slant, :width, :foundry, :adstyle, :registry,¶  :size, :name, :script, :otf¶See the documentation of ‘font-spec’ for their meanings.¶In addition, if FONT is a font-entity or a font-object, values of¶:script and :otf are different from those of a font-spec as below:¶¶The value of :script may be a list of scripts that are supported by the font.¶¶The value of :otf is a cons (GSUB . GPOS) where GSUB and GPOS are lists¶representing the OpenType features supported by the font by this form:¶  ((SCRIPT (LANGSYS FEATURE ...) ...) ...)¶SCRIPT, LANGSYS, and FEATURE are all symbols representing OpenType¶Layout tags.¶¶In addition to the keys listed abobe, the following keys are reserved¶for the specific meanings as below:¶¶The value of :combining-capability is non-nil if the font-backend of¶FONT supports rendering of combining characters for non-OTF fonts.¶¶(fn FONT KEY)",
"font-face-attributes":"Return a plist of face attributes generated by FONT.¶FONT is a font name, a font-spec, a font-entity, or a font-object.¶The return value is a list of the form¶¶(:family FAMILY :height HEIGHT :weight WEIGHT :slant SLANT :width WIDTH)¶¶where FAMILY, HEIGHT, WEIGHT, SLANT, and WIDTH are face attribute values¶compatible with ‘set-face-attribute’.  Some of these key-attribute pairs¶may be omitted from the list if they are not specified by FONT.¶¶The optional argument FRAME specifies the frame that the face attributes¶are to be displayed on.  If omitted, the selected frame is used.¶¶(fn FONT &amp;optional FRAME)",
"font-xlfd-name":"Return XLFD name of FONT.¶FONT is a font-spec, font-entity, or font-object.¶If the name is too long for XLFD (maximum 255 chars), return nil.¶If the 2nd optional arg FOLD-WILDCARDS is non-nil,¶the consecutive wildcards are folded into one.¶¶(fn FONT &amp;optional FOLD-WILDCARDS)",
"font-info":"Return information about a font named NAME on frame FRAME.¶If FRAME is omitted or nil, use the selected frame.¶¶The returned value is a vector:¶  [ OPENED-NAME FULL-NAME SIZE HEIGHT BASELINE-OFFSET RELATIVE-COMPOSE¶    DEFAULT-ASCENT MAX-WIDTH ASCENT DESCENT SPACE-WIDTH AVERAGE-WIDTH¶    CAPABILITY ]¶where¶  OPENED-NAME is the name used for opening the font,¶  FULL-NAME is the full name of the font,¶  SIZE is the pixelsize of the font,¶  HEIGHT is the pixel-height of the font (i.e., ascent + descent),¶  BASELINE-OFFSET is the upward offset pixels from ASCII baseline,¶  RELATIVE-COMPOSE and DEFAULT-ASCENT are the numbers controlling¶    how to compose characters,¶  MAX-WIDTH is the maximum advance width of the font,¶  ASCENT, DESCENT, SPACE-WIDTH, AVERAGE-WIDTH are metrics of the font¶    in pixels,¶  FILENAME is the font file name, a string (or nil if the font backend¶    doesn’t provide a file name).¶  CAPABILITY is a list whose first element is a symbol representing the¶    font format, one of x, opentype, truetype, type1, pcf, or bdf.¶    The remaining elements describe the details of the font capabilities,¶    as follows:¶¶      If the font is OpenType font, the form of the list is¶        (opentype GSUB GPOS)¶      where GSUB shows which &quot;GSUB&quot; features the font supports, and GPOS¶      shows which &quot;GPOS&quot; features the font supports.  Both GSUB and GPOS are¶      lists of the form:¶\t((SCRIPT (LANGSYS FEATURE ...) ...) ...)¶¶      where¶        SCRIPT is a symbol representing OpenType script tag.¶        LANGSYS is a symbol representing OpenType langsys tag, or nil¶         representing the default langsys.¶        FEATURE is a symbol representing OpenType feature tag.¶¶      If the font is not an OpenType font, there are no elements¶      in CAPABILITY except the font format symbol.¶¶If the named font is not yet loaded, return nil.¶¶(fn NAME &amp;optional FRAME)",
"query-font":"Return information about FONT-OBJECT.¶The value is a vector:¶  [ NAME FILENAME PIXEL-SIZE SIZE ASCENT DESCENT SPACE-WIDTH AVERAGE-WIDTH¶    CAPABILITY ]¶¶NAME is the font name, a string (or nil if the font backend doesn’t¶provide a name).¶¶FILENAME is the font file name, a string (or nil if the font backend¶doesn’t provide a file name).¶¶PIXEL-SIZE is a pixel size by which the font is opened.¶¶SIZE is a maximum advance width of the font in pixels.¶¶ASCENT, DESCENT, SPACE-WIDTH, AVERAGE-WIDTH are metrics of the font in¶pixels.¶¶CAPABILITY is a list whose first element is a symbol representing the¶font format (x, opentype, truetype, type1, pcf, or bdf) and the¶remaining elements describe the details of the font capability.¶¶If the font is OpenType font, the form of the list is¶  (opentype GSUB GPOS)¶where GSUB shows which &quot;GSUB&quot; features the font supports, and GPOS¶shows which &quot;GPOS&quot; features the font supports.  Both GSUB and GPOS are¶lists of the format:¶  ((SCRIPT (LANGSYS FEATURE ...) ...) ...)¶¶If the font is not OpenType font, currently the length of the form is¶one.¶¶SCRIPT is a symbol representing OpenType script tag.¶¶LANGSYS is a symbol representing OpenType langsys tag, or nil¶representing the default langsys.¶¶FEATURE is a symbol representing OpenType feature tag.¶¶If the font is not OpenType font, CAPABILITY is nil.¶¶(fn FONT-OBJECT)",
"default-font-width":"Return the width in pixels of the current buffer’s default face font.¶¶If the default font is remapped (see ‘face-remapping-alist’), the¶function returns the width of the remapped face.",
"default-font-height":"Return the height in pixels of the current buffer’s default face font.¶¶If the default font is remapped (see ‘face-remapping-alist’), the¶function returns the height of the remapped face.",
"window-font-width":"Return average character width for the font of FACE used in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶If FACE is nil or omitted, the default face is used.  If FACE is¶remapped (see ‘face-remapping-alist’), the function returns the¶information for the remapped face.",
"window-font-height":"Return character height for the font of FACE used in WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶If FACE is nil or omitted, the default face is used.  If FACE is¶remapped (see ‘face-remapping-alist’), the function returns the¶information for the remapped face.",
"kbd":"Convert KEYS to the internal Emacs key representation.¶KEYS should be a string in the format returned by commands such¶as ‘C-h k’ (‘describe-key’).¶This is the same format used for saving keyboard macros (see¶‘edmacro-mode’).¶¶(fn KEYS)",
"terminal-name":"Return the name of the terminal device TERMINAL.¶It is not guaranteed that the returned value is unique among opened devices.¶¶TERMINAL may be a terminal object, a frame, or nil (meaning the¶selected frame’s terminal).¶¶(fn &amp;optional TERMINAL)",
"terminal-list":"Return a list of all terminal devices.¶¶(fn)",
"get-device-terminal":"Return the terminal corresponding to DEVICE.¶DEVICE can be a terminal, a frame, nil (meaning the selected frame’s terminal),¶the name of an X display device (HOST.SERVER.SCREEN) or a tty device file.¶¶(fn DEVICE)",
"delete-terminal":"Delete TERMINAL by deleting all frames on it and closing the terminal.¶TERMINAL may be a terminal object, a frame, or nil (meaning the¶selected frame’s terminal).¶¶Normally, you may not delete a display if all other displays are suspended,¶but if the second argument FORCE is non-nil, you may do so.¶¶(fn &amp;optional TERMINAL FORCE)",
"x-display-list":"Return the list of display names that Emacs has connections to.¶¶(fn)",
"x-open-connection":"Open a connection to a display server.¶DISPLAY is the name of the display to connect to.¶Optional second arg XRM-STRING is a string of resources in xrdb format.¶If the optional third arg MUST-SUCCEED is non-nil,¶terminate Emacs if we can’t open the connection.¶(In the Nextstep version, the last two arguments are currently ignored.)¶¶(fn DISPLAY &amp;optional XRM-STRING MUST-SUCCEED)",
"x-close-connection":"Close the connection to TERMINAL’s X server.¶For TERMINAL, specify a terminal object, a frame or a display name (a¶string).  If TERMINAL is nil, that stands for the selected frame’s¶terminal.¶¶(fn TERMINAL)",
"display-monitor-attributes-list":"Return a list of physical monitor attributes on DISPLAY.¶DISPLAY can be a display name, a terminal name, or a frame.¶If DISPLAY is omitted or nil, it defaults to the selected frame’s display.¶Each element of the list represents the attributes of a physical¶monitor.  The first element corresponds to the primary monitor.¶¶The attributes for a physical monitor are represented as an alist¶of attribute keys and values as follows:¶¶ geometry -- Position and size in pixels in the form of (X Y WIDTH HEIGHT)¶ workarea -- Position and size of the work area in pixels in the¶\t     form of (X Y WIDTH HEIGHT)¶ mm-size  -- Width and height in millimeters in the form of¶ \t     (WIDTH HEIGHT)¶ frames   -- List of frames dominated by the physical monitor¶ name (*) -- Name of the physical monitor as a string¶ source (*) -- Source of multi-monitor information as a string¶¶where X, Y, WIDTH, and HEIGHT are integers.  X and Y are coordinates¶of the top-left corner, and might be negative for monitors other than¶the primary one.  Keys labeled with (*) are optional.¶¶The &quot;work area&quot; is a measure of the &quot;usable&quot; display space.¶It may be less than the total screen size, owing to space taken up¶by window manager features (docks, taskbars, etc.).  The precise¶details depend on the platform and environment.¶¶The ‘source’ attribute describes the source from which the information¶was obtained.  On X, this may be one of: &quot;Gdk&quot;, &quot;XRandr&quot;, &quot;Xinerama&quot;,¶or &quot;fallback&quot;.¶¶A frame is dominated by a physical monitor when either the¶largest area of the frame resides in the monitor, or the monitor¶is the closest to the frame if the frame does not intersect any¶physical monitors.  Every (non-tooltip) frame (including invisible ones)¶in a graphical display is dominated by exactly one physical¶monitor at a time, though it can span multiple (or no) physical¶monitors.¶¶(fn &amp;optional DISPLAY)",
"frame-monitor-attributes":"Return the attributes of the physical monitor dominating FRAME.¶If FRAME is omitted or nil, describe the currently selected frame.¶¶A frame is dominated by a physical monitor when either the¶largest area of the frame resides in the monitor, or the monitor¶is the closest to the frame if the frame does not intersect any¶physical monitors.¶¶See ‘display-monitor-attributes-list’ for the list of attribute¶keys and their meanings.¶¶(fn &amp;optional FRAME)",
"read-event":"Read an event object from the input stream.¶If the optional argument PROMPT is non-nil, display that as a prompt.¶If the optional argument INHERIT-INPUT-METHOD is non-nil and some¶input method is turned on in the current buffer, that input method¶is used for reading a character.¶If the optional argument SECONDS is non-nil, it should be a number¶specifying the maximum number of seconds to wait for input.  If no¶input arrives in that time, return nil.  SECONDS may be a¶floating-point value.¶¶(fn &amp;optional PROMPT INHERIT-INPUT-METHOD SECONDS)",
"read-char":"Read a character from the command input (keyboard or macro).¶It is returned as a number.¶If the character has modifiers, they are resolved and reflected to the¶character code if possible (e.g. C-SPC -&gt; 0).¶¶If the user generates an event which is not a character (i.e. a mouse¶click or function key event), ‘read-char’ signals an error.  As an¶exception, switch-frame events are put off until non-character events¶can be read.¶If you want to read non-character events, or ignore them, call¶‘read-event’ or ‘read-char-exclusive’ instead.¶¶If the optional argument PROMPT is non-nil, display that as a prompt.¶If the optional argument INHERIT-INPUT-METHOD is non-nil and some¶input method is turned on in the current buffer, that input method¶is used for reading a character.¶If the optional argument SECONDS is non-nil, it should be a number¶specifying the maximum number of seconds to wait for input.  If no¶input arrives in that time, return nil.  SECONDS may be a¶floating-point value.¶¶(fn &amp;optional PROMPT INHERIT-INPUT-METHOD SECONDS)",
"read-char-exclusive":"Read a character from the command input (keyboard or macro).¶It is returned as a number.  Non-character events are ignored.¶If the character has modifiers, they are resolved and reflected to the¶character code if possible (e.g. C-SPC -&gt; 0).¶¶If the optional argument PROMPT is non-nil, display that as a prompt.¶If the optional argument INHERIT-INPUT-METHOD is non-nil and some¶input method is turned on in the current buffer, that input method¶is used for reading a character.¶If the optional argument SECONDS is non-nil, it should be a number¶specifying the maximum number of seconds to wait for input.  If no¶input arrives in that time, return nil.  SECONDS may be a¶floating-point value.¶¶(fn &amp;optional PROMPT INHERIT-INPUT-METHOD SECONDS)",
"read-key":"Read a key from the keyboard.¶Contrary to ‘read-event’ this will not return a raw event but instead will¶obey the input decoding and translations usually done by ‘read-key-sequence’.¶So escape sequences and keyboard encoding are taken into account.¶When there’s an ambiguity because the key looks like the prefix of¶some sort of escape sequence, the ambiguity is resolved via ‘read-key-delay’.¶¶(fn &amp;optional PROMPT)",
"read-char-choice":"Read and return one of CHARS, prompting for PROMPT.¶Any input that is not one of CHARS is ignored.¶¶If optional argument INHIBIT-KEYBOARD-QUIT is non-nil, ignore¶keyboard-quit events while waiting for a valid input.¶¶(fn PROMPT CHARS &amp;optional INHIBIT-KEYBOARD-QUIT)",
"backtrace-debug":"Set the debug-on-exit flag of eval frame LEVEL levels down to FLAG.¶The debugger is entered when that frame exits, if the flag is non-nil.¶¶(fn LEVEL FLAG)",
"backtrace-frame":"Return the function and arguments NFRAMES up from current execution point.¶If that frame has not evaluated the arguments yet (or is a special form),¶the value is (nil FUNCTION ARG-FORMS...).¶If that frame has evaluated its arguments and called its function already,¶the value is (t FUNCTION ARG-VALUES...).¶A &amp;rest arg is represented as the tail of the list ARG-VALUES.¶FUNCTION is whatever was supplied as car of evaluated list,¶or a lambda expression for macro calls.¶If NFRAMES is more than the number of frames, the value is nil.¶If BASE is non-nil, it should be a function and NFRAMES counts from its¶nearest activation frame.¶¶(fn NFRAMES &amp;optional BASE)",
"directory-files":"Return a list of names of files in DIRECTORY.¶There are three optional arguments:¶If FULL is non-nil, return absolute file names.  Otherwise return names¶ that are relative to the specified directory.¶If MATCH is non-nil, mention only file names that match the regexp MATCH.¶If NOSORT is non-nil, the list is not sorted--its order is unpredictable.¶ Otherwise, the list returned is sorted with ‘string-lessp’.¶ NOSORT is useful if you plan to sort the result yourself.¶¶(fn DIRECTORY &amp;optional FULL MATCH NOSORT)",
"directory-files-recursively":"Return list of all files under DIR that have file names matching REGEXP.¶This function works recursively.  Files are returned in &quot;depth first&quot;¶order, and files from each directory are sorted in alphabetical order.¶Each file name appears in the returned list in its absolute form.¶Optional argument INCLUDE-DIRECTORIES non-nil means also include in the¶output directories whose names match REGEXP.¶¶(fn DIR REGEXP &amp;optional INCLUDE-DIRECTORIES)",
"directory-files-and-attributes":"Return a list of names of files and their attributes in DIRECTORY.¶There are four optional arguments:¶If FULL is non-nil, return absolute file names.  Otherwise return names¶ that are relative to the specified directory.¶If MATCH is non-nil, mention only file names that match the regexp MATCH.¶If NOSORT is non-nil, the list is not sorted--its order is unpredictable.¶ NOSORT is useful if you plan to sort the result yourself.¶ID-FORMAT specifies the preferred format of attributes uid and gid, see¶‘file-attributes’ for further documentation.¶On MS-Windows, performance depends on ‘w32-get-true-file-attributes’,¶which see.¶¶(fn DIRECTORY &amp;optional FULL MATCH NOSORT ID-FORMAT)",
"file-expand-wildcards":"Expand wildcard pattern PATTERN.¶This returns a list of file names which match the pattern.¶Files are sorted in ‘string&lt;’ order.¶¶If PATTERN is written as an absolute file name,¶the values are absolute also.¶¶If PATTERN is written as a relative file name, it is interpreted¶relative to the current default directory, ‘default-directory’.¶The file names returned are normally also relative to the current¶default directory.  However, if FULL is non-nil, they are absolute.¶¶(fn PATTERN &amp;optional FULL)",
"insert-directory":"Insert directory listing for FILE, formatted according to SWITCHES.¶Leaves point after the inserted text.¶SWITCHES may be a string of options, or a list of strings¶representing individual options.¶Optional third arg WILDCARD means treat FILE as shell wildcard.¶Optional fourth arg FULL-DIRECTORY-P means file is a directory and¶switches do not contain ‘d’, so that a full listing is expected.¶¶This works by running a directory listing program¶whose name is in the variable ‘insert-directory-program’.¶If WILDCARD, it also runs the shell specified by ‘shell-file-name’.¶¶When SWITCHES contains the long ‘--dired’ option, this function¶treats it specially, for the sake of dired.  However, the¶normally equivalent short ‘-D’ option is just passed on to¶‘insert-directory-program’, as any other option.¶¶(fn FILE SWITCHES &amp;optional WILDCARD FULL-DIRECTORY-P)",
"scan-lists":"Scan from character number FROM by COUNT lists.¶Scan forward if COUNT is positive, backward if COUNT is negative.¶Return the character number of the position thus found.¶¶A &quot;list&quot;, in this context, refers to a balanced parenthetical¶grouping, as determined by the syntax table.¶¶If DEPTH is nonzero, treat that as the nesting depth of the starting¶point (i.e. the starting point is DEPTH parentheses deep).  This¶function scans over parentheses until the depth goes to zero COUNT¶times.  Hence, positive DEPTH moves out that number of levels of¶parentheses, while negative DEPTH moves to a deeper level.¶¶Comments are ignored if ‘parse-sexp-ignore-comments’ is non-nil.¶¶If we reach the beginning or end of the accessible part of the buffer¶before we have scanned over COUNT lists, return nil if the depth at¶that point is zero, and signal a error if the depth is nonzero.¶¶(fn FROM COUNT DEPTH)",
"scan-sexps":"Scan from character number FROM by COUNT balanced expressions.¶If COUNT is negative, scan backwards.¶Returns the character number of the position thus found.¶¶Comments are ignored if ‘parse-sexp-ignore-comments’ is non-nil.¶¶If the beginning or end of (the accessible part of) the buffer is reached¶in the middle of a parenthetical grouping, an error is signaled.¶If the beginning or end is reached between groupings¶but before count is used up, nil is returned.¶¶(fn FROM COUNT)",
"forward-comment":"Move forward across up to COUNT comments.  If COUNT is negative, move backward.¶Stop scanning if we find something other than a comment or whitespace.¶Set point to where scanning stops.¶If COUNT comments are found as expected, with nothing except whitespace¶between them, return t; otherwise return nil.¶¶(fn COUNT)",
"tq-create":"Create and return a transaction queue communicating with PROCESS.¶PROCESS should be a subprocess capable of sending and receiving¶streams of bytes.  It may be a local process, or it may be connected¶to a tcp server on another machine.¶¶(fn PROCESS)",
"set-window-fringes":"Set the fringe widths of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Second arg LEFT-WIDTH specifies the number of pixels to reserve for¶the left fringe.  Optional third arg RIGHT-WIDTH specifies the right¶fringe width.  If a fringe width arg is nil, that means to use the¶frame’s default fringe width.  Default fringe widths can be set with¶the command ‘set-fringe-style’.¶If optional fourth arg OUTSIDE-MARGINS is non-nil, draw the fringes¶outside of the display margins.  By default, fringes are drawn between¶display marginal areas and the text area.¶¶Return t if any fringe was actually changed and nil otherwise.¶¶(fn WINDOW LEFT-WIDTH &amp;optional RIGHT-WIDTH OUTSIDE-MARGINS)",
"window-fringes":"Get width of fringes of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶¶Value is a list of the form (LEFT-WIDTH RIGHT-WIDTH OUTSIDE-MARGINS).¶¶(fn &amp;optional WINDOW)",
"commandp":"Non-nil if FUNCTION makes provisions for interactive calling.¶This means it contains a description for how to read arguments to give it.¶The value is nil for an invalid function or a symbol with no function¶definition.¶¶Interactively callable functions include strings and vectors (treated¶as keyboard macros), lambda-expressions that contain a top-level call¶to ‘interactive’, autoload definitions made by ‘autoload’ with non-nil¶fourth argument, and some of the built-in functions of Lisp.¶¶Also, a symbol satisfies ‘commandp’ if its function definition does so.¶¶If the optional argument FOR-CALL-INTERACTIVELY is non-nil,¶then strings and vectors are not accepted.¶¶(fn FUNCTION &amp;optional FOR-CALL-INTERACTIVELY)",
"call-interactively":"Call FUNCTION, providing args according to its interactive calling specs.¶Return the value FUNCTION returns.¶The function contains a specification of how to do the argument reading.¶In the case of user-defined functions, this is specified by placing a call¶to the function ‘interactive’ at the top level of the function body.¶See ‘interactive’.¶¶Optional second arg RECORD-FLAG non-nil¶means unconditionally put this command in the command-history.¶Otherwise, this is done only if an arg is read using the minibuffer.¶¶Optional third arg KEYS, if given, specifies the sequence of events to¶supply, as a vector, if the command inquires which events were used to¶invoke it.  If KEYS is omitted or nil, the return value of¶‘this-command-keys-vector’ is used.¶¶(fn FUNCTION &amp;optional RECORD-FLAG KEYS)",
"funcall-interactively":"Like ‘funcall’ but marks the call as interactive.¶I.e. arrange that within the called function ‘called-interactively-p’ will¶return non-nil.¶¶(fn FUNCTION &amp;rest ARGUMENTS)",
"command-execute":"Execute CMD as an editor command.¶CMD must be a symbol that satisfies the ‘commandp’ predicate.¶Optional second arg RECORD-FLAG non-nil¶means unconditionally put this command in the variable ‘command-history’.¶Otherwise, that is done only if an arg is read using the minibuffer.¶The argument KEYS specifies the value to use instead of (this-command-keys)¶when reading the arguments; if it is nil, (this-command-keys) is used.¶The argument SPECIAL, if non-nil, means that this command is executing¶a special event, so ignore the prefix argument and don’t clear it.¶¶(fn CMD &amp;optional RECORD-FLAG KEYS SPECIAL)",
"make-bool-vector":"Return a new bool-vector of length LENGTH, using INIT for each element.¶LENGTH must be a number.  INIT matters only in whether it is t or nil.¶¶(fn LENGTH INIT)",
"bool-vector":"Return a new bool-vector with specified arguments as elements.¶Any number of arguments, even zero arguments, are allowed.¶¶(fn &amp;rest OBJECTS)",
"bool-vector-p":"Return t if OBJECT is a bool-vector.¶¶(fn OBJECT)",
"bool-vector-exclusive-or":"Return A ^ B, bitwise exclusive or.¶If optional third argument C is given, store result into C.¶A, B, and C must be bool vectors of the same length.¶Return the destination vector if it changed or nil otherwise.¶¶(fn A B &amp;optional C)",
"bool-vector-union":"Return A | B, bitwise or.¶If optional third argument C is given, store result into C.¶A, B, and C must be bool vectors of the same length.¶Return the destination vector if it changed or nil otherwise.¶¶(fn A B &amp;optional C)",
"bool-vector-intersection":"Return A &amp; B, bitwise and.¶If optional third argument C is given, store result into C.¶A, B, and C must be bool vectors of the same length.¶Return the destination vector if it changed or nil otherwise.¶¶(fn A B &amp;optional C)",
"bool-vector-set-difference":"Return A &amp;~ B, set difference.¶If optional third argument C is given, store result into C.¶A, B, and C must be bool vectors of the same length.¶Return the destination vector if it changed or nil otherwise.¶¶(fn A B &amp;optional C)",
"bool-vector-not":"Compute ~A, set complement.¶If optional second argument B is given, store result into B.¶A and B must be bool vectors of the same length.¶Return the destination vector.¶¶(fn A &amp;optional B)",
"bool-vector-subsetp":"Return t if every t value in A is also t in B, nil otherwise.¶A and B must be bool vectors of the same length.¶¶(fn A B)",
"bool-vector-count-consecutive":"Count how many consecutive elements in A equal B starting at I.¶A is a bool vector, B is t or nil, and I is an index into A.¶¶(fn A B I)",
"bool-vector-count-population":"Count how many elements in A are t.¶A is a bool vector.  To count A’s nil elements, subtract the return¶value from A’s length.¶¶(fn A)",
"current-active-maps":"Return a list of the currently active keymaps.¶OLP if non-nil indicates that we should obey ‘overriding-local-map’ and¶‘overriding-terminal-local-map’.  POSITION can specify a click position¶like in the respective argument of ‘key-binding’.¶¶(fn &amp;optional OLP POSITION)",
"key-binding":"Return the binding for command KEY in current keymaps.¶KEY is a string or vector, a sequence of keystrokes.¶The binding is probably a symbol with a function definition.¶¶Normally, ‘key-binding’ ignores bindings for t, which act as default¶bindings, used when nothing else in the keymap applies; this makes it¶usable as a general function for probing keymaps.  However, if the¶optional second argument ACCEPT-DEFAULT is non-nil, ‘key-binding’ does¶recognize the default bindings, just as ‘read-key-sequence’ does.¶¶Like the normal command loop, ‘key-binding’ will remap the command¶resulting from looking up KEY by looking up the command in the¶current keymaps.  However, if the optional third argument NO-REMAP¶is non-nil, ‘key-binding’ returns the unmapped command.¶¶If KEY is a key sequence initiated with the mouse, the used keymaps¶will depend on the clicked mouse position with regard to the buffer¶and possible local keymaps on strings.¶¶If the optional argument POSITION is non-nil, it specifies a mouse¶position as returned by ‘event-start’ and ‘event-end’, and the lookup¶occurs in the keymaps associated with it instead of KEY.  It can also¶be a number or marker, in which case the keymap properties at the¶specified buffer position instead of point are used.¶¶(fn KEY &amp;optional ACCEPT-DEFAULT NO-REMAP POSITION)",
"byte-compile":"If FORM is a symbol, byte-compile its function definition.¶If FORM is a lambda or a macro, byte-compile it as a function.¶¶(fn FORM)",
"batch-byte-compile":"Run ‘byte-compile-file’ on the files remaining on the command line.¶Use this from the command line, with ‘-batch’;¶it won’t work in an interactive Emacs.¶Each file is processed even if an error occurred previously.¶For example, invoke &quot;emacs -batch -f batch-byte-compile $emacs/ ~/*.el&quot;.¶If NOFORCE is non-nil, don’t recompile a file that seems to be¶already up-to-date.¶¶(fn &amp;optional NOFORCE)",
"tooltip-mode":"Toggle Tooltip mode.¶With a prefix argument ARG, enable Tooltip mode if ARG is positive,¶and disable it otherwise.  If called from Lisp, enable the mode¶if ARG is omitted or nil.¶¶When this global minor mode is enabled, Emacs displays help¶text (e.g. for buttons and menu items that you put the mouse on)¶in a pop-up window.¶¶When Tooltip mode is disabled, Emacs displays help text in the¶echo area, instead of making a pop-up window.",
"tooltip-event-buffer":"Return the buffer over which event EVENT occurred.¶This might return nil if the event did not occur over a buffer.",
"gap-position":"Return the position of the gap, in the current buffer.¶See also ‘gap-size’.¶¶(fn)",
"gap-size":"Return the size of the current buffer’s gap.¶See also ‘gap-position’.¶¶(fn)",
"fetch-bytecode":"If byte-compiled OBJECT is lazy-loaded, fetch it now.¶¶(fn OBJECT)",
"define-key-after":"Add binding in KEYMAP for KEY =&gt; DEFINITION, right after AFTER’s binding.¶This is like ‘define-key’ except that the binding for KEY is placed¶just after the binding for the event AFTER, instead of at the beginning¶of the map.  Note that AFTER must be an event type (like KEY), NOT a command¶(like DEFINITION).¶¶If AFTER is t or omitted, the new binding goes at the end of the keymap.¶AFTER should be a single event type--a symbol or a character, not a sequence.¶¶Bindings are always added before any inherited map.¶¶The order of bindings in a keymap only matters when it is used as¶a menu, so this function is not useful for non-menu keymaps.¶¶(fn KEYMAP KEY DEFINITION &amp;optional AFTER)",
"set-process-filter":"Give PROCESS the filter function FILTER; nil means default.¶A value of t means stop accepting output from the process.¶¶When a process has a non-default filter, its buffer is not used for output.¶Instead, each time it does output, the entire string of output is¶passed to the filter.¶¶The filter gets two arguments: the process and the string of output.¶The string argument is normally a multibyte string, except:¶- if the process’s input coding system is no-conversion or raw-text,¶  it is a unibyte string (the non-converted input), or else¶- if ‘default-enable-multibyte-characters’ is nil, it is a unibyte¶  string (the result of converting the decoded input multibyte¶  string to unibyte with ‘string-make-unibyte’).¶¶(fn PROCESS FILTER)",
"process-filter":"Return the filter function of PROCESS.¶See ‘set-process-filter’ for more info on filter functions.¶¶(fn PROCESS)",
"read-minibuffer":"Return a Lisp object read using the minibuffer, unevaluated.¶Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS¶is a string to insert in the minibuffer before reading.¶(INITIAL-CONTENTS can also be a cons of a string and an integer.¶Such arguments are used as in ‘read-from-minibuffer’.)¶¶(fn PROMPT &amp;optional INITIAL-CONTENTS)",
"eval-minibuffer":"Return value of Lisp expression read using the minibuffer.¶Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS¶is a string to insert in the minibuffer before reading.¶(INITIAL-CONTENTS can also be a cons of a string and an integer.¶Such arguments are used as in ‘read-from-minibuffer’.)¶¶(fn PROMPT &amp;optional INITIAL-CONTENTS)",
"edit-and-eval-command":"Prompting with PROMPT, let user edit COMMAND and eval result.¶COMMAND is a Lisp expression.  Let user edit that expression in¶the minibuffer, then read and evaluate the result.¶¶(fn PROMPT COMMAND)",
"verify-visited-file-modtime":"Return t if last mod time of BUF’s visited file matches what BUF records.¶This means that the file has not been changed since it was visited or saved.¶If BUF is omitted or nil, it defaults to the current buffer.¶See Info node ‘(elisp)Modification Time’ for more details.¶¶(fn &amp;optional BUF)",
"clear-visited-file-modtime":"Clear out records of last mod time of visited file.¶Next attempt to save will not complain of a discrepancy.",
"visited-file-modtime":"Return the current buffer’s recorded visited file modification time.¶The value is a list of the form (HIGH LOW USEC PSEC), like the time values that¶‘file-attributes’ returns.  If the current buffer has no recorded file¶modification time, this function returns 0.  If the visited file¶doesn’t exist, return -1.¶See Info node ‘(elisp)Modification Time’ for more details.¶¶(fn)",
"set-visited-file-modtime":"Update buffer’s recorded modification time from the visited file’s time.¶Useful if the buffer was not read from the file normally¶or if the file itself has been changed for some known benign reason.¶An argument specifies the modification time value to use¶(instead of that of the visited file), in the form of a list¶(HIGH LOW USEC PSEC) or an integer flag as returned by¶‘visited-file-modtime’.¶¶(fn &amp;optional TIME-FLAG)",
"ask-user-about-supersession-threat":"Ask a user who is about to modify an obsolete buffer what to do.¶This function has two choices: it can return, in which case the modification¶of the buffer will proceed, or it can (signal 'file-supersession (file)),¶in which case the proposed buffer modification will not be made.¶¶You can rewrite this to use any criterion you like to choose which one to do.¶The buffer in question is current when this function is called.¶¶(fn FN)",
"string-to-multibyte":"Return a multibyte string with the same individual chars as STRING.¶If STRING is multibyte, the result is STRING itself.¶Otherwise it is a newly created string, with no text properties.¶¶If STRING is unibyte and contains an 8-bit byte, it is converted to¶the corresponding multibyte character of charset ‘eight-bit’.¶¶This differs from ‘string-as-multibyte’ by converting each byte of a correct¶utf-8 sequence to an eight-bit character, not just bytes that don’t form a¶correct sequence.¶¶(fn STRING)",
"string-to-unibyte":"Return a unibyte string with the same individual chars as STRING.¶If STRING is unibyte, the result is STRING itself.¶Otherwise it is a newly created string, with no text properties,¶where each ‘eight-bit’ character is converted to the corresponding byte.¶If STRING contains a non-ASCII, non-‘eight-bit’ character,¶an error is signaled.¶¶(fn STRING)",
"byte-to-string":"Convert arg BYTE to a unibyte string containing that byte.¶¶(fn BYTE)",
"multibyte-char-to-unibyte":"Convert the multibyte character CH to a byte.¶If the multibyte character does not represent a byte, return -1.¶¶(fn CH)",
"unibyte-char-to-multibyte":"Convert the byte CH to multibyte character.¶¶(fn CH)",
"syntax-ppss":"Parse-Partial-Sexp State at POS, defaulting to point.¶The returned value is the same as that of ‘parse-partial-sexp’¶run from ‘point-min’ to POS except that values at positions 2 and 6¶in the returned list (counting from 0) cannot be relied upon.¶Point is at POS when this function returns.¶¶It is necessary to call ‘syntax-ppss-flush-cache’ explicitly if¶this function is called while ‘before-change-functions’ is¶temporarily let-bound, or if the buffer is modified without¶running the hook.¶¶(fn &amp;optional POS)",
"syntax-ppss-flush-cache":"Flush the cache of ‘syntax-ppss’ starting at position BEG.¶¶(fn BEG &amp;rest IGNORED)",
"read":"Read one Lisp expression as text from STREAM, return as Lisp object.¶If STREAM is nil, use the value of ‘standard-input’ (which see).¶STREAM or the value of ‘standard-input’ may be:¶ a buffer (read from point and advance it)¶ a marker (read from where it points and advance it)¶ a function (call it with no arguments for each character,¶     call it with a char as argument to push a char back)¶ a string (takes text from string, starting at the beginning)¶ t (read text line using minibuffer and use it, or read from¶    standard input in batch mode).¶¶(fn &amp;optional STREAM)",
"read-from-string":"Read one Lisp expression which is represented as text by STRING.¶Returns a cons: (OBJECT-READ . FINAL-STRING-INDEX).¶FINAL-STRING-INDEX is an integer giving the position of the next¶remaining character in STRING.  START and END optionally delimit¶a substring of STRING from which to read;  they default to 0 and¶(length STRING) respectively.  Negative values are counted from¶the end of STRING.¶¶(fn STRING &amp;optional START END)",
"set-binary-mode":"Switch STREAM to binary I/O mode or text I/O mode.¶STREAM can be one of the symbols ‘stdin’, ‘stdout’, or ‘stderr’.¶If MODE is non-nil, switch STREAM to binary mode, otherwise switch¶it to text mode.¶¶As a side effect, this function flushes any pending STREAM’s data.¶¶Value is the previous value of STREAM’s I/O mode, nil for text mode,¶non-nil for binary mode.¶¶On MS-Windows and MS-DOS, binary mode is needed to read or write¶arbitrary binary data, and for disabling translation between CR-LF¶pairs and a single newline character.  Examples include generation¶of text files with Unix-style end-of-line format using ‘princ’ in¶batch mode, with standard output redirected to a file.¶¶On Posix systems, this function always returns non-nil, and has no¶effect except for flushing STREAM’s data.¶¶(fn STREAM MODE)",
"event-start":"Return the starting position of EVENT.¶EVENT should be a mouse click, drag, or key press event.  If¶EVENT is nil, the value of ‘posn-at-point’ is used instead.¶¶The following accessor functions are used to access the elements¶of the position:¶¶‘posn-window’: The window the event is in.¶‘posn-area’: A symbol identifying the area the event occurred in,¶or nil if the event occurred in the text area.¶‘posn-point’: The buffer position of the event.¶‘posn-x-y’: The pixel-based coordinates of the event.¶‘posn-col-row’: The estimated column and row corresponding to the¶position of the event.¶‘posn-actual-col-row’: The actual column and row corresponding to the¶position of the event.¶‘posn-string’: The string object of the event, which is either¶nil or (STRING . POSITION)’.¶‘posn-image’: The image object of the event, if any.¶‘posn-object’: The image or string object of the event, if any.¶‘posn-timestamp’: The time the event occurred, in milliseconds.¶¶For more information, see Info node ‘(elisp)Click Events’.¶¶(fn EVENT)",
"event-end":"Return the ending position of EVENT.¶EVENT should be a click, drag, or key press event.¶¶See ‘event-start’ for a description of the value returned.¶¶(fn EVENT)",
"posnp":"Return non-nil if OBJ appears to be a valid ‘posn’ object specifying a window.¶A ‘posn’ object is returned from functions such as ‘event-start’.¶If OBJ is a valid ‘posn’ object, but specifies a frame rather¶than a window, return nil.¶¶(fn OBJ)",
"posn-window":"Return the window in POSITION.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-area":"Return the window area recorded in POSITION, or nil for the text area.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-point":"Return the buffer location in POSITION.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶Returns nil if POSITION does not correspond to any buffer location (e.g.¶a click on a scroll bar).¶¶(fn POSITION)",
"posn-x-y":"Return the x and y coordinates in POSITION.¶The return value has the form (X . Y), where X and Y are given in¶pixels.  POSITION should be a list of the form returned by¶‘event-start’ and ‘event-end’.¶¶(fn POSITION)",
"posn-col-row":"Return the nominal column and row in POSITION, measured in characters.¶The column and row values are approximations calculated from the x¶and y coordinates in POSITION and the frame’s default character width¶and default line height, including spacing.¶For a scroll-bar event, the result column is 0, and the row¶corresponds to the vertical position of the click in the scroll bar.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-actual-col-row":"Return the window row number in POSITION and character number in that row.¶¶Return nil if POSITION does not contain the actual position; in that case¶‘posn-col-row’ can be used to get approximate values.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶This function does not account for the width on display, like the¶number of visual columns taken by a TAB or image.  If you need¶the coordinates of POSITION in character units, you should use¶‘posn-col-row’, not this function.¶¶(fn POSITION)",
"posn-string":"Return the string object of POSITION.¶Value is a cons (STRING . STRING-POS), or nil if not a string.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-image":"Return the image object of POSITION.¶Value is a list (image ...), or nil if not an image.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-object":"Return the object (image or string) of POSITION.¶Value is a list (image ...) for an image object, a cons cell¶(STRING . STRING-POS) for a string object, and nil for a buffer position.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-object-x-y":"Return the x and y coordinates relative to the object of POSITION.¶The return value has the form (DX . DY), where DX and DY are¶given in pixels.  POSITION should be a list of the form returned¶by ‘event-start’ and ‘event-end’.¶¶(fn POSITION)",
"posn-object-width-height":"Return the pixel width and height of the object of POSITION.¶The return value has the form (WIDTH . HEIGHT).  POSITION should¶be a list of the form returned by ‘event-start’ and ‘event-end’.¶¶(fn POSITION)",
"posn-timestamp":"Return the timestamp of POSITION.¶POSITION should be a list of the form returned by the ‘event-start’¶and ‘event-end’ functions.¶¶(fn POSITION)",
"posn-at-point":"Return position information for buffer POS in WINDOW.¶POS defaults to point in WINDOW; WINDOW defaults to the selected window.¶¶Return nil if position is not visible in window.  Otherwise,¶the return value is similar to that returned by ‘event-start’ for¶a mouse click at the upper left corner of the glyph corresponding¶to the given buffer position:¶   (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)¶    IMAGE (DX . DY) (WIDTH . HEIGHT))¶The ‘posn-’ functions access elements of such lists.¶¶(fn &amp;optional POS WINDOW)",
"posn-at-x-y":"Return position information for pixel coordinates X and Y.¶By default, X and Y are relative to text area of the selected window.¶Optional third arg FRAME-OR-WINDOW non-nil specifies frame or window.¶If optional fourth arg WHOLE is non-nil, X is relative to the left¶edge of the window.¶¶The return value is similar to a mouse click position:¶   (WINDOW AREA-OR-POS (X . Y) TIMESTAMP OBJECT POS (COL . ROW)¶    IMAGE (DX . DY) (WIDTH . HEIGHT))¶The ‘posn-’ functions access elements of such lists.¶¶(fn X Y &amp;optional FRAME-OR-WINDOW WHOLE)",
"image-flush":"Flush the image with specification SPEC on frame FRAME.¶This removes the image from the Emacs image cache.  If SPEC specifies¶an image file, the next redisplay of this image will read from the¶current contents of that file.¶¶FRAME nil or omitted means use the selected frame.¶FRAME t means refresh the image on all frames.¶¶(fn SPEC &amp;optional FRAME)",
"clear-image-cache":"Clear the image cache.¶FILTER nil or a frame means clear all images in the selected frame.¶FILTER t means clear the image caches of all frames.¶Anything else, means only clear those images which refer to FILTER,¶which is then usually a filename.¶¶(fn &amp;optional FILTER)",
"sentence-end":"Return the regexp describing the end of a sentence.¶¶This function returns either the value of the variable ‘sentence-end’¶if it is non-nil, or the default value constructed from the¶variables ‘sentence-end-base’, ‘sentence-end-double-space’,¶‘sentence-end-without-period’ and ‘sentence-end-without-space’.¶¶The default value specifies that in order to be recognized as the¶end of a sentence, the ending period, question mark, or exclamation point¶must be followed by two spaces, with perhaps some closing delimiters¶in between.  See Info node ‘(elisp)Standard Regexps’.",
"system-name":"Return the host name of the machine you are running on, as a string.¶¶(fn)",
"parse-colon-path":"Explode a search path into a list of directory names.¶Directories are separated by ‘path-separator’ (which is colon in¶GNU and Unix systems).  Substitute environment variables into the¶resulting list of directory names.  For an empty path element (i.e.,¶a leading or trailing separator, or two adjacent separators), return¶nil (meaning ‘default-directory’) as the associated list element.¶¶(fn SEARCH-PATH)",
"load-average":"Return list of 1 minute, 5 minute and 15 minute load averages.¶¶Each of the three load averages is multiplied by 100, then converted¶to integer.¶¶When USE-FLOATS is non-nil, floats will be used instead of integers.¶These floats are not multiplied by 100.¶¶If the 5-minute or 15-minute load averages are not available, return a¶shortened list, containing only those averages which are available.¶¶An error is thrown if the load average can’t be obtained.  In some¶cases making it work would require Emacs being installed setuid or¶setgid so that it can read kernel information, and that usually isn’t¶advisable.¶¶(fn &amp;optional USE-FLOATS)",
"emacs-pid":"Return the process ID of Emacs, as a number.¶¶(fn)",
"y-or-n-p":"Ask user a &quot;y or n&quot; question.¶Return t if answer is &quot;y&quot; and nil if it is &quot;n&quot;.¶PROMPT is the string to display to ask the question.  It should¶end in a space; ‘y-or-n-p’ adds &quot;(y or n) &quot; to it.¶¶No confirmation of the answer is requested; a single character is¶enough.  SPC also means yes, and DEL means no.¶¶To be precise, this function translates user input into responses¶by consulting the bindings in ‘query-replace-map’; see the¶documentation of that variable for more information.  In this¶case, the useful bindings are ‘act’, ‘skip’, ‘recenter’,¶‘scroll-up’, ‘scroll-down’, and ‘quit’.¶An ‘act’ response means yes, and a ‘skip’ response means no.¶A ‘quit’ response means to invoke ‘keyboard-quit’.¶If the user enters ‘recenter’, ‘scroll-up’, or ‘scroll-down’¶responses, perform the requested window recentering or scrolling¶and ask again.¶¶Under a windowing system a dialog box will be used if ‘last-nonmenu-event’¶is nil and ‘use-dialog-box’ is non-nil.¶¶(fn PROMPT)",
"y-or-n-p-with-timeout":"Like (y-or-n-p PROMPT), with a timeout.¶If the user does not answer after SECONDS seconds, return DEFAULT-VALUE.",
"yes-or-no-p":"Ask user a &quot;y or n&quot; question.¶Return t if answer is &quot;y&quot; and nil if it is &quot;n&quot;.¶PROMPT is the string to display to ask the question.  It should¶end in a space; ‘y-or-n-p’ adds &quot;(y or n) &quot; to it.¶¶No confirmation of the answer is requested; a single character is¶enough.  SPC also means yes, and DEL means no.¶¶To be precise, this function translates user input into responses¶by consulting the bindings in ‘query-replace-map’; see the¶documentation of that variable for more information.  In this¶case, the useful bindings are ‘act’, ‘skip’, ‘recenter’,¶‘scroll-up’, ‘scroll-down’, and ‘quit’.¶An ‘act’ response means yes, and a ‘skip’ response means no.¶A ‘quit’ response means to invoke ‘keyboard-quit’.¶If the user enters ‘recenter’, ‘scroll-up’, or ‘scroll-down’¶responses, perform the requested window recentering or scrolling¶and ask again.¶¶Under a windowing system a dialog box will be used if ‘last-nonmenu-event’¶is nil and ‘use-dialog-box’ is non-nil.¶¶(fn PROMPT)",
"hash-table-p":"Return t if OBJ is a Lisp hash table object.¶¶(fn OBJ)",
"copy-hash-table":"Return a copy of hash table TABLE.¶¶(fn TABLE)",
"hash-table-count":"Return the number of elements in TABLE.¶¶(fn TABLE)",
"hash-table-test":"Return the test TABLE uses.¶¶(fn TABLE)",
"hash-table-weakness":"Return the weakness of TABLE.¶¶(fn TABLE)",
"hash-table-rehash-size":"Return the current rehash size of TABLE.¶¶(fn TABLE)",
"hash-table-rehash-threshold":"Return the current rehash threshold of TABLE.¶¶(fn TABLE)",
"hash-table-size":"Return the size of TABLE.¶The size can be used as an argument to ‘make-hash-table’ to create¶a hash table than can hold as many elements as TABLE holds¶without need for resizing.¶¶(fn TABLE)",
"custom-initialize-delay":"Delay initialization of SYMBOL to the next Emacs start.¶This is used in files that are preloaded (or for autoloaded¶variables), so that the initialization is done in the run-time¶context rather than the build-time context.  This also has the¶side-effect that the (delayed) initialization is performed with¶the :set function.¶¶For variables in preloaded files, you can simply use this¶function for the :initialize property.  For autoloaded variables,¶you will also need to add an autoload stanza calling this¶function, and another one setting the standard-value property.¶Or you can wrap the defcustom in a progn, to force the autoloader¶to include all of it.",
"dump-emacs":"Dump current state of Emacs into executable file FILENAME.¶Take symbols from SYMFILE (presumably the file you executed to run Emacs).¶This is used in the file ‘loadup.el’ when building Emacs.¶¶You must run Emacs in batch mode in order to dump it.¶¶(fn FILENAME SYMFILE)",
"define-error":"Define NAME as a new error signal.¶MESSAGE is a string that will be output to the echo area if such an error¶is signaled without being caught by a ‘condition-case’.¶PARENT is either a signal or a list of signals from which it inherits.¶Defaults to ‘error’.¶¶(fn NAME MESSAGE &amp;optional PARENT)",
"set-auto-mode":"Select major mode appropriate for current buffer.¶¶To find the right major mode, this function checks for a -*- mode tag¶checks for a ‘mode:’ entry in the Local Variables section of the file,¶checks if it uses an interpreter listed in ‘interpreter-mode-alist’,¶matches the buffer beginning against ‘magic-mode-alist’,¶compares the filename against the entries in ‘auto-mode-alist’,¶then matches the buffer beginning against ‘magic-fallback-mode-alist’.¶¶If ‘enable-local-variables’ is nil, or if the file name matches¶‘inhibit-local-variables-regexps’, this function does not check¶for any mode: tag anywhere in the file.  If ‘local-enable-local-variables’¶is nil, then the only mode: tag that can be relevant is a -*- one.¶¶If the optional argument KEEP-MODE-IF-SAME is non-nil, then we¶set the major mode only if that would change it.  In other words¶we don’t actually set it to the same mode the buffer already has.¶¶(fn &amp;optional KEEP-MODE-IF-SAME)",
"set-buffer-major-mode":"Set an appropriate major mode for BUFFER.¶For the *scratch* buffer, use ‘initial-major-mode’, otherwise choose a mode¶according to the default value of ‘major-mode’.¶Use this function before selecting the buffer, since it may need to inspect¶the current buffer’s major mode.¶¶(fn BUFFER)",
"next-window":"Return live window after WINDOW in the cyclic ordering of windows.¶WINDOW must be a live window and defaults to the selected one.  The¶optional arguments MINIBUF and ALL-FRAMES specify the set of windows to¶consider.¶¶MINIBUF nil or omitted means consider the minibuffer window only if the¶minibuffer is active.  MINIBUF t means consider the minibuffer window¶even if the minibuffer is not active.  Any other value means do not¶consider the minibuffer window even if the minibuffer is active.¶¶ALL-FRAMES nil or omitted means consider all windows on WINDOW’s frame,¶plus the minibuffer window if specified by the MINIBUF argument.  If the¶minibuffer counts, consider all windows on all frames that share that¶minibuffer too.  The following non-nil values of ALL-FRAMES have special¶meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames.¶¶- 0 (the number zero) means consider all windows on all visible and¶  iconified frames.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on WINDOW’s frame and no¶others.¶¶If you use consistent values for MINIBUF and ALL-FRAMES, you can use¶‘next-window’ to iterate through the entire cycle of acceptable¶windows, eventually ending up back at the window you started with.¶‘previous-window’ traverses the same cycle, in the reverse order.¶¶(fn &amp;optional WINDOW MINIBUF ALL-FRAMES)",
"previous-window":"Return live window before WINDOW in the cyclic ordering of windows.¶WINDOW must be a live window and defaults to the selected one.  The¶optional arguments MINIBUF and ALL-FRAMES specify the set of windows to¶consider.¶¶MINIBUF nil or omitted means consider the minibuffer window only if the¶minibuffer is active.  MINIBUF t means consider the minibuffer window¶even if the minibuffer is not active.  Any other value means do not¶consider the minibuffer window even if the minibuffer is active.¶¶ALL-FRAMES nil or omitted means consider all windows on WINDOW’s frame,¶plus the minibuffer window if specified by the MINIBUF argument.  If the¶minibuffer counts, consider all windows on all frames that share that¶minibuffer too.  The following non-nil values of ALL-FRAMES have special¶meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames.¶¶- 0 (the number zero) means consider all windows on all visible and¶  iconified frames.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on WINDOW’s frame and no¶others.¶¶If you use consistent values for MINIBUF and ALL-FRAMES, you can¶use ‘previous-window’ to iterate through the entire cycle of¶acceptable windows, eventually ending up back at the window you¶started with.  ‘next-window’ traverses the same cycle, in the¶reverse order.¶¶(fn &amp;optional WINDOW MINIBUF ALL-FRAMES)",
"walk-windows":"Cycle through all live windows, calling FUN for each one.¶FUN must specify a function with a window as its sole argument.¶The optional arguments MINIBUF and ALL-FRAMES specify the set of¶windows to include in the walk.¶¶MINIBUF t means include the minibuffer window even if the¶minibuffer is not active.  MINIBUF nil or omitted means include¶the minibuffer window only if the minibuffer is active.  Any¶other value means do not include the minibuffer window even if¶the minibuffer is active.¶¶ALL-FRAMES nil or omitted means consider all windows on the¶selected frame, plus the minibuffer window if specified by the¶MINIBUF argument.  If the minibuffer counts, consider all windows¶on all frames that share that minibuffer too.  The following¶non-nil values of ALL-FRAMES have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on the selected frame¶and no others.¶¶This function changes neither the order of recently selected¶windows nor the buffer list.",
"one-window-p":"Return non-nil if the selected window is the only window.¶Optional arg NOMINI non-nil means don’t count the minibuffer¶even if it is active.  Otherwise, the minibuffer is counted¶when it is active.¶¶Optional argument ALL-FRAMES specifies the set of frames to¶consider, see also ‘next-window’.  ALL-FRAMES nil or omitted¶means consider windows on the selected frame only, plus the¶minibuffer window if specified by the NOMINI argument.  If the¶minibuffer counts, consider all windows on all frames that share¶that minibuffer too.  The remaining non-nil values of ALL-FRAMES¶with a special meaning are:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on the selected frame¶and no others.",
"get-lru-window":"Return the least recently used window on frames specified by ALL-FRAMES.¶Return a full-width window if possible.  A minibuffer window is¶never a candidate.  A dedicated window is never a candidate¶unless DEDICATED is non-nil, so if all windows are dedicated, the¶value is nil.  Avoid returning the selected window if possible.¶Optional argument NOT-SELECTED non-nil means never return the¶selected window.¶¶The following non-nil values of the optional argument ALL-FRAMES¶have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Any other value of ALL-FRAMES means consider all windows on the¶selected frame and no others.",
"get-mru-window":"Return the most recently used window on frames specified by ALL-FRAMES.¶A minibuffer window is never a candidate.  A dedicated window is¶never a candidate unless DEDICATED is non-nil, so if all windows¶are dedicated, the value is nil.  Optional argument NOT-SELECTED¶non-nil means never return the selected window.¶¶The following non-nil values of the optional argument ALL-FRAMES¶have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Any other value of ALL-FRAMES means consider all windows on the¶selected frame and no others.",
"get-largest-window":"Return the largest window on frames specified by ALL-FRAMES.¶A minibuffer window is never a candidate.  A dedicated window is¶never a candidate unless DEDICATED is non-nil, so if all windows¶are dedicated, the value is nil.  Optional argument NOT-SELECTED¶non-nil means never return the selected window.¶¶The following non-nil values of the optional argument ALL-FRAMES¶have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Any other value of ALL-FRAMES means consider all windows on the¶selected frame and no others.",
"get-window-with-predicate":"Return a live window satisfying PREDICATE.¶More precisely, cycle through all windows calling the function¶PREDICATE on each one of them with the window as its sole¶argument.  Return the first window for which PREDICATE returns¶non-nil.  Windows are scanned starting with the window following¶the selected window.  If no window satisfies PREDICATE, return¶DEFAULT.¶¶MINIBUF t means include the minibuffer window even if the¶minibuffer is not active.  MINIBUF nil or omitted means include¶the minibuffer window only if the minibuffer is active.  Any¶other value means do not include the minibuffer window even if¶the minibuffer is active.¶¶ALL-FRAMES nil or omitted means consider all windows on the selected¶frame, plus the minibuffer window if specified by the MINIBUF¶argument.  If the minibuffer counts, consider all windows on all¶frames that share that minibuffer too.  The following non-nil¶values of ALL-FRAMES have special meanings:¶¶- t means consider all windows on all existing frames.¶¶- ‘visible’ means consider all windows on all visible frames on¶  the current terminal.¶¶- 0 (the number zero) means consider all windows on all visible¶  and iconified frames on the current terminal.¶¶- A frame means consider all windows on that frame only.¶¶Anything else means consider all windows on the selected frame¶and no others.",
"list-system-processes":"Return a list of numerical process IDs of all running processes.¶If this functionality is unsupported, return nil.¶¶See ‘process-attributes’ for getting attributes of a process given its ID.¶¶(fn)",
"process-attributes":"Return attributes of the process given by its PID, a number.¶¶Value is an alist where each element is a cons cell of the form¶¶    (KEY . VALUE)¶¶If this functionality is unsupported, the value is nil.¶¶See ‘list-system-processes’ for getting a list of all process IDs.¶¶The KEYs of the attributes that this function may return are listed¶below, together with the type of the associated VALUE (in parentheses).¶Not all platforms support all of these attributes; unsupported¶attributes will not appear in the returned alist.¶Unless explicitly indicated otherwise, numbers can have either¶integer or floating point values.¶¶ euid    -- Effective user User ID of the process (number)¶ user    -- User name corresponding to euid (string)¶ egid    -- Effective user Group ID of the process (number)¶ group   -- Group name corresponding to egid (string)¶ comm    -- Command name (executable name only) (string)¶ state   -- Process state code, such as &quot;S&quot;, &quot;R&quot;, or &quot;T&quot; (string)¶ ppid    -- Parent process ID (number)¶ pgrp    -- Process group ID (number)¶ sess    -- Session ID, i.e. process ID of session leader (number)¶ ttname  -- Controlling tty name (string)¶ tpgid   -- ID of foreground process group on the process’s tty (number)¶ minflt  -- number of minor page faults (number)¶ majflt  -- number of major page faults (number)¶ cminflt -- cumulative number of minor page faults (number)¶ cmajflt -- cumulative number of major page faults (number)¶ utime   -- user time used by the process, in (current-time) format,¶              which is a list of integers (HIGH LOW USEC PSEC)¶ stime   -- system time used by the process (current-time)¶ time    -- sum of utime and stime (current-time)¶ cutime  -- user time used by the process and its children (current-time)¶ cstime  -- system time used by the process and its children (current-time)¶ ctime   -- sum of cutime and cstime (current-time)¶ pri     -- priority of the process (number)¶ nice    -- nice value of the process (number)¶ thcount -- process thread count (number)¶ start   -- time the process started (current-time)¶ vsize   -- virtual memory size of the process in KB’s (number)¶ rss     -- resident set size of the process in KB’s (number)¶ etime   -- elapsed time the process is running, in (HIGH LOW USEC PSEC) format¶ pcpu    -- percents of CPU time used by the process (floating-point number)¶ pmem    -- percents of total physical memory used by process’s resident set¶              (floating-point number)¶ args    -- command line which invoked the process (string).¶¶(fn PID)",
"define-abbrev":"Define an abbrev in TABLE named NAME, to expand to EXPANSION and call HOOK.¶NAME must be a string, and should be lower-case.¶EXPANSION should usually be a string.¶To undefine an abbrev, define it with EXPANSION = nil.¶If HOOK is non-nil, it should be a function of no arguments;¶it is called after EXPANSION is inserted.¶If EXPANSION is not a string (and not nil), the abbrev is a¶ special one, which does not expand in the usual way but only¶ runs HOOK.¶¶If HOOK is a non-nil symbol with a non-nil ‘no-self-insert’ property,¶it can control whether the character that triggered abbrev expansion¶is inserted.  If such a HOOK returns non-nil, the character is not¶inserted.  If such a HOOK returns nil, then so does ‘abbrev-insert’¶(and ‘expand-abbrev’), as if no abbrev expansion had taken place.¶¶PROPS is a property list.  The following properties are special:¶- ‘:count’: the value for the abbrev’s usage-count, which is incremented each¶  time the abbrev is used (the default is zero).¶- ‘:system’: if non-nil, says that this is a &quot;system&quot; abbreviation¶  which should not be saved in the user’s abbreviation file.¶  Unless ‘:system’ is ‘force’, a system abbreviation will not¶  overwrite a non-system abbreviation of the same name.¶- ‘:case-fixed’: non-nil means that abbreviations are looked up without¶  case-folding, and the expansion is not capitalized/upcased.¶- ‘:enable-function’: a function of no argument which returns non-nil if the¶  abbrev should be used for a particular call of ‘expand-abbrev’.¶¶An obsolete but still supported calling form is:¶¶(define-abbrev TABLE NAME EXPANSION &amp;optional HOOK COUNT SYSTEM).¶¶(fn TABLE NAME EXPANSION &amp;optional HOOK &amp;rest PROPS)",
"find-auto-coding":"Find a coding system for a file FILENAME of which SIZE bytes follow point.¶These bytes should include at least the first 1k of the file¶and the last 3k of the file, but the middle may be omitted.¶¶The function checks FILENAME against the variable ‘auto-coding-alist’.¶If FILENAME doesn’t match any entries in the variable, it checks the¶contents of the current buffer following point against¶‘auto-coding-regexp-alist’.  If no match is found, it checks for a¶‘coding:’ tag in the first one or two lines following point.  If no¶‘coding:’ tag is found, it checks any local variables list in the last¶3K bytes out of the SIZE bytes.  Finally, if none of these methods¶succeed, it checks to see if any function in ‘auto-coding-functions’¶gives a match.¶¶If a coding system is specified, the return value is a cons¶(CODING . SOURCE), where CODING is the specified coding system and¶SOURCE is a symbol ‘auto-coding-alist’, ‘auto-coding-regexp-alist’,¶‘:coding’, or ‘auto-coding-functions’ indicating by what CODING is¶specified.  Note that the validity of CODING is not checked;¶it’s the caller’s responsibility to check it.¶¶If nothing is specified, the return value is nil.",
"set-auto-coding":"Return coding system for a file FILENAME of which SIZE bytes follow point.¶See ‘find-auto-coding’ for how the coding system is found.¶Return nil if an invalid coding system is found.¶¶The variable ‘set-auto-coding-function’ (which see) is set to this¶function by default.",
"find-operation-coding-system":"Choose a coding system for an operation based on the target name.¶The value names a pair of coding systems: (DECODING-SYSTEM . ENCODING-SYSTEM).¶DECODING-SYSTEM is the coding system to use for decoding¶(in case OPERATION does decoding), and ENCODING-SYSTEM is the coding system¶for encoding (in case OPERATION does encoding).¶¶The first argument OPERATION specifies an I/O primitive:¶  For file I/O, ‘insert-file-contents’ or ‘write-region’.¶  For process I/O, ‘call-process’, ‘call-process-region’, or ‘start-process’.¶  For network I/O, ‘open-network-stream’.¶¶The remaining arguments should be the same arguments that were passed¶to the primitive.  Depending on which primitive, one of those arguments¶is selected as the TARGET.  For example, if OPERATION does file I/O,¶whichever argument specifies the file name is TARGET.¶¶TARGET has a meaning which depends on OPERATION:¶  For file I/O, TARGET is a file name (except for the special case below).¶  For process I/O, TARGET is a process name.¶  For network I/O, TARGET is a service name or a port number.¶¶This function looks up what is specified for TARGET in¶‘file-coding-system-alist’, ‘process-coding-system-alist’,¶or ‘network-coding-system-alist’ depending on OPERATION.¶They may specify a coding system, a cons of coding systems,¶or a function symbol to call.¶In the last case, we call the function with one argument,¶which is a list of all the arguments given to this function.¶If the function can’t decide a coding system, it can return¶‘undecided’ so that the normal code-detection is performed.¶¶If OPERATION is ‘insert-file-contents’, the argument corresponding to¶TARGET may be a cons (FILENAME . BUFFER).  In that case, FILENAME is a¶file name to look up, and BUFFER is a buffer that contains the file’s¶contents (not yet decoded).  If ‘file-coding-system-alist’ specifies a¶function to call for FILENAME, that function should examine the¶contents of BUFFER instead of reading the file.¶¶(fn OPERATION ARGUMENTS...)",
"listify-key-sequence":"Convert a key sequence to a list of events.¶¶(fn KEY)",
"input-pending-p":"Return t if command input is currently available with no wait.¶Actually, the value is nil only if we can be sure that no input is available;¶if there is a doubt, the value is t.¶¶If CHECK-TIMERS is non-nil, timers that are ready to run will do so.¶¶(fn &amp;optional CHECK-TIMERS)",
"discard-input":"Discard the contents of the terminal input buffer.¶Also end any kbd macro being defined.¶¶(fn)",
"messages-buffer":"Return the &quot;*Messages*&quot; buffer.¶If it does not exist, create and it switch it to ‘messages-buffer-mode’.",
"set":"Set SYMBOL’s value to NEWVAL, and return NEWVAL.¶¶(fn SYMBOL NEWVAL)",
"auto-save-file-name-p":"Return non-nil if FILENAME can be yielded by ‘make-auto-save-file-name’.¶FILENAME should lack slashes.  You can redefine this for customization.¶¶(fn FILENAME)",
"make-auto-save-file-name":"Return file name to use for auto-saves of current buffer.¶Does not consider ‘auto-save-visited-file-name’ as that variable is checked¶before calling this function.  You can redefine this for customization.¶See also ‘auto-save-file-name-p’.",
"recent-auto-save-p":"Return t if current buffer has been auto-saved recently.¶More precisely, if it has been auto-saved since last read from or saved¶in the visited file.  If the buffer has no visited file,¶then any auto-save counts as &quot;recent&quot;.¶¶(fn)",
"set-buffer-auto-saved":"Mark current buffer as auto-saved with its current text.¶No auto-save file will be written until the buffer changes again.¶¶(fn)",
"delete-auto-save-file-if-necessary":"Delete auto-save file for current buffer if ‘delete-auto-save-files’ is t.¶Normally delete only if the file was written by this Emacs since¶the last real save, but optional arg FORCE non-nil means delete anyway.¶¶(fn &amp;optional FORCE)",
"rename-auto-save-file":"Adjust current buffer’s auto save file name for current conditions.¶Also rename any existing auto save file, if it was made in this session.",
"abbrev-put":"Set the property PROP of abbrev ABBREV to value VAL.¶See ‘define-abbrev’ for the effect of some special properties.¶¶(fn ABBREV PROP VAL)",
"abbrev-get":"Get the property PROP of abbrev ABBREV¶¶(fn ABBREV PROP)",
"forward-word-strictly":"Move point forward ARG words (backward if ARG is negative).¶If ARG is omitted or nil, move point forward one word.¶Normally returns t.¶If an edge of the buffer or a field boundary is reached, point is left there¶and the function returns nil.  Field boundaries are not noticed if¶‘inhibit-field-text-motion’ is non-nil.¶¶This function is like ‘forward-word’, but it is not affected¶by ‘find-word-boundary-function-table’ (as set up by¶e.g. ‘subword-mode’).  It is also not interactive.¶¶(fn &amp;optional ARG)",
"backward-word-strictly":"Move backward until encountering the beginning of a word.¶With argument ARG, do this that many times.¶If ARG is omitted or nil, move point backward one word.¶¶This function is like ‘forward-word’, but it is not affected¶by ‘find-word-boundary-function-table’ (as set up by¶e.g. ‘subword-mode’).  It is also not interactive.¶¶(fn &amp;optional ARG)",
"advice-add":"Like ‘add-function’ but for the function named SYMBOL.¶Contrary to ‘add-function’, this will properly handle the cases where SYMBOL¶is defined as a macro, alias, command, ...¶¶(fn SYMBOL WHERE FUNCTION &amp;optional PROPS)",
"advice-remove":"Like ‘remove-function’ but for the function named SYMBOL.¶Contrary to ‘remove-function’, this also works when SYMBOL is a macro¶or an autoload and it preserves ‘fboundp’.¶Instead of the actual function to remove, FUNCTION can also be the ‘name’¶of the piece of advice.¶¶(fn SYMBOL FUNCTION)",
"advice-member-p":"Return non-nil if ADVICE has been added to SYMBOL.¶Instead of ADVICE being the actual function, it can also be the ‘name’¶of the piece of advice.¶¶(fn ADVICE SYMBOL)",
"advice-mapc":"Apply FUN to every advice function in SYMBOL.¶FUN is called with a two arguments: the function that was added, and the¶properties alist that was specified when it was added.¶¶(fn FUN SYMBOL)",
"store-substring":"Embed OBJ (string or character) at index IDX of STRING.¶¶(fn STRING IDX OBJ)",
"clear-string":"Clear the contents of STRING.¶This makes STRING unibyte and may change its length.¶¶(fn STRING)",
"user-login-name":"Return the name under which the user logged in, as a string.¶This is based on the effective uid, not the real uid.¶Also, if the environment variables LOGNAME or USER are set,¶that determines the value of this function.¶¶If optional argument UID is an integer or a float, return the login name¶of the user with that uid, or nil if there is no such user.¶¶(fn &amp;optional UID)",
"user-real-login-name":"Return the name of the user’s real uid, as a string.¶This ignores the environment variables LOGNAME and USER, so it differs from¶‘user-login-name’ when running under ‘su’.¶¶(fn)",
"user-full-name":"Return the full name of the user logged in, as a string.¶If the full name corresponding to Emacs’s userid is not known,¶return &quot;unknown&quot;.¶¶If optional argument UID is an integer or float, return the full name¶of the user with that uid, or nil if there is no such user.¶If UID is a string, return the full name of the user with that login¶name, or nil if there is no such user.¶¶(fn &amp;optional UID)",
"user-real-uid":"Return the real uid of Emacs.¶Value is an integer or a float, depending on the value.¶¶(fn)",
"user-uid":"Return the effective uid of Emacs.¶Value is an integer or a float, depending on the value.¶¶(fn)",
"group-gid":"Return the effective gid of Emacs.¶Value is an integer or a float, depending on the value.¶¶(fn)",
"group-real-gid":"Return the real gid of Emacs.¶Value is an integer or a float, depending on the value.¶¶(fn)",
"system-users":"Return a list of user names currently registered in the system.¶If we don’t know how to determine that on this platform, just¶return a list with one element, taken from ‘user-real-login-name’.¶¶(fn)",
"system-groups":"Return a list of user group names currently registered in the system.¶The value may be nil if not supported on this platform.¶¶(fn)",
"play-sound":"SOUND is a list of the form ‘(sound KEYWORD VALUE...)’.¶The following keywords are recognized:¶¶  :file FILE - read sound data from FILE.  If FILE isn’t an¶absolute file name, it is searched in ‘data-directory’.¶¶  :data DATA - read sound data from string DATA.¶¶Exactly one of :file or :data must be present.¶¶  :volume VOL - set volume to VOL.  VOL must an integer in the¶range 0..100 or a float in the range 0..1.0.  If not specified,¶don’t change the volume setting of the sound device.¶¶  :device DEVICE - play sound on DEVICE.  If not specified,¶a system-dependent default device name is used.¶¶Note: :data and :device are currently not supported on Windows.¶¶(fn SOUND)",
"overlays-at":"Return a list of the overlays that contain the character at POS.¶If SORTED is non-nil, then sort them by decreasing priority.¶¶(fn POS &amp;optional SORTED)",
"overlays-in":"Return a list of the overlays that overlap the region BEG ... END.¶Overlap means that at least one character is contained within the overlay¶and also contained within the specified region.¶Empty overlays are included in the result if they are located at BEG,¶between BEG and END, or at END provided END denotes the position at the¶end of the buffer.¶¶(fn BEG END)",
"next-overlay-change":"Return the next position after POS where an overlay starts or ends.¶If there are no overlay boundaries from POS to (point-max),¶the value is (point-max).¶¶(fn POS)",
"previous-overlay-change":"Return the previous position before POS where an overlay starts or ends.¶If there are no overlay boundaries from (point-min) to POS,¶the value is (point-min).¶¶(fn POS)",
"next-property-change":"Return the position of next property change.¶Scans characters forward from POSITION in OBJECT till it finds¶a change in some text property, then returns the position of the change.¶If the optional second argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶Return nil if LIMIT is nil or omitted, and the property is constant all¶the way to the end of OBJECT; if the value is non-nil, it is a position¶greater than POSITION, never equal.¶¶If the optional third argument LIMIT is non-nil, don’t search¶past position LIMIT; return LIMIT if nothing is found before LIMIT.¶¶(fn POSITION &amp;optional OBJECT LIMIT)",
"previous-property-change":"Return the position of previous property change.¶Scans characters backwards from POSITION in OBJECT till it finds¶a change in some text property, then returns the position of the change.¶If the optional second argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶Return nil if LIMIT is nil or omitted, and the property is constant all¶the way to the start of OBJECT; if the value is non-nil, it is a position¶less than POSITION, never equal.¶¶If the optional third argument LIMIT is non-nil, don’t search¶back past position LIMIT; return LIMIT if nothing is found until LIMIT.¶¶(fn POSITION &amp;optional OBJECT LIMIT)",
"next-single-property-change":"Return the position of next property change for a specific property.¶Scans characters forward from POSITION till it finds¶a change in the PROP property, then returns the position of the change.¶If the optional third argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶The property values are compared with ‘eq’.¶Return nil if LIMIT is nil or omitted, and the property is constant all¶the way to the end of OBJECT; if the value is non-nil, it is a position¶greater than POSITION, never equal.¶¶If the optional fourth argument LIMIT is non-nil, don’t search¶past position LIMIT; return LIMIT if nothing is found before LIMIT.¶¶(fn POSITION PROP &amp;optional OBJECT LIMIT)",
"previous-single-property-change":"Return the position of previous property change for a specific property.¶Scans characters backward from POSITION till it finds¶a change in the PROP property, then returns the position of the change.¶If the optional third argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶The property values are compared with ‘eq’.¶Return nil if LIMIT is nil or omitted, and the property is constant all¶the way to the start of OBJECT; if the value is non-nil, it is a position¶less than POSITION, never equal.¶¶If the optional fourth argument LIMIT is non-nil, don’t search¶back past position LIMIT; return LIMIT if nothing is found until LIMIT.¶¶(fn POSITION PROP &amp;optional OBJECT LIMIT)",
"next-char-property-change":"Return the position of next text property or overlay change.¶This scans characters forward in the current buffer from POSITION till¶it finds a change in some text property, or the beginning or end of an¶overlay, and returns the position of that.¶If none is found, and LIMIT is nil or omitted, the function¶returns (point-max).¶¶If the optional second argument LIMIT is non-nil, the function doesn’t¶search past position LIMIT, and returns LIMIT if nothing is found¶before LIMIT.  LIMIT is a no-op if it is greater than (point-max).¶¶(fn POSITION &amp;optional LIMIT)",
"previous-char-property-change":"Return the position of previous text property or overlay change.¶Scans characters backward in the current buffer from POSITION till it¶finds a change in some text property, or the beginning or end of an¶overlay, and returns the position of that.¶If none is found, and LIMIT is nil or omitted, the function¶returns (point-min).¶¶If the optional second argument LIMIT is non-nil, the function doesn’t¶search before position LIMIT, and returns LIMIT if nothing is found¶before LIMIT.  LIMIT is a no-op if it is less than (point-min).¶¶(fn POSITION &amp;optional LIMIT)",
"next-single-char-property-change":"Return the position of next text property or overlay change for a specific property.¶Scans characters forward from POSITION till it finds¶a change in the PROP property, then returns the position of the change.¶If the optional third argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶¶In a string, scan runs to the end of the string, unless LIMIT is non-nil.¶In a buffer, if LIMIT is nil or omitted, it runs to (point-max), and the¶value cannot exceed that.¶If the optional fourth argument LIMIT is non-nil, don’t search¶past position LIMIT; return LIMIT if nothing is found before LIMIT.¶¶The property values are compared with ‘eq’.¶If the property is constant all the way to the end of OBJECT, return the¶last valid position in OBJECT.¶¶(fn POSITION PROP &amp;optional OBJECT LIMIT)",
"previous-single-char-property-change":"Return the position of previous text property or overlay change for a specific property.¶Scans characters backward from POSITION till it finds¶a change in the PROP property, then returns the position of the change.¶If the optional third argument OBJECT is a buffer (or nil, which means¶the current buffer), POSITION is a buffer position (integer or marker).¶If OBJECT is a string, POSITION is a 0-based index into it.¶¶In a string, scan runs to the start of the string, unless LIMIT is non-nil.¶In a buffer, if LIMIT is nil or omitted, it runs to (point-min), and the¶value cannot be less than that.¶If the optional fourth argument LIMIT is non-nil, don’t search back past¶position LIMIT; return LIMIT if nothing is found before reaching LIMIT.¶¶The property values are compared with ‘eq’.¶If the property is constant all the way to the start of OBJECT, return the¶first valid position in OBJECT.¶¶(fn POSITION PROP &amp;optional OBJECT LIMIT)",
"text-property-any":"Check text from START to END for property PROPERTY equaling VALUE.¶If so, return the position of the first character whose property PROPERTY¶is ‘eq’ to VALUE.  Otherwise return nil.¶If the optional fifth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶¶(fn START END PROPERTY VALUE &amp;optional OBJECT)",
"text-property-not-all":"Check text from START to END for property PROPERTY not equaling VALUE.¶If so, return the position of the first character whose property PROPERTY¶is not ‘eq’ to VALUE.  Otherwise, return nil.¶If the optional fifth argument OBJECT is a buffer (or nil, which means¶the current buffer), START and END are buffer positions (integers or¶markers).  If OBJECT is a string, START and END are 0-based indices into it.¶¶(fn START END PROPERTY VALUE &amp;optional OBJECT)",
"symbol-value":"Return SYMBOL’s value.  Error if that is void.¶Note that if ‘lexical-binding’ is in effect, this returns the¶global value outside of any lexical scope.¶¶(fn SYMBOL)",
"make-abbrev-table":"Create a new, empty abbrev table object.¶PROPS is a list of properties.¶¶(fn &amp;optional PROPS)",
"abbrev-table-p":"Return non-nil if OBJECT is an abbrev table.¶¶(fn OBJECT)",
"clear-abbrev-table":"Undefine all abbrevs in abbrev table TABLE, leaving it empty.¶¶(fn TABLE)",
"copy-abbrev-table":"Make a new abbrev-table with the same abbrevs as TABLE.¶Does not copy property lists.¶¶(fn TABLE)",
"define-abbrev-table":"Define TABLENAME (a symbol) as an abbrev table name.¶Define abbrevs in it according to DEFINITIONS, which is a list of elements¶of the form (ABBREVNAME EXPANSION ...) that are passed to ‘define-abbrev’.¶PROPS is a property list to apply to the table.¶Properties with special meaning:¶- ‘:parents’ contains a list of abbrev tables from which this table inherits¶  abbreviations.¶- ‘:case-fixed’ non-nil means that abbreviations are looked up without¶  case-folding, and the expansion is not capitalized/upcased.¶- ‘:regexp’ is a regular expression that specifies how to extract the¶  name of the abbrev before point.  The submatch 1 is treated¶  as the potential name of an abbrev.  If :regexp is nil, the default¶  behavior uses ‘backward-word’ and ‘forward-word’ to extract the name¶  of the abbrev, which can therefore only be a single word.¶- ‘:enable-function’ can be set to a function of no argument which returns¶  non-nil if and only if the abbrevs in this table should be used for this¶  instance of ‘expand-abbrev’.¶¶(fn TABLENAME DEFINITIONS &amp;optional DOCSTRING &amp;rest PROPS)",
"insert-abbrev-table-description":"Insert before point a full description of abbrev table named NAME.¶NAME is a symbol whose value is an abbrev table.¶If optional 2nd arg READABLE is non-nil, a human-readable description¶is inserted.  Otherwise the description is an expression,¶a call to ‘define-abbrev-table’, which would¶define the abbrev table NAME exactly as it is currently defined.¶¶Abbrevs marked as &quot;system abbrevs&quot; are omitted.¶¶(fn NAME &amp;optional READABLE)",
"advice-function-member-p":"Return non-nil if ADVICE is already in FUNCTION-DEF.¶Instead of ADVICE being the actual function, it can also be the ‘name’¶of the piece of advice.¶¶(fn ADVICE FUNCTION-DEF)",
"advice-function-mapc":"Apply F to every advice function in FUNCTION-DEF.¶F is called with two arguments: the function that was added, and the¶properties alist that was specified when it was added.¶¶(fn F FUNCTION-DEF)",
"advice-eval-interactive-spec":"Evaluate the interactive spec SPEC.¶¶(fn SPEC)",
"display-buffer-same-window":"Display BUFFER in the selected window.¶This fails if ALIST has a non-nil ‘inhibit-same-window’ entry, or¶if the selected window is a minibuffer window or is dedicated to¶another buffer; in that case, return nil.  Otherwise, return the¶selected window.",
"display-buffer-reuse-window":"Return a window that is already displaying BUFFER.¶Return nil if no usable window is found.¶¶If ALIST has a non-nil ‘inhibit-same-window’ entry, the selected¶window is not eligible for reuse.¶¶If ALIST contains a ‘reusable-frames’ entry, its value determines¶which frames to search for a reusable window:¶  nil -- the selected frame (actually the last non-minibuffer frame)¶  A frame   -- just that frame¶  ‘visible’ -- all visible frames¶  0   -- all frames on the current terminal¶  t   -- all frames.¶¶If ALIST contains no ‘reusable-frames’ entry, search just the¶selected frame if ‘display-buffer-reuse-frames’ and¶‘pop-up-frames’ are both nil; search all frames on the current¶terminal if either of those variables is non-nil.¶¶If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the¶event that a window on another frame is chosen, avoid raising¶that frame.",
"display-buffer-pop-up-frame":"Display BUFFER in a new frame.¶This works by calling ‘pop-up-frame-function’.  If successful,¶return the window used; otherwise return nil.¶¶If ALIST has a non-nil ‘inhibit-switch-frame’ entry, avoid¶raising the new frame.¶¶If ALIST has a non-nil ‘pop-up-frame-parameters’ entry, the¶corresponding value is an alist of frame parameters to give the¶new frame.",
"display-buffer-use-some-frame":"Display BUFFER in an existing frame that meets a predicate¶(by default any frame other than the current frame).  If¶successful, return the window used; otherwise return nil.¶¶If ALIST has a non-nil ‘inhibit-switch-frame’ entry, avoid¶raising the frame.¶¶If ALIST has a non-nil ‘frame-predicate’ entry, its value is a¶function taking one argument (a frame), returning non-nil if the¶frame is a candidate; this function replaces the default¶predicate.¶¶If ALIST has a non-nil ‘inhibit-same-window’ entry, avoid using¶the currently selected window (only useful with a frame-predicate¶that allows the selected frame).",
"display-buffer-pop-up-window":"Display BUFFER by popping up a new window.¶The new window is created on the selected frame, or in¶‘last-nonminibuffer-frame’ if no windows can be created there.¶If successful, return the new window; otherwise return nil.¶¶If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the¶event that the new window is created on another frame, avoid¶raising the frame.",
"display-buffer-below-selected":"Try displaying BUFFER in a window below the selected window.¶This either splits the selected window or reuses the window below¶the selected one.",
"display-buffer-in-previous-window":"Display BUFFER in a window previously showing it.¶If ALIST has a non-nil ‘inhibit-same-window’ entry, the selected¶window is not eligible for reuse.¶¶If ALIST contains a ‘reusable-frames’ entry, its value determines¶which frames to search for a reusable window:¶  nil -- the selected frame (actually the last non-minibuffer frame)¶  A frame   -- just that frame¶  ‘visible’ -- all visible frames¶  0   -- all frames on the current terminal¶  t   -- all frames.¶¶If ALIST contains no ‘reusable-frames’ entry, search just the¶selected frame if ‘display-buffer-reuse-frames’ and¶‘pop-up-frames’ are both nil; search all frames on the current¶terminal if either of those variables is non-nil.¶¶If ALIST has a ‘previous-window’ entry, the window specified by¶that entry will override any other window found by the methods¶above, even if that window never showed BUFFER before.",
"display-buffer-at-bottom":"Try displaying BUFFER in a window at the bottom of the selected frame.¶This either reuses such a window provided it shows BUFFER¶already, splits a window at the bottom of the frame or the¶frame’s root window, or reuses some window at the bottom of the¶selected frame.",
"display-buffer-use-some-window":"Display BUFFER in an existing window.¶Search for a usable window, set that window to the buffer, and¶return the window.  If no suitable window is found, return nil.¶¶If ALIST has a non-nil ‘inhibit-switch-frame’ entry, then in the¶event that a window in another frame is chosen, avoid raising¶that frame.",
"display-buffer-no-window":"Display BUFFER in no window.¶If ALIST has a non-nil ‘allow-no-window’ entry, then don’t display¶a window at all.  This makes possible to override the default action¶and avoid displaying the buffer.  It is assumed that when the caller¶specifies a non-nil ‘allow-no-window’ then it can handle a nil value¶returned from ‘display-buffer’ in this case.",
"isnan":"Return non nil if argument X is a NaN.¶¶(fn X)",
"frexp":"Get significand and exponent of a floating point number.¶Breaks the floating point number X into its binary significand SGNFCAND¶(a floating point value between 0.5 (included) and 1.0 (excluded))¶and an integral exponent EXP for 2, such that:¶¶  X = SGNFCAND * 2^EXP¶¶The function returns the cons cell (SGNFCAND . EXP).¶If X is zero, both parts (SGNFCAND and EXP) are zero.¶¶(fn X)",
"ldexp":"Return SGNFCAND * 2**EXPONENT, as a floating point number.¶EXPONENT must be an integer.¶¶(fn SGNFCAND EXPONENT)",
"copysign":"Copy sign of X2 to value of X1, and return the result.¶Cause an error if X1 or X2 is not a float.¶¶(fn X1 X2)",
"logb":"Returns largest integer &lt;= the base 2 log of the magnitude of ARG.¶This is the same as the exponent of a float.¶¶(fn ARG)",
"file-newer-than-file-p":"Return t if file FILE1 is newer than file FILE2.¶If FILE1 does not exist, the answer is nil;¶otherwise, if FILE2 does not exist, the answer is t.¶¶(fn FILE1 FILE2)",
"file-attributes":"Return a list of attributes of file FILENAME.¶Value is nil if specified file cannot be opened.¶¶ID-FORMAT specifies the preferred format of attributes uid and gid (see¶below) - valid values are ‘string’ and ‘integer’.  The latter is the¶default, but we plan to change that, so you should specify a non-nil value¶for ID-FORMAT if you use the returned uid or gid.¶¶Elements of the attribute list are:¶ 0. t for directory, string (name linked to) for symbolic link, or nil.¶ 1. Number of links to file.¶ 2. File uid as a string or a number.  If a string value cannot be¶  looked up, a numeric value, either an integer or a float, is returned.¶ 3. File gid, likewise.¶ 4. Last access time, as a list of integers (HIGH LOW USEC PSEC) in the¶  same style as (current-time).¶  (See a note below about access time on FAT-based filesystems.)¶ 5. Last modification time, likewise.  This is the time of the last¶  change to the file’s contents.¶ 6. Last status change time, likewise.  This is the time of last change¶  to the file’s attributes: owner and group, access mode bits, etc.¶ 7. Size in bytes.¶  This is a floating point number if the size is too large for an integer.¶ 8. File modes, as a string of ten letters or dashes as in ls -l.¶ 9. An unspecified value, present only for backward compatibility.¶10. inode number.  If it is larger than what an Emacs integer can hold,¶  this is of the form (HIGH . LOW): first the high bits, then the low 16 bits.¶  If even HIGH is too large for an Emacs integer, this is instead of the form¶  (HIGH MIDDLE . LOW): first the high bits, then the middle 24 bits,¶  and finally the low 16 bits.¶11. Filesystem device number.  If it is larger than what the Emacs¶  integer can hold, this is a cons cell, similar to the inode number.¶¶On most filesystems, the combination of the inode and the device¶number uniquely identifies the file.¶¶On MS-Windows, performance depends on ‘w32-get-true-file-attributes’,¶which see.¶¶On some FAT-based filesystems, only the date of last access is recorded,¶so last access time will always be midnight of that day.¶¶(fn FILENAME &amp;optional ID-FORMAT)",
"file-nlinks":"Return number of names file FILENAME has.¶¶(fn FILENAME)",
"barf-if-buffer-read-only":"Signal a ‘buffer-read-only’ error if the current buffer is read-only.¶If the text under POSITION (which defaults to point) has the¶‘inhibit-read-only’ text property set, the error will not be raised.¶¶(fn &amp;optional POSITION)",
"file-acl":"Return ACL entries of file named FILENAME.¶The entries are returned in a format suitable for use in ‘set-file-acl’¶but is otherwise undocumented and subject to change.¶Return nil if file does not exist or is not accessible, or if Emacs¶was unable to determine the ACL entries.¶¶(fn FILENAME)",
"file-selinux-context":"Return SELinux context of file named FILENAME.¶The return value is a list (USER ROLE TYPE RANGE), where the list¶elements are strings naming the user, role, type, and range of the¶file’s SELinux security context.¶¶Return (nil nil nil nil) if the file is nonexistent or inaccessible,¶or if SELinux is disabled, or if Emacs lacks SELinux support.¶¶(fn FILENAME)",
"file-extended-attributes":"Return an alist of extended attributes of file FILENAME.¶¶Extended attributes are platform-specific metadata about the file,¶such as SELinux context, list of ACL entries, etc.¶¶(fn FILENAME)",
"zlib-available-p":"Return t if zlib decompression is available in this instance of Emacs.¶¶(fn)",
"zlib-decompress-region":"Decompress a gzip- or zlib-compressed region.¶Replace the text in the region by the decompressed data.¶On failure, return nil and leave the data in place.¶This function can be called only in unibyte buffers.¶¶(fn START END)",
"window-preserve-size":"Preserve height of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶Optional argument HORIZONTAL non-nil means preserve the width of¶WINDOW.¶¶PRESERVE t means to preserve the current height/width of WINDOW’s¶body in frame and window resizing operations whenever possible.¶The height/width of WINDOW will change only if Emacs has no other¶choice.  Resizing a window whose height/width is preserved never¶throws an error.¶¶PRESERVE nil means to stop preserving the height/width of WINDOW,¶lifting the respective restraint induced by a previous call of¶‘window-preserve-size’ for WINDOW.  Calling ‘enlarge-window’,¶‘shrink-window’, ‘split-window’ or ‘fit-window-to-buffer’ with¶WINDOW as argument also removes the respective restraint.¶¶Other values of PRESERVE are reserved for future use.",
"window-preserved-size":"Return preserved height of window WINDOW.¶WINDOW must be a live window and defaults to the selected one.¶Optional argument HORIZONTAL non-nil means to return preserved¶width of WINDOW.",
"load":"Execute a file of Lisp code named FILE.¶First try FILE with ‘.elc’ appended, then try with ‘.el’, then try¶with a system-dependent suffix of dynamic modules (see ‘load-suffixes’),¶then try FILE unmodified (the exact suffixes in the exact order are¶determined by ‘load-suffixes’).  Environment variable references in¶FILE are replaced with their values by calling ‘substitute-in-file-name’.¶This function searches the directories in ‘load-path’.¶¶If optional second arg NOERROR is non-nil,¶report no error if FILE doesn’t exist.¶Print messages at start and end of loading unless¶optional third arg NOMESSAGE is non-nil (but ‘force-load-messages’¶overrides that).¶If optional fourth arg NOSUFFIX is non-nil, don’t try adding¶suffixes to the specified name FILE.¶If optional fifth arg MUST-SUFFIX is non-nil, insist on¶the suffix ‘.elc’ or ‘.el’ or the module suffix; don’t accept just¶FILE unless it ends in one of those suffixes or includes a directory name.¶¶If NOSUFFIX is nil, then if a file could not be found, try looking for¶a different representation of the file by adding non-empty suffixes to¶its name, before trying another file.  Emacs uses this feature to find¶compressed versions of files when Auto Compression mode is enabled.¶If NOSUFFIX is non-nil, disable this feature.¶¶The suffixes that this function tries out, when NOSUFFIX is nil, are¶given by the return value of ‘get-load-suffixes’ and the values listed¶in ‘load-file-rep-suffixes’.  If MUST-SUFFIX is non-nil, only the¶return value of ‘get-load-suffixes’ is used, i.e. the file name is¶required to have a non-empty suffix.¶¶When searching suffixes, this function normally stops at the first¶one that exists.  If the option ‘load-prefer-newer’ is non-nil,¶however, it tries all suffixes, and uses whichever file is the newest.¶¶Loading a file records its definitions, and its ‘provide’ and¶‘require’ calls, in an element of ‘load-history’ whose¶car is the file name loaded.  See ‘load-history’.¶¶While the file is in the process of being loaded, the variable¶‘load-in-progress’ is non-nil and the variable ‘load-file-name’¶is bound to the file’s name.¶¶Return t if the file exists and loads successfully.¶¶(fn FILE &amp;optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)",
"arrayp":"Return t if OBJECT is an array (string or vector).¶¶(fn OBJECT)",
"aref":"Return the element of ARRAY at index IDX.¶ARRAY may be a vector, a string, a char-table, a bool-vector,¶or a byte-code object.  IDX starts at 0.¶¶(fn ARRAY IDX)",
"aset":"Store into the element of ARRAY at index IDX the value NEWELT.¶Return NEWELT.  ARRAY may be a vector, a string, a char-table or a¶bool-vector.  IDX starts at 0.¶¶(fn ARRAY IDX NEWELT)",
"fillarray":"Store each element of ARRAY with ITEM.¶ARRAY is a vector, string, char-table, or bool-vector.¶¶(fn ARRAY ITEM)",
"delete-process":"Delete PROCESS: kill it and forget about it immediately.¶PROCESS may be a process, a buffer, the name of a process or buffer, or¶nil, indicating the current buffer’s process.¶¶(fn PROCESS)",
"image-mask-p":"Return t if image SPEC has a mask bitmap.¶FRAME is the frame on which the image will be displayed.  FRAME nil¶or omitted means use the selected frame.¶¶(fn SPEC &amp;optional FRAME)",
"interrupt-process":"Interrupt process PROCESS.¶PROCESS may be a process, a buffer, or the name of a process or buffer.¶No arg or nil means current buffer’s process.¶Second arg CURRENT-GROUP non-nil means send signal to¶the current process-group of the process’s controlling terminal¶rather than to the process’s own process group.¶If the process is a shell, this means interrupt current subjob¶rather than the shell.¶¶If CURRENT-GROUP is ‘lambda’, and if the shell owns the terminal,¶don’t send the signal.¶¶(fn &amp;optional PROCESS CURRENT-GROUP)",
"kill-process":"Kill process PROCESS.  May be process or name of one.¶See function ‘interrupt-process’ for more details on usage.¶¶(fn &amp;optional PROCESS CURRENT-GROUP)",
"quit-process":"Send QUIT signal to process PROCESS.  May be process or name of one.¶See function ‘interrupt-process’ for more details on usage.¶¶(fn &amp;optional PROCESS CURRENT-GROUP)",
"stop-process":"Stop process PROCESS.  May be process or name of one.¶See function ‘interrupt-process’ for more details on usage.¶If PROCESS is a network or serial or pipe connection, inhibit handling¶of incoming traffic.¶¶(fn &amp;optional PROCESS CURRENT-GROUP)",
"continue-process":"Continue process PROCESS.  May be process or name of one.¶See function ‘interrupt-process’ for more details on usage.¶If PROCESS is a network or serial process, resume handling of incoming¶traffic.¶¶(fn &amp;optional PROCESS CURRENT-GROUP)",
"minibuffer-depth":"Return current depth of activations of minibuffer, a nonnegative integer.¶¶(fn)",
"gethash":"Look up KEY in TABLE and return its associated value.¶If KEY is not found, return DFLT which defaults to nil.¶¶(fn KEY TABLE &amp;optional DFLT)",
"puthash":"Associate KEY with VALUE in hash table TABLE.¶If KEY is already present in table, replace its current value with¶VALUE.  In any case, return VALUE.¶¶(fn KEY VALUE TABLE)",
"remhash":"Remove KEY from TABLE.¶¶(fn KEY TABLE)",
"clrhash":"Clear hash table TABLE and return it.¶¶(fn TABLE)",
"maphash":"Call FUNCTION for all entries in hash table TABLE.¶FUNCTION is called with two arguments, KEY and VALUE.¶‘maphash’ always returns nil.¶¶(fn FUNCTION TABLE)",
"read-quoted-char":"Like ‘read-char’, but do not allow quitting.¶Also, if the first character read is an octal digit,¶we read any number of octal digits and return the¶specified character code.  Any nondigit terminates the sequence.¶If the terminator is RET, it is discarded;¶any other terminator is used itself as input.¶¶The optional argument PROMPT specifies a string to use to prompt the user.¶The variable ‘read-quoted-char-radix’ controls which radix to use¶for numeric input.¶¶(fn &amp;optional PROMPT)",
"eql":"Return t if the two args are the same Lisp object.¶Floating-point numbers of equal value are ‘eql’, but they may not be ‘eq’.¶¶(fn OBJ1 OBJ2)",
"max":"Return largest of all the arguments (which must be numbers or markers).¶The value is always a number; markers are converted to numbers.¶¶(fn NUMBER-OR-MARKER &amp;rest NUMBERS-OR-MARKERS)",
"min":"Return smallest of all the arguments (which must be numbers or markers).¶The value is always a number; markers are converted to numbers.¶¶(fn NUMBER-OR-MARKER &amp;rest NUMBERS-OR-MARKERS)",
"abs":"Return the absolute value of ARG.¶¶(fn ARG)",
"framep":"Return non-nil if OBJECT is a frame.¶Value is:¶  t for a termcap frame (a character-only terminal),¶ ‘x’ for an Emacs frame that is really an X window,¶ ‘w32’ for an Emacs frame that is a window on MS-Windows display,¶ ‘ns’ for an Emacs frame on a GNUstep or Macintosh Cocoa display,¶ ‘pc’ for a direct-write MS-DOS frame.¶See also ‘frame-live-p’.¶¶(fn OBJECT)",
"frame-terminal":"Return the terminal that FRAME is displayed on.¶If FRAME is nil, the selected frame is used.¶¶The terminal device is represented by its integer identifier.¶¶(fn &amp;optional FRAME)",
"terminal-live-p":"Return non-nil if OBJECT is a terminal which has not been deleted.¶Value is nil if OBJECT is not a live display terminal.¶If object is a live display terminal, the return value indicates what¶sort of output terminal it uses.  See the documentation of ‘framep’ for¶possible return values.¶¶(fn OBJECT)",
"image-type-available-p":"Return non-nil if image type TYPE is available.¶Image types are symbols like ‘xbm’ or ‘jpeg’.",
"mapcar":"Apply FUNCTION to each element of SEQUENCE, and make a list of the results.¶The result is a list just as long as SEQUENCE.¶SEQUENCE may be a list, a vector, a bool-vector, or a string.¶¶(fn FUNCTION SEQUENCE)",
"mapc":"Apply FUNCTION to each element of SEQUENCE for side effects only.¶Unlike ‘mapcar’, don’t accumulate the results.  Return SEQUENCE.¶SEQUENCE may be a list, a vector, a bool-vector, or a string.¶¶(fn FUNCTION SEQUENCE)",
"mapconcat":"Apply FUNCTION to each element of SEQUENCE, and concat the results as strings.¶In between each pair of results, stick in SEPARATOR.  Thus, &quot; &quot; as¶SEPARATOR results in spaces between the values returned by FUNCTION.¶SEQUENCE may be a list, a vector, a bool-vector, or a string.¶¶(fn FUNCTION SEQUENCE SEPARATOR)",
"purecopy":"Make a copy of object OBJ in pure storage.¶Recursively copies contents of vectors and cons cells.¶Does not copy symbols.  Copies strings without text properties.¶¶(fn OBJ)",
"current-bidi-paragraph-direction":"Return paragraph direction at point in BUFFER.¶Value is either ‘left-to-right’ or ‘right-to-left’.¶If BUFFER is omitted or nil, it defaults to the current buffer.¶¶Paragraph direction determines how the text in the paragraph is displayed.¶In left-to-right paragraphs, text begins at the left margin of the window¶and the reading direction is generally left to right.  In right-to-left¶paragraphs, text begins at the right margin and is read from right to left.¶¶See also ‘bidi-paragraph-direction’.¶¶(fn &amp;optional BUFFER)",
"move-point-visually":"Move point in the visual order in the specified DIRECTION.¶DIRECTION can be 1, meaning move to the right, or -1, which moves to the¶left.¶¶Value is the new character position of point.¶¶(fn DIRECTION)",
"bidi-string-mark-left-to-right":"Return a string that can be safely inserted in left-to-right text.¶¶Normally, inserting a string with right-to-left (RTL) script into¶a buffer may cause some subsequent text to be displayed as part¶of the RTL segment (usually this affects punctuation characters).¶This function returns a string which displays as STR but forces¶subsequent text to be displayed as left-to-right.¶¶If STR contains any RTL character, this function returns a string¶consisting of STR followed by an invisible left-to-right mark¶(LRM) character.  Otherwise, it returns STR.¶¶(fn STR)",
"bidi-find-overridden-directionality":"Return position between FROM and TO where directionality was overridden.¶¶This function returns the first character position in the specified¶region of OBJECT where there is a character whose ‘bidi-class’ property¶is ‘L’, but which was forced to display as ‘R’ by a directional¶override, and likewise with characters whose ‘bidi-class’ is ‘R’¶or ‘AL’ that were forced to display as ‘L’.¶¶If no such character is found, the function returns nil.¶¶OBJECT is a Lisp string or buffer to search for overridden¶directionality, and defaults to the current buffer if nil or omitted.¶OBJECT can also be a window, in which case the function will search¶the buffer displayed in that window.  Passing the window instead of¶a buffer is preferable when the buffer is displayed in some window,¶because this function will then be able to correctly account for¶window-specific overlays, which can affect the results.¶¶Strong directional characters ‘L’, ‘R’, and ‘AL’ can have their¶intrinsic directionality overridden by directional override¶control characters RLO (u+202e) and LRO (u+202d).  See the¶function ‘get-char-code-property’ for a way to inquire about¶the ‘bidi-class’ property of a character.¶¶(fn FROM TO &amp;optional OBJECT)",
"buffer-substring-with-bidi-context":"Return portion of current buffer between START and END with bidi context.¶¶This function works similar to ‘buffer-substring’, but it prepends and¶appends to the text bidi directional control characters necessary to¶preserve the visual appearance of the text if it is inserted at another¶place.  This is useful when the buffer substring includes bidirectional¶text and control characters that cause non-trivial reordering on display.¶If copied verbatim, such text can have a very different visual appearance,¶and can also change the visual appearance of the surrounding text at the¶destination of the copy.¶¶Optional argument NO-PROPERTIES, if non-nil, means copy the text without¶the text properties.¶¶(fn START END &amp;optional NO-PROPERTIES)",
"special-form-p":"Non-nil if and only if OBJECT is a special form.¶¶(fn OBJECT)",
"type-of":"Return a symbol representing the type of OBJECT.¶The symbol returned names the object’s basic type;¶for example, (type-of 1) returns ‘integer’.¶¶(fn OBJECT)",
"syntax-ppss-toplevel-pos":"Get the latest syntactically outermost position found in a syntactic scan.¶PPSS is a scan state, as returned by ‘parse-partial-sexp’ or ‘syntax-ppss’.¶An &quot;outermost position&quot; means one that it is outside of any syntactic entity:¶outside of any parentheses, comments, or strings encountered in the scan.¶If no such position is recorded in PPSS (because the end of the scan was¶itself at the outermost level), return nil.¶¶(fn PPSS)",
"shell-quote-argument":"Quote ARGUMENT for passing as argument to an inferior shell.¶¶This function is designed to work with the syntax of your system’s¶standard shell, and might produce incorrect results with unusual shells.¶See Info node ‘(elisp)Security Considerations’.¶¶(fn ARGUMENT)",
"split-string-and-unquote":"Split the STRING into a list of strings.¶It understands Emacs Lisp quoting within STRING, such that¶  (split-string-and-unquote (combine-and-quote-strings strs)) == strs¶The SEPARATOR regexp defaults to &quot;⧷s-+&quot;.¶¶(fn STRING &amp;optional SEPARATOR)",
"combine-and-quote-strings":"Concatenate the STRINGS, adding the SEPARATOR (default &quot; &quot;).¶This tries to quote the strings to avoid ambiguity such that¶  (split-string-and-unquote (combine-and-quote-strings strs)) == strs¶Only some SEPARATORs will work properly.¶¶Note that this is not intended to protect STRINGS from¶interpretation by shells, use ‘shell-quote-argument’ for that.¶¶(fn STRINGS &amp;optional SEPARATOR)",
"posix-looking-at":"Return t if text after point matches regular expression REGEXP.¶Find the longest match, in accord with Posix regular expression rules.¶This function modifies the match data that ‘match-beginning’,¶‘match-end’ and ‘match-data’ access; save and restore the match¶data if you want to preserve them.¶¶(fn REGEXP)",
"posix-string-match":"Return index of start of first match for REGEXP in STRING, or nil.¶Find the longest match, in accord with Posix regular expression rules.¶Case is ignored if ‘case-fold-search’ is non-nil in the current buffer.¶If third arg START is non-nil, start search at that index in STRING.¶For index of first char beyond the match, do (match-end 0).¶‘match-end’ and ‘match-beginning’ also give indices of substrings¶matched by parenthesis constructs in the pattern.¶¶(fn REGEXP STRING &amp;optional START)",
"define-hash-table-test":"Define a new hash table test with name NAME, a symbol.¶¶In hash tables created with NAME specified as test, use TEST to¶compare keys, and HASH for computing hash codes of keys.¶¶TEST must be a function taking two arguments and returning non-nil if¶both arguments are the same.  HASH must be a function taking one¶argument and returning an object that is the hash code of the argument.¶It should be the case that if (eq (funcall HASH x1) (funcall HASH x2))¶returns nil, then (funcall TEST x1 x2) also returns nil.¶¶(fn NAME TEST HASH)",
"sxhash":"Compute a hash code for OBJ and return it as integer.¶¶(fn OBJ)",
"window-system":"The name of the window system that FRAME is displaying through.¶The value is a symbol:¶ nil for a termcap frame (a character-only terminal),¶ ‘x’ for an Emacs frame that is really an X window,¶ ‘w32’ for an Emacs frame that is a window on MS-Windows display,¶ ‘ns’ for an Emacs frame on a GNUstep or Macintosh Cocoa display,¶ ‘pc’ for a direct-write MS-DOS frame.¶¶FRAME defaults to the currently selected frame.¶¶Use of this function as a predicate is deprecated.  Instead,¶use ‘display-graphic-p’ or any of the other ‘display-*-p’¶predicates which report frame’s specific UI-related capabilities.¶¶(fn &amp;optional FRAME)",
"setcar":"Set the car of CELL to be NEWCAR.  Returns NEWCAR.¶¶(fn CELL NEWCAR)",
"read-buffer":"Read the name of a buffer and return as a string.¶Prompt with PROMPT.¶Optional second arg DEF is value to return if user enters an empty line.¶ If DEF is a list of default values, return its first element.¶Optional third arg REQUIRE-MATCH determines whether non-existing¶ buffer names are allowed.  It has the same meaning as the¶ REQUIRE-MATCH argument of ‘completing-read’.¶The argument PROMPT should be a string ending with a colon and a space.¶If ‘read-buffer-completion-ignore-case’ is non-nil, completion ignores¶case while reading the buffer name.¶If ‘read-buffer-function’ is non-nil, this works by calling it as a¶function, instead of the usual behavior.¶Optional arg PREDICATE if non-nil is a function limiting the buffers that can¶be considered.¶¶(fn PROMPT &amp;optional DEF REQUIRE-MATCH PREDICATE)",
"read-command":"Read the name of a command and return as a symbol.¶Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element¶if it is a list.¶¶(fn PROMPT &amp;optional DEFAULT-VALUE)",
"read-variable":"Read the name of a user option and return it as a symbol.¶Prompt with PROMPT.  By default, return DEFAULT-VALUE or its first element¶if it is a list.¶A user option, or customizable variable, is one for which¶‘custom-variable-p’ returns non-nil.¶¶(fn PROMPT &amp;optional DEFAULT-VALUE)",
"force-mode-line-update":"Force redisplay of the current buffer’s mode line and header line.¶With optional non-nil ALL, force redisplay of all mode lines and¶header lines.  This function also forces recomputation of the¶menu bar menus and the frame title.¶¶(fn &amp;optional ALL)",
"file-locked-p":"Return a value indicating whether FILENAME is locked.¶The value is nil if the FILENAME is not locked,¶t if it is locked by you, else a string saying which user has locked it.¶¶(fn FILENAME)",
"lock-buffer":"Lock FILE, if current buffer is modified.¶FILE defaults to current buffer’s visited file,¶or else nothing is done if current buffer isn’t visiting a file.¶¶If the option ‘create-lockfiles’ is nil, this does nothing.¶¶(fn &amp;optional FILE)",
"unlock-buffer":"Unlock the file visited in the current buffer.¶If the buffer is not modified, this does nothing because the file¶should not be locked in that case.¶¶(fn)",
"ask-user-about-lock":"Ask user what to do when he wants to edit FILE but it is locked by OPPONENT.¶This function has a choice of three things to do:¶  do (signal 'file-locked (list FILE OPPONENT))¶    to refrain from editing the file¶  return t (grab the lock on the file)¶  return nil (edit the file even though it is locked).¶You can redefine this function to choose among those three alternatives¶in any way you like.¶¶(fn FILE OPPONENT)",
"make-display-table":"Return a new, empty display table.",
"display-table-slot":"Return the value of the extra slot in DISPLAY-TABLE named SLOT.¶SLOT may be a number from 0 to 5 inclusive, or a slot name (symbol).¶Valid symbols are ‘truncation’, ‘wrap’, ‘escape’, ‘control’,¶‘selective-display’, and ‘vertical-border’.",
"set-display-table-slot":"Set the value of the extra slot in DISPLAY-TABLE named SLOT to VALUE.¶SLOT may be a number from 0 to 5 inclusive, or a name (symbol).¶Valid symbols are ‘truncation’, ‘wrap’, ‘escape’, ‘control’,¶‘selective-display’, and ‘vertical-border’.",
"describe-display-table":"Describe the display table DT in a help buffer.",
"get":"Return the value of SYMBOL’s PROPNAME property.¶This is the last value stored with ‘(put SYMBOL PROPNAME VALUE)’.¶¶(fn SYMBOL PROPNAME)",
"put":"Store SYMBOL’s PROPNAME property with value VALUE.¶It can be retrieved with ‘(get SYMBOL PROPNAME)’.¶¶(fn SYMBOL PROPNAME VALUE)",
"symbol-plist":"Return SYMBOL’s property list.¶¶(fn SYMBOL)",
"setplist":"Set SYMBOL’s property list to NEWPLIST, and return NEWPLIST.¶¶(fn SYMBOL NEWPLIST)",
"function-get":"Return the value of property PROP of function F.¶If AUTOLOAD is non-nil and F is autoloaded, try to autoload it¶in the hope that it will set PROP.  If AUTOLOAD is ‘macro’, only do it¶if it’s an autoloaded macro.¶¶(fn F PROP &amp;optional AUTOLOAD)",
"function-put":"Set FUNCTION’s property PROP to VALUE.¶The namespace for PROP is shared with symbols.¶So far, FUNCTION can only be a symbol, not a lambda expression.¶¶(fn FUNCTION PROP VALUE)",
"process-buffer":"Return the buffer PROCESS is associated with.¶The default process filter inserts output from PROCESS into this buffer.¶¶(fn PROCESS)",
"process-mark":"Return the marker for the end of the last output from PROCESS.¶¶(fn PROCESS)",
"set-process-buffer":"Set buffer associated with PROCESS to BUFFER (a buffer, or nil).¶Return BUFFER.¶¶(fn PROCESS BUFFER)",
"get-buffer-process":"Return the (or a) live process associated with BUFFER.¶BUFFER may be a buffer or the name of one.¶Return nil if all processes associated with BUFFER have been¶deleted or killed.¶¶(fn BUFFER)",
"set-process-window-size":"Tell PROCESS that it has logical window size WIDTH by HEIGHT.¶Value is t if PROCESS was successfully told about the window size,¶nil otherwise.¶¶(fn PROCESS HEIGHT WIDTH)",
"current-indentation":"Return the indentation of the current line.¶This is the horizontal position of the character¶following any initial whitespace.¶¶(fn)",
"read-input-method-name":"Read a name of input method from a minibuffer prompting with PROMPT.¶If DEFAULT is non-nil, use that as the default,¶and substitute it into PROMPT at the first ‘%s’.¶If INHIBIT-NULL is non-nil, null input signals an error.¶¶The return value is a string.¶¶(fn PROMPT &amp;optional DEFAULT INHIBIT-NULL)",
"make-obsolete":"Make the byte-compiler warn that function OBSOLETE-NAME is obsolete.¶OBSOLETE-NAME should be a function name or macro name (a symbol).¶¶The warning will say that CURRENT-NAME should be used instead.¶If CURRENT-NAME is a string, that is the ‘use instead’ message¶(it should end with a period, and not start with a capital).¶WHEN should be a string indicating when the function¶was first made obsolete, for example a date or a release number.¶¶(fn OBSOLETE-NAME CURRENT-NAME &amp;optional WHEN)",
"set-advertised-calling-convention":"Set the advertised SIGNATURE of FUNCTION.¶This will allow the byte-compiler to warn the programmer when she uses¶an obsolete calling convention.  WHEN specifies since when the calling¶convention was modified.¶¶(fn FUNCTION SIGNATURE WHEN)",
"suspend-tty":"Suspend the terminal device TTY.¶¶The device is restored to its default state, and Emacs ceases all¶access to the tty device.  Frames that use the device are not deleted,¶but input is not read from them and if they change, their display is¶not updated.¶¶TTY may be a terminal object, a frame, or nil for the terminal device¶of the currently selected frame.¶¶This function runs ‘suspend-tty-functions’ after suspending the¶device.  The functions are run with one arg, the id of the suspended¶terminal device.¶¶‘suspend-tty’ does nothing if it is called on a device that is already¶suspended.¶¶A suspended tty may be resumed by calling ‘resume-tty’ on it.¶¶(fn &amp;optional TTY)",
"resume-tty":"Resume the previously suspended terminal device TTY.¶The terminal is opened and reinitialized.  Frames that are on the¶suspended terminal are revived.¶¶It is an error to resume a terminal while another terminal is active¶on the same device.¶¶This function runs ‘resume-tty-functions’ after resuming the terminal.¶The functions are run with one arg, the id of the resumed terminal¶device.¶¶‘resume-tty’ does nothing if it is called on a device that is not¶suspended.¶¶TTY may be a terminal object, a frame, or nil (meaning the selected¶frame’s terminal).¶¶(fn &amp;optional TTY)",
"controlling-tty-p":"Return non-nil if TERMINAL is the controlling tty of the Emacs process.¶¶TERMINAL can be a terminal object, a frame, or nil (meaning the¶selected frame’s terminal).  This function always returns nil if¶TERMINAL is not on a tty device.¶¶(fn &amp;optional TERMINAL)",
"overlayp":"Return t if OBJECT is an overlay.¶¶(fn OBJECT)",
"make-overlay":"Create a new overlay with range BEG to END in BUFFER and return it.¶If omitted, BUFFER defaults to the current buffer.¶BEG and END may be integers or markers.¶The fourth arg FRONT-ADVANCE, if non-nil, makes the marker¶for the front of the overlay advance when text is inserted there¶(which means the text *is not* included in the overlay).¶The fifth arg REAR-ADVANCE, if non-nil, makes the marker¶for the rear of the overlay advance when text is inserted there¶(which means the text *is* included in the overlay).¶¶(fn BEG END &amp;optional BUFFER FRONT-ADVANCE REAR-ADVANCE)",
"overlay-start":"Return the position at which OVERLAY starts.¶¶(fn OVERLAY)",
"overlay-end":"Return the position at which OVERLAY ends.¶¶(fn OVERLAY)",
"overlay-buffer":"Return the buffer OVERLAY belongs to.¶Return nil if OVERLAY has been deleted.¶¶(fn OVERLAY)",
"delete-overlay":"Delete the overlay OVERLAY from its buffer.¶¶(fn OVERLAY)",
"move-overlay":"Set the endpoints of OVERLAY to BEG and END in BUFFER.¶If BUFFER is omitted, leave OVERLAY in the same buffer it inhabits now.¶If BUFFER is omitted, and OVERLAY is in no buffer, put it in the current¶buffer.¶¶(fn OVERLAY BEG END &amp;optional BUFFER)",
"remove-overlays":"Clear BEG and END of overlays whose property NAME has value VAL.¶Overlays might be moved and/or split.¶BEG and END default respectively to the beginning and end of buffer.¶¶(fn &amp;optional BEG END NAME VAL)",
"copy-overlay":"Return a copy of overlay O.¶¶(fn O)",
"overlay-recenter":"Recenter the overlays of the current buffer around position POS.¶That makes overlay lookup faster for positions near POS (but perhaps slower¶for positions far away from POS).¶¶(fn POS)",
"nconc":"Concatenate any number of lists by altering them.¶Only the last argument is not altered, and need not be a list.¶¶(fn &amp;rest LISTS)",
"expand-file-name":"Convert filename NAME to absolute, and canonicalize it.¶Second arg DEFAULT-DIRECTORY is directory to start with if NAME is relative¶(does not start with slash or tilde); both the directory name and¶a directory’s file name are accepted.  If DEFAULT-DIRECTORY is nil or¶missing, the current buffer’s value of ‘default-directory’ is used.¶NAME should be a string that is a valid file name for the underlying¶filesystem.¶File name components that are ‘.’ are removed, and¶so are file name components followed by ‘..’, along with the ‘..’ itself;¶note that these simplifications are done without checking the resulting¶file names in the file system.¶Multiple consecutive slashes are collapsed into a single slash,¶except at the beginning of the file name when they are significant (e.g.,¶UNC file names on MS-Windows.)¶An initial ‘~/’ expands to your home directory.¶An initial ‘~USER/’ expands to USER’s home directory.¶See also the function ‘substitute-in-file-name’.¶¶For technical reasons, this function can return correct but¶non-intuitive results for the root directory; for instance,¶(expand-file-name &quot;..&quot; &quot;/&quot;) returns &quot;/..&quot;.  For this reason, use¶(directory-file-name (file-name-directory dirname)) to traverse a¶filesystem tree, not (expand-file-name &quot;..&quot;  dirname).¶¶(fn NAME &amp;optional DEFAULT-DIRECTORY)",
"substitute-in-file-name":"Substitute environment variables referred to in FILENAME.¶‘$FOO’ where FOO is an environment variable name means to substitute¶the value of that variable.  The variable name should be terminated¶with a character not a letter, digit or underscore; otherwise, enclose¶the entire variable name in braces.¶¶If ‘/~’ appears, all of FILENAME through that ‘/’ is discarded.¶If ‘//’ appears, everything up to and including the first of¶those ‘/’ is discarded.¶¶(fn FILENAME)",
"prefix-numeric-value":"Return numeric meaning of raw prefix argument RAW.¶A raw prefix argument is what you get from ‘(interactive &quot;P&quot;)’.¶Its numeric meaning is what you would get from ‘(interactive &quot;p&quot;)’.¶¶(fn RAW)",
"lsh":"Return VALUE with its bits shifted left by COUNT.¶If COUNT is negative, shifting is actually to the right.¶In this case, zeros are shifted in on the left.¶¶(fn VALUE COUNT)",
"ash":"Return VALUE with its bits shifted left by COUNT.¶If COUNT is negative, shifting is actually to the right.¶In this case, the sign bit is duplicated.¶¶(fn VALUE COUNT)",
"logand":"Return bitwise-and of all the arguments.¶Arguments may be integers, or markers converted to integers.¶¶(fn &amp;rest INTS-OR-MARKERS)",
"logior":"Return bitwise-or of all the arguments.¶Arguments may be integers, or markers converted to integers.¶¶(fn &amp;rest INTS-OR-MARKERS)",
"logxor":"Return bitwise-exclusive-or of all the arguments.¶Arguments may be integers, or markers converted to integers.¶¶(fn &amp;rest INTS-OR-MARKERS)",
"lognot":"Return the bitwise complement of NUMBER.  NUMBER must be an integer.¶¶(fn NUMBER)",
"display-warning":"Display a warning message, MESSAGE.¶TYPE is the warning type: either a custom group name (a symbol),¶or a list of symbols whose first element is a custom group name.¶(The rest of the symbols represent subcategories, for warning purposes¶only, and you can use whatever symbols you like.)¶¶LEVEL should be either :debug, :warning, :error, or :emergency¶(but see ‘warning-minimum-level’ and ‘warning-minimum-log-level’).¶Default is :warning.¶¶:emergency -- a problem that will seriously impair Emacs operation soon¶\t      if you do not attend to it promptly.¶:error     -- data or circumstances that are inherently wrong.¶:warning   -- data or circumstances that are not inherently wrong,¶\t      but raise suspicion of a possible problem.¶:debug     -- info for debugging only.¶¶BUFFER-NAME, if specified, is the name of the buffer for logging¶the warning.  By default, it is ‘*Warnings*’.  If this function¶has to create the buffer, it disables undo in the buffer.¶¶See the ‘warnings’ custom group for user customization features.¶¶See also ‘warning-series’, ‘warning-prefix-function’ and¶‘warning-fill-prefix’ for additional programming features.¶¶(fn TYPE MESSAGE &amp;optional LEVEL BUFFER-NAME)",
"lwarn":"Display a warning message made from (format-message MESSAGE ARGS...).¶¶Aside from generating the message with ‘format-message’,¶this is equivalent to ‘display-warning’.¶¶TYPE is the warning type: either a custom group name (a symbol),¶or a list of symbols whose first element is a custom group name.¶(The rest of the symbols represent subcategories and¶can be whatever you like.)¶¶LEVEL should be either :debug, :warning, :error, or :emergency¶(but see ‘warning-minimum-level’ and ‘warning-minimum-log-level’).¶¶:emergency -- a problem that will seriously impair Emacs operation soon¶\t      if you do not attend to it promptly.¶:error     -- invalid data or circumstances.¶:warning   -- suspicious data or circumstances.¶:debug     -- info for debugging only.¶¶(fn TYPE LEVEL MESSAGE &amp;rest ARGS)",
"warn":"Display a warning message made from (format-message MESSAGE ARGS...).¶Aside from generating the message with ‘format-message’,¶this is equivalent to ‘display-warning’, using¶‘emacs’ as the type and ‘:warning’ as the level.¶¶(fn MESSAGE &amp;rest ARGS)",
"next-button":"Return the next button after position POS in the current buffer.¶If COUNT-CURRENT is non-nil, count any button at POS in the search,¶instead of starting at the next button.",
"previous-button":"Return the previous button before position POS in the current buffer.¶If COUNT-CURRENT is non-nil, count any button at POS in the search,¶instead of starting at the next button.",
"font-lock-add-keywords":"Add highlighting KEYWORDS for MODE.¶¶MODE should be a symbol, the major mode command name, such as ‘c-mode’¶or nil.  If nil, highlighting keywords are added for the current buffer.¶KEYWORDS should be a list; see the variable ‘font-lock-keywords’.¶By default they are added at the beginning of the current highlighting list.¶If optional argument HOW is ‘set’, they are used to replace the current¶highlighting list.  If HOW is any other non-nil value, they are added at the¶end of the current highlighting list.¶¶For example:¶¶ (font-lock-add-keywords 'c-mode¶  '((&quot;⧷⧷&lt;⧷⧷(FIXME⧷⧷):&quot; 1 'font-lock-warning-face prepend)¶    (&quot;⧷⧷&lt;⧷⧷(and⧷⧷|or⧷⧷|not⧷⧷)⧷⧷&gt;&quot; . 'font-lock-keyword-face)))¶¶adds two fontification patterns for C mode, to fontify ‘FIXME:’ words, even in¶comments, and to fontify ‘and’, ‘or’ and ‘not’ words as keywords.¶¶The above procedure will only add the keywords for C mode, not¶for modes derived from C mode.  To add them for derived modes too,¶pass nil for MODE and add the call to c-mode-hook.¶¶For example:¶¶ (add-hook 'c-mode-hook¶  (lambda ()¶   (font-lock-add-keywords nil¶    '((&quot;⧷⧷&lt;⧷⧷(FIXME⧷⧷):&quot; 1 'font-lock-warning-face prepend)¶      (&quot;⧷⧷&lt;⧷⧷(and⧷⧷|or⧷⧷|not⧷⧷)⧷⧷&gt;&quot; .¶       'font-lock-keyword-face)))))¶¶The above procedure may fail to add keywords to derived modes if¶some involved major mode does not follow the standard conventions.¶File a bug report if this happens, so the major mode can be corrected.¶¶Note that some modes have specialized support for additional patterns, e.g.,¶see the variables ‘c-font-lock-extra-types’, ‘c++-font-lock-extra-types’,¶‘objc-font-lock-extra-types’ and ‘java-font-lock-extra-types’.",
"font-lock-remove-keywords":"Remove highlighting KEYWORDS for MODE.¶¶MODE should be a symbol, the major mode command name, such as¶‘c-mode’ or nil.  If nil, highlighting keywords are removed for¶the current buffer.¶¶For a description of KEYWORDS, see ‘font-lock-add-keywords’.¶¶To make the removal apply to modes derived from MODE as well,¶pass nil for MODE and add the call to MODE-hook.  This may fail¶for some derived modes if some involved major mode does not¶follow the standard conventions.  File a bug report if this¶happens, so the major mode can be corrected.",
"current-justification":"How should we justify this line?¶This returns the value of the text-property ‘justification’,¶or the variable ‘default-justification’ if there is no text-property.¶However, it returns nil rather than ‘none’ to mean &quot;don’t justify&quot;.",
"display-completion-list":"Display the list of completions, COMPLETIONS, using ‘standard-output’.¶Each element may be just a symbol or string¶or may be a list of two strings to be printed as if concatenated.¶If it is a list of two strings, the first is the actual completion¶alternative, the second serves as annotation.¶‘standard-output’ must be a buffer.¶The actual completion alternatives, as inserted, are given ‘mouse-face’¶properties of ‘highlight’.¶At the end, this runs the normal hook ‘completion-setup-hook’.¶It can find the completion buffer in ‘standard-output’.¶¶(fn COMPLETIONS &amp;optional COMMON-SUBSTRING)",
"make-sparse-keymap":"Construct and return a new sparse keymap.¶Its car is ‘keymap’ and its cdr is an alist of (CHAR . DEFINITION),¶which binds the character CHAR to DEFINITION, or (SYMBOL . DEFINITION),¶which binds the function key or mouse event SYMBOL to DEFINITION.¶Initially the alist is nil.¶¶The optional arg STRING supplies a menu name for the keymap¶in case you use it as a menu with ‘x-popup-menu’.¶¶(fn &amp;optional STRING)",
"make-keymap":"Construct and return a new keymap, of the form (keymap CHARTABLE . ALIST).¶CHARTABLE is a char-table that holds the bindings for all characters¶without modifiers.  All entries in it are initially nil, meaning¶&quot;command undefined&quot;.  ALIST is an assoc-list which holds bindings for¶function keys, mouse events, and any other things that appear in the¶input stream.  Initially, ALIST is nil.¶¶The optional arg STRING supplies a menu name for the keymap¶in case you use it as a menu with ‘x-popup-menu’.¶¶(fn &amp;optional STRING)",
"copy-keymap":"Return a copy of the keymap KEYMAP.¶The copy starts out with the same definitions of KEYMAP,¶but changing either the copy or KEYMAP does not affect the other.¶Any key definitions that are subkeymaps are recursively copied.¶However, a key definition which is a symbol whose definition is a keymap¶is not copied.¶¶(fn KEYMAP)",
"window-right-divider-width":"Return the width in pixels of WINDOW’s right divider.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"window-bottom-divider-width":"Return the width in pixels of WINDOW’s bottom divider.¶WINDOW must be a live window and defaults to the selected one.¶¶(fn &amp;optional WINDOW)",
"autoload":"Define FUNCTION to autoload from FILE.¶FUNCTION is a symbol; FILE is a file name string to pass to ‘load’.¶Third arg DOCSTRING is documentation for the function.¶Fourth arg INTERACTIVE if non-nil says function can be called interactively.¶Fifth arg TYPE indicates the type of the object:¶   nil or omitted says FUNCTION is a function,¶   ‘keymap’ says FUNCTION is really a keymap, and¶   ‘macro’ or t says FUNCTION is really a macro.¶Third through fifth args give info about the real definition.¶They default to nil.¶If FUNCTION is already defined other than as an autoload,¶this does nothing and returns nil.¶¶(fn FUNCTION FILE &amp;optional DOCSTRING INTERACTIVE TYPE)",
"autoloadp":"Non-nil if OBJECT is an autoload.¶¶(fn OBJECT)",
"autoload-do-load":"Load FUNDEF which should be an autoload.¶If non-nil, FUNNAME should be the symbol whose function value is FUNDEF,¶in which case the function returns the new autoloaded function value.¶If equal to ‘macro’, MACRO-ONLY specifies that FUNDEF should only be loaded if¶it defines a macro.¶¶(fn FUNDEF &amp;optional FUNNAME MACRO-ONLY)",
"syntax-table-p":"Return t if OBJECT is a syntax table.¶Currently, any char-table counts as a syntax table.¶¶(fn OBJECT)",
"standard-syntax-table":"Return the standard syntax table.¶This is the one used for new buffers.¶¶(fn)",
"throw":"Throw to the catch for TAG and return VALUE from it.¶Both TAG and VALUE are evalled.¶¶(fn TAG VALUE)",
"facep":"Return non-nil if FACE is a face name; nil otherwise.¶A face name can be a string or a symbol.",
"x-get-resource":"Return the value of ATTRIBUTE, of class CLASS, from the X defaults database.¶This uses ‘INSTANCE.ATTRIBUTE’ as the key and ‘Emacs.CLASS’ as the¶class, where INSTANCE is the name under which Emacs was invoked, or¶the name specified by the ‘-name’ or ‘-rn’ command-line arguments.¶¶The optional arguments COMPONENT and SUBCLASS add to the key and the¶class, respectively.  You must specify both of them or neither.¶If you specify them, the key is ‘INSTANCE.COMPONENT.ATTRIBUTE’¶and the class is ‘Emacs.CLASS.SUBCLASS’.¶¶(fn ATTRIBUTE CLASS &amp;optional COMPONENT SUBCLASS)",
"set-marker-insertion-type":"Set the insertion-type of MARKER to TYPE.¶If TYPE is t, it means the marker advances when you insert text at it.¶If TYPE is nil, it means the marker stays behind when you insert text at it.¶¶(fn MARKER TYPE)",
"marker-insertion-type":"Return insertion type of MARKER: t if it stays after inserted text.¶The value nil means the marker stays before text inserted there.¶¶(fn MARKER)",
"format-mode-line":"Format a string out of a mode line format specification.¶First arg FORMAT specifies the mode line format (see ‘mode-line-format’¶for details) to use.¶¶By default, the format is evaluated for the currently selected window.¶¶Optional second arg FACE specifies the face property to put on all¶characters for which no face is specified.  The value nil means the¶default face.  The value t means whatever face the window’s mode line¶currently uses (either ‘mode-line’ or ‘mode-line-inactive’,¶depending on whether the window is the selected window or not).¶An integer value means the value string has no text¶properties.¶¶Optional third and fourth args WINDOW and BUFFER specify the window¶and buffer to use as the context for the formatting (defaults¶are the selected window and the WINDOW’s buffer).¶¶(fn FORMAT &amp;optional FACE WINDOW BUFFER)",
"quietly-read-abbrev-file":"Read abbrev definitions from file written with ‘write-abbrev-file’.¶Optional argument FILE is the name of the file to read;¶it defaults to the value of ‘abbrev-file-name’.¶Does not display any message.¶¶(fn &amp;optional FILE)",
"window-dedicated-p":"Return non-nil when WINDOW is dedicated to its buffer.¶More precisely, return the value assigned by the last call of¶‘set-window-dedicated-p’ for WINDOW.  Return nil if that function was¶never called with WINDOW as its argument, or the value set by that¶function was internally reset since its last call.  WINDOW must be a¶live window and defaults to the selected one.¶¶When a window is dedicated to its buffer, ‘display-buffer’ will refrain¶from displaying another buffer in it.  ‘get-lru-window’ and¶‘get-largest-window’ treat dedicated windows specially.¶‘delete-windows-on’, ‘replace-buffer-in-windows’, ‘quit-window’ and¶‘kill-buffer’ can delete a dedicated window and the containing frame.¶¶Functions like ‘set-window-buffer’ may change the buffer displayed by a¶window, unless that window is &quot;strongly&quot; dedicated to its buffer, that¶is the value returned by ‘window-dedicated-p’ is t.¶¶(fn &amp;optional WINDOW)",
"set-window-dedicated-p":"Mark WINDOW as dedicated according to FLAG.¶WINDOW must be a live window and defaults to the selected one.  FLAG¶non-nil means mark WINDOW as dedicated to its buffer.  FLAG nil means¶mark WINDOW as non-dedicated.  Return FLAG.¶¶When a window is dedicated to its buffer, ‘display-buffer’ will refrain¶from displaying another buffer in it.  ‘get-lru-window’ and¶‘get-largest-window’ treat dedicated windows specially.¶‘delete-windows-on’, ‘replace-buffer-in-windows’, ‘quit-window’,¶‘quit-restore-window’ and ‘kill-buffer’ can delete a dedicated window¶and the containing frame.¶¶As a special case, if FLAG is t, mark WINDOW as &quot;strongly&quot; dedicated to¶its buffer.  Functions like ‘set-window-buffer’ may change the buffer¶displayed by a window, unless that window is strongly dedicated to its¶buffer.  If and when ‘set-window-buffer’ displays another buffer in a¶window, it also makes sure that the window is no more dedicated.¶¶(fn WINDOW FLAG)",
"cancel-timer":"Remove TIMER from the list of active timers.",
"make-network-process":"Create and return a network server or client process.¶¶In Emacs, network connections are represented by process objects, so¶input and output work as for subprocesses and ‘delete-process’ closes¶a network connection.  However, a network process has no process id,¶it cannot be signaled, and the status codes are different from normal¶processes.¶¶Arguments are specified as keyword/argument pairs.  The following¶arguments are defined:¶¶:name NAME -- NAME is name for process.  It is modified if necessary¶to make it unique.¶¶:buffer BUFFER -- BUFFER is the buffer (or buffer-name) to associate¶with the process.  Process output goes at end of that buffer, unless¶you specify an output stream or filter function to handle the output.¶BUFFER may be also nil, meaning that this process is not associated¶with any buffer.¶¶:host HOST -- HOST is name of the host to connect to, or its IP¶address.  The symbol ‘local’ specifies the local host.  If specified¶for a server process, it must be a valid name or address for the local¶host, and only clients connecting to that address will be accepted.¶¶:service SERVICE -- SERVICE is name of the service desired, or an¶integer specifying a port number to connect to.  If SERVICE is t,¶a random port number is selected for the server.  (If Emacs was¶compiled with getaddrinfo, a port number can also be specified as a¶string, e.g. &quot;80&quot;, as well as an integer.  This is not portable.)¶¶:type TYPE -- TYPE is the type of connection.  The default (nil) is a¶stream type connection, ‘datagram’ creates a datagram type connection,¶‘seqpacket’ creates a reliable datagram connection.¶¶:family FAMILY -- FAMILY is the address (and protocol) family for the¶service specified by HOST and SERVICE.  The default (nil) is to use¶whatever address family (IPv4 or IPv6) that is defined for the host¶and port number specified by HOST and SERVICE.  Other address families¶supported are:¶  local -- for a local (i.e. UNIX) address specified by SERVICE.¶  ipv4  -- use IPv4 address family only.¶  ipv6  -- use IPv6 address family only.¶¶:local ADDRESS -- ADDRESS is the local address used for the connection.¶This parameter is ignored when opening a client process. When specified¶for a server process, the FAMILY, HOST and SERVICE args are ignored.¶¶:remote ADDRESS -- ADDRESS is the remote partner’s address for the¶connection.  This parameter is ignored when opening a stream server¶process.  For a datagram server process, it specifies the initial¶setting of the remote datagram address.  When specified for a client¶process, the FAMILY, HOST, and SERVICE args are ignored.¶¶The format of ADDRESS depends on the address family:¶- An IPv4 address is represented as an vector of integers [A B C D P]¶corresponding to numeric IP address A.B.C.D and port number P.¶- A local address is represented as a string with the address in the¶local address space.¶- An &quot;unsupported family&quot; address is represented by a cons (F . AV)¶where F is the family number and AV is a vector containing the socket¶address data with one element per address data byte.  Do not rely on¶this format in portable code, as it may depend on implementation¶defined constants, data sizes, and data structure alignment.¶¶:coding CODING -- If CODING is a symbol, it specifies the coding¶system used for both reading and writing for this process.  If CODING¶is a cons (DECODING . ENCODING), DECODING is used for reading, and¶ENCODING is used for writing.¶¶:nowait BOOL -- If BOOL is non-nil for a stream type client process,¶return without waiting for the connection to complete; instead, the¶sentinel function will be called with second arg matching &quot;open&quot; (if¶successful) or &quot;failed&quot; when the connect completes.  Default is to use¶a blocking connect (i.e. wait) for stream type connections.¶¶:noquery BOOL -- Query the user unless BOOL is non-nil, and process is¶running when Emacs is exited.¶¶:stop BOOL -- Start process in the ‘stopped’ state if BOOL non-nil.¶In the stopped state, a server process does not accept new¶connections, and a client process does not handle incoming traffic.¶The stopped state is cleared by ‘continue-process’ and set by¶‘stop-process’.¶¶:filter FILTER -- Install FILTER as the process filter.¶¶:filter-multibyte BOOL -- If BOOL is non-nil, strings given to the¶process filter are multibyte, otherwise they are unibyte.¶If this keyword is not specified, the strings are multibyte if¶the default value of ‘enable-multibyte-characters’ is non-nil.¶¶:sentinel SENTINEL -- Install SENTINEL as the process sentinel.¶¶:log LOG -- Install LOG as the server process log function.  This¶function is called when the server accepts a network connection from a¶client.  The arguments are SERVER, CLIENT, and MESSAGE, where SERVER¶is the server process, CLIENT is the new process for the connection,¶and MESSAGE is a string.¶¶:plist PLIST -- Install PLIST as the new process’s initial plist.¶¶:server QLEN -- if QLEN is non-nil, create a server process for the¶specified FAMILY, SERVICE, and connection type (stream or datagram).¶If QLEN is an integer, it is used as the max. length of the server’s¶pending connection queue (also known as the backlog); the default¶queue length is 5.  Default is to create a client process.¶¶The following network options can be specified for this connection:¶¶:broadcast BOOL    -- Allow send and receive of datagram broadcasts.¶:dontroute BOOL    -- Only send to directly connected hosts.¶:keepalive BOOL    -- Send keep-alive messages on network stream.¶:linger BOOL or TIMEOUT -- Send queued messages before closing.¶:oobinline BOOL    -- Place out-of-band data in receive data stream.¶:priority INT      -- Set protocol defined priority for sent packets.¶:reuseaddr BOOL    -- Allow reusing a recently used local address¶                      (this is allowed by default for a server process).¶:bindtodevice NAME -- bind to interface NAME.  Using this may require¶                      special privileges on some systems.¶¶Consult the relevant system programmer’s manual pages for more¶information on using these options.¶¶¶A server process will listen for and accept connections from clients.¶When a client connection is accepted, a new network process is created¶for the connection with the following parameters:¶¶- The client’s process name is constructed by concatenating the server¶process’s NAME and a client identification string.¶- If the FILTER argument is non-nil, the client process will not get a¶separate process buffer; otherwise, the client’s process buffer is a newly¶created buffer named after the server process’s BUFFER name or process¶NAME concatenated with the client identification string.¶- The connection type and the process filter and sentinel parameters are¶inherited from the server process’s TYPE, FILTER and SENTINEL.¶- The client process’s contact info is set according to the client’s¶addressing information (typically an IP address and a port number).¶- The client process’s plist is initialized from the server’s plist.¶¶Notice that the FILTER and SENTINEL args are never used directly by¶the server process.  Also, the BUFFER argument is not used directly by¶the server process, but via the optional :log function, accepted (and¶failed) connections may be logged in the server process’s buffer.¶¶The original argument list, modified with the actual connection¶information, is available via the ‘process-contact’ function.¶¶(fn &amp;rest ARGS)",
"time-less-p":"Return non-nil if time value T1 is earlier than time value T2.¶¶(fn T1 T2)",
"time-subtract":"Return the difference between two time values A and B, as a time value.¶¶(fn A B)",
"time-add":"Return the sum of two time values A and B, as a time value.¶¶(fn A B)",
"time-to-days":"The number of days between the Gregorian date 0001-12-31bce and TIME.¶TIME should be a time value.¶The Gregorian date Sunday, December 31, 1bce is imaginary.",
"time-to-day-in-year":"Return the day number within the year corresponding to TIME.",
"date-leap-year-p":"Return t if YEAR is a leap year.",
"buffer-swap-text":"Swap the text between current buffer and BUFFER.¶Using this function from ‘save-excursion’ might produce surprising¶results, see Info node ‘(elisp)Swapping Text’.¶¶(fn BUFFER)",
"mark":"Return this buffer’s mark value as integer, or nil if never set.¶¶In Transient Mark mode, this function signals an error if¶the mark is not active.  However, if ‘mark-even-if-inactive’ is non-nil,¶or the argument FORCE is non-nil, it disregards whether the mark¶is active, and returns an integer or nil in the usual way.¶¶If you are using this in an editing command, you are most likely making¶a mistake; see the documentation of ‘set-mark’.¶¶(fn &amp;optional FORCE)",
"mark-marker":"Return this buffer’s mark, as a marker object.¶Watch out!  Moving this marker changes the mark position.¶If you set the marker not to point anywhere, the buffer will have no mark.¶¶(fn)",
"set-mark":"Set this buffer’s mark to POS.  Don’t use this function!¶That is to say, don’t use this function unless you want¶the user to see that the mark has moved, and you want the previous¶mark position to be lost.¶¶Normally, when a new mark is set, the old one should go on the stack.¶This is why most applications should use ‘push-mark’, not ‘set-mark’.¶¶Novice Emacs Lisp programmers often try to use the mark for the wrong¶purposes.  The mark saves a location for the user’s convenience.¶Most editing commands should not alter the mark.¶To remember a location for internal use in the Lisp program,¶store it in a Lisp variable.  Example:¶¶   (let ((beg (point))) (forward-line 1) (delete-region beg (point))).¶¶(fn POS)",
"push-mark":"Set mark at LOCATION (point, by default) and push old mark on mark ring.¶If the last global mark pushed was not in the current buffer,¶also push LOCATION on the global mark ring.¶Display ‘Mark set’ unless the optional second arg NOMSG is non-nil.¶¶Novice Emacs Lisp programmers often try to use the mark for the wrong¶purposes.  See the documentation of ‘set-mark’ for more information.¶¶In Transient Mark mode, activate mark if optional third arg ACTIVATE non-nil.¶¶(fn &amp;optional LOCATION NOMSG ACTIVATE)",
"pop-mark":"Pop off mark ring into the buffer’s actual mark.¶Does not set point.  Does nothing if mark ring is empty.",
"deactivate-mark":"Deactivate the mark.¶If Transient Mark mode is disabled, this function normally does¶nothing; but if FORCE is non-nil, it deactivates the mark anyway.¶¶Deactivating the mark sets ‘mark-active’ to nil, updates the¶primary selection according to ‘select-active-regions’, and runs¶‘deactivate-mark-hook’.¶¶If Transient Mark mode was temporarily enabled, reset the value¶of the variable ‘transient-mark-mode’; if this causes Transient¶Mark mode to be disabled, don’t change ‘mark-active’ to nil or¶run ‘deactivate-mark-hook’.¶¶(fn &amp;optional FORCE)",
"handle-shift-selection":"Activate/deactivate mark depending on invocation thru shift translation.¶This function is called by ‘call-interactively’ when a command¶with a ‘^’ character in its ‘interactive’ spec is invoked, before¶running the command itself.¶¶If ‘shift-select-mode’ is enabled and the command was invoked¶through shift translation, set the mark and activate the region¶temporarily, unless it was already set in this way.  See¶‘this-command-keys-shift-translated’ for the meaning of shift¶translation.¶¶Otherwise, if the region has been activated temporarily,¶deactivate it, and restore the variable ‘transient-mark-mode’ to¶its earlier value.",
"cons":"Create a new cons, give it CAR and CDR as components, and return it.¶¶(fn CAR CDR)",
"list":"Return a newly created list with specified arguments as elements.¶Any number of arguments, even zero arguments, are allowed.¶¶(fn &amp;rest OBJECTS)",
"make-list":"Return a newly created list of length LENGTH, with each element being INIT.¶¶(fn LENGTH INIT)",
"append":"Concatenate all the arguments and make the result a list.¶The result is a list whose elements are the elements of all the arguments.¶Each argument may be a list, vector or string.¶The last argument is not copied, just used as the tail of the new list.¶¶(fn &amp;rest SEQUENCES)",
"copy-tree":"Make a copy of TREE.¶If TREE is a cons cell, this recursively copies both its car and its cdr.¶Contrast to ‘copy-sequence’, which copies only along the cdrs.  With second¶argument VECP, this copies vectors as well as conses.¶¶(fn TREE &amp;optional VECP)",
"number-sequence":"Return a sequence of numbers from FROM to TO (both inclusive) as a list.¶INC is the increment used between numbers in the sequence and defaults to 1.¶So, the Nth element of the list is (+ FROM (* N INC)) where N counts from¶zero.  TO is only included if there is an N for which TO = FROM + N * INC.¶If TO is nil or numerically equal to FROM, return (FROM).¶If INC is positive and TO is less than FROM, or INC is negative¶and TO is larger than FROM, return nil.¶If INC is zero and TO is neither nil nor numerically equal to¶FROM, signal an error.¶¶This function is primarily designed for integer arguments.¶Nevertheless, FROM, TO and INC can be integer or float.  However,¶floating point arithmetic is inexact.  For instance, depending on¶the machine, it may quite well happen that¶(number-sequence 0.4 0.6 0.2) returns the one element list (0.4),¶whereas (number-sequence 0.4 0.8 0.2) returns a list with three¶elements.  Thus, if some of the arguments are floats and one wants¶to make sure that TO is included, one may have to explicitly write¶TO as (+ FROM (* N INC)) or use a variable whose value was¶computed with this exact expression.  Alternatively, you can,¶of course, also replace TO with a slightly larger value¶(or a slightly more negative value if INC is negative).¶¶(fn FROM &amp;optional TO INC)",
"line-beginning-position":"Return the character position of the first character on the current line.¶With optional argument N, scan forward N - 1 lines first.¶If the scan reaches the end of the buffer, return that position.¶¶This function ignores text display directionality; it returns the¶position of the first character in logical order, i.e. the smallest¶character position on the line.¶¶This function constrains the returned position to the current field¶unless that position would be on a different line than the original,¶unconstrained result.  If N is nil or 1, and a front-sticky field¶starts at point, the scan stops as soon as it starts.  To ignore field¶boundaries, bind ‘inhibit-field-text-motion’ to t.¶¶This function does not move point.¶¶(fn &amp;optional N)",
"line-end-position":"Return the character position of the last character on the current line.¶With argument N not nil or 1, move forward N - 1 lines first.¶If scan reaches end of buffer, return that position.¶¶This function ignores text display directionality; it returns the¶position of the last character in logical order, i.e. the largest¶character position on the line.¶¶This function constrains the returned position to the current field¶unless that would be on a different line than the original,¶unconstrained result.  If N is nil or 1, and a rear-sticky field ends¶at point, the scan stops as soon as it starts.  To ignore field¶boundaries bind ‘inhibit-field-text-motion’ to t.¶¶This function does not move point.¶¶(fn &amp;optional N)",
"count-lines":"Return number of lines between START and END.¶This is usually the number of newlines between them,¶but can be one more if START is not equal to END¶and the greater of them is not at the start of a line.¶¶(fn START END)",
"line-number-at-pos":"Return (narrowed) buffer line number at position POS.¶If POS is nil, use current buffer location.¶Counting starts at (point-min), so the value refers¶to the contents of the accessible portion of the buffer.¶¶(fn &amp;optional POS)",
"completion-in-region":"Complete the text between START and END using COLLECTION.¶Point needs to be somewhere between START and END.¶PREDICATE (a function called with no arguments) says when to exit.¶This calls the function that ‘completion-in-region-function’ specifies¶(passing the same four arguments that it received) to do the work,¶and returns whatever it does.  The return value should be nil¶if there was no valid completion, else t.¶¶(fn START END COLLECTION &amp;optional PREDICATE)",
"make-marker":"Return a newly allocated marker which does not point at any place.¶¶(fn)",
"point-marker":"Return value of point, as a marker object.¶¶(fn)",
"point-min-marker":"Return a marker to the minimum permissible value of point in this buffer.¶This is the beginning, unless narrowing (a buffer restriction) is in effect.¶¶(fn)",
"point-max-marker":"Return a marker to the maximum permissible value of point in this buffer.¶This is (1+ (buffer-size)), unless narrowing (a buffer restriction)¶is in effect, in which case it is less.¶¶(fn)",
"copy-marker":"Return a new marker pointing at the same place as MARKER.¶If argument is a number, makes a new marker pointing¶at that position in the current buffer.¶If MARKER is not specified, the new marker does not point anywhere.¶The optional argument TYPE specifies the insertion type of the new marker;¶see ‘marker-insertion-type’.¶¶(fn &amp;optional MARKER TYPE)",
"defcustom":"Declare SYMBOL as a customizable variable.¶SYMBOL is the variable name; it should not be quoted.¶STANDARD is an expression specifying the variable’s standard¶value.  It should not be quoted.  It is evaluated once by¶‘defcustom’, and the value is assigned to SYMBOL if the variable¶is unbound.  The expression itself is also stored, so that¶Customize can re-evaluate it later to get the standard value.¶DOC is the variable documentation.¶¶This macro uses ‘defvar’ as a subroutine, which also marks the¶variable as &quot;special&quot;, so that it is always dynamically bound¶even when ‘lexical-binding’ is t.¶¶The remaining arguments to ‘defcustom’ should have the form¶¶   [KEYWORD VALUE]...¶¶The following keywords are meaningful:¶¶:type\tVALUE should be a widget type for editing the symbol’s value.¶\tEvery ‘defcustom’ should specify a value for this keyword.¶:options VALUE should be a list of valid members of the widget type.¶:initialize¶\tVALUE should be a function used to initialize the¶\tvariable.  It takes two arguments, the symbol and value¶\tgiven in the ‘defcustom’ call.  The default is¶\t‘custom-initialize-reset’.¶:set\tVALUE should be a function to set the value of the symbol¶\twhen using the Customize user interface.  It takes two arguments,¶\tthe symbol to set and the value to give it.  The function should¶\tnot modify its value argument destructively.  The default choice¶\tof function is ‘set-default’.¶:get\tVALUE should be a function to extract the value of symbol.¶\tThe function takes one argument, a symbol, and should return¶\tthe current value for that symbol.  The default choice of function¶\tis ‘default-value’.¶:require¶\tVALUE should be a feature symbol.  If you save a value¶\tfor this option, then when your init file loads the value,¶\tit does (require VALUE) first.¶:set-after VARIABLES¶\tSpecifies that SYMBOL should be set after the list of variables¶        VARIABLES when both have been customized.¶:risky\tSet SYMBOL’s ‘risky-local-variable’ property to VALUE.¶:safe\tSet SYMBOL’s ‘safe-local-variable’ property to VALUE.¶        See Info node ‘(elisp) File Local Variables’.¶¶The following common keywords are also meaningful.¶¶:group  VALUE should be a customization group.¶        Add SYMBOL (or FACE with ‘defface’) to that group.¶:link LINK-DATA¶        Include an external link after the documentation string for this¶        item.  This is a sentence containing an active field which¶        references some other documentation.¶¶        There are several alternatives you can use for LINK-DATA:¶¶        (custom-manual INFO-NODE)¶             Link to an Info node; INFO-NODE is a string which specifies¶             the node name, as in &quot;(emacs)Top&quot;.¶¶        (info-link INFO-NODE)¶             Like ‘custom-manual’ except that the link appears in the¶             customization buffer with the Info node name.¶¶        (url-link URL)¶             Link to a web page; URL is a string which specifies the URL.¶¶        (emacs-commentary-link LIBRARY)¶             Link to the commentary section of LIBRARY.¶¶        (emacs-library-link LIBRARY)¶             Link to an Emacs Lisp LIBRARY file.¶¶        (file-link FILE)¶             Link to FILE.¶¶        (function-link FUNCTION)¶             Link to the documentation of FUNCTION.¶¶        (variable-link VARIABLE)¶             Link to the documentation of VARIABLE.¶¶        (custom-group-link GROUP)¶             Link to another customization GROUP.¶¶        You can specify the text to use in the customization buffer by¶        adding ‘:tag NAME’ after the first element of the LINK-DATA; for¶        example, (info-link :tag &quot;foo&quot; &quot;(emacs)Top&quot;) makes a link to the¶        Emacs manual which appears in the buffer as ‘foo’.¶¶        An item can have more than one external link; however, most items¶        have none at all.¶:version¶        VALUE should be a string specifying that the variable was¶        first introduced, or its default value was changed, in Emacs¶        version VERSION.¶:package-version¶        VALUE should be a list with the form (PACKAGE . VERSION)¶        specifying that the variable was first introduced, or its¶        default value was changed, in PACKAGE version VERSION.  This¶        keyword takes priority over :version.  The PACKAGE and VERSION¶        must appear in the alist ‘customize-package-emacs-version-alist’.¶        Since PACKAGE must be unique and the user might see it in an¶        error message, a good choice is the official name of the¶        package, such as MH-E or Gnus.¶:tag LABEL¶        Use LABEL, a string, instead of the item’s name, to label the item¶        in customization menus and buffers.¶:load FILE¶        Load file FILE (a string) before displaying this customization¶        item.  Loading is done with ‘load’, and only if the file is¶        not already loaded.¶¶If SYMBOL has a local binding, then this form affects the local¶binding.  This is normally not what you want.  Thus, if you need¶to load a file defining variables with this form, or with¶‘defvar’ or ‘defconst’, you should always load that file¶_outside_ any bindings for these variables.  (‘defvar’ and¶‘defconst’ behave similarly in this respect.)¶¶See Info node ‘(elisp) Customization’ in the Emacs Lisp manual¶for more information.",
"deftheme":"Declare THEME to be a Custom theme.¶The optional argument DOC is a doc string describing the theme.¶¶Any theme ‘foo’ should be defined in a file called ‘foo-theme.el’;¶see ‘custom-make-theme-feature’ for more information.",
"provide-theme":"Indicate that this file provides THEME.¶This calls ‘provide’ to provide the feature name stored in THEME’s¶property ‘theme-feature’ (which is usually a symbol created by¶‘custom-make-theme-feature’).",
"push":"Add NEWELT to the list stored in the generalized variable PLACE.¶This is morally equivalent to (setf PLACE (cons NEWELT PLACE)),¶except that PLACE is only evaluated once (after NEWELT).¶¶(fn NEWELT PLACE)",
"save-match-data":"Execute the BODY forms, restoring the global value of the match data.¶The value returned is the value of the last form in BODY.¶¶(fn &amp;rest BODY)",
"pop":"Return the first element of PLACE’s value, and remove it from the list.¶PLACE must be a generalized variable whose value is a list.¶If the value is nil, ‘pop’ returns nil but does not actually¶change the list.¶¶(fn PLACE)",
"defsubst":"Define an inline function.  The syntax is just like that of ‘defun’.¶(fn NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)¶¶(fn NAME ARGLIST &amp;rest BODY)",
"define-alternatives":"Define the new command ‘COMMAND’.¶¶The argument ‘COMMAND’ should be a symbol.¶¶Running ‘M-x COMMAND RET’ for the first time prompts for which¶alternative to use and records the selected command as a custom¶variable.¶¶Running ‘C-u M-x COMMAND RET’ prompts again for an alternative¶and overwrites the previous choice.¶¶The variable ‘COMMAND-alternatives’ contains an alist with¶alternative implementations of COMMAND.  ‘define-alternatives’¶does not have any effect until this variable is set.¶¶CUSTOMIZATIONS, if non-nil, should be composed of alternating¶‘defcustom’ keywords and values to add to the declaration of¶‘COMMAND-alternatives’ (typically :group and :version).¶¶(fn COMMAND &amp;rest CUSTOMIZATIONS)",
"with-output-to-temp-buffer":"Bind ‘standard-output’ to buffer BUFNAME, eval BODY, then show that buffer.¶¶This construct makes buffer BUFNAME empty before running BODY.¶It does not make the buffer current for BODY.¶Instead it binds ‘standard-output’ to that buffer, so that output¶generated with ‘prin1’ and similar functions in BODY goes into¶the buffer.¶¶At the end of BODY, this marks buffer BUFNAME unmodified and displays¶it in a window, but does not select it.  The normal way to do this is¶by calling ‘display-buffer’, then running ‘temp-buffer-show-hook’.¶However, if ‘temp-buffer-show-function’ is non-nil, it calls that¶function instead (and does not run ‘temp-buffer-show-hook’).  The¶function gets one argument, the buffer to display.¶¶The return value of ‘with-output-to-temp-buffer’ is the value of the¶last form in BODY.  If BODY does not finish normally, the buffer¶BUFNAME is not displayed.¶¶This runs the hook ‘temp-buffer-setup-hook’ before BODY,¶with the buffer BUFNAME temporarily current.  It runs the hook¶‘temp-buffer-show-hook’ after displaying buffer BUFNAME, with that¶buffer temporarily current, and the window that was used to display it¶temporarily selected.  But it doesn’t run ‘temp-buffer-show-hook’¶if it uses ‘temp-buffer-show-function’.¶¶By default, the setup hook puts the buffer into Help mode before running BODY.¶If BODY does not change the major mode, the show hook makes the buffer¶read-only, and scans it for function and variable names to make them into¶clickable cross-references.¶¶See the related form ‘with-temp-buffer-window’.¶¶(fn BUFNAME &amp;rest BODY)",
"with-temp-buffer-window":"Bind ‘standard-output’ to BUFFER-OR-NAME, eval BODY, show the buffer.¶BUFFER-OR-NAME must specify either a live buffer, or the name of¶a buffer (if it does not exist, this macro creates it).¶¶Make the buffer specified by BUFFER-OR-NAME empty before running¶BODY and bind ‘standard-output’ to that buffer, so that output¶generated with ‘prin1’ and similar functions in BODY goes into¶that buffer.  Do not make that buffer current for running the¶forms in BODY.  Use ‘with-current-buffer-window’ instead if you¶need to run BODY with that buffer current.¶¶At the end of BODY, mark the specified buffer unmodified and¶read-only, and display it in a window (but do not select it).¶The display happens by calling ‘display-buffer’ passing it the¶ACTION argument.  If ‘temp-buffer-resize-mode’ is enabled, the¶corresponding window may be resized automatically.¶¶Return the value returned by BODY, unless QUIT-FUNCTION specifies¶a function.  In that case, run that function with two arguments -¶the window showing the specified buffer and the value returned by¶BODY - and return the value returned by that function.¶¶If the buffer is displayed on a new frame, the window manager may¶decide to select that frame.  In that case, it’s usually a good¶strategy if QUIT-FUNCTION selects the window showing the buffer¶before reading any value from the minibuffer; for example, when¶asking a ‘yes-or-no-p’ question.¶¶This runs the hook ‘temp-buffer-window-setup-hook’ before BODY,¶with the specified buffer temporarily current.  It runs the hook¶‘temp-buffer-window-show-hook’ after displaying the buffer, with¶that buffer temporarily current, and the window that was used to¶display it temporarily selected.¶¶This construct is similar to ‘with-output-to-temp-buffer’ but,¶neither runs ‘temp-buffer-setup-hook’ which usually puts the¶buffer in Help mode, nor ‘temp-buffer-show-function’ (the ACTION¶argument replaces this).",
"with-current-buffer-window":"Evaluate BODY with a buffer BUFFER-OR-NAME current and show that buffer.¶This construct is like ‘with-temp-buffer-window’ but unlike that¶makes the buffer specified by BUFFER-OR-NAME current for running¶BODY.",
"with-displayed-buffer-window":"Show a buffer BUFFER-OR-NAME and evaluate BODY in that buffer.¶This construct is like ‘with-current-buffer-window’ but unlike that¶displays the buffer specified by BUFFER-OR-NAME before running BODY.",
"pcase":"Evaluate EXP and attempt to match it against structural patterns.¶CASES is a list of elements of the form (PATTERN CODE...).¶¶A structural PATTERN describes a template that identifies a class¶of values.  For example, the pattern `(,foo ,bar) matches any¶two element list, binding its elements to symbols named ‘foo’ and¶‘bar’ -- in much the same way that ‘cl-destructuring-bind’ would.¶¶A significant difference from ‘cl-destructuring-bind’ is that, if¶a pattern match fails, the next case is tried until either a¶successful match is found or there are no more cases.¶¶Another difference is that pattern elements may be quoted,¶meaning they must match exactly: The pattern '(foo bar)¶matches only against two element lists containing the symbols¶‘foo’ and ‘bar’ in that order.  (As a short-hand, atoms always¶match themselves, such as numbers or strings, and need not be¶quoted.)¶¶Lastly, a pattern can be logical, such as (pred numberp), that¶matches any number-like element; or the symbol ‘_’, that matches¶anything.  Also, when patterns are backquoted, a comma may be¶used to introduce logical patterns inside backquoted patterns.¶¶The complete list of standard patterns is as follows:¶¶  _\t\tmatches anything.¶  SYMBOL\tmatches anything and binds it to SYMBOL.¶                If a SYMBOL is used twice in the same pattern¶                the second occurrence becomes an ‘eq’uality test.¶  (or PAT...)\tmatches if any of the patterns matches.¶  (and PAT...)\tmatches if all the patterns match.¶  'VAL\t\tmatches if the object is ‘equal’ to VAL.¶  ATOM\t\tis a shorthand for 'ATOM.¶\t\t   ATOM can be a keyword, an integer, or a string.¶  (pred FUN)\tmatches if FUN applied to the object returns non-nil.¶  (guard BOOLEXP)\tmatches if BOOLEXP evaluates to non-nil.¶  (let PAT EXP)\tmatches if EXP matches PAT.¶  (app FUN PAT)\tmatches if FUN applied to the object matches PAT.¶¶Additional patterns can be defined using ‘pcase-defmacro’.¶¶The FUN argument in the ‘app’ pattern may have the following forms:¶  SYMBOL or (lambda ARGS BODY)  in which case it’s called with one argument.¶  (F ARG1 .. ARGn) in which case F gets called with an n+1’th argument¶                        which is the value being matched.¶So a FUN of the form SYMBOL is equivalent to (FUN).¶FUN can refer to variables bound earlier in the pattern.¶¶See Info node ‘(elisp) Pattern matching case statement’ in the¶Emacs Lisp manual for more information and examples.¶¶-- (seq &amp;rest PATTERNS)¶¶Build a ‘pcase’ pattern that matches elements of SEQUENCE.¶¶The ‘pcase’ pattern will match each element of PATTERNS against the¶corresponding element of SEQUENCE.¶¶Extra elements of the sequence are ignored if fewer PATTERNS are¶given, and the match does not fail.¶¶-- (map &amp;rest ARGS)¶¶Build a ‘pcase’ pattern matching map elements.¶¶ARGS is a list of elements to be matched in the map.¶¶Each element of ARGS can be of the form (KEY PAT), in which case KEY is¶evaluated and searched for in the map.  The match fails if for any KEY¶found in the map, the corresponding PAT doesn’t match the value¶associated to the KEY.¶¶Each element can also be a SYMBOL, which is an abbreviation of a (KEY¶PAT) tuple of the form ('SYMBOL SYMBOL).¶¶Keys in ARGS not found in the map are ignored, and the match doesn’t¶fail.¶¶-- (eieio &amp;rest FIELDS)¶¶Pcase patterns to match EIEIO objects.¶Elements of FIELDS can be of the form (NAME PAT) in which case the contents of¶field NAME is matched against PAT, or they can be of the form NAME which¶is a shorthand for (NAME NAME).¶¶-- (cl-struct TYPE &amp;rest FIELDS)¶¶Pcase patterns to match cl-structs.¶Elements of FIELDS can be of the form (NAME PAT) in which case the contents of¶field NAME is matched against PAT, or they can be of the form NAME which¶is a shorthand for (NAME NAME).¶¶-- `QPAT¶¶Backquote-style pcase patterns.¶QPAT can take the following forms:¶  (QPAT1 . QPAT2)       matches if QPAT1 matches the car and QPAT2 the cdr.¶  [QPAT1 QPAT2..QPATn]  matches a vector of length n and QPAT1..QPATn match¶                           its 0..(n-1)th elements, respectively.¶  ,PAT                  matches if the pcase pattern PAT matches.¶  ATOM                  matches if the object is ‘equal’ to ATOM.¶\t\t\t   ATOM can be a symbol, an integer, or a string.¶¶(fn EXP &amp;rest CASES)",
"pcase-defmacro":"Define a new kind of pcase PATTERN, by macro expansion.¶Patterns of the form (NAME ...) will be expanded according¶to this macro.¶¶(fn NAME ARGS &amp;rest BODY)",
"with-temp-message":"Display MESSAGE temporarily if non-nil while BODY is evaluated.¶The original message is restored to the echo area after BODY has finished.¶The value returned is the value of the last form in BODY.¶MESSAGE is written to the message log buffer if ‘message-log-max’ is non-nil.¶If MESSAGE is nil, the echo area and message log buffer are unchanged.¶Use a MESSAGE of &quot;&quot; to temporarily clear the echo area.¶¶(fn MESSAGE &amp;rest BODY)",
"declare-function":"Tell the byte-compiler that function FN is defined, in FILE.¶Optional ARGLIST is the argument list used by the function.¶The FILE argument is not used by the byte-compiler, but by the¶‘check-declare’ package, which checks that FILE contains a¶definition for FN.  ARGLIST is used by both the byte-compiler¶and ‘check-declare’ to check for consistency.¶¶FILE can be either a Lisp file (in which case the &quot;.el&quot;¶extension is optional), or a C file.  C files are expanded¶relative to the Emacs &quot;src/&quot; directory.  Lisp files are¶searched for using ‘locate-library’, and if that fails they are¶expanded relative to the location of the file containing the¶declaration.  A FILE with an &quot;ext:&quot; prefix is an external file.¶‘check-declare’ will check such files if they are found, and skip¶them without error if they are not.¶¶FILEONLY non-nil means that ‘check-declare’ will only check that¶FILE exists, not that it defines FN.  This is intended for¶function-definitions that ‘check-declare’ does not recognize, e.g.¶‘defstruct’.¶¶To specify a value for FILEONLY without passing an argument list,¶set ARGLIST to t.  This is necessary because nil means an¶empty argument list, rather than an unspecified one.¶¶Note that for the purposes of ‘check-declare’, this statement¶must be the first non-whitespace on a line.¶¶For more information, see Info node ‘(elisp)Declaring Functions’.¶¶(fn FN FILE &amp;optional ARGLIST FILEONLY)",
"defimage":"Define SYMBOL as an image, and return SYMBOL.¶¶SPECS is a list of image specifications.  DOC is an optional¶documentation string.¶¶Each image specification in SPECS is a property list.  The contents of¶a specification are image type dependent.  All specifications must at¶least contain the properties ‘:type TYPE’ and either ‘:file FILE’ or¶‘:data DATA’, where TYPE is a symbol specifying the image type,¶e.g. ‘xbm’, FILE is the file to load the image from, and DATA is a¶string containing the actual image data.  The first image¶specification whose TYPE is supported, and FILE exists, is used to¶define SYMBOL.¶¶Example:¶¶   (defimage test-image ((:type xpm :file &quot;~/test1.xpm&quot;)¶                         (:type xbm :file &quot;~/test1.xbm&quot;)))",
"setf":"Set each PLACE to the value of its VAL.¶This is a generalized version of ‘setq’; the PLACEs may be symbolic¶references such as (car x) or (aref x i), as well as plain symbols.¶For example, (setf (cadr x) y) is equivalent to (setcar (cdr x) y).¶The return value is the last VAL in the list.¶¶(fn PLACE VAL PLACE VAL ...)",
"with-output-to-string":"Execute BODY, return the text it sent to ‘standard-output’, as a string.¶¶(fn &amp;rest BODY)",
"with-syntax-table":"Evaluate BODY with syntax table of current buffer set to TABLE.¶The syntax table of the current buffer is saved, BODY is evaluated, and the¶saved table is restored, even in case of an abnormal exit.¶Value is what BODY returns.¶¶(fn TABLE &amp;rest BODY)",
"seq-doseq":"Loop over a sequence.¶Evaluate BODY with VAR bound to each element of SEQUENCE, in turn.¶¶Similar to ‘dolist’ but can be applied to lists, strings, and vectors.¶¶(fn (VAR SEQUENCE) BODY...)",
"seq-let":"Bind the variables in ARGS to the elements of SEQUENCE, then evaluate BODY.¶¶ARGS can also include the ‘&amp;rest’ marker followed by a variable¶name to be bound to the rest of SEQUENCE.¶¶(fn ARGS SEQUENCE &amp;rest BODY)",
"with-eval-after-load":"Execute BODY after FILE is loaded.¶FILE is normally a feature name, but it can also be a file name,¶in case that file does not provide any feature.  See ‘eval-after-load’¶for more details about the different forms of FILE and their semantics.¶¶(fn FILE &amp;rest BODY)",
"defface":"Declare FACE as a customizable face that defaults to SPEC.¶FACE does not need to be quoted.¶¶Third argument DOC is the face documentation.¶¶If FACE has been set with ‘custom-theme-set-faces’, set the face¶attributes as specified by that function, otherwise set the face¶attributes according to SPEC.¶¶The remaining arguments should have the form [KEYWORD VALUE]...¶For a list of valid keywords, see the common keywords listed in¶‘defcustom’.¶¶SPEC should be a &quot;face spec&quot;, i.e., an alist of the form¶¶   ((DISPLAY . ATTS)...)¶¶where DISPLAY is a form specifying conditions to match certain¶terminals and ATTS is a property list (ATTR VALUE ATTR VALUE...)¶specifying face attributes and values for frames on those¶terminals.  On each terminal, the first element with a matching¶DISPLAY specification takes effect, and the remaining elements in¶SPEC are disregarded.¶¶As a special exception, in the first element of SPEC, DISPLAY can¶be the special value ‘default’.  Then the ATTS in that element¶act as defaults for all the following elements.¶¶For backward compatibility, elements of SPEC can be written¶as (DISPLAY ATTS) instead of (DISPLAY . ATTS).¶¶Each DISPLAY can have the following values:¶ - ‘default’ (only in the first element).¶ - The symbol t, which matches all terminals.¶ - An alist of conditions.  Each alist element must have the form¶   (REQ ITEM...).  A matching terminal must satisfy each¶   specified condition by matching one of its ITEMs.  Each REQ¶   must be one of the following:¶   - ‘type’ (the terminal type).¶     Each ITEM must be one of the values returned by¶     ‘window-system’.  Under X, additional allowed values are¶     ‘motif’, ‘lucid’, ‘gtk’ and ‘x-toolkit’.¶   - ‘class’ (the terminal’s color support).¶     Each ITEM should be one of ‘color’, ‘grayscale’, or ‘mono’.¶   - ‘background’ (what color is used for the background text)¶     Each ITEM should be one of ‘light’ or ‘dark’.¶   - ‘min-colors’ (the minimum number of supported colors)¶     Each ITEM should be an integer, which is compared with the¶     result of ‘display-color-cells’.¶   - ‘supports’ (match terminals supporting certain attributes).¶     Each ITEM should be a list of face attributes.  See¶     ‘display-supports-face-attributes-p’ for more information on¶     exactly how testing is done.¶¶In the ATTS property list, possible attributes are ‘:family’,¶‘:width’, ‘:height’, ‘:weight’, ‘:slant’, ‘:underline’,¶‘:overline’, ‘:strike-through’, ‘:box’, ‘:foreground’,¶‘:background’, ‘:stipple’, ‘:inverse-video’, and ‘:inherit’.¶¶See Info node ‘(elisp) Faces’ in the Emacs Lisp manual for more¶information.",
"dotimes-with-progress-reporter":"Loop a certain number of times and report progress in the echo area.¶Evaluate BODY with VAR bound to successive integers running from¶0, inclusive, to COUNT, exclusive.  Then evaluate RESULT to get¶the return value (nil if RESULT is omitted).¶¶At each iteration MESSAGE followed by progress percentage is¶printed in the echo area.  After the loop is finished, MESSAGE¶followed by word &quot;done&quot; is printed.  This macro is a¶convenience wrapper around ‘make-progress-reporter’ and friends.¶¶(fn (VAR COUNT [RESULT]) MESSAGE BODY...)",
"with-current-buffer":"Execute the forms in BODY with BUFFER-OR-NAME temporarily current.¶BUFFER-OR-NAME must be a buffer or the name of an existing buffer.¶The value returned is the value of the last form in BODY.  See¶also ‘with-temp-buffer’.¶¶(fn BUFFER-OR-NAME &amp;rest BODY)",
"with-temp-buffer":"Create a temporary buffer, and evaluate BODY there like ‘progn’.¶See also ‘with-temp-file’ and ‘with-output-to-string’.¶¶(fn &amp;rest BODY)",
"delay-mode-hooks":"Execute BODY, but delay any ‘run-mode-hooks’.¶These hooks will be executed by the first following call to¶‘run-mode-hooks’ that occurs outside any ‘delay-mode-hooks’ form.¶Only affects hooks run in the current buffer.¶¶(fn &amp;rest BODY)",
"cl-defgeneric":"Create a generic function NAME.¶DOC-STRING is the base documentation for this class.  A generic¶function has no body, as its purpose is to decide which method body¶is appropriate to use.  Specific methods are defined with ‘cl-defmethod’.¶With this implementation the ARGS are currently ignored.¶OPTIONS-AND-METHODS currently understands:¶- (:documentation DOCSTRING)¶- (declare DECLARATIONS)¶- (:argument-precedence-order &amp;rest ARGS)¶- (:method [QUALIFIERS...] ARGS &amp;rest BODY)¶DEFAULT-BODY, if present, is used as the body of a default method.¶¶(fn NAME ARGS [DOC-STRING] [OPTIONS-AND-METHODS...] &amp;rest DEFAULT-BODY)",
"cl-defmethod":"Define a new method for generic function NAME.¶I.e. it defines the implementation of NAME to use for invocations where the¶values of the dispatch arguments match the specified TYPEs.¶The dispatch arguments have to be among the mandatory arguments, and¶all methods of NAME have to use the same set of arguments for dispatch.¶Each dispatch argument and TYPE are specified in ARGS where the corresponding¶formal argument appears as (VAR TYPE) rather than just VAR.¶¶The optional second argument QUALIFIER is a specifier that¶modifies how the method is combined with other methods, including:¶   :before  - Method will be called before the primary¶   :after   - Method will be called after the primary¶   :around  - Method will be called around everything else¶The absence of QUALIFIER means this is a &quot;primary&quot; method.¶¶TYPE can be one of the basic types (see the full list and their¶hierarchy in ‘cl--generic-typeof-types’), CL struct type, or an¶EIEIO class.¶¶Other than that, TYPE can also be of the form ‘(eql VAL)’ in¶which case this method will be invoked when the argument is ‘eql’¶to VAL, or ‘(head VAL)’, in which case the argument is required¶to be a cons with VAL as its head.¶¶(fn NAME [QUALIFIER] ARGS &amp;rest [DOCSTRING] BODY)",
"gv-define-simple-setter":"Define a simple setter method for generalized variable NAME.¶This macro is an easy-to-use substitute for ‘gv-define-expander’ that works¶well for simple place forms.  Assignments of VAL to (NAME ARGS...) are¶turned into calls of the form (SETTER ARGS... VAL).¶¶If FIX-RETURN is non-nil, then SETTER is not assumed to return VAL and¶instead the assignment is turned into something equivalent to¶  (let ((temp VAL))¶    (SETTER ARGS... temp)¶    temp)¶so as to preserve the semantics of ‘setf’.¶¶(fn NAME SETTER &amp;optional FIX-RETURN)",
"gv-define-setter":"Define a setter method for generalized variable NAME.¶This macro is an easy-to-use substitute for ‘gv-define-expander’ that works¶well for simple place forms.¶Assignments of VAL to (NAME ARGS...) are expanded by binding the argument¶forms (VAL ARGS...) according to ARGLIST, then executing BODY, which must¶return a Lisp form that does the assignment.¶The first arg in ARGLIST (the one that receives VAL) receives an expression¶which can do arbitrary things, whereas the other arguments are all guaranteed¶to be pure and copyable.  Example use:¶  (gv-define-setter aref (v a i) `(aset ,a ,i ,v))¶¶(fn NAME ARGLIST &amp;rest BODY)",
"defmacro":"Define NAME as a macro.¶When the macro is called, as in (NAME ARGS...),¶the function (lambda ARGLIST BODY...) is applied to¶the list ARGS... as it appears in the expression,¶and the result should be a form to be evaluated instead of the original.¶DECL is a declaration, optional, of the form (declare DECLS...) where¶DECLS is a list of elements of the form (PROP . VALUES).  These are¶interpreted according to ‘macro-declarations-alist’.¶The return value is undefined.¶¶(fn NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)",
"with-file-modes":"Execute BODY with default file permissions temporarily set to MODES.¶MODES is as for ‘set-default-file-modes’.¶¶(fn MODES &amp;rest BODY)",
"condition-case-unless-debug":"Like ‘condition-case’ except that it does not prevent debugging.¶More specifically if ‘debug-on-error’ is set then the debugger will be invoked¶even if this catches the signal.¶¶(fn VAR BODYFORM &amp;rest HANDLERS)",
"ignore-errors":"Execute BODY; if an error occurs, return nil.¶Otherwise, return result of last form in BODY.¶See also ‘with-demoted-errors’ that does something similar¶without silencing all errors.¶¶(fn &amp;rest BODY)",
"with-demoted-errors":"Run BODY and demote any errors to simple messages.¶FORMAT is a string passed to ‘message’ to format any error message.¶It should contain a single %-sequence; e.g., &quot;Error: %S&quot;.¶¶If ‘debug-on-error’ is non-nil, run BODY without catching its errors.¶This is to be used around code which is not expected to signal an error¶but which should be robust in the unexpected case that an error is signaled.¶¶For backward compatibility, if FORMAT is not a constant string, it¶is assumed to be part of BODY, in which case the message format¶used is &quot;Error: %S&quot;.¶¶(fn FORMAT &amp;rest BODY)",
"easy-menu-define":"Define a pop-up menu and/or menu bar menu specified by MENU.¶If SYMBOL is non-nil, define SYMBOL as a function to pop up the¶submenu defined by MENU, with DOC as its doc string.¶¶MAPS, if non-nil, should be a keymap or a list of keymaps; add¶the submenu defined by MENU to the keymap or each of the keymaps,¶as a top-level menu bar item.¶¶The first element of MENU must be a string.  It is the menu bar¶item name.  It may be followed by the following keyword argument¶pairs:¶¶ :filter FUNCTION¶    FUNCTION must be a function which, if called with one¶    argument---the list of the other menu items---returns the¶    items to actually display.¶¶ :visible INCLUDE¶    INCLUDE is an expression.  The menu is visible if the¶    expression evaluates to a non-nil value.  ‘:included’ is an¶    alias for ‘:visible’.¶¶ :active ENABLE¶    ENABLE is an expression.  The menu is enabled for selection¶    if the expression evaluates to a non-nil value.  ‘:enable’ is¶    an alias for ‘:active’.¶¶The rest of the elements in MENU are menu items.¶A menu item can be a vector of three elements:¶¶  [NAME CALLBACK ENABLE]¶¶NAME is a string--the menu item name.¶¶CALLBACK is a command to run when the item is chosen, or an¶expression to evaluate when the item is chosen.¶¶ENABLE is an expression; the item is enabled for selection if the¶expression evaluates to a non-nil value.¶¶Alternatively, a menu item may have the form:¶¶   [ NAME CALLBACK [ KEYWORD ARG ]... ]¶¶where NAME and CALLBACK have the same meanings as above, and each¶optional KEYWORD and ARG pair should be one of the following:¶¶ :keys KEYS¶    KEYS is a string; a keyboard equivalent to the menu item.¶    This is normally not needed because keyboard equivalents are¶    usually computed automatically.  KEYS is expanded with¶    ‘substitute-command-keys’ before it is used.¶¶ :key-sequence KEYS¶    KEYS is a hint for speeding up Emacs’s first display of the¶    menu.  It should be nil if you know that the menu item has no¶    keyboard equivalent; otherwise it should be a string or¶    vector specifying a keyboard equivalent for the menu item.¶¶ :active ENABLE¶    ENABLE is an expression; the item is enabled for selection¶    whenever this expression’s value is non-nil.  ‘:enable’ is an¶    alias for ‘:active’.¶¶ :visible INCLUDE¶    INCLUDE is an expression; this item is only visible if this¶    expression has a non-nil value.  ‘:included’ is an alias for¶    ‘:visible’.¶¶ :label FORM¶    FORM is an expression that is dynamically evaluated and whose¶    value serves as the menu item’s label (the default is NAME).¶¶ :suffix FORM¶    FORM is an expression that is dynamically evaluated and whose¶    value is concatenated with the menu entry’s label.¶¶ :style STYLE¶    STYLE is a symbol describing the type of menu item; it should¶    be ‘toggle’ (a checkbox), or ‘radio’ (a radio button), or any¶    other value (meaning an ordinary menu item).¶¶ :selected SELECTED¶    SELECTED is an expression; the checkbox or radio button is¶    selected whenever the expression’s value is non-nil.¶¶ :help HELP¶    HELP is a string, the help to display for the menu item.¶¶Alternatively, a menu item can be a string.  Then that string¶appears in the menu as unselectable text.  A string consisting¶solely of dashes is displayed as a menu separator.¶¶Alternatively, a menu item can be a list with the same format as¶MENU.  This is a submenu.¶¶(fn SYMBOL MAPS DOC MENU)",
"save-window-excursion":"Execute BODY, then restore previous window configuration.¶This macro saves the window configuration on the selected frame,¶executes BODY, then calls ‘set-window-configuration’ to restore¶the saved window configuration.  The return value is the last¶form in BODY.  The window configuration is also restored if BODY¶exits nonlocally.¶¶BEWARE: Most uses of this macro introduce bugs.¶E.g. it should not be used to try and prevent some code from opening¶a new window, since that window may sometimes appear in another frame,¶in which case ‘save-window-excursion’ cannot help.¶¶(fn &amp;rest BODY)",
"setq-local":"Set variable VAR to value VAL in current buffer.¶¶(fn VAR VAL)",
"defvar-local":"Define VAR as a buffer-local variable with default value VAL.¶Like ‘defvar’ but additionally marks the variable as being automatically¶buffer-local wherever it is set.¶¶(fn VAR VAL &amp;optional DOCSTRING)",
"define-generic-mode":"Create a new generic mode MODE.¶¶MODE is the name of the command for the generic mode; don’t quote it.¶The optional DOCSTRING is the documentation for the mode command.  If¶you do not supply it, ‘define-generic-mode’ uses a default¶documentation string instead.¶¶COMMENT-LIST is a list in which each element is either a character, a¶string of one or two characters, or a cons cell.  A character or a¶string is set up in the mode’s syntax table as a &quot;comment starter&quot;.¶If the entry is a cons cell, the ‘car’ is set up as a &quot;comment¶starter&quot; and the ‘cdr’ as a &quot;comment ender&quot;.  (Use nil for the¶latter if you want comments to end at the end of the line.)  Note that¶the syntax table has limitations about what comment starters and¶enders are actually possible.¶¶KEYWORD-LIST is a list of keywords to highlight with¶‘font-lock-keyword-face’.  Each keyword should be a string.¶¶FONT-LOCK-LIST is a list of additional expressions to highlight.  Each¶element of this list should have the same form as an element of¶‘font-lock-keywords’.¶¶AUTO-MODE-LIST is a list of regular expressions to add to¶‘auto-mode-alist’.  These regular expressions are added when Emacs¶runs the macro expansion.¶¶FUNCTION-LIST is a list of functions to call to do some additional¶setup.  The mode command calls these functions just before it runs the¶mode hook ‘MODE-hook’.¶¶See the file generic-x.el for some examples of ‘define-generic-mode’.¶¶(fn MODE COMMENT-LIST KEYWORD-LIST FONT-LOCK-LIST AUTO-MODE-LIST FUNCTION-LIST &amp;optional DOCSTRING)",
"with-local-quit":"Execute BODY, allowing quits to terminate BODY but not escape further.¶When a quit terminates BODY, ‘with-local-quit’ returns nil but¶requests another quit.  That quit will be processed as soon as quitting¶is allowed once again.  (Immediately, if ‘inhibit-quit’ is nil.)¶¶(fn &amp;rest BODY)",
"dolist":":around advice: ‘cl--wrap-in-nil-block’¶¶Loop over a list.¶Evaluate BODY with VAR bound to each car from LIST, in turn.¶Then evaluate RESULT to get return value, default nil.¶¶(fn (VAR LIST [RESULT]) BODY...)",
"dotimes":":around advice: ‘cl--wrap-in-nil-block’¶¶Loop a certain number of times.¶Evaluate BODY with VAR bound to successive integers running from 0,¶inclusive, to COUNT, exclusive.  Then evaluate RESULT to get¶the return value (nil if RESULT is omitted).¶¶(fn (VAR COUNT [RESULT]) BODY...)",
"save-mark-and-excursion":"Like ‘save-excursion’, but also save and restore the mark state.¶This macro does what ‘save-excursion’ did before Emacs 25.1.¶¶(fn &amp;rest BODY)",
"with-coding-priority":"Execute BODY like ‘progn’ with CODING-SYSTEMS at the front of priority list.¶CODING-SYSTEMS is a list of coding systems.  See ‘set-coding-system-priority’.¶This affects the implicit sorting of lists of coding systems returned by¶operations such as ‘find-coding-systems-region’.¶¶(fn CODING-SYSTEMS &amp;rest BODY)",
"defun":"Define NAME as a function.¶The definition is (lambda ARGLIST [DOCSTRING] BODY...).¶See also the function ‘interactive’.¶DECL is a declaration, optional, of the form (declare DECLS...) where¶DECLS is a list of elements of the form (PROP . VALUES).  These are¶interpreted according to ‘defun-declarations-alist’.¶The return value is undefined.¶¶(fn NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)",
"define-inline":"¶¶(fn NAME ARGS &amp;rest BODY)",
"define-minor-mode":"Define a new minor mode MODE.¶This defines the toggle command MODE and (by default) a control variable¶MODE (you can override this with the :variable keyword, see below).¶DOC is the documentation for the mode toggle command.¶¶The defined mode command takes one optional (prefix) argument.¶Interactively with no prefix argument, it toggles the mode.¶A prefix argument enables the mode if the argument is positive,¶and disables it otherwise.¶¶When called from Lisp, the mode command toggles the mode if the¶argument is ‘toggle’, disables the mode if the argument is a¶non-positive integer, and enables the mode otherwise (including¶if the argument is omitted or nil or a positive integer).¶¶If DOC is nil, give the mode command a basic doc-string¶documenting what its argument does.¶¶Optional INIT-VALUE is the initial value of the mode’s variable.¶Optional LIGHTER is displayed in the mode line when the mode is on.¶Optional KEYMAP is the default keymap bound to the mode keymap.¶  If non-nil, it should be a variable name (whose value is a keymap),¶  or an expression that returns either a keymap or a list of¶  arguments for ‘easy-mmode-define-keymap’.  If you supply a KEYMAP¶  argument that is not a symbol, this macro defines the variable¶  MODE-map and gives it the value that KEYMAP specifies.¶¶BODY contains code to execute each time the mode is enabled or disabled.¶  It is executed after toggling the mode, and before running MODE-hook.¶  Before the actual body code, you can write keyword arguments, i.e.¶  alternating keywords and values.  If you provide BODY, then you must¶  provide (even if just nil) INIT-VALUE, LIGHTER, and KEYMAP, or provide¶  at least one keyword argument, or both; otherwise, BODY would be¶  misinterpreted as the first omitted argument.  The following special¶  keywords are supported (other keywords are passed to ‘defcustom’ if¶  the minor mode is global):¶¶:group GROUP\tCustom group name to use in all generated ‘defcustom’ forms.¶\t\tDefaults to MODE without the possible trailing &quot;-mode&quot;.¶\t\tDon’t use this default group name unless you have written a¶\t\t‘defgroup’ to define that group properly.¶:global GLOBAL\tIf non-nil specifies that the minor mode is not meant to be¶\t\tbuffer-local, so don’t make the variable MODE buffer-local.¶\t\tBy default, the mode is buffer-local.¶:init-value VAL\tSame as the INIT-VALUE argument.¶\t\tNot used if you also specify :variable.¶:lighter SPEC\tSame as the LIGHTER argument.¶:keymap MAP\tSame as the KEYMAP argument.¶:require SYM\tSame as in ‘defcustom’.¶:variable PLACE\tThe location to use instead of the variable MODE to store¶\t\tthe state of the mode.\tThis can be simply a different¶\t\tnamed variable, or a generalized variable.¶\t\tPLACE can also be of the form (GET . SET), where GET is¶\t\tan expression that returns the current state, and SET is¶\t\ta function that takes one argument, the new state, and¶\t\tsets it.  If you specify a :variable, this function does¶\t\tnot define a MODE variable (nor any of the terms used¶\t\tin :variable).¶¶:after-hook     A single lisp form which is evaluated after the mode hooks¶                have been run.  It should not be quoted.¶¶For example, you could write¶  (define-minor-mode foo-mode &quot;If enabled, foo on you!&quot;¶    :lighter &quot; Foo&quot; :require 'foo :global t :group 'hassle :version &quot;27.5&quot;¶    ...BODY CODE...)",
"define-globalized-minor-mode":"Make a global mode GLOBAL-MODE corresponding to buffer-local minor MODE.¶TURN-ON is a function that will be called with no args in every buffer¶  and that should try to turn MODE on if applicable for that buffer.¶KEYS is a list of CL-style keyword arguments.  As the minor mode¶  defined by this function is always global, any :global keyword is¶  ignored.  Other keywords have the same meaning as in ‘define-minor-mode’,¶  which see.  In particular, :group specifies the custom group.¶  The most useful keywords are those that are passed on to the¶  ‘defcustom’.  It normally makes no sense to pass the :lighter¶  or :keymap keywords to ‘define-globalized-minor-mode’, since these¶  are usually passed to the buffer-local version of the minor mode.¶¶If MODE’s set-up depends on the major mode in effect when it was¶enabled, then disabling and reenabling MODE should make MODE work¶correctly with the current major mode.  This is important to¶prevent problems with derived modes, that is, major modes that¶call another major mode in their body.¶¶When a major mode is initialized, MODE is actually turned on just¶after running the major mode’s hook.  However, MODE is not turned¶on if the hook has explicitly disabled it.",
"lazy-completion-table":"Initialize variable VAR as a lazy completion table.¶If the completion table VAR is used for the first time (e.g., by passing VAR¶as an argument to ‘try-completion’), the function FUN is called with no¶arguments.  FUN must return the completion table that will be stored in VAR.¶If completion is requested in the minibuffer, FUN will be called in the buffer¶from which the minibuffer was entered.  The return value of¶‘lazy-completion-table’ must be used to initialize the value of VAR.¶¶You should give VAR a non-nil ‘risky-local-variable’ property.¶¶(fn VAR FUN)",
"define-obsolete-variable-alias":"Make OBSOLETE-NAME a variable alias for CURRENT-NAME and mark it obsolete.¶This uses ‘defvaralias’ and ‘make-obsolete-variable’ (which see).¶See the Info node ‘(elisp)Variable Aliases’ for more details.¶¶If CURRENT-NAME is a defcustom or a defvar (more generally, any variable¶where OBSOLETE-NAME may be set, e.g. in an init file, before the¶alias is defined), then the define-obsolete-variable-alias¶statement should be evaluated before the defcustom, if user¶customizations are to be respected.  The simplest way to achieve¶this is to place the alias statement before the defcustom (this¶is not necessary for aliases that are autoloaded, or in files¶dumped with Emacs).  This is so that any user customizations are¶applied before the defcustom tries to initialize the¶variable (this is due to the way ‘defvaralias’ works).¶¶If provided, WHEN should be a string indicating when the variable¶was first made obsolete, for example a date or a release number.¶¶For the benefit of ‘custom-set-variables’, if OBSOLETE-NAME has¶any of the following properties, they are copied to¶CURRENT-NAME, if it does not already have them:¶‘saved-value’, ‘saved-variable-comment’.¶¶(fn OBSOLETE-NAME CURRENT-NAME &amp;optional WHEN DOCSTRING)",
"save-selected-window":"Execute BODY, then select the previously selected window.¶The value returned is the value of the last form in BODY.¶¶This macro saves and restores the selected window, as well as the¶selected window in each frame.  If the previously selected window¶is no longer live, then whatever window is selected at the end of¶BODY remains selected.  If the previously selected window of some¶frame is no longer live at the end of BODY, that frame’s selected¶window is left alone.¶¶This macro saves and restores the current buffer, since otherwise¶its normal operation could make a different buffer current.  The¶order of recently selected windows and the buffer list ordering¶are not altered by this macro (unless they are altered in BODY).",
"with-selected-window":"Execute the forms in BODY with WINDOW as the selected window.¶The value returned is the value of the last form in BODY.¶¶This macro saves and restores the selected window, as well as the¶selected window of each frame.  It does not change the order of¶recently selected windows.  If the previously selected window of¶some frame is no longer live at the end of BODY, that frame’s¶selected window is left alone.  If the selected window is no¶longer live, then whatever window is selected at the end of BODY¶remains selected.¶¶This macro uses ‘save-current-buffer’ to save and restore the¶current buffer, since otherwise its normal operation could¶potentially make a different buffer current.  It does not alter¶the buffer list ordering.¶¶(fn WINDOW &amp;rest BODY)",
"declare":":after advice: ‘cl--pass-args-to-cl-declare’¶¶Do not evaluate any arguments, and return nil.¶If a ‘declare’ form appears as the first form in the body of a¶‘defun’ or ‘defmacro’ form, SPECS specifies various additional¶information about the function or macro; these go into effect¶during the evaluation of the ‘defun’ or ‘defmacro’ form.¶¶The possible values of SPECS are specified by¶‘defun-declarations-alist’ and ‘macro-declarations-alist’.¶¶For more information, see info node ‘(elisp)Declare Form’.¶¶(fn &amp;rest SPECS)",
"with-help-window":"Display buffer named BUFFER-NAME in a help window.¶Evaluate the forms in BODY with standard output bound to a buffer¶called BUFFER-NAME (creating it if it does not exist), put that¶buffer in ‘help-mode’, display the buffer in a window (see¶‘with-temp-buffer-window’ for details) and issue a message how to¶deal with that &quot;help&quot; window when it’s no more needed.  Select¶the help window if the current value of the user option¶‘help-window-select’ says so.  Return last value in BODY.",
"define-derived-mode":"Create a new mode as a variant of an existing mode.¶¶The arguments to this command are as follow:¶¶CHILD:     the name of the command for the derived mode.¶PARENT:    the name of the command for the parent mode (e.g. ‘text-mode’)¶           or nil if there is no parent.¶NAME:      a string which will appear in the status line (e.g. &quot;Hypertext&quot;)¶DOCSTRING: an optional documentation string--if you do not supply one,¶           the function will attempt to invent something useful.¶BODY:      forms to execute just before running the¶           hooks for the new mode.  Do not use ‘interactive’ here.¶¶BODY can start with a bunch of keyword arguments.  The following keyword¶  arguments are currently understood:¶:group GROUP¶\tDeclare the customization group that corresponds to this mode.¶\tThe command ‘customize-mode’ uses this.¶:syntax-table TABLE¶\tUse TABLE instead of the default (CHILD-syntax-table).¶\tA nil value means to simply use the same syntax-table as the parent.¶:abbrev-table TABLE¶\tUse TABLE instead of the default (CHILD-abbrev-table).¶\tA nil value means to simply use the same abbrev-table as the parent.¶¶Here is how you could define LaTeX-Thesis mode as a variant of LaTeX mode:¶¶  (define-derived-mode LaTeX-thesis-mode LaTeX-mode &quot;LaTeX-Thesis&quot;)¶¶You could then make new key bindings for ‘LaTeX-thesis-mode-map’¶without changing regular LaTeX mode.  In this example, BODY is empty,¶and DOCSTRING is generated by default.¶¶On a more complicated level, the following command uses ‘sgml-mode’ as¶the parent, and then sets the variable ‘case-fold-search’ to nil:¶¶  (define-derived-mode article-mode sgml-mode &quot;Article&quot;¶    &quot;Major mode for editing technical articles.&quot;¶    (setq case-fold-search nil))¶¶Note that if the documentation string had been left out, it would have¶been generated automatically, with a reference to the keymap.¶¶The new mode runs the hook constructed by the function¶‘derived-mode-hook-name’.¶¶See Info node ‘(elisp)Derived Modes’ for more details.",
"when":"If COND yields non-nil, do BODY, else return nil.¶When COND yields non-nil, eval BODY forms sequentially and return¶value of last one, or nil if there are none.¶¶(fn COND BODY...)",
"unless":"If COND yields nil, do BODY, else return nil.¶When COND yields nil, eval BODY forms sequentially and return¶value of last one, or nil if there are none.¶¶(fn COND BODY...)",
"combine-after-change-calls":"Execute BODY, but don’t call the after-change functions till the end.¶If BODY makes changes in the buffer, they are recorded¶and the functions on ‘after-change-functions’ are called several times¶when BODY is finished.¶The return value is the value of the last form in BODY.¶¶If ‘before-change-functions’ is non-nil, then calls to the after-change¶functions can’t be deferred, so in that case this macro has no effect.¶¶Do not alter ‘after-change-functions’ or ‘before-change-functions’¶in BODY.¶¶(fn &amp;rest BODY)",
"with-case-table":"Execute the forms in BODY with TABLE as the current case table.¶The value returned is the value of the last form in BODY.¶¶(fn TABLE &amp;rest BODY)",
"define-obsolete-face-alias":"Make OBSOLETE-FACE a face alias for CURRENT-FACE and mark it obsolete.¶If provided, WHEN should be a string indicating when the face¶was first made obsolete, for example a date or a release number.¶¶(fn OBSOLETE-FACE CURRENT-FACE WHEN)",
"noreturn":"Evaluate FORM, expecting it not to return.¶If FORM does return, signal an error.¶¶(fn FORM)",
"def-edebug-spec":"Set the ‘edebug-form-spec’ property of SYMBOL according to SPEC.¶Both SYMBOL and SPEC are unevaluated.  The SPEC can be:¶0 (instrument no arguments); t (instrument all arguments);¶a symbol (naming a function with an Edebug specification); or a list.¶The elements of the list describe the argument types; see¶Info node ‘(elisp)Specification List’ for details.¶¶(fn SYMBOL SPEC)",
"while-no-input":"Execute BODY only as long as there’s no pending input.¶If input arrives, that ends the execution of BODY,¶and ‘while-no-input’ returns t.  Quitting makes it return nil.¶If BODY finishes, ‘while-no-input’ returns whatever value BODY produced.¶¶(fn &amp;rest BODY)",
"define-advice":"Define an advice and add it to function named SYMBOL.¶See ‘advice-add’ and ‘add-function’ for explanation on the¶arguments.  Note if NAME is nil the advice is anonymous;¶otherwise it is named ‘SYMBOL@NAME’.¶¶(fn SYMBOL (WHERE LAMBDA-LIST &amp;optional NAME DEPTH) &amp;rest BODY)",
"add-function":"Add a piece of advice on the function stored at PLACE.¶FUNCTION describes the code to add.  WHERE describes where to add it.¶WHERE can be explained by showing the resulting new function, as the¶result of combining FUNCTION and the previous value of PLACE, which we¶call OLDFUN here:¶‘:before’\t(lambda (&amp;rest r) (apply FUNCTION r) (apply OLDFUN r))¶‘:after’\t(lambda (&amp;rest r) (prog1 (apply OLDFUN r) (apply FUNCTION r)))¶‘:around’\t(lambda (&amp;rest r) (apply FUNCTION OLDFUN r))¶‘:override’\t(lambda (&amp;rest r) (apply FUNCTION r))¶‘:before-while’\t(lambda (&amp;rest r) (and (apply FUNCTION r) (apply OLDFUN r)))¶‘:before-until’\t(lambda (&amp;rest r) (or  (apply FUNCTION r) (apply OLDFUN r)))¶‘:after-while’\t(lambda (&amp;rest r) (and (apply OLDFUN r) (apply FUNCTION r)))¶‘:after-until’\t(lambda (&amp;rest r) (or  (apply OLDFUN r) (apply FUNCTION r)))¶‘:filter-args’\t(lambda (&amp;rest r) (apply OLDFUN (funcall FUNCTION r)))¶‘:filter-return’(lambda (&amp;rest r) (funcall FUNCTION (apply OLDFUN r)))¶If FUNCTION was already added, do nothing.¶PROPS is an alist of additional properties, among which the following have¶a special meaning:¶- ‘name’: a string or symbol.  It can be used to refer to this piece of advice.¶- ‘depth’: a number indicating a preference w.r.t ordering.¶  The default depth is 0.  By convention, a depth of 100 means that¶  the advice  should be innermost (i.e. at the end of the list),¶  whereas a depth of -100 means that the advice should be outermost.¶¶If PLACE is a symbol, its ‘default-value’ will be affected.¶Use (local 'SYMBOL) if you want to apply FUNCTION to SYMBOL buffer-locally.¶Use (var VAR) if you want to apply FUNCTION to the (lexical) VAR.¶¶If one of FUNCTION or OLDFUN is interactive, then the resulting function¶is also interactive.  There are 3 cases:¶- FUNCTION is not interactive: the interactive spec of OLDFUN is used.¶- The interactive spec of FUNCTION is itself a function: it should take one¶  argument (the interactive spec of OLDFUN, which it can pass to¶  ‘advice-eval-interactive-spec’) and return the list of arguments to use.¶- Else, use the interactive spec of FUNCTION and ignore the one of OLDFUN.¶¶(fn WHERE PLACE FUNCTION &amp;optional PROPS)",
"remove-function":"Remove the FUNCTION piece of advice from PLACE.¶If FUNCTION was not added to PLACE, do nothing.¶Instead of FUNCTION being the actual function, it can also be the ‘name’¶of the piece of advice.¶¶(fn PLACE FUNCTION)",
"lambda":"Return a lambda expression.¶A call of the form (lambda ARGS DOCSTRING INTERACTIVE BODY) is¶self-quoting; the result of evaluating the lambda expression is the¶expression itself.  The lambda expression may then be treated as a¶function, i.e., stored as the function value of a symbol, passed to¶‘funcall’ or ‘mapcar’, etc.¶¶ARGS should take the same form as an argument list for a ‘defun’.¶DOCSTRING is an optional documentation string.¶ If present, it should describe how to call the function.¶ But documentation strings are usually not useful in nameless functions.¶INTERACTIVE should be a call to the function ‘interactive’, which see.¶It may also be omitted.¶BODY should be a list of Lisp expressions.¶¶(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)",
"define-obsolete-function-alias":"Set OBSOLETE-NAME’s function definition to CURRENT-NAME and mark it obsolete.¶¶(define-obsolete-function-alias 'old-fun 'new-fun &quot;22.1&quot; &quot;old-fun’s doc.&quot;)¶¶is equivalent to the following two lines of code:¶¶(defalias 'old-fun 'new-fun &quot;old-fun’s doc.&quot;)¶(make-obsolete 'old-fun 'new-fun &quot;22.1&quot;)¶¶If provided, WHEN should be a string indicating when the function¶was first made obsolete, for example a date or a release number.¶¶See the docstrings of ‘defalias’ and ‘make-obsolete’ for more details.¶¶(fn OBSOLETE-NAME CURRENT-NAME &amp;optional WHEN DOCSTRING)",
"with-temp-file":"Create a new buffer, evaluate BODY there, and write the buffer to FILE.¶The value returned is the value of the last form in BODY.¶See also ‘with-temp-buffer’.¶¶(fn FILE &amp;rest BODY)",
"defgroup":"Declare SYMBOL as a customization group containing MEMBERS.¶SYMBOL does not need to be quoted.¶¶Third argument DOC is the group documentation.  This should be a short¶description of the group, beginning with a capital and ending with¶a period.  Words other than the first should not be capitalized, if they¶are not usually written so.¶¶MEMBERS should be an alist of the form ((NAME WIDGET)...) where¶NAME is a symbol and WIDGET is a widget for editing that symbol.¶Useful widgets are ‘custom-variable’ for editing variables,¶‘custom-face’ for editing faces, and ‘custom-group’ for editing groups.¶¶The remaining arguments should have the form¶¶   [KEYWORD VALUE]...¶¶For a list of valid keywords, see the common keywords listed in¶‘defcustom’.¶¶See Info node ‘(elisp) Customization’ in the Emacs Lisp manual¶for more information.",
"with-timeout":"Run BODY, but if it doesn’t finish in SECONDS seconds, give up.¶If we give up, we run the TIMEOUT-FORMS and return the value of the last one.¶The timeout is checked whenever Emacs waits for some kind of external¶event (such as keyboard input, input from subprocesses, or a certain time);¶if the program loops without waiting in any way, the timeout will not¶be detected.¶¶(fn (SECONDS TIMEOUT-FORMS...) BODY)",
"catch":"Eval BODY allowing nonlocal exits using ‘throw’.¶TAG is evalled to get the tag to use; it must not be nil.¶¶Then the BODY is executed.¶Within BODY, a call to ‘throw’ with the same TAG exits BODY and this ‘catch’.¶If no throw happens, ‘catch’ returns the value of the last BODY form.¶If a throw happens, it specifies the value to return from ‘catch’.¶¶(fn TAG BODY...)",
"function":"Like ‘quote’, but preferred for objects which are functions.¶In byte compilation, ‘function’ causes its argument to be compiled.¶‘quote’ cannot do that.¶¶(fn ARG)",
"setq":"Set each SYM to the value of its VAL.¶The symbols SYM are variables; they are literal (not evaluated).¶The values VAL are expressions; they are evaluated.¶Thus, (setq x (1+ y)) sets ‘x’ to the value of ‘(1+ y)’.¶The second VAL is not computed until after the first SYM is set, and so on;¶each VAL can use the new value of variables set earlier in the ‘setq’.¶The return value of the ‘setq’ form is the value of the last VAL.¶¶(fn [SYM VAL]...)",
"eval-and-compile":"Like ‘progn’, but evaluates the body at compile time and at¶load time.  In interpreted code, this is entirely equivalent to¶‘progn’, except that the value of the expression may be (but is¶not necessarily) computed at load time if eager macro expansion¶is enabled.¶¶(fn &amp;rest BODY)",
"eval-when-compile":"Like ‘progn’, but evaluates the body at compile time if you’re compiling.¶Thus, the result of the body appears to the compiler as a quoted¶constant.  In interpreted code, this is entirely equivalent to¶‘progn’, except that the value of the expression may be (but is¶not necessarily) computed at load time if eager macro expansion¶is enabled.¶¶(fn &amp;rest BODY)",
"defvar":"Define SYMBOL as a variable, and return SYMBOL.¶You are not required to define a variable in order to use it, but¶defining it lets you supply an initial value and documentation, which¶can be referred to by the Emacs help facilities and other programming¶tools.  The ‘defvar’ form also declares the variable as &quot;special&quot;,¶so that it is always dynamically bound even if ‘lexical-binding’ is t.¶¶The optional argument INITVALUE is evaluated, and used to set SYMBOL,¶only if SYMBOL’s value is void.  If SYMBOL is buffer-local, its¶default value is what is set; buffer-local values are not affected.¶If INITVALUE is missing, SYMBOL’s value is not set.¶¶If SYMBOL has a local binding, then this form affects the local¶binding.  This is usually not what you want.  Thus, if you need to¶load a file defining variables, with this form or with ‘defconst’ or¶‘defcustom’, you should always load that file _outside_ any bindings¶for these variables.  (‘defconst’ and ‘defcustom’ behave similarly in¶this respect.)¶¶The optional argument DOCSTRING is a documentation string for the¶variable.¶¶To define a user option, use ‘defcustom’ instead of ‘defvar’.¶¶(fn SYMBOL &amp;optional INITVALUE DOCSTRING)",
"defconst":"Define SYMBOL as a constant variable.¶This declares that neither programs nor users should ever change the¶value.  This constancy is not actually enforced by Emacs Lisp, but¶SYMBOL is marked as a special variable so that it is never lexically¶bound.¶¶The ‘defconst’ form always sets the value of SYMBOL to the result of¶evalling INITVALUE.  If SYMBOL is buffer-local, its default value is¶what is set; buffer-local values are not affected.  If SYMBOL has a¶local binding, then this form sets the local binding’s value.¶However, you should normally not make local bindings for variables¶defined with this form.¶¶The optional DOCSTRING specifies the variable’s documentation string.¶¶(fn SYMBOL INITVALUE [DOCSTRING])",
"if":"If COND yields non-nil, do THEN, else do ELSE...¶Returns the value of THEN or the value of the last of the ELSE’s.¶THEN must be one expression, but ELSE... can be zero or more expressions.¶If COND yields nil, and there are no ELSE’s, the value is nil.¶¶(fn COND THEN ELSE...)",
"cond":"Try each clause until one succeeds.¶Each clause looks like (CONDITION BODY...).  CONDITION is evaluated¶and, if the value is non-nil, this clause succeeds:¶then the expressions in BODY are evaluated and the last one’s¶value is the value of the cond-form.¶If a clause has one element, as in (CONDITION), then the cond-form¶returns CONDITION’s value, if that is non-nil.¶If no clause succeeds, cond returns nil.¶¶(fn CLAUSES...)",
"track-mouse":"Evaluate BODY with mouse movement events enabled.¶Within a ‘track-mouse’ form, mouse motion generates input events that¶ you can read with ‘read-event’.¶Normally, mouse motion is ignored.¶¶(fn &amp;rest BODY)",
"save-restriction":"Execute BODY, saving and restoring current buffer’s restrictions.¶The buffer’s restrictions make parts of the beginning and end invisible.¶(They are set up with ‘narrow-to-region’ and eliminated with ‘widen’.)¶This special form, ‘save-restriction’, saves the current buffer’s restrictions¶when it is entered, and restores them when it is exited.¶So any ‘narrow-to-region’ within BODY lasts only until the end of the form.¶The old restrictions settings are restored¶even in case of abnormal exit (throw or error).¶¶The value returned is the value of the last form in BODY.¶¶Note: if you are using both ‘save-excursion’ and ‘save-restriction’,¶use ‘save-excursion’ outermost:¶    (save-excursion (save-restriction ...))¶¶(fn &amp;rest BODY)",
"with-no-warnings":"Like ‘progn’, but prevents compiler warnings in the body.¶¶(fn &amp;rest BODY)",
"interactive":"Specify a way of parsing arguments for interactive use of a function.¶For example, write¶ (defun foo (arg buf) &quot;Doc string&quot; (interactive &quot;P⧷nbbuffer: &quot;) .... )¶ to make ARG be the raw prefix argument, and set BUF to an existing buffer,¶ when ‘foo’ is called as a command.¶¶The &quot;call&quot; to ‘interactive’ is actually a declaration rather than a¶ function; it tells ‘call-interactively’ how to read arguments to pass¶ to the function.  When actually called, ‘interactive’ just returns¶ nil.¶¶Usually the argument of ‘interactive’ is a string containing a code¶ letter followed optionally by a prompt.  (Some code letters do not¶ use I/O to get the argument and do not use prompts.)  To pass several¶ arguments to the command, concatenate the individual strings,¶ separating them by newline characters.¶¶Prompts are passed to ‘format’, and may use % escapes to print the¶ arguments that have already been read.¶If the argument is not a string, it is evaluated to get a list of¶ arguments to pass to the command.¶Just ‘(interactive)’ means pass no arguments to the command when¶ calling interactively.¶¶Code letters available are:¶a -- Function name: symbol with a function definition.¶b -- Name of existing buffer.¶B -- Name of buffer, possibly nonexistent.¶c -- Character (no input method is used).¶C -- Command name: symbol with interactive function definition.¶d -- Value of point as number.  Does not do I/O.¶D -- Directory name.¶e -- Parameterized event (i.e., one that’s a list) that invoked this command.¶     If used more than once, the Nth ‘e’ returns the Nth parameterized event.¶     This skips events that are integers or symbols.¶f -- Existing file name.¶F -- Possibly nonexistent file name.¶G -- Possibly nonexistent file name, defaulting to just directory name.¶i -- Ignored, i.e. always nil.  Does not do I/O.¶k -- Key sequence (downcase the last event if needed to get a definition).¶K -- Key sequence to be redefined (do not downcase the last event).¶m -- Value of mark as number.  Does not do I/O.¶M -- Any string.  Inherits the current input method.¶n -- Number read using minibuffer.¶N -- Numeric prefix arg, or if none, do like code ‘n’.¶p -- Prefix arg converted to number.  Does not do I/O.¶P -- Prefix arg in raw form.  Does not do I/O.¶r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.¶s -- Any string.  Does not inherit the current input method.¶S -- Any symbol.¶U -- Mouse up event discarded by a previous k or K argument.¶v -- Variable name: symbol that is ‘custom-variable-p’.¶x -- Lisp expression read but not evaluated.¶X -- Lisp expression read and evaluated.¶z -- Coding system.¶Z -- Coding system, nil if no prefix arg.¶¶In addition, if the string begins with ‘*’, an error is signaled if¶  the buffer is read-only.¶If ‘@’ appears at the beginning of the string, and if the key sequence¶ used to invoke the command includes any mouse events, then the window¶ associated with the first of those events is selected before the¶ command is run.¶If the string begins with ‘^’ and ‘shift-select-mode’ is non-nil,¶ Emacs first calls the function ‘handle-shift-selection’.¶You may use ‘@’, ‘*’, and ‘^’ together.  They are processed in the¶ order that they appear, before reading any arguments.¶¶(fn &amp;optional ARG-DESCRIPTOR)",
"save-excursion":"Save point, and current buffer; execute BODY; restore those things.¶Executes BODY just like ‘progn’.¶The values of point and the current buffer are restored¶even in case of abnormal exit (throw or error).¶¶If you only want to save the current buffer but not point,¶then just use ‘save-current-buffer’, or even ‘with-current-buffer’.¶¶Before Emacs 25.1, ‘save-excursion’ used to save the mark state.¶To save the marker state as well as the point and buffer, use¶‘save-mark-and-excursion’.¶¶(fn &amp;rest BODY)",
"while":"If TEST yields non-nil, eval BODY... and repeat.¶The order of execution is thus TEST, BODY, TEST, BODY and so on¶until TEST returns nil.¶¶(fn TEST BODY...)",
"condition-case":"Regain control when an error is signaled.¶Executes BODYFORM and returns its value if no error happens.¶Each element of HANDLERS looks like (CONDITION-NAME BODY...)¶where the BODY is made of Lisp expressions.¶¶A handler is applicable to an error¶if CONDITION-NAME is one of the error’s condition names.¶If an error happens, the first applicable handler is run.¶¶The car of a handler may be a list of condition names instead of a¶single condition name; then it handles all of them.  If the special¶condition name ‘debug’ is present in this list, it allows another¶condition in the list to run the debugger if ‘debug-on-error’ and the¶other usual mechanisms says it should (otherwise, ‘condition-case’¶suppresses the debugger).¶¶When a handler handles an error, control returns to the ‘condition-case’¶and it executes the handler’s BODY...¶with VAR bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.¶(If VAR is nil, the handler can’t access that information.)¶Then the value of the last BODY form is returned from the ‘condition-case’¶expression.¶¶See also the function ‘signal’ for more info.¶¶(fn VAR BODYFORM &amp;rest HANDLERS)",
"quote":"Return the argument, without evaluating it.  ‘(quote x)’ yields ‘x’.¶Warning: ‘quote’ does not construct its return value, but just returns¶the value that was pre-constructed by the Lisp reader (see info node¶‘(elisp)Printed Representation’).¶This means that '(a . b) is not identical to (cons 'a 'b): the former¶does not cons.  Quoting should be reserved for constants that will¶never be modified by side-effects, unless you like self-modifying code.¶See the common pitfall in info node ‘(elisp)Rearrangement’ for an example¶of unexpected results when a quoted object is modified.¶¶(fn ARG)",
"save-current-buffer":"Record which buffer is current; execute BODY; make that buffer current.¶BODY is executed just like ‘progn’.¶¶(fn &amp;rest BODY)",
"let":"Bind variables according to VARLIST then eval BODY.¶The value of the last form in BODY is returned.¶Each element of VARLIST is a symbol (which is bound to nil)¶or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).¶All the VALUEFORMs are evalled before any symbols are bound.¶¶(fn VARLIST BODY...)",
"let*":"Bind variables according to VARLIST then eval BODY.¶The value of the last form in BODY is returned.¶Each element of VARLIST is a symbol (which is bound to nil)¶or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).¶Each VALUEFORM can refer to the symbols already bound by this VARLIST.¶¶(fn VARLIST BODY...)",
"and":"Eval args until one of them yields nil, then return nil.¶The remaining args are not evalled at all.¶If no arg yields nil, return the last arg’s value.¶¶(fn CONDITIONS...)",
"or":"Eval args until one of them yields non-nil, then return that value.¶The remaining args are not evalled at all.¶If all args return nil, return nil.¶¶(fn CONDITIONS...)",
"setq-default":"Set the default value of variable VAR to VALUE.¶VAR, the variable name, is literal (not evaluated);¶VALUE is an expression: it is evaluated and its value returned.¶The default value of a variable is seen in buffers¶that do not have their own values for the variable.¶¶More generally, you can use multiple variables and values, as in¶  (setq-default VAR VALUE VAR VALUE...)¶This sets each VAR’s default value to the corresponding VALUE.¶The VALUE for the Nth VAR can refer to the new default values¶of previous VARs.¶¶(fn [VAR VALUE]...)",
"unwind-protect":"Do BODYFORM, protecting with UNWINDFORMS.¶If BODYFORM completes normally, its value is returned¶after executing the UNWINDFORMS.¶If BODYFORM exits nonlocally, the UNWINDFORMS are executed anyway.¶¶(fn BODYFORM UNWINDFORMS...)",
"progn":"Eval BODY forms sequentially and return value of last one.¶¶(fn BODY...)",
"prog1":"Eval FIRST and BODY sequentially; return value from FIRST.¶The value of FIRST is saved during the evaluation of the remaining args,¶whose values are discarded.¶¶(fn FIRST BODY...)",
"prog2":"Eval FORM1, FORM2 and BODY sequentially; return value from FORM2.¶The value of FORM2 is saved during the evaluation of the¶remaining args, whose values are discarded.¶¶(fn FORM1 FORM2 BODY...)"
}
