;; -*- coding: utf-8 -*-
;; 2013-07-15

(setq fnames
      '(
abbrev-mode
abbrev-prefix-mark
abort-recursive-edit
add-hook
add-to-list
align-regexp
all-completions
and
append
append-next-kill
append-to-file
apply
apply-macro-to-region-lines
apropos
apropos-command
apropos-value
aref
array
artist-mode
aset
assoc
async-shell-command
auto-complete
auto-fill-mode
autoload
back-to-indentation
backward-char
backward-delete-char-untabify
backward-kill-word
backward-list
backward-page
backward-paragraph
backward-sentence
backward-sexp
backward-up-list
backward-word
balance-windows
beep
beginning-of-buffer
beginning-of-defun
beginning-of-line
benchmark-run
bookmark-bmenu-list
bookmark-save
bookmark-set
boundp
bounds-of-thing-at-point
browse-url
browse-url-firefox
browse-url-of-buffer
buffer-file-name
buffer-modified-p
buffer-name
buffer-string
buffer-substring
buffer-substring-no-properties
bury-buffer
byte-compile-file
calc
calendar
called-interactively-p
call-last-kbd-macro
call-process
capitalize
capitalize-region
capitalize-word
car
catch
cdr
center-line
changefreq
char-to-string
clean-buffer-list
clear-rectangle
clojure-mode
clone-buffer
close-current-buffer
close-rectangle
cmd-shell
c-mode
color-theme-classic
color-theme-select
column-number-mode
command-execute
comment-dwim
comment-region
compact-uncompact-block
concat
cond
condition-case
cons
content
coordinates
copy-directory
copy-file
copy-to-register
count-lines
count-words
cperl-electric-backspace
cperl-mode
cua-mode
current-buffer
customize-group
customize-variable
custom-set-faces
custom-set-variables
cycle-font
cycle-hyphen-underscore-space
dabbrev-expand
deactivate-mark
defadvice
defalias
default
defcustom
define-derived-mode
define-key
defun
defvar
dehtmlize-span-region
delete-backward-char
delete-blank-lines
delete-char
delete-directory
delete-file
delete-horizontal-space
delete-indentation
delete-matching-lines
delete-non-matching-lines
delete-other-windows
delete-rectangle
delete-region
delete-selection-mode
delete-trailing-whitespace
delete-whitespace-rectangle
delete-window
delimit-columns-rectangle
describe-bindings
describe-char
describe-coding-system
describe-function
describe-key
describe-major-mode
describe-mode
describe-package
describe-syntax
describe-variable
description
desktop-save-mode
die
diff
diff-backup
digit-argument
directory-files
dired
dired-copy-filename-as-kill
dired-do-byte-compile
dired-do-kill-lines
dired-do-query-replace-regexp
dired-do-rename-regexp
dired-do-search
dired-get-marked-files
dired-jump
dired-mark-files-regexp
dired-mode
diredp-byte-compile-this-file
dired-toggle-read-only
display-completion-list
div
doc-view-mode
dolist
dotimes
downcase
downcase-region
downcase-word
down-list
ediff
electric-pair-mode
elisp-index-search
else
elt
emacs-index-search
emacs-lisp-mode
end-kbd-macro
end-of-buffer
end-of-defun
end-of-line
enlarge-window
enlarge-window-horizontally
enriched-mode
eq
equal
erase-buffer
ergoemacs-close-current-buffer
ergoemacs-extras
ergoemacs-mode
ergoemacs-next-user-buffer
ergoemacs-previous-user-buffer
ergoemacs-switch-to-next-frame
error
eshell
eval-buffer
eval-defun
eval-expression
eval-last-sexp
eval-region
exchange-point-and-mark
execute-extended-command
exit-minibuffer
expand-file-name
expt
extend-selection
extract-rectangle
extract-url
face-font
face-foreground
fboundp
featurep
feed
ffap
figcaption
figure
file-exists-p
fileFilterQ
file-name-directory
file-name-extension
file-name-nondirectory
file-name-sans-extension
file-relative-name
fill-flowed
fill-paragraph
fill-region
find
find-dired
find-file
find-file-at-point
find-file-literally
find-grep
find-if
find-lisp-find-files
find-tag
fix-timestamp-string
float
floatp
flush-lines
flyspell-buffer
flyspell-mode
focus-frame
follow-mode
font-lock-mode
for
foreach
form
format
format-time-string
forward-char
forward-close-bracket
forward-line
forward-list
forward-page
forward-paragraph
forward-sentence
forward-sexp
forward-word
fun
func1
func2
funcall
fundamental-mode
get
get-file-buffer
gethash
get_links
get-selection-or-unit
global-hl-line-mode
global-linum-mode
global-set-key
global-subword-mode
global-unset-key
global-visual-line-mode
global-whitespace-mode
global-whitespace-newline-mode
gnus-url-unhex-string
goto-char
goto-line
grep
grep-find
h1
hash-table-count
header
hexl-find-file
hexl-mode
hide-body
highlight-lines-matching-regexp
highlight-phrase
highlight-regexp
hippie-expand
hl-line-mode
holidays
htmlfontify-buffer
html-headline-1
html-headline-2
html-horizontal-rule
html-image
htmlize-buffer
htmlize-file
htmlize-region
html-list-item
html-mode
html-paragraph
html-unordered-list
ibuffer
icomplete-mode
icon
iconify-or-deiconify-frame
id
ido-find-file
ido-mode
ido-switch-buffer
ielm
if
image-dired-delete-tag
img
in
indent-for-tab-command
indent-new-comment-line
indent-region
info
info-apropos
Info-copy-current-node-name
input
insert
insert-buffer-substring-no-properties
insert-date-time
insert-file-contents
insert-google-map-link
insert-kbd-macro
insert-kml
insert-random-uuid
insert-rectangle
insert-register
integerp
interactive
isearch-backward
isearch-forward
isearch-forward-at-point
isearch-mode
isearch-printing-char
isearch-repeat-forward
ispell-word
iswitchb-buffer
iswitchb-mode
js-mode
jump-to-register
just-one-space
kbd
keep-lines
keyboard-quit
keyboard-translate
kill-all-local-variables
kill-append
kill-buffer
kill-line
kill-line-backward
kill-rectangle
kill-region
kill-ring-save
kill-sentence
kill-some-buffers
kill-whole-line
kill-word
kmacro-end-and-call-macro
kmacro-end-macro
kmacro-start-macro
kml
lambda
last
lastmod
length
let
let*
lgrep
li
line-beginning-position
line-end-position
line-move-visual
link
linum-mode
lisp-interaction-mode
list
list-buffers
list-character-sets
list-charset-chars
list-coding-systems
list-colors-display
list-input-methods
list-matching-lines
list-packages
llSay
llWhisper
load
load-file
load-theme
loc
local
local-set-key
local-url-to-file-path
looking-at
lookup-google
make-directory
make-google-earth
make-hash-table
make-sparse-keymap
make-vector
man
manual-entry
mapc
mapcar
mapconcat
maphash
mark-defun
mark-page
mark-paragraph
mark-sexp
mark-whole-buffer
mark-word
match-beginning
match-end
match-string
math-symbol-input-mode
md5
member
memq
message
method1
method2
modify-syntax-entry
move-beginning-of-line
move-end-of-line
move-to-window-line
move-to-window-line-top-bottom
msys-shell
multi-occur
multi-occur-in-matching-buffers
mwheel-scroll
my
myComposition
my-process-file
name
name-last-kbd-macro
namespace
narrow-to-region
negative-argument
new-empty-buffer
newline
next-buffer
next-emacs-buffer
next-history-element
next-line
next-matching-history-element
next-user-buffer
nil
not
nth
null
number-to-string
nxml-mode
object
occur
occur-cease-edit
occur-edit-mode
open-in-desktop
open-last-closed
open-line
open-rectangle
or
Or
org-mode
org-return
org-self-insert-command
org-time-stamp
other-window
outline-mode
p
package-menu-execute
package-menu-mark-delete
package-menu-mark-install
package-menu-mark-unmark
package-menu-mode
package-menu-refresh
page-break-lines-mode
param
parse-time-string
partial-completion-mode
perl-mode
picture-mode
point
point-max
point-min
pop
pop-global-mark
powershell
pre
prefix-numeric-value
previous-buffer
previous-emacs-buffer
previous-history-element
previous-line
previous-matching-history-element
previous-user-buffer
prin1
princ
print
print-buffer-confirm
priority
proced
process_file
processFile
progn
provide
public
push
push-mark
put
puthash
python-backspace
python-mode
python-shift-left
python-shift-right
query-replace
query-replace-regexp
quote
quoted-insert
rainbow-delimiters-mode
rainbow-mode
random
rassoc
read
read-directory-name
read-file-name
read-from-minibuffer
read-regexp
read-string
recenter
recenter-top-bottom
recentf-mode
recentf-open-files
rectangle-number-lines
redo
reduce
regexp-builder
regexp-opt
regexp-quote
region-active-p
region-beginning
region-end
remember
remhash
remove-hook
remove-vowel
rename-file
repeat-complex-command
replace-match
replace-pairs-in-string
replace-pairs-in-string-recursive
replace-pairs-region
replace-rectangle
replace-regexp
replace-regexp-in-string
replace-regexp-pairs-in-string
replace-regexp-pairs-region
replace-string
report-emacs-bug
require
re-search-backward
re-search-forward
resume
return
reverse
reverse-region
revert-buffer
rgrep
right-char
rights
rst-mode
ruby-mode
run-hooks
run-mode-hooks
save-buffer
save-buffers-kill-terminal
save-current-configuration
save-excursion
save-restriction
save-some-buffers
script
scroll-down
scroll-lock-mode
scroll-up
scroll-up-command
scroll-up-line
search-backward
search-backward-regexp
search-forward
search-forward-regexp
select-current-block
select-current-line
select-text-in-quote
self-insert-command
server-start
set-background-color
set-buffer
set-buffer-file-coding-system
set-file-modes
set-frame-parameter
set-input-method
set-mark
set-mark-command
setq
setq-default
set-variable
sgml-delete-tag
sgml-mode
sgml-skip-tag-backward
sgml-skip-tag-forward
sgml-tags-invisible
shell
shell-command
shell-command-on-region
shell-command-to-string
show-paren-mode
shrink-whitespaces
shrink-window
shrink-window-horizontally
shrink-window-if-larger-than-buffer
skip-chars-backward
skip-chars-forward
sleep-for
smex
snippet-mode
soft-wrap-lines
sort
sort-columns
sort-fields
sort-lines
sort-numeric-fields
sort-pages
sort-paragraphs
sort-regexp-fields
source-linkify
span
split-string
split-window-below
split-window-horizontally
split-window-right
split-window-vertically
start-kbd-macro
start-process
start-process-shell-command
strict
string
string=
string-equal
string-insert-rectangle
string-match
string-match-p
string-rectangle
string-to-number
sub
subrp
substring
substring-no-properties
subtitle
summary
switch-to-buffer
switch-to-next-frame
switch-to-previous-frame
symbol-function
symbol-name
symbolp
symbol-plist
symbol-value
t
tabbar-mode
tabify
table
table-capture
table-delete-column
table-delete-row
table-generate-source
table-insert
table-insert-column
table-insert-row
table-release
tab-to-tab-stop
tags-loop-continue
tags-query-replace
td
term
text-mode
thing-at-point
throw
title
tmm-menubar
toggle-case-fold-search
toggle-debug-on-error
toggle-input-method
toggle-letter-case
toggle-line-spacing
toggle-read-only
toggle-text-mode-auto-fill
toggle-truncate-lines
toggle-word-wrap
tr
transient-mark-mode
transpose-chars
transpose-lines
transpose-words
try-completion
tumme
ucs-insert
undo
undo-tree-mode
unit-at-cursor
universal-argument
unless
untabify
upcase
upcase-initials
upcase-initials-region
upcase-region
upcase-word
updated
uri
url
url-retrieve-synchronously
urlset
url-unhex-string
use
use-local-map
var
variable-pitch-mode
vc-annotate
vconcat
vector
vectorp
video-search-linkify
view-echo-area-messages
view-emacs-news
view-mode
visual-line-mode
wdired-abort-changes
wdired-change-to-wdired-mode
wdired-finish-edit
when
where-is-old-binding
while
whitespace-cleanup
whitespace-mode
whitespace-newline-mode
widen
window-configuration-to-register
winner-mode
winner-redo
winner-undo
with-current-buffer
with-output-to-temp-buffer
with-temp-buffer
with-temp-file
woman
wrap-url
write-file
write-region
xahsite-filepath-to-href-value
xah-update-page-tag
xesam-search
xml-mode
xmsi-list-math-symbols
xmsi-mode
xyz-comment-dwim
xyz-mode
yank
yank-pop
yank-rectangle
yas/reload-all
yes-or-no-p
y-or-n-p
youtube-linkify
yow
zap-to-char
        )
      )

(defun descFunc87801 (function)
  "Display the full documentation of FUNCTION (a symbol)."
  (interactive
   (let ((fn (function-called-at-point))
	 (enable-recursive-minibuffers t)
	 val)
     (setq val (completing-read (if fn
				    (format "Describe function (default %s): " fn)
				  "Describe function: ")
				obarray 'fboundp t nil nil
				(and fn (symbol-name fn))))
     (list (if (equal val "")
	       fn (intern val)))))
  (if (null function)
      (message "You didn't specify a function")
    (help-setup-xref (list #'descFunc87801 function)
		     (called-interactively-p 'interactive))
    (save-excursion
      (with-help-window (help-buffer)
	(prin1 function)
	;; Use " is " instead of a colon so that
	;; it is easier to get out the function name using forward-sexp.
	(princ " is ")
	(describeFunction77838 function)
	(with-current-buffer standard-output
	  ;; Return the text we displayed.
	  (buffer-string))))))

(defun describeFunction77838 (function)
  (let* ((advised (and (symbolp function) (featurep 'advice)
		       (ad-get-advice-info function)))
	 ;; If the function is advised, use the symbol that has the
	 ;; real definition, if that symbol is already set up.
	 (real-function
	  (or (and advised
		   (let ((origname (cdr (assq 'origname advised))))
		     (and (fboundp origname) origname)))
	      function))
	 ;; Get the real definition.
	 (def (if (symbolp real-function)
		  (symbol-function real-function)
		function))
	 (aliased (symbolp def))
	 (real-def (if aliased
		       (let ((f def))
			 (while (and (fboundp f)
				     (symbolp (symbol-function f)))
			   (setq f (symbol-function f)))
			 f)
		     def))
	 (file-name (find-lisp-object-file-name function def))
         (pt1 (with-current-buffer (help-buffer) (point)))
	 (beg (if (and (or (byte-code-function-p def)
			   (keymapp def)
			   (memq (car-safe def) '(macro lambda closure)))
		       file-name
		       (help-fns--autoloaded-p function file-name))
		  (if (commandp def)
		      "an interactive autoloaded "
		    "an autoloaded ")
		(if (commandp def) "an interactive " "a "))))

    ;; Print what kind of function-like object FUNCTION is.
    (princ (cond ((or (stringp def) (vectorp def))
		  "a keyboard macro")
		 ((subrp def)
		  (if (eq 'unevalled (cdr (subr-arity def)))
		      (concat beg "special form")
		    (concat beg "built-in function")))
		 ((byte-code-function-p def)
		  (concat beg "compiled Lisp function"))
		 (aliased
		  (format "an alias for `%s'" real-def))
		 ((eq (car-safe def) 'lambda)
		  (concat beg "Lisp function"))
		 ((eq (car-safe def) 'macro)
		  (concat beg "Lisp macro"))
		 ((eq (car-safe def) 'closure)
		  (concat beg "Lisp closure"))
		 ((autoloadp def)
		  (format "%s autoloaded %s"
			  (if (commandp def) "an interactive" "an")
			  (if (eq (nth 4 def) 'keymap) "keymap"
			    (if (nth 4 def) "Lisp macro" "Lisp function"))))
		 ((keymapp def)
		  (let ((is-full nil)
			(elts (cdr-safe def)))
		    (while elts
		      (if (char-table-p (car-safe elts))
			  (setq is-full t
				elts nil))
		      (setq elts (cdr-safe elts)))
		    (concat beg (if is-full "keymap" "sparse keymap"))))
		 (t "")))

    (if (and aliased (not (fboundp real-def)))
	(princ ",\nwhich is not defined.  Please make a bug report.")
      (with-current-buffer standard-output
	(save-excursion
	  (save-match-data
	    (when (re-search-backward "alias for `\\([^`']+\\)'" nil t)
	      (help-xref-button 1 'help-function real-def)))))

      (when file-name
	(princ " in `")
	;; We used to add .el to the file name,
	;; but that's completely wrong when the user used load-file.
	(princ (if (eq file-name 'C-source)
		   "C source code"
		 (file-name-nondirectory file-name)))
	(princ "'")
	;; Make a hyperlink to the library.
	(with-current-buffer standard-output
	  (save-excursion
	    (re-search-backward "`\\([^`']+\\)'" nil t)
	    (help-xref-button 1 'help-function-def function file-name))))
      (princ ".")
      (with-current-buffer (help-buffer)
	(fill-region-as-paragraph (save-excursion (goto-char pt1) (forward-line 0) (point))
				  (point)))
      (terpri)(terpri)

      (let* ((doc-raw (documentation function t))
	     ;; If the function is autoloaded, and its docstring has
	     ;; key substitution constructs, load the library.
	     (doc (progn
		    (and (autoloadp real-def) doc-raw
			 help-enable-auto-load
			 (string-match "\\([^\\]=\\|[^=]\\|\\`\\)\\\\[[{<]"
				       doc-raw)
			 (load (cadr real-def) t))
		    (substitute-command-keys doc-raw))))

        ;; (help-fns--key-bindings function)
        (with-current-buffer standard-output
          (setq doc (help-fns--signature function doc real-def real-function))

          (help-fns--compiler-macro function)
          (help-fns--parent-mode function)
          (help-fns--obsolete function)

          (insert "\n"
                  (or doc "Not documented.")))))))


(with-temp-file "xxx.txt"
  (mapc
   (lambda (fn-59908)

     (when (fboundp fn-59908)
       (let ((uuu (descFunc87801 fn-59908)))
         (insert (format "〈〈%s〉〉:〈〈%s〉〉•85170" fn-59908 (replace-regexp-in-string "\"" "\\\"" uuu "FIXEDCASE" "LITERAL") ) ) ) )
     )
   fnames)
  )

(find-file "xxx.txt")

(let ((case-fold-search nil))

  ;; escape JavaScript string
  (goto-char (point-min))
  (while (search-forward "\n" nil t) (replace-match "•"))

  ;; escape html
  (goto-char (point-min))
  (while (search-forward "&" nil t) (replace-match "&amp;"))

  (goto-char (point-min))
  (while (search-forward "<" nil t) (replace-match "&lt;"))

  (goto-char (point-min))
  (while (search-forward ">" nil t) (replace-match "&gt;"))

  ;; escape JavaScript
  (goto-char (point-min))
  (while (search-forward "\"" nil t) (replace-match "&quote"))

  (goto-char (point-min))
  (while (search-forward "\\" nil t) (replace-match "⧷"))

  ;; make it js hash
  (goto-char (point-min))
  (while (search-forward "〈〈" nil t) (replace-match "\""))

  (goto-char (point-min))
  (while (search-forward "〉〉" nil t) (replace-match "\""))

  (goto-char (point-min))
  (while (search-forward "•85170" nil t) (replace-match ",\n"))
  )

;; (setq uuu (replace-regexp-in-string "\n" "•" uuu "FIXEDCASE" "LITERAL") )
;; (setq uuu (replace-regexp-in-string "<" "&lt;" uuu "FIXEDCASE" "LITERAL") )
;; (setq uuu (replace-regexp-in-string ">" "&gt;" uuu "FIXEDCASE" "LITERAL") )
;; (setq uuu (replace-regexp-in-string "&" "&amp;;" uuu "FIXEDCASE" "LITERAL") )

;; < > & needs to be encoded as HTML entities
;; " needs to be escaped
